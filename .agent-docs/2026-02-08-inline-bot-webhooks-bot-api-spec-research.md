# Inline Bot Webhooks + Bot API/SDK Research (Telegram-Inspired)

Date: 2026-02-08

Scope:
- Investigate Telegram Bot API inbound delivery patterns (webhook vs long polling).
- Investigate current Inline bot primitives, updates architecture, and data model.
- Propose multiple design plans for adding bot webhook support in Inline.
- Consolidate into a production-grade spec with a senior-engineer oversight pass.
- No implementation in this doc.

Local sources referenced:
- Telegram Bot API docs: `/Users/mo/dev/telegram/telegram_bot_api.html`
- Inline server entry: `server/src/index.ts`
- Inline bot creation + token: `server/src/functions/createBot.ts`, `server/src/functions/bot.revealToken.ts`, `server/src/db/schema/botTokens.ts`, `server/src/db/models/botTokens.ts`, `server/src/utils/auth.ts`
- Inline auth token verification: `server/src/controllers/plugins.ts`
- Inline update persistence and sync: `server/src/db/schema/updates.ts`, `server/src/db/models/updates.ts`, `server/src/modules/updates/sync.ts`, `server/src/functions/updates.getUpdates.ts`, `proto/server.proto`, `proto/core.proto`
- Inline realtime push: `server/src/realtime/message.ts`
- Inline membership + peer encoding: `server/src/db/schema/chats.ts`, `server/src/db/schema/members.ts`, `server/src/realtime/encoders/encodePeer.ts`, `server/src/realtime/encoders/encodeChat.ts`, `server/src/realtime/encoders/encodeUser.ts`
- Inline examples of persistent vs transient updates:
  - Persistent message updates: `server/src/db/models/messages.ts`
  - Some transient updates: `server/src/functions/messages.addReaction.ts`, `server/src/functions/messages.addChatParticipant.ts`, `server/src/modules/loom/processLoomLink.ts`
- Inline macOS bot settings UI: `apple/InlineMac/Views/Settings/Views/BotsSettingsDetailView.swift`
- Inline TS realtime client: `web/packages/client/src/realtime/realtime.ts`

---

## 1) Telegram Bot API Inbound Delivery (What Matters)

Telegram’s Bot API provides two mutually-exclusive ways of receiving updates:
- Long polling: `getUpdates` returns an array of JSON `Update` objects.
- Webhook: `setWebhook` registers an HTTPS URL; Telegram sends HTTPS POST requests with a JSON `Update` body.

Key webhook semantics from Telegram:
- Webhook delivery is retried on non-`2xx` HTTP status codes.
- `secret_token` can be configured; Telegram includes `X-Telegram-Bot-Api-Secret-Token` header on webhook requests.
- `allowed_updates` filters which update types are delivered.
- `drop_pending_updates` clears backlog.
- `getWebhookInfo` reports URL, pending count, last error fields, allowed updates, max connections.
- `getUpdates` does not work when webhook is configured.
- Updates are stored by Telegram until delivered, but not kept longer than 24 hours.

Reference: `/Users/mo/dev/telegram/telegram_bot_api.html`

---

## 2) Inline Bot Primitives (Current State)

### 2.1 Bots are Users
- Inline represents bots as normal users with `users.bot = true`.
- `users.botCreatorId` links bot ownership to a human user.
- Bot usernames must end with `"bot"` (server validates in `createBot`).

References:
- `server/src/db/schema/users.ts`
- `server/src/functions/createBot.ts`

### 2.2 Bot Tokens are Sessions (Encrypted at Rest)
- Token format is `<userId>:IN<random>` generated by `generateToken(userId)` in `server/src/utils/auth.ts`.
- Sessions are validated by hashing the full token and matching `sessions.tokenHash` (`server/src/controllers/plugins.ts`).
- Bots get a session created with `clientType: "api"` on creation.
- `bot_tokens` table stores the bot token encrypted (v1 encryption module), tied to `sessionId`.

References:
- `server/src/utils/auth.ts`
- `server/src/controllers/plugins.ts`
- `server/src/functions/createBot.ts`
- `server/src/db/schema/botTokens.ts`
- `server/src/db/models/botTokens.ts`

### 2.3 There is Already a Bot UI
- macOS settings page can create bots, list bots, reveal tokens.
- It stores tokens client-side for display/copy only.

Reference:
- `apple/InlineMac/Views/Settings/Views/BotsSettingsDetailView.swift`

---

## 3) Inline Updates Architecture (Durable vs Realtime)

Inline has two relevant channels already:

### 3.1 Durable persisted updates (offline sync)
- Persisted update records in `updates` table.
- Updates are bucketed by `UpdateBucket` enum: Chat, Space, User.
- Each bucket has a per-entity monotonic sequence (`seq`) used by sync (client-side PTS equivalent).
- The `payload` is an encrypted binary `server.ServerUpdate` (`proto/server.proto`) stored in one `bytea` column using `Encryption2` format.
- `Sync` reads persisted updates and inflates them into `core.Update` payloads by fetching referenced entities from DB (messages, chats, etc.).
- `server/src/functions/updates.getUpdates.ts` returns slices with `seq`, `date`, `final`, and `resultType` (including `TOO_LONG`).

References:
- `server/src/db/schema/updates.ts`
- `server/src/db/models/updates.ts`
- `proto/server.proto`
- `server/src/modules/updates/sync.ts`
- `server/src/functions/updates.getUpdates.ts`

### 3.2 Realtime pushes (connected clients)
- `RealtimeUpdates.pushToUser` sends `UpdatesPayload` over WS to currently connected sessions.
- Some flows send realtime updates without persisting them first.

References:
- `server/src/realtime/message.ts`
- Example transient paths:
  - `server/src/functions/messages.addReaction.ts` uses `Updates.shared.pushUpdate` (realtime only).
  - `server/src/functions/messages.addChatParticipant.ts` pushes `participantAdd` realtime without persisting.
  - `server/src/modules/loom/processLoomLink.ts` pushes `messageAttachment` realtime without persisting.

### 3.3 Implication for Bots
If bot updates are based only on persisted updates, bots will not see some current realtime-only events unless Inline starts persisting those too or explicitly enqueues bot events at the realtime send points.

---

## 4) Design Space: What “Webhook Support” Could Mean

### Plan A: Telegram-style bot update queue (recommended)
- Create a bot-specific update queue with a single per-bot cursor (`update_id`).
- Expose two consumption modes: `getUpdates` and webhook delivery.
- Map eligible Inline durable updates into this bot queue.

Pros:
- Best developer ergonomics (one cursor, one stream).
- Natural parity between webhook and polling.
- Clear dedupe story with `update_id`.

Cons:
- Requires new persistence and background worker loops.
- Requires recipient resolution and event filtering logic.

### Plan B: Webhook only notifies “new updates available”
- Webhook event signals chatId/spaceId and a new update seq.
- Bot then pulls actual data via existing Inline `getUpdates` buckets (chat/space/user).

Pros:
- Less new state.
- Leverages existing bucket-based storage.

Cons:
- Poor DX (many cursors, per-bucket state).
- More API calls, higher load.
- Harder to document correctly.

### Plan C: WebSocket-only bot gateway
- Bots connect to Inline realtime and receive updates live.

Pros:
- Minimal new server work.

Cons:
- Does not satisfy webhook requirement.
- Forces always-on connections, harder for serverless bots.

---

## 5) Consolidated Spec (From Pass 1 and Pass 2)

### 5.1 Goals
- Bot developers can receive events via:
  - Webhook (HTTPS POST).
  - Long polling (`getUpdates`).
- Delivery is at-least-once and ordered per bot.
- Bot API/SDK provides a clean surface for inbound events and minimal outbound actions.

### 5.2 Non-goals (MVP)
- Full app marketplace, OAuth installs, granular scopes.
- Exactly-once delivery.
- Shipping every existing realtime-only Inline update type as a bot event.

### 5.3 Public bot event schema (avoid leaking internal shapes)
Recommendation:
- Define a bot-specific `BotUpdate` envelope:
  - `update_id` (int64-as-string)
  - `event_type` (snake_case)
  - `event` payload
  - `date` (unix seconds)
- Keep “allowed updates” filtering based on these stable `event_type` strings.

Reason:
- Avoid coupling public APIs to internal `core.Update` or `server.ServerUpdate` shapes and naming.

### 5.4 API surface (suggested)
Base:
- `https://api.inline.chat/bot/v1`

Auth:
- `Authorization: Bearer <bot_token>`
- Token must resolve to a session for a bot user (`users.bot = true`), otherwise 401/403.

Webhook:
- `POST /webhook/set`
- `POST /webhook/delete`
- `GET /webhook/info`

Long polling:
- `GET /updates/get`
- Telegram-style ack by offset.
- Mutually exclusive with webhook enabled.

Outbound actions (minimal):
- `POST /messages/send`
- `POST /messages/edit`
- `POST /messages/delete`

Idempotency:
- Require `random_id` for `send` (Inline already uses `randomId` on messages; duplicate handling exists in `server/src/functions/messages.sendMessage.ts`).
- SDK should generate and attach idempotency values.

### 5.5 Event eligibility (MVP)
MVP should start with durable-only events derived from persisted updates:
- Message: new, edited, deleted.
- Chat: created, deleted, info changes, pinned changes, visibility changes.
- Space membership: member add/update/remove.
- User bucket: join space, dialog archive, removed from space/thread.

Explicitly excluded in MVP (currently realtime-only today):
- Reactions.
- Typing/presence.
- Participant add.
- Message attachment updates from link previews.

---

## 6) Data Model Proposal (Pass 2)

Tables:

`bot_webhooks`:
- `bot_user_id` unique FK to users.
- `url` nullable.
- `secret_token` encrypted (do not store plaintext).
- `allowed_updates` jsonb.
- Status fields: last error, pending count derivable, timestamps.

`bot_state`:
- `bot_user_id` PK.
- `next_update_id` bigint.
- `last_acked_update_id` bigint.
- One cursor model is recommended even if both webhook and polling exist.

`bot_updates`:
- `(bot_user_id, update_id)` PK.
- `event_type`.
- Source pointer: `(bucket, entity_id, seq)` for inflation.
- Delivery state and retry fields (attempts, next attempt).
- Optional payload cache is not required in MVP if inflation is cheap enough.

Indexes:
- `(bot_user_id, update_id)` primary key.
- Partial index for pending deliverables by `next_attempt_at`.
- Optional: `(bot_user_id, state, update_id)` to fetch head quickly.

---

## 7) Outbox Pattern (Correctness and Performance)

Why:
- Avoid doing webhook work on hot paths like sendMessage.
- Ensure "persisted update committed" implies "bot pipeline sees it" even if worker crashes.

Where to hook (two chokepoints for persistent updates):
- `UpdatesModel.insertUpdate(...)` in `server/src/db/models/updates.ts`
- `UserBucketUpdates.enqueue(...)` in `server/src/modules/updates/userBucketUpdates.ts`

Outbox:
- Minimal row contains `(bucket, entity_id, seq, event_type, created_at)`.
- Expansion worker converts outbox rows into per-bot `bot_updates`.
- Must be idempotent:
  - Add `source_outbox_id` into `bot_updates`.
  - Unique constraint on `(bot_user_id, source_outbox_id)` to prevent duplicates on retries.

---

## 8) Recipient Resolution Rules (Based on Inline Data Model)

Source entities:
- Chats in `server/src/db/schema/chats.ts`.
- Chat participants in `chat_participants` (also in `server/src/db/schema/chats.ts`).
- Space members in `server/src/db/schema/members.ts`.

Rules for chat bucket updates:
- If chat is `private`: recipients are the two users, filter to bots.
- If chat is `thread`:
  - If `spaceId` is null: recipients are `chat_participants`, filter to bots.
  - If `spaceId` is set and `publicThread=true`: recipients are `members` with `canAccessPublicChats=true`, filter to bots.
  - Else: recipients are `chat_participants`, filter to bots.

Special correctness note:
- Some removal flows send a realtime update directly to removed users because they are no longer in the "topic", while also persisting a user-bucket update.
- Example patterns:
  - Removed from thread: `server/src/functions/messages.removeChatParticipant.ts`
  - Removed from space: `server/src/functions/space.deleteMember.ts`
- Bot event pipeline must include user-bucket updates so removals are not missed.

---

## 9) Webhook Delivery Worker (Robustness)

MVP constraints:
- Enforce `max_connections = 1` (one in-flight update per bot).
- Deliver updates strictly in increasing `update_id` order.

Select strategy:
- Fetch one pending update per bot in order.
- Use `FOR UPDATE SKIP LOCKED` on `bot_updates` rows to support multi-worker scaling.
- Use a `delivering` lease timeout to recover from worker crashes.

HTTP semantics:
- Success: any 2xx response.
- Failure: network errors, timeout, and any non-2xx response.
- Treat 3xx as failure to avoid redirect risks.
- Respect `Retry-After` for 429/503 if present.

Retry:
- Exponential backoff with jitter.
- Max attempts or max age (for example 24h) then dead-letter.

Headers:
- `X-Inline-Bot-User-Id`
- `X-Inline-Update-Id`
- `X-Inline-Bot-Api-Secret-Token` if configured.
- Optional HMAC signature header is recommended.

---

## 10) Security and Privacy (P0 Items)

Webhook SSRF mitigation on `setWebhook`:
- Require `https://` in production.
- Block private/link-local IP ranges after DNS resolution.
- Block redirects in delivery.

Origin verification:
- Support a Telegram-style secret token header.
- Add optional HMAC signature over raw body as defense in depth.

PII minimization:
- Current `encodeUser` can include email/phone when `min=false` (`server/src/realtime/encoders/encodeUser.ts`).
- Some server updates embed `User` objects (for example space member add in `server/src/functions/space.inviteToSpace.ts`).
- Bot event pipeline must run a sanitizer so bot payloads never include:
  - `email`, `phone_number`, and any other sensitive fields.
- Prefer a dedicated bot encoder, not reuse of internal "full user" encoding.

---

## 11) Testing Plan (Expanded)

Unit tests:
- Outbox rows are emitted for chat/space updates and for user bucket updates.
- Outbox expansion is idempotent.
- Recipient resolution across:
  - DM chats (bot is min or max id).
  - Space public threads (bot is member with public access).
  - Private threads (bot is a participant).
- allowed_updates filtering.
- Per-bot update_id allocation is gapless under concurrency.
- Sanitization: bot payloads never include email/phone.

Integration tests:
- Webhook retries: receiver returns 500 twice then 200.
- Ordering: two updates for same bot never delivered out of order.
- Mode switching:
  - Polling then enabling webhook.
  - Webhook with `drop_pending_updates` clears backlog.
- Polling ack behavior matches Telegram-style offset confirmation.

Performance checks:
- Public thread recipient resolution queries only bots, not all members.
- Worker throughput and DB load are measurable and bounded.

Reference: existing sync tests demonstrate the persistent update inflation path:
- `server/src/__tests__/modules/syncFlow.test.ts`

---

## 12) Senior Engineer Oversight Pass (Third-Pass Concerns)

Things to block merge on:
- Public API must not expose internal `core.Update` union directly.
- Per-bot monotonic update_id and explicit ack semantics.
- One in-flight per bot (until multi-connection is explicitly supported).
- No webhook work on hot paths.
- Idempotent outbox and expansion.
- SSRF controls.
- PII sanitizer boundary and tests.
- Observability:
  - Pending queue depth.
  - Delivery success rate.
  - Last error visibility (`getWebhookInfo`).
  - Cleanup/TTL for delivered and dead-letter rows.

Suggested ship milestones:
- Milestone 1: durable bot updates queue + `getUpdates` polling.
- Milestone 2: webhook delivery and webhook management.
- Milestone 3: SDK packaging + examples, then add realtime-only event types if desired.

---

## 13) Open Questions (Need Decisions)

1) Audience model:
- Do bots receive all events for chats/spaces they are members of by default?
- Do we need explicit per-chat subscriptions?

2) Privacy mode:
- Should bots default to mention-only visibility in group contexts?

3) Mode exclusivity:
- Strict Telegram behavior (webhook disables polling) or allow both with explicit duplicate contract?

4) Payload stability:
- Should bot payload use minimal Inline types (Message/Chat/Peer) or a more independent schema?

5) Retention:
- Keep pending bot updates 24 hours like Telegram, or configurable?

---

## 14) Production Readiness Note

Not ready for production until:
- Outbox is in place and idempotent.
- update_id semantics are implemented and tested.
- Webhook SSRF + secret verification are implemented.
- PII-sanitization is implemented and tested.

