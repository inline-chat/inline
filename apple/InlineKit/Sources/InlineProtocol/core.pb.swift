// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Method: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case getMe // = 1
  case sendMessage // = 2
  case getPeerPhoto // = 3
  case deleteMessages // = 4
  case getChatHistory // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .getMe
    case 2: self = .sendMessage
    case 3: self = .getPeerPhoto
    case 4: self = .deleteMessages
    case 5: self = .getChatHistory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .getMe: return 1
    case .sendMessage: return 2
    case .getPeerPhoto: return 3
    case .deleteMessages: return 4
    case .getChatHistory: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Method] = [
    .unspecified,
    .getMe,
    .sendMessage,
    .getPeerPhoto,
    .deleteMessages,
    .getChatHistory,
  ]

}

public struct ClientMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var seq: UInt32 = 0

  public var body: ClientMessage.OneOf_Body? = nil

  public var connectionInit: ConnectionInit {
    get {
      if case .connectionInit(let v)? = body {return v}
      return ConnectionInit()
    }
    set {body = .connectionInit(newValue)}
  }

  public var rpcCall: RpcCall {
    get {
      if case .rpcCall(let v)? = body {return v}
      return RpcCall()
    }
    set {body = .rpcCall(newValue)}
  }

  public var ack: Ack {
    get {
      if case .ack(let v)? = body {return v}
      return Ack()
    }
    set {body = .ack(newValue)}
  }

  public var ping: Ping {
    get {
      if case .ping(let v)? = body {return v}
      return Ping()
    }
    set {body = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    case connectionInit(ConnectionInit)
    case rpcCall(RpcCall)
    case ack(Ack)
    case ping(Ping)

  }

  public init() {}
}

public struct ConnectionInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ServerProtocolMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var body: ServerProtocolMessage.OneOf_Body? = nil

  public var connectionOpen: ConnectionOpen {
    get {
      if case .connectionOpen(let v)? = body {return v}
      return ConnectionOpen()
    }
    set {body = .connectionOpen(newValue)}
  }

  public var rpcResult: RpcResult {
    get {
      if case .rpcResult(let v)? = body {return v}
      return RpcResult()
    }
    set {body = .rpcResult(newValue)}
  }

  public var rpcError: RpcError {
    get {
      if case .rpcError(let v)? = body {return v}
      return RpcError()
    }
    set {body = .rpcError(newValue)}
  }

  public var message: ServerMessage {
    get {
      if case .message(let v)? = body {return v}
      return ServerMessage()
    }
    set {body = .message(newValue)}
  }

  public var ack: Ack {
    get {
      if case .ack(let v)? = body {return v}
      return Ack()
    }
    set {body = .ack(newValue)}
  }

  public var pong: Pong {
    get {
      if case .pong(let v)? = body {return v}
      return Pong()
    }
    set {body = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    case connectionOpen(ConnectionOpen)
    case rpcResult(RpcResult)
    case rpcError(RpcError)
    case message(ServerMessage)
    case ack(Ack)
    case pong(Pong)

  }

  public init() {}
}

public struct ServerMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: ServerMessage.OneOf_Payload? = nil

  public var update: UpdatesPayload {
    get {
      if case .update(let v)? = payload {return v}
      return UpdatesPayload()
    }
    set {payload = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case update(UpdatesPayload)

  }

  public init() {}
}

public struct UpdatesPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msgID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ConnectionOpen: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonce: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pong: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonce: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: InputPeer.OneOf_Type? = nil

  public var self_p: InputPeerSelf {
    get {
      if case .self_p(let v)? = type {return v}
      return InputPeerSelf()
    }
    set {type = .self_p(newValue)}
  }

  public var chat: InputPeerChat {
    get {
      if case .chat(let v)? = type {return v}
      return InputPeerChat()
    }
    set {type = .chat(newValue)}
  }

  public var user: InputPeerUser {
    get {
      if case .user(let v)? = type {return v}
      return InputPeerUser()
    }
    set {type = .user(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case self_p(InputPeerSelf)
    case chat(InputPeerChat)
    case user(InputPeerUser)

  }

  public init() {}
}

public struct InputPeerSelf: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeerChat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeerUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Peer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Peer.OneOf_Type? = nil

  public var chat: PeerChat {
    get {
      if case .chat(let v)? = type {return v}
      return PeerChat()
    }
    set {type = .chat(newValue)}
  }

  public var user: PeerUser {
    get {
      if case .user(let v)? = type {return v}
      return PeerUser()
    }
    set {type = .user(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case chat(PeerChat)
    case user(PeerUser)

  }

  public init() {}
}

public struct PeerChat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PeerUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var firstName: String {
    get {return _firstName ?? String()}
    set {_firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  public var hasFirstName: Bool {return self._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  public mutating func clearFirstName() {self._firstName = nil}

  public var lastName: String {
    get {return _lastName ?? String()}
    set {_lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  public var hasLastName: Bool {return self._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  public mutating func clearLastName() {self._lastName = nil}

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var phoneNumber: String {
    get {return _phoneNumber ?? String()}
    set {_phoneNumber = newValue}
  }
  /// Returns true if `phoneNumber` has been explicitly set.
  public var hasPhoneNumber: Bool {return self._phoneNumber != nil}
  /// Clears the value of `phoneNumber`. Subsequent reads from it will return its default value.
  public mutating func clearPhoneNumber() {self._phoneNumber = nil}

  public var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {self._email = nil}

  /// If true, certain fields such as email or phone_number will be missing
  public var min: Bool {
    get {return _min ?? false}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  public var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  public mutating func clearMin() {self._min = nil}

  public var status: UserStatus {
    get {return _status ?? UserStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var profilePhoto: UserProfilePhoto {
    get {return _profilePhoto ?? UserProfilePhoto()}
    set {_profilePhoto = newValue}
  }
  /// Returns true if `profilePhoto` has been explicitly set.
  public var hasProfilePhoto: Bool {return self._profilePhoto != nil}
  /// Clears the value of `profilePhoto`. Subsequent reads from it will return its default value.
  public mutating func clearProfilePhoto() {self._profilePhoto = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _firstName: String? = nil
  fileprivate var _lastName: String? = nil
  fileprivate var _username: String? = nil
  fileprivate var _phoneNumber: String? = nil
  fileprivate var _email: String? = nil
  fileprivate var _min: Bool? = nil
  fileprivate var _status: UserStatus? = nil
  fileprivate var _profilePhoto: UserProfilePhoto? = nil
}

public struct UserProfilePhoto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the photo
  public var photoID: Int64 = 0

  /// Stripped thumbnail of the photo
  public var strippedThumb: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Message: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User ID of the sender
  public var fromID: Int64 {
    get {return _storage._fromID}
    set {_uniqueStorage()._fromID = newValue}
  }

  /// Peer ID of the recipient
  public var peerID: Peer {
    get {return _storage._peerID ?? Peer()}
    set {_uniqueStorage()._peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return _storage._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {_uniqueStorage()._peerID = nil}

  /// The "chat ID" of the message, for messages in a chat
  public var chatID: Int64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  /// Message text
  public var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// Whether the message is outgoing
  public var out: Bool {
    get {return _storage._out}
    set {_uniqueStorage()._out = newValue}
  }

  /// Date of the message
  public var date: Int64 {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  /// Whether user is mentioned
  public var mentioned: Bool {
    get {return _storage._mentioned ?? false}
    set {_uniqueStorage()._mentioned = newValue}
  }
  /// Returns true if `mentioned` has been explicitly set.
  public var hasMentioned: Bool {return _storage._mentioned != nil}
  /// Clears the value of `mentioned`. Subsequent reads from it will return its default value.
  public mutating func clearMentioned() {_uniqueStorage()._mentioned = nil}

  /// Message ID of the message being replied to
  public var replyToMsgID: Int64 {
    get {return _storage._replyToMsgID ?? 0}
    set {_uniqueStorage()._replyToMsgID = newValue}
  }
  /// Returns true if `replyToMsgID` has been explicitly set.
  public var hasReplyToMsgID: Bool {return _storage._replyToMsgID != nil}
  /// Clears the value of `replyToMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearReplyToMsgID() {_uniqueStorage()._replyToMsgID = nil}

  /// Media of the message
  public var media: MessageMedia {
    get {return _storage._media ?? MessageMedia()}
    set {_uniqueStorage()._media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return _storage._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {_uniqueStorage()._media = nil}

  /// Date of the last edit if edited
  public var editDate: Int64 {
    get {return _storage._editDate ?? 0}
    set {_uniqueStorage()._editDate = newValue}
  }
  /// Returns true if `editDate` has been explicitly set.
  public var hasEditDate: Bool {return _storage._editDate != nil}
  /// Clears the value of `editDate`. Subsequent reads from it will return its default value.
  public mutating func clearEditDate() {_uniqueStorage()._editDate = nil}

  /// ID of the grouped message if it's part of an album
  public var groupedID: Int64 {
    get {return _storage._groupedID ?? 0}
    set {_uniqueStorage()._groupedID = newValue}
  }
  /// Returns true if `groupedID` has been explicitly set.
  public var hasGroupedID: Bool {return _storage._groupedID != nil}
  /// Clears the value of `groupedID`. Subsequent reads from it will return its default value.
  public mutating func clearGroupedID() {_uniqueStorage()._groupedID = nil}

  /// Attachments of the message
  public var attachments: MessageAttachments {
    get {return _storage._attachments ?? MessageAttachments()}
    set {_uniqueStorage()._attachments = newValue}
  }
  /// Returns true if `attachments` has been explicitly set.
  public var hasAttachments: Bool {return _storage._attachments != nil}
  /// Clears the value of `attachments`. Subsequent reads from it will return its default value.
  public mutating func clearAttachments() {_uniqueStorage()._attachments = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MessageAttachments: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachments: [MessageAttachment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: Int64 = 0

  public var attachment: MessageAttachment.OneOf_Attachment? = nil

  public var externalTask: MessageAttachmentExternalTask {
    get {
      if case .externalTask(let v)? = attachment {return v}
      return MessageAttachmentExternalTask()
    }
    set {attachment = .externalTask(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Attachment: Equatable, Sendable {
    case externalTask(MessageAttachmentExternalTask)

  }

  public init() {}
}

public struct MessageAttachmentExternalTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of external task in our database
  public var id: Int64 = 0

  /// ID of the task in the external application
  public var taskID: String = String()

  /// Application name 
  public var application: String = String()

  /// Title of the task/issue
  public var title: String = String()

  /// Status of the task
  public var status: MessageAttachmentExternalTask.Status = .unspecified

  /// Assigned user ID in Inline
  public var assignedUserID: Int64 = 0

  /// URL of the task/issue in the external application
  public var url: String = String()

  /// Number/code of the task/issue in the external application
  public var number: String = String()

  /// Date of creation/addition in Inline
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case backlog // = 1
    case todo // = 2
    case inProgress // = 3
    case done // = 4
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .backlog
      case 2: self = .todo
      case 3: self = .inProgress
      case 4: self = .done
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .backlog: return 1
      case .todo: return 2
      case .inProgress: return 3
      case .done: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [MessageAttachmentExternalTask.Status] = [
      .unspecified,
      .backlog,
      .todo,
      .inProgress,
      .done,
      .cancelled,
    ]

  }

  public init() {}
}

/// WIP: add document, audio, video.
public struct MessageMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: MessageMedia.OneOf_Media? = nil

  public var photo: MessagePhoto {
    get {
      if case .photo(let v)? = media {return v}
      return MessagePhoto()
    }
    set {media = .photo(newValue)}
  }

  public var video: MessageVideo {
    get {
      if case .video(let v)? = media {return v}
      return MessageVideo()
    }
    set {media = .video(newValue)}
  }

  public var document: MessageDocument {
    get {
      if case .document(let v)? = media {return v}
      return MessageDocument()
    }
    set {media = .document(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Media: Equatable, Sendable {
    case photo(MessagePhoto)
    case video(MessageVideo)
    case document(MessageDocument)

  }

  public init() {}
}

public struct MessagePhoto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
}

public struct MessageVideo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var video: Video {
    get {return _video ?? Video()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {self._video = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _video: Video? = nil
}

public struct MessageDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var document: Document {
    get {return _document ?? Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Document? = nil
}

public struct Video: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Date of upload
  public var date: Int64 = 0

  /// Width of the video
  public var w: Int32 = 0

  /// Height of the video
  public var h: Int32 = 0

  /// Duration of the video in seconds
  public var duration: Int32 = 0

  /// File size
  public var size: Int32 = 0

  /// Thumbnail of the video
  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
  fileprivate var _cdnURL: String? = nil
}

public struct Document: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Original file name
  public var fileName: String = String()

  /// MIME type of the file
  public var mimeType: String = String()

  /// File size
  public var size: Int32 = 0

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  /// Date of upload
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cdnURL: String? = nil
}

/// Photo for message media, profile photo, space photo, or chat photo
public struct Photo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID
  public var id: Int64 = 0

  /// Date of upload
  public var date: Int64 = 0

  public var sizes: [PhotoSize] = []

  /// Format of the photo
  public var format: Photo.Format = .unspecified

  /// Unique identifier of the file
  public var fileUniqueID: String {
    get {return _fileUniqueID ?? String()}
    set {_fileUniqueID = newValue}
  }
  /// Returns true if `fileUniqueID` has been explicitly set.
  public var hasFileUniqueID: Bool {return self._fileUniqueID != nil}
  /// Clears the value of `fileUniqueID`. Subsequent reads from it will return its default value.
  public mutating func clearFileUniqueID() {self._fileUniqueID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case jpeg // = 1
    case png // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .jpeg
      case 2: self = .png
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .jpeg: return 1
      case .png: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Photo.Format] = [
      .unspecified,
      .jpeg,
      .png,
    ]

  }

  public init() {}

  fileprivate var _fileUniqueID: String? = nil
}

public struct PhotoSize: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///* Thumbnail type.
  ///Currently supported: 
  ///- "b" - small box 140x140
  ///- "c" - medium box 320x320
  ///- "d" - regular box 800x800
  ///- "f" - large box 2560x2560
  ///- "s" - stripped (tiny version embedded in bytes)
  ///- "y" - ??
  ///- "x" - small cropped ??
  ///- "w" - medium cropped ??
  ///- "v" - ??
  public var type: String = String()

  /// Width in pixels
  public var w: Int32 = 0

  /// Height in pixels
  public var h: Int32 = 0

  /// File size
  public var size: Int32 = 0

  /// Bytes for stripped size used in blur thumbnails
  public var bytes: Data {
    get {return _bytes ?? Data()}
    set {_bytes = newValue}
  }
  /// Returns true if `bytes` has been explicitly set.
  public var hasBytes: Bool {return self._bytes != nil}
  /// Clears the value of `bytes`. Subsequent reads from it will return its default value.
  public mutating func clearBytes() {self._bytes = nil}

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bytes: Data? = nil
  fileprivate var _cdnURL: String? = nil
}

public struct RpcError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reqMsgID: UInt64 = 0

  public var errorCode: RpcError.Code = .unknown

  public var message: String = String()

  public var code: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of error
  public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case badRequest // = 1
    case unauthenticated // = 2
    case rateLimit // = 3
    case internalError // = 4
    case peerIDInvalid // = 5
    case messageIDInvalid // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .badRequest
      case 2: self = .unauthenticated
      case 3: self = .rateLimit
      case 4: self = .internalError
      case 5: self = .peerIDInvalid
      case 6: self = .messageIDInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .badRequest: return 1
      case .unauthenticated: return 2
      case .rateLimit: return 3
      case .internalError: return 4
      case .peerIDInvalid: return 5
      case .messageIDInvalid: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [RpcError.Code] = [
      .unknown,
      .badRequest,
      .unauthenticated,
      .rateLimit,
      .internalError,
      .peerIDInvalid,
      .messageIDInvalid,
    ]

  }

  public init() {}
}

public struct RpcCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Method = .unspecified

  public var input: RpcCall.OneOf_Input? = nil

  public var getMe: GetMeInput {
    get {
      if case .getMe(let v)? = input {return v}
      return GetMeInput()
    }
    set {input = .getMe(newValue)}
  }

  public var getPeerPhoto: GetPeerPhotoInput {
    get {
      if case .getPeerPhoto(let v)? = input {return v}
      return GetPeerPhotoInput()
    }
    set {input = .getPeerPhoto(newValue)}
  }

  public var deleteMessages: DeleteMessagesInput {
    get {
      if case .deleteMessages(let v)? = input {return v}
      return DeleteMessagesInput()
    }
    set {input = .deleteMessages(newValue)}
  }

  public var sendMessage: SendMessageInput {
    get {
      if case .sendMessage(let v)? = input {return v}
      return SendMessageInput()
    }
    set {input = .sendMessage(newValue)}
  }

  public var getChatHistory: GetChatHistoryInput {
    get {
      if case .getChatHistory(let v)? = input {return v}
      return GetChatHistoryInput()
    }
    set {input = .getChatHistory(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Input: Equatable, Sendable {
    case getMe(GetMeInput)
    case getPeerPhoto(GetPeerPhotoInput)
    case deleteMessages(DeleteMessagesInput)
    case sendMessage(SendMessageInput)
    case getChatHistory(GetChatHistoryInput)

  }

  public init() {}
}

public struct RpcResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reqMsgID: UInt64 = 0

  public var result: RpcResult.OneOf_Result? = nil

  public var getMe: GetMeResult {
    get {
      if case .getMe(let v)? = result {return v}
      return GetMeResult()
    }
    set {result = .getMe(newValue)}
  }

  public var getPeerPhoto: GetPeerPhotoResult {
    get {
      if case .getPeerPhoto(let v)? = result {return v}
      return GetPeerPhotoResult()
    }
    set {result = .getPeerPhoto(newValue)}
  }

  public var deleteMessages: DeleteMessagesResult {
    get {
      if case .deleteMessages(let v)? = result {return v}
      return DeleteMessagesResult()
    }
    set {result = .deleteMessages(newValue)}
  }

  public var sendMessage: SendMessageResult {
    get {
      if case .sendMessage(let v)? = result {return v}
      return SendMessageResult()
    }
    set {result = .sendMessage(newValue)}
  }

  public var getChatHistory: GetChatHistoryResult {
    get {
      if case .getChatHistory(let v)? = result {return v}
      return GetChatHistoryResult()
    }
    set {result = .getChatHistory(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case getMe(GetMeResult)
    case getPeerPhoto(GetPeerPhotoResult)
    case deleteMessages(DeleteMessagesResult)
    case sendMessage(SendMessageResult)
    case getChatHistory(GetChatHistoryResult)

  }

  public init() {}
}

public struct GetMeInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetMeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: User? = nil
}

public struct GetPeerPhotoInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var photoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct GetPeerPhotoResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
}

public struct DeleteMessagesInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int64] = []

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct DeleteMessagesResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: InputMedia.OneOf_Media? = nil

  public var photo: InputMediaPhoto {
    get {
      if case .photo(let v)? = media {return v}
      return InputMediaPhoto()
    }
    set {media = .photo(newValue)}
  }

  public var video: InputMediaVideo {
    get {
      if case .video(let v)? = media {return v}
      return InputMediaVideo()
    }
    set {media = .video(newValue)}
  }

  public var document: InputMediaDocument {
    get {
      if case .document(let v)? = media {return v}
      return InputMediaDocument()
    }
    set {media = .document(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Media: Equatable, Sendable {
    case photo(InputMediaPhoto)
    case video(InputMediaVideo)
    case document(InputMediaDocument)

  }

  public init() {}
}

public struct InputMediaPhoto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the photo that we have uploaded
  public var photoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMediaVideo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the video that we have uploaded
  public var videoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMediaDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the document that we have uploaded
  public var documentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SendMessageInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Message text or caption
  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  /// Message ID of the message being replied to
  public var replyToMsgID: Int64 {
    get {return _replyToMsgID ?? 0}
    set {_replyToMsgID = newValue}
  }
  /// Returns true if `replyToMsgID` has been explicitly set.
  public var hasReplyToMsgID: Bool {return self._replyToMsgID != nil}
  /// Clears the value of `replyToMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearReplyToMsgID() {self._replyToMsgID = nil}

  /// Random ID to prevent duplicate messages
  public var randomID: Int64 {
    get {return _randomID ?? 0}
    set {_randomID = newValue}
  }
  /// Returns true if `randomID` has been explicitly set.
  public var hasRandomID: Bool {return self._randomID != nil}
  /// Clears the value of `randomID`. Subsequent reads from it will return its default value.
  public mutating func clearRandomID() {self._randomID = nil}

  /// Media to send
  public var media: InputMedia {
    get {return _media ?? InputMedia()}
    set {_media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return self._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {self._media = nil}

  /// Date of sending (until we fix the client reordering)
  public var temporarySendDate: Int64 {
    get {return _temporarySendDate ?? 0}
    set {_temporarySendDate = newValue}
  }
  /// Returns true if `temporarySendDate` has been explicitly set.
  public var hasTemporarySendDate: Bool {return self._temporarySendDate != nil}
  /// Clears the value of `temporarySendDate`. Subsequent reads from it will return its default value.
  public mutating func clearTemporarySendDate() {self._temporarySendDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
  fileprivate var _message: String? = nil
  fileprivate var _replyToMsgID: Int64? = nil
  fileprivate var _randomID: Int64? = nil
  fileprivate var _media: InputMedia? = nil
  fileprivate var _temporarySendDate: Int64? = nil
}

public struct SendMessageResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChatHistoryInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// ID of the message to start from
  public var offsetID: Int64 {
    get {return _offsetID ?? 0}
    set {_offsetID = newValue}
  }
  /// Returns true if `offsetID` has been explicitly set.
  public var hasOffsetID: Bool {return self._offsetID != nil}
  /// Clears the value of `offsetID`. Subsequent reads from it will return its default value.
  public mutating func clearOffsetID() {self._offsetID = nil}

  /// Number of messages to return
  public var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
  fileprivate var _offsetID: Int64? = nil
  fileprivate var _limit: Int32? = nil
}

public struct GetChatHistoryResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///  Updates Subsystem
public struct Update: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var update: Update.OneOf_Update? = nil

  public var newMessage: UpdateNewMessage {
    get {
      if case .newMessage(let v)? = update {return v}
      return UpdateNewMessage()
    }
    set {update = .newMessage(newValue)}
  }

  public var editMessage: UpdateEditMessage {
    get {
      if case .editMessage(let v)? = update {return v}
      return UpdateEditMessage()
    }
    set {update = .editMessage(newValue)}
  }

  public var updateMessageID: UpdateMessageId {
    get {
      if case .updateMessageID(let v)? = update {return v}
      return UpdateMessageId()
    }
    set {update = .updateMessageID(newValue)}
  }

  public var deleteMessages: UpdateDeleteMessages {
    get {
      if case .deleteMessages(let v)? = update {return v}
      return UpdateDeleteMessages()
    }
    set {update = .deleteMessages(newValue)}
  }

  public var updateComposeAction: UpdateComposeAction {
    get {
      if case .updateComposeAction(let v)? = update {return v}
      return UpdateComposeAction()
    }
    set {update = .updateComposeAction(newValue)}
  }

  public var updateUserStatus: UpdateUserStatus {
    get {
      if case .updateUserStatus(let v)? = update {return v}
      return UpdateUserStatus()
    }
    set {update = .updateUserStatus(newValue)}
  }

  public var messageAttachment: UpdateMessageAttachment {
    get {
      if case .messageAttachment(let v)? = update {return v}
      return UpdateMessageAttachment()
    }
    set {update = .messageAttachment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Update: Equatable, Sendable {
    case newMessage(UpdateNewMessage)
    case editMessage(UpdateEditMessage)
    case updateMessageID(UpdateMessageId)
    case deleteMessages(UpdateDeleteMessages)
    case updateComposeAction(UpdateComposeAction)
    case updateUserStatus(UpdateUserStatus)
    case messageAttachment(UpdateMessageAttachment)

  }

  public init() {}
}

public struct UpdateNewMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Message? = nil
}

public struct UpdateEditMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Message? = nil
}

/// Update when messages are deleted
public struct UpdateDeleteMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int64] = []

  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

/// Update when a message ID is updated after sending
public struct UpdateMessageId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: Int64 = 0

  public var randomID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update when a user starts or stops composing a message for typing, uploading a photo, etc
public struct UpdateComposeAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User ID of the user who is composing the message
  public var userID: Int64 = 0

  /// Peer ID of the peer user is composing the message to
  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Action of the user (typing, etc)
  public var action: UpdateComposeAction.ComposeAction = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ComposeAction: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case none // = 0
    case typing // = 1
    case uploadingPhoto // = 2
    case uploadingDocument // = 3
    case uploadingVideo // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .typing
      case 2: self = .uploadingPhoto
      case 3: self = .uploadingDocument
      case 4: self = .uploadingVideo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .typing: return 1
      case .uploadingPhoto: return 2
      case .uploadingDocument: return 3
      case .uploadingVideo: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [UpdateComposeAction.ComposeAction] = [
      .none,
      .typing,
      .uploadingPhoto,
      .uploadingDocument,
      .uploadingVideo,
    ]

  }

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

public struct UpdateMessageAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachment: MessageAttachment {
    get {return _attachment ?? MessageAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: MessageAttachment? = nil
}

public struct UpdateUserStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var status: UserStatus {
    get {return _status ?? UserStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: UserStatus? = nil
}

public struct UserStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var online: UserStatus.Status = .unknown

  public var lastOnline: LastOnline {
    get {return _lastOnline ?? LastOnline()}
    set {_lastOnline = newValue}
  }
  /// Returns true if `lastOnline` has been explicitly set.
  public var hasLastOnline: Bool {return self._lastOnline != nil}
  /// Clears the value of `lastOnline`. Subsequent reads from it will return its default value.
  public mutating func clearLastOnline() {self._lastOnline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case online // = 1
    case offline // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .online
      case 2: self = .offline
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .online: return 1
      case .offline: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [UserStatus.Status] = [
      .unknown,
      .online,
      .offline,
    ]

  }

  public init() {}

  fileprivate var _lastOnline: LastOnline? = nil
}

public struct LastOnline: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Date of the last online if exact last online is permitted by the user
  public var date: Int64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: Int64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "GET_ME"),
    2: .same(proto: "SEND_MESSAGE"),
    3: .same(proto: "GET_PEER_PHOTO"),
    4: .same(proto: "DELETE_MESSAGES"),
    5: .same(proto: "GET_CHAT_HISTORY"),
  ]
}

extension ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "seq"),
    4: .standard(proto: "connection_init"),
    5: .standard(proto: "rpc_call"),
    6: .same(proto: "ack"),
    7: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 4: try {
        var v: ConnectionInit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .connectionInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .connectionInit(v)
        }
      }()
      case 5: try {
        var v: RpcCall?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcCall(v)
        }
      }()
      case 6: try {
        var v: Ack?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ack(v)
        }
      }()
      case 7: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 2)
    }
    switch self.body {
    case .connectionInit?: try {
      guard case .connectionInit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpcCall?: try {
      guard case .rpcCall(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientMessage, rhs: ClientMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConnectionInit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConnectionInit, rhs: ConnectionInit) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServerProtocolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ServerProtocolMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    4: .standard(proto: "connection_open"),
    5: .standard(proto: "rpc_result"),
    6: .standard(proto: "rpc_error"),
    7: .same(proto: "message"),
    8: .same(proto: "ack"),
    9: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 4: try {
        var v: ConnectionOpen?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .connectionOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .connectionOpen(v)
        }
      }()
      case 5: try {
        var v: RpcResult?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcResult(v)
        }
      }()
      case 6: try {
        var v: RpcError?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcError(v)
        }
      }()
      case 7: try {
        var v: ServerMessage?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .message(v)
        }
      }()
      case 8: try {
        var v: Ack?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ack(v)
        }
      }()
      case 9: try {
        var v: Pong?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.body {
    case .connectionOpen?: try {
      guard case .connectionOpen(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpcResult?: try {
      guard case .rpcResult(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .rpcError?: try {
      guard case .rpcError(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .message?: try {
      guard case .message(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerProtocolMessage, rhs: ServerProtocolMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ServerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: UpdatesPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerMessage, rhs: ServerMessage) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdatesPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdatesPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdatesPayload, rhs: UpdatesPayload) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.msgID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ack, rhs: Ack) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConnectionOpen"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConnectionOpen, rhs: ConnectionOpen) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ping, rhs: Ping) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Pong"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pong, rhs: Pong) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "self"),
    3: .same(proto: "chat"),
    4: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: InputPeerSelf?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .self_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .self_p(v)
        }
      }()
      case 3: try {
        var v: InputPeerChat?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chat(v)
        }
      }()
      case 4: try {
        var v: InputPeerUser?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .user(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .self_p?: try {
      guard case .self_p(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chat?: try {
      guard case .chat(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .user?: try {
      guard case .user(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeer, rhs: InputPeer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerSelf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerSelf"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerSelf, rhs: InputPeerSelf) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerChat, rhs: InputPeerChat) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerUser, rhs: InputPeerUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Peer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "chat"),
    3: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: PeerChat?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chat(v)
        }
      }()
      case 3: try {
        var v: PeerUser?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .user(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .chat?: try {
      guard case .chat(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .user?: try {
      guard case .user(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Peer, rhs: Peer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeerChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeerChat, rhs: PeerChat) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeerUser, rhs: PeerUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "first_name"),
    3: .standard(proto: "last_name"),
    4: .same(proto: "username"),
    5: .standard(proto: "phone_number"),
    6: .same(proto: "email"),
    7: .same(proto: "min"),
    8: .same(proto: "status"),
    9: .standard(proto: "profile_photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._firstName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._lastName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._phoneNumber) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._email) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._min) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._profilePhoto) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._firstName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._phoneNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._min {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._profilePhoto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._firstName != rhs._firstName {return false}
    if lhs._lastName != rhs._lastName {return false}
    if lhs._username != rhs._username {return false}
    if lhs._phoneNumber != rhs._phoneNumber {return false}
    if lhs._email != rhs._email {return false}
    if lhs._min != rhs._min {return false}
    if lhs._status != rhs._status {return false}
    if lhs._profilePhoto != rhs._profilePhoto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserProfilePhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserProfilePhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
    2: .standard(proto: "stripped_thumb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.photoID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.strippedThumb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularInt64Field(value: self.photoID, fieldNumber: 1)
    }
    if !self.strippedThumb.isEmpty {
      try visitor.visitSingularBytesField(value: self.strippedThumb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserProfilePhoto, rhs: UserProfilePhoto) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.strippedThumb != rhs.strippedThumb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "from_id"),
    3: .standard(proto: "peer_id"),
    4: .standard(proto: "chat_id"),
    5: .same(proto: "message"),
    6: .same(proto: "out"),
    7: .same(proto: "date"),
    8: .same(proto: "mentioned"),
    9: .standard(proto: "reply_to_msg_id"),
    10: .same(proto: "media"),
    11: .standard(proto: "edit_date"),
    12: .standard(proto: "grouped_id"),
    13: .same(proto: "attachments"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _fromID: Int64 = 0
    var _peerID: Peer? = nil
    var _chatID: Int64 = 0
    var _message: String? = nil
    var _out: Bool = false
    var _date: Int64 = 0
    var _mentioned: Bool? = nil
    var _replyToMsgID: Int64? = nil
    var _media: MessageMedia? = nil
    var _editDate: Int64? = nil
    var _groupedID: Int64? = nil
    var _attachments: MessageAttachments? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fromID = source._fromID
      _peerID = source._peerID
      _chatID = source._chatID
      _message = source._message
      _out = source._out
      _date = source._date
      _mentioned = source._mentioned
      _replyToMsgID = source._replyToMsgID
      _media = source._media
      _editDate = source._editDate
      _groupedID = source._groupedID
      _attachments = source._attachments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._fromID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._peerID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._chatID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._out) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._date) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._mentioned) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._replyToMsgID) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._media) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._editDate) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._groupedID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._attachments) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._fromID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromID, fieldNumber: 2)
      }
      try { if let v = _storage._peerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._chatID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chatID, fieldNumber: 4)
      }
      try { if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      if _storage._out != false {
        try visitor.visitSingularBoolField(value: _storage._out, fieldNumber: 6)
      }
      if _storage._date != 0 {
        try visitor.visitSingularInt64Field(value: _storage._date, fieldNumber: 7)
      }
      try { if let v = _storage._mentioned {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._replyToMsgID {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._media {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._editDate {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._groupedID {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._attachments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Message, rhs: Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fromID != rhs_storage._fromID {return false}
        if _storage._peerID != rhs_storage._peerID {return false}
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._out != rhs_storage._out {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._mentioned != rhs_storage._mentioned {return false}
        if _storage._replyToMsgID != rhs_storage._replyToMsgID {return false}
        if _storage._media != rhs_storage._media {return false}
        if _storage._editDate != rhs_storage._editDate {return false}
        if _storage._groupedID != rhs_storage._groupedID {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachments"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachments, rhs: MessageAttachments) -> Bool {
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "external_task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try {
        var v: MessageAttachmentExternalTask?
        var hadOneofValue = false
        if let current = self.attachment {
          hadOneofValue = true
          if case .externalTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attachment = .externalTask(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    try { if case .externalTask(let v)? = self.attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachment, rhs: MessageAttachment) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachmentExternalTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachmentExternalTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "task_id"),
    3: .same(proto: "application"),
    4: .same(proto: "title"),
    5: .same(proto: "status"),
    6: .standard(proto: "assigned_user_id"),
    7: .same(proto: "url"),
    8: .same(proto: "number"),
    9: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.assignedUserID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.assignedUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.assignedUserID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 8)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachmentExternalTask, rhs: MessageAttachmentExternalTask) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.title != rhs.title {return false}
    if lhs.status != rhs.status {return false}
    if lhs.assignedUserID != rhs.assignedUserID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.number != rhs.number {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachmentExternalTask.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_BACKLOG"),
    2: .same(proto: "STATUS_TODO"),
    3: .same(proto: "STATUS_IN_PROGRESS"),
    4: .same(proto: "STATUS_DONE"),
    5: .same(proto: "STATUS_CANCELLED"),
  ]
}

extension MessageMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
    2: .same(proto: "video"),
    3: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MessagePhoto?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .photo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .photo(v)
        }
      }()
      case 2: try {
        var v: MessageVideo?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .video(v)
        }
      }()
      case 3: try {
        var v: MessageDocument?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .document(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.media {
    case .photo?: try {
      guard case .photo(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .video?: try {
      guard case .video(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .document?: try {
      guard case .document(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageMedia, rhs: MessageMedia) -> Bool {
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessagePhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessagePhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessagePhoto, rhs: MessagePhoto) -> Bool {
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "video"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageVideo, rhs: MessageVideo) -> Bool {
    if lhs._video != rhs._video {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageDocument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageDocument, rhs: MessageDocument) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Video"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "w"),
    4: .same(proto: "h"),
    5: .same(proto: "duration"),
    6: .same(proto: "size"),
    7: .same(proto: "photo"),
    8: .standard(proto: "cdn_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.w) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.h) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if self.w != 0 {
      try visitor.visitSingularInt32Field(value: self.w, fieldNumber: 3)
    }
    if self.h != 0 {
      try visitor.visitSingularInt32Field(value: self.h, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 6)
    }
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Video, rhs: Video) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.date != rhs.date {return false}
    if lhs.w != rhs.w {return false}
    if lhs.h != rhs.h {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.size != rhs.size {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Document"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "mime_type"),
    4: .same(proto: "size"),
    5: .standard(proto: "cdn_url"),
    6: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Document, rhs: Document) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.size != rhs.size {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Photo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Photo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "sizes"),
    4: .same(proto: "format"),
    100: .standard(proto: "file_unique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sizes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self._fileUniqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sizes, fieldNumber: 3)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    try { if let v = self._fileUniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Photo, rhs: Photo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.date != rhs.date {return false}
    if lhs.sizes != rhs.sizes {return false}
    if lhs.format != rhs.format {return false}
    if lhs._fileUniqueID != rhs._fileUniqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Photo.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMAT_UNSPECIFIED"),
    1: .same(proto: "FORMAT_JPEG"),
    2: .same(proto: "FORMAT_PNG"),
  ]
}

extension PhotoSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PhotoSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "w"),
    3: .same(proto: "h"),
    4: .same(proto: "size"),
    5: .same(proto: "bytes"),
    6: .standard(proto: "cdn_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.w) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.h) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._bytes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.w != 0 {
      try visitor.visitSingularInt32Field(value: self.w, fieldNumber: 2)
    }
    if self.h != 0 {
      try visitor.visitSingularInt32Field(value: self.h, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    try { if let v = self._bytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PhotoSize, rhs: PhotoSize) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.w != rhs.w {return false}
    if lhs.h != rhs.h {return false}
    if lhs.size != rhs.size {return false}
    if lhs._bytes != rhs._bytes {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "req_msg_id"),
    2: .standard(proto: "error_code"),
    3: .same(proto: "message"),
    4: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.reqMsgID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reqMsgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.reqMsgID, fieldNumber: 1)
    }
    if self.errorCode != .unknown {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcError, rhs: RpcError) -> Bool {
    if lhs.reqMsgID != rhs.reqMsgID {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BAD_REQUEST"),
    2: .same(proto: "UNAUTHENTICATED"),
    3: .same(proto: "RATE_LIMIT"),
    4: .same(proto: "INTERNAL_ERROR"),
    5: .same(proto: "PEER_ID_INVALID"),
    6: .same(proto: "MESSAGE_ID_INVALID"),
  ]
}

extension RpcCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "getMe"),
    3: .same(proto: "getPeerPhoto"),
    4: .same(proto: "deleteMessages"),
    5: .same(proto: "sendMessage"),
    6: .same(proto: "getChatHistory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try {
        var v: GetMeInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getMe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getMe(v)
        }
      }()
      case 3: try {
        var v: GetPeerPhotoInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getPeerPhoto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getPeerPhoto(v)
        }
      }()
      case 4: try {
        var v: DeleteMessagesInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .deleteMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .deleteMessages(v)
        }
      }()
      case 5: try {
        var v: SendMessageInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .sendMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .sendMessage(v)
        }
      }()
      case 6: try {
        var v: GetChatHistoryInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getChatHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getChatHistory(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.method != .unspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    switch self.input {
    case .getMe?: try {
      guard case .getMe(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPeerPhoto?: try {
      guard case .getPeerPhoto(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMessages?: try {
      guard case .deleteMessages(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sendMessage?: try {
      guard case .sendMessage(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getChatHistory?: try {
      guard case .getChatHistory(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcCall, rhs: RpcCall) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "req_msg_id"),
    2: .same(proto: "getMe"),
    3: .same(proto: "getPeerPhoto"),
    4: .same(proto: "deleteMessages"),
    5: .same(proto: "sendMessage"),
    6: .same(proto: "getChatHistory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.reqMsgID) }()
      case 2: try {
        var v: GetMeResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .getMe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .getMe(v)
        }
      }()
      case 3: try {
        var v: GetPeerPhotoResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .getPeerPhoto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .getPeerPhoto(v)
        }
      }()
      case 4: try {
        var v: DeleteMessagesResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .deleteMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .deleteMessages(v)
        }
      }()
      case 5: try {
        var v: SendMessageResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .sendMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .sendMessage(v)
        }
      }()
      case 6: try {
        var v: GetChatHistoryResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .getChatHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .getChatHistory(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.reqMsgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.reqMsgID, fieldNumber: 1)
    }
    switch self.result {
    case .getMe?: try {
      guard case .getMe(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPeerPhoto?: try {
      guard case .getPeerPhoto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMessages?: try {
      guard case .deleteMessages(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sendMessage?: try {
      guard case .sendMessage(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getChatHistory?: try {
      guard case .getChatHistory(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcResult, rhs: RpcResult) -> Bool {
    if lhs.reqMsgID != rhs.reqMsgID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetMeInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMeInput, rhs: GetMeInput) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetMeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMeResult, rhs: GetMeResult) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPeerPhotoInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPeerPhotoInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.photoID != 0 {
      try visitor.visitSingularInt64Field(value: self.photoID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPeerPhotoInput, rhs: GetPeerPhotoInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPeerPhotoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPeerPhotoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPeerPhotoResult, rhs: GetPeerPhotoResult) -> Bool {
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteMessagesInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteMessagesInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
    2: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageIds, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteMessagesInput, rhs: DeleteMessagesInput) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteMessagesResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteMessagesResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteMessagesResult, rhs: DeleteMessagesResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
    2: .same(proto: "video"),
    3: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InputMediaPhoto?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .photo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .photo(v)
        }
      }()
      case 2: try {
        var v: InputMediaVideo?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .video(v)
        }
      }()
      case 3: try {
        var v: InputMediaDocument?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .document(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.media {
    case .photo?: try {
      guard case .photo(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .video?: try {
      guard case .video(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .document?: try {
      guard case .document(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMedia, rhs: InputMedia) -> Bool {
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaPhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaPhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularInt64Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaPhoto, rhs: InputMediaPhoto) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.videoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoID != 0 {
      try visitor.visitSingularInt64Field(value: self.videoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaVideo, rhs: InputMediaVideo) -> Bool {
    if lhs.videoID != rhs.videoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaDocument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.documentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.documentID != 0 {
      try visitor.visitSingularInt64Field(value: self.documentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaDocument, rhs: InputMediaDocument) -> Bool {
    if lhs.documentID != rhs.documentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .same(proto: "message"),
    3: .standard(proto: "reply_to_msg_id"),
    4: .standard(proto: "random_id"),
    5: .same(proto: "media"),
    1000: .standard(proto: "temporary_send_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._replyToMsgID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._randomID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      case 1000: try { try decoder.decodeSingularInt64Field(value: &self._temporarySendDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._replyToMsgID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._randomID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._temporarySendDate {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendMessageInput, rhs: SendMessageInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._message != rhs._message {return false}
    if lhs._replyToMsgID != rhs._replyToMsgID {return false}
    if lhs._randomID != rhs._randomID {return false}
    if lhs._media != rhs._media {return false}
    if lhs._temporarySendDate != rhs._temporarySendDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendMessageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendMessageResult, rhs: SendMessageResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatHistoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatHistoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "offset_id"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._offsetID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offsetID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatHistoryInput, rhs: GetChatHistoryInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._offsetID != rhs._offsetID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatHistoryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatHistoryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatHistoryResult, rhs: GetChatHistoryResult) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "new_message"),
    5: .standard(proto: "edit_message"),
    6: .standard(proto: "update_message_id"),
    7: .standard(proto: "delete_messages"),
    8: .standard(proto: "update_compose_action"),
    9: .standard(proto: "update_user_status"),
    10: .standard(proto: "message_attachment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: UpdateNewMessage?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .newMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .newMessage(v)
        }
      }()
      case 5: try {
        var v: UpdateEditMessage?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .editMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .editMessage(v)
        }
      }()
      case 6: try {
        var v: UpdateMessageId?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateMessageID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateMessageID(v)
        }
      }()
      case 7: try {
        var v: UpdateDeleteMessages?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .deleteMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .deleteMessages(v)
        }
      }()
      case 8: try {
        var v: UpdateComposeAction?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateComposeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateComposeAction(v)
        }
      }()
      case 9: try {
        var v: UpdateUserStatus?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateUserStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateUserStatus(v)
        }
      }()
      case 10: try {
        var v: UpdateMessageAttachment?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .messageAttachment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .messageAttachment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.update {
    case .newMessage?: try {
      guard case .newMessage(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .editMessage?: try {
      guard case .editMessage(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .updateMessageID?: try {
      guard case .updateMessageID(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteMessages?: try {
      guard case .deleteMessages(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .updateComposeAction?: try {
      guard case .updateComposeAction(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .updateUserStatus?: try {
      guard case .updateUserStatus(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .messageAttachment?: try {
      guard case .messageAttachment(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Update, rhs: Update) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateNewMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateNewMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateNewMessage, rhs: UpdateNewMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateEditMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateEditMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateEditMessage, rhs: UpdateEditMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateDeleteMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateDeleteMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
    2: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageIds, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateDeleteMessages, rhs: UpdateDeleteMessages) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateMessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateMessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "random_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.randomID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if self.randomID != 0 {
      try visitor.visitSingularInt64Field(value: self.randomID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateMessageId, rhs: UpdateMessageId) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.randomID != rhs.randomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateComposeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateComposeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "peer_id"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.action != .none {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateComposeAction, rhs: UpdateComposeAction) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateComposeAction.ComposeAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "TYPING"),
    2: .same(proto: "UPLOADING_PHOTO"),
    3: .same(proto: "UPLOADING_DOCUMENT"),
    4: .same(proto: "UPLOADING_VIDEO"),
  ]
}

extension UpdateMessageAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateMessageAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateMessageAttachment, rhs: UpdateMessageAttachment) -> Bool {
    if lhs._attachment != rhs._attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateUserStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateUserStatus, rhs: UpdateUserStatus) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "online"),
    2: .standard(proto: "last_online"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.online) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastOnline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.online != .unknown {
      try visitor.visitSingularEnumField(value: self.online, fieldNumber: 1)
    }
    try { if let v = self._lastOnline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserStatus, rhs: UserStatus) -> Bool {
    if lhs.online != rhs.online {return false}
    if lhs._lastOnline != rhs._lastOnline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserStatus.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLINE"),
    2: .same(proto: "OFFLINE"),
  ]
}

extension LastOnline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LastOnline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastOnline, rhs: LastOnline) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
