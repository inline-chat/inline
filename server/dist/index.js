// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// ../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// ../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// ../node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// ../node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// ../node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
    var _a;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// ../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger2 = (0, global_utils_1.getGlobal)("diag");
    if (!logger2) {
      return;
    }
    args.unshift(namespace);
    return logger2[funcName](...args);
  }
});

// ../node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// ../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger2) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger2 = logger2 || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger2[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger2);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// ../node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger2 = (0, global_utils_1.getGlobal)("diag");
          if (!logger2)
            return;
          return logger2[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger2, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger2 === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// ../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// ../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// ../node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// ../node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// ../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// ../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// ../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// ../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// ../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// ../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// ../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// ../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// ../node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// ../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// ../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// ../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// ../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// ../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// ../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})\$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// ../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// ../node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// ../node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// ../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// ../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// ../node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// ../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// ../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// ../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// ../node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// ../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// ../node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// ../node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// ../node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = undefined;
  var api_1 = require_src();
  var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
  }
  exports.suppressTracing = suppressTracing;
  function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
  }
  exports.unsuppressTracing = unsuppressTracing;
  function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
  }
  exports.isTracingSuppressed = isTracingSuppressed;
});

// ../node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = undefined;
  exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
  exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
  exports.BAGGAGE_ITEMS_SEPARATOR = ",";
  exports.BAGGAGE_HEADER = "baggage";
  exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
  exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
  exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
});

// ../node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = undefined;
  var api_1 = require_src();
  var constants_1 = require_constants();
  function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
      const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
      return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, "");
  }
  exports.serializeKeyPairs = serializeKeyPairs;
  function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
      let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
      if (value.metadata !== undefined) {
        entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
      }
      return entry;
    });
  }
  exports.getKeyPairs = getKeyPairs;
  function parsePairKeyValue(entry) {
    const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
      return;
    const keyPairPart = valueProps.shift();
    if (!keyPairPart)
      return;
    const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
      return;
    const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    let metadata;
    if (valueProps.length > 0) {
      metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key, value, metadata };
  }
  exports.parsePairKeyValue = parsePairKeyValue;
  function parseKeyPairsIntoRecord(value) {
    if (typeof value !== "string" || value.length === 0)
      return {};
    return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
      return parsePairKeyValue(entry);
    }).filter((keyPair) => keyPair !== undefined && keyPair.value.length > 0).reduce((headers, keyPair) => {
      headers[keyPair.key] = keyPair.value;
      return headers;
    }, {});
  }
  exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
});

// ../node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CBaggagePropagator = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var constants_1 = require_constants();
  var utils_1 = require_utils3();

  class W3CBaggagePropagator {
    inject(context, carrier, setter) {
      const baggage = api_1.propagation.getBaggage(context);
      if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
        return;
      const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
        return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
      const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
    }
    extract(context, carrier, getter) {
      const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
      const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context;
      const baggage = {};
      if (baggageString.length === 0) {
        return context;
      }
      const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach((entry) => {
        const keyPair = (0, utils_1.parsePairKeyValue)(entry);
        if (keyPair) {
          const baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context;
      }
      return api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
    }
    fields() {
      return [constants_1.BAGGAGE_HEADER];
    }
  }
  exports.W3CBaggagePropagator = W3CBaggagePropagator;
});

// ../node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnchoredClock = undefined;

  class AnchoredClock {
    constructor(systemClock, monotonicClock) {
      this._monotonicClock = monotonicClock;
      this._epochMillis = systemClock.now();
      this._performanceMillis = monotonicClock.now();
    }
    now() {
      const delta = this._monotonicClock.now() - this._performanceMillis;
      return this._epochMillis + delta;
    }
  }
  exports.AnchoredClock = AnchoredClock;
});

// ../node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = undefined;
  var api_1 = require_src();
  function sanitizeAttributes(attributes) {
    const out = {};
    if (typeof attributes !== "object" || attributes == null) {
      return out;
    }
    for (const [key, val2] of Object.entries(attributes)) {
      if (!isAttributeKey(key)) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        continue;
      }
      if (!isAttributeValue(val2)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        continue;
      }
      if (Array.isArray(val2)) {
        out[key] = val2.slice();
      } else {
        out[key] = val2;
      }
    }
    return out;
  }
  exports.sanitizeAttributes = sanitizeAttributes;
  function isAttributeKey(key) {
    return typeof key === "string" && key.length > 0;
  }
  exports.isAttributeKey = isAttributeKey;
  function isAttributeValue(val2) {
    if (val2 == null) {
      return true;
    }
    if (Array.isArray(val2)) {
      return isHomogeneousAttributeValueArray(val2);
    }
    return isValidPrimitiveAttributeValue(val2);
  }
  exports.isAttributeValue = isAttributeValue;
  function isHomogeneousAttributeValueArray(arr) {
    let type;
    for (const element of arr) {
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
    return true;
  }
  function isValidPrimitiveAttributeValue(val2) {
    switch (typeof val2) {
      case "number":
      case "boolean":
      case "string":
        return true;
    }
    return false;
  }
});

// ../node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loggingErrorHandler = undefined;
  var api_1 = require_src();
  function loggingErrorHandler() {
    return (ex) => {
      api_1.diag.error(stringifyException(ex));
    };
  }
  exports.loggingErrorHandler = loggingErrorHandler;
  function stringifyException(ex) {
    if (typeof ex === "string") {
      return ex;
    } else {
      return JSON.stringify(flattenException(ex));
    }
  }
  function flattenException(ex) {
    const result = {};
    let current = ex;
    while (current !== null) {
      Object.getOwnPropertyNames(current).forEach((propertyName) => {
        if (result[propertyName])
          return;
        const value = current[propertyName];
        if (value) {
          result[propertyName] = String(value);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return result;
  }
});

// ../node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalErrorHandler = exports.setGlobalErrorHandler = undefined;
  var logging_error_handler_1 = require_logging_error_handler();
  var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
  function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
  }
  exports.setGlobalErrorHandler = setGlobalErrorHandler;
  function globalErrorHandler(ex) {
    try {
      delegateHandler(ex);
    } catch (_a) {
    }
  }
  exports.globalErrorHandler = globalErrorHandler;
});

// ../node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracesSamplerValues = undefined;
  var TracesSamplerValues;
  (function(TracesSamplerValues2) {
    TracesSamplerValues2["AlwaysOff"] = "always_off";
    TracesSamplerValues2["AlwaysOn"] = "always_on";
    TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
  })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
});

// ../node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = undefined;
  var api_1 = require_src();
  var sampling_1 = require_sampling();
  var DEFAULT_LIST_SEPARATOR = ",";
  var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
  function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
  }
  var ENVIRONMENT_NUMBERS_KEYS = [
    "OTEL_BSP_EXPORT_TIMEOUT",
    "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
    "OTEL_BSP_MAX_QUEUE_SIZE",
    "OTEL_BSP_SCHEDULE_DELAY",
    "OTEL_BLRP_EXPORT_TIMEOUT",
    "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
    "OTEL_BLRP_MAX_QUEUE_SIZE",
    "OTEL_BLRP_SCHEDULE_DELAY",
    "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_SPAN_EVENT_COUNT_LIMIT",
    "OTEL_SPAN_LINK_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
    "OTEL_EXPORTER_OTLP_TIMEOUT",
    "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
    "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
    "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
    "OTEL_EXPORTER_JAEGER_AGENT_PORT"
  ];
  function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
  }
  var ENVIRONMENT_LISTS_KEYS = [
    "OTEL_NO_PATCH_MODULES",
    "OTEL_PROPAGATORS"
  ];
  function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
  }
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
  exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
  exports.DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ["tracecontext", "baggage"],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
  };
  function parseBoolean(key, environment, values) {
    if (typeof values[key] === "undefined") {
      return;
    }
    const value = String(values[key]);
    environment[key] = value.toLowerCase() === "true";
  }
  function parseNumber(name, environment, values, min = -Infinity, max = Infinity) {
    if (typeof values[name] !== "undefined") {
      const value = Number(values[name]);
      if (!isNaN(value)) {
        if (value < min) {
          environment[name] = min;
        } else if (value > max) {
          environment[name] = max;
        } else {
          environment[name] = value;
        }
      }
    }
  }
  function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
    const givenValue = input[name];
    if (typeof givenValue === "string") {
      output[name] = givenValue.split(separator).map((v) => v.trim());
    }
  }
  var logLevelMap = {
    ALL: api_1.DiagLogLevel.ALL,
    VERBOSE: api_1.DiagLogLevel.VERBOSE,
    DEBUG: api_1.DiagLogLevel.DEBUG,
    INFO: api_1.DiagLogLevel.INFO,
    WARN: api_1.DiagLogLevel.WARN,
    ERROR: api_1.DiagLogLevel.ERROR,
    NONE: api_1.DiagLogLevel.NONE
  };
  function setLogLevelFromEnv(key, environment, values) {
    const value = values[key];
    if (typeof value === "string") {
      const theLevel = logLevelMap[value.toUpperCase()];
      if (theLevel != null) {
        environment[key] = theLevel;
      }
    }
  }
  function parseEnvironment(values) {
    const environment = {};
    for (const env in exports.DEFAULT_ENVIRONMENT) {
      const key = env;
      switch (key) {
        case "OTEL_LOG_LEVEL":
          setLogLevelFromEnv(key, environment, values);
          break;
        default:
          if (isEnvVarABoolean(key)) {
            parseBoolean(key, environment, values);
          } else if (isEnvVarANumber(key)) {
            parseNumber(key, environment, values);
          } else if (isEnvVarAList(key)) {
            parseStringList(key, environment, values);
          } else {
            const value = values[key];
            if (typeof value !== "undefined" && value !== null) {
              environment[key] = String(value);
            }
          }
      }
    }
    return environment;
  }
  exports.parseEnvironment = parseEnvironment;
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnvWithoutDefaults = exports.getEnv = undefined;
  var environment_1 = require_environment();
  function getEnv() {
    const processEnv = (0, environment_1.parseEnvironment)(process.env);
    return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
  }
  exports.getEnv = getEnv;
  function getEnvWithoutDefaults() {
    return (0, environment_1.parseEnvironment)(process.env);
  }
  exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToBinary = undefined;
  function intValue(charCode) {
    if (charCode >= 48 && charCode <= 57) {
      return charCode - 48;
    }
    if (charCode >= 97 && charCode <= 102) {
      return charCode - 87;
    }
    return charCode - 55;
  }
  function hexToBinary(hexStr) {
    const buf = new Uint8Array(hexStr.length / 2);
    let offset = 0;
    for (let i = 0;i < hexStr.length; i += 2) {
      const hi = intValue(hexStr.charCodeAt(i));
      const lo = intValue(hexStr.charCodeAt(i + 1));
      buf[offset++] = hi << 4 | lo;
    }
    return buf;
  }
  exports.hexToBinary = hexToBinary;
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToBase64 = undefined;
  var hex_to_binary_1 = require_hex_to_binary();
  function hexToBase64(hexStr) {
    return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
  }
  exports.hexToBase64 = hexToBase64;
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = undefined;
  var SPAN_ID_BYTES = 8;
  var TRACE_ID_BYTES = 16;

  class RandomIdGenerator {
    constructor() {
      this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
      this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
  }
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return function generateId() {
      for (let i = 0;i < bytes / 4; i++) {
        SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
      }
      for (let i = 0;i < bytes; i++) {
        if (SHARED_BUFFER[i] > 0) {
          break;
        } else if (i === bytes - 1) {
          SHARED_BUFFER[bytes - 1] = 1;
        }
      }
      return SHARED_BUFFER.toString("hex", 0, bytes);
    };
  }
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.otperformance = undefined;
  var perf_hooks_1 = import.meta.require("perf_hooks");
  exports.otperformance = perf_hooks_1.performance;
});

// ../node_modules/@opentelemetry/core/build/src/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.26.0";
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val2 = values[lp];
      if (val2) {
        res[String(val2).toUpperCase().replace(/[-.]/g, "_")] = val2;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils4();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticAttributes(), exports);
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils4();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticResourceAttributes(), exports);
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = undefined;
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = undefined;
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// ../node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_trace2(), exports);
  __exportStar(require_resource(), exports);
  __exportStar(require_stable_attributes(), exports);
  __exportStar(require_stable_metrics(), exports);
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SDK_INFO = undefined;
  var version_1 = require_version2();
  var semantic_conventions_1 = require_src2();
  exports.SDK_INFO = {
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
    [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
  };
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = undefined;
  function unrefTimer(timer) {
    timer.unref();
  }
  exports.unrefTimer = unrefTimer;
});

// ../node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports.RandomIdGenerator = exports.hexToBase64 = exports._globalThis = exports.getEnv = exports.getEnvWithoutDefaults = undefined;
  var environment_1 = require_environment2();
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return environment_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return environment_1.getEnv;
  } });
  var globalThis_1 = require_globalThis2();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
  var hex_to_base64_1 = require_hex_to_base64();
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return hex_to_base64_1.hexToBase64;
  } });
  var RandomIdGenerator_1 = require_RandomIdGenerator();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return RandomIdGenerator_1.RandomIdGenerator;
  } });
  var performance_1 = require_performance();
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return performance_1.otperformance;
  } });
  var sdk_info_1 = require_sdk_info();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return sdk_info_1.SDK_INFO;
  } });
  var timer_util_1 = require_timer_util();
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return timer_util_1.unrefTimer;
  } });
});

// ../node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = undefined;
  var node_1 = require_node2();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return node_1.RandomIdGenerator;
  } });
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return node_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return node_1.getEnv;
  } });
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return node_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return node_1.hexToBase64;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return node_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return node_1.unrefTimer;
  } });
});

// ../node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = undefined;
  var platform_1 = require_platform2();
  var NANOSECOND_DIGITS = 9;
  var NANOSECOND_DIGITS_IN_MILLIS = 6;
  var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
  var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  function millisToHrTime(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    const seconds = Math.trunc(epochSeconds);
    const nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
  }
  exports.millisToHrTime = millisToHrTime;
  function getTimeOrigin() {
    let timeOrigin = platform_1.otperformance.timeOrigin;
    if (typeof timeOrigin !== "number") {
      const perf = platform_1.otperformance;
      timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
  }
  exports.getTimeOrigin = getTimeOrigin;
  function hrTime(performanceNow) {
    const timeOrigin = millisToHrTime(getTimeOrigin());
    const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
    return addHrTimes(timeOrigin, now);
  }
  exports.hrTime = hrTime;
  function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) {
      return time;
    } else if (typeof time === "number") {
      if (time < getTimeOrigin()) {
        return hrTime(time);
      } else {
        return millisToHrTime(time);
      }
    } else if (time instanceof Date) {
      return millisToHrTime(time.getTime());
    } else {
      throw TypeError("Invalid input type");
    }
  }
  exports.timeInputToHrTime = timeInputToHrTime;
  function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0];
    let nanos = endTime[1] - startTime[1];
    if (nanos < 0) {
      seconds -= 1;
      nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
  }
  exports.hrTimeDuration = hrTimeDuration;
  function hrTimeToTimeStamp(time) {
    const precision = NANOSECOND_DIGITS;
    const tmp = `${"0".repeat(precision)}${time[1]}Z`;
    const nanoString = tmp.substr(tmp.length - precision - 1);
    const date = new Date(time[0] * 1000).toISOString();
    return date.replace("000Z", nanoString);
  }
  exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
  function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
  }
  exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
  function hrTimeToMilliseconds(time) {
    return time[0] * 1000 + time[1] / 1e6;
  }
  exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
  function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1000;
  }
  exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
  function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
  }
  exports.isTimeInputHrTime = isTimeInputHrTime;
  function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
  }
  exports.isTimeInput = isTimeInput;
  function addHrTimes(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    if (out[1] >= SECOND_TO_NANOSECONDS) {
      out[1] -= SECOND_TO_NANOSECONDS;
      out[0] += 1;
    }
    return out;
  }
  exports.addHrTimes = addHrTimes;
});

// ../node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExportResultCode = undefined;
  var ExportResultCode;
  (function(ExportResultCode2) {
    ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
  })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
});

// ../node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompositePropagator = undefined;
  var api_1 = require_src();

  class CompositePropagator {
    constructor(config = {}) {
      var _a;
      this._propagators = (_a = config.propagators) !== null && _a !== undefined ? _a : [];
      this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
    }
    inject(context, carrier, setter) {
      for (const propagator of this._propagators) {
        try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
      }
    }
    extract(context, carrier, getter) {
      return this._propagators.reduce((ctx, propagator) => {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
        return ctx;
      }, context);
    }
    fields() {
      return this._fields.slice();
    }
  }
  exports.CompositePropagator = CompositePropagator;
});

// ../node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})\$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceState = undefined;
  var validators_1 = require_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceState {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceState;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceState = TraceState;
});

// ../node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var TraceState_1 = require_TraceState();
  exports.TRACE_PARENT_HEADER = "traceparent";
  exports.TRACE_STATE_HEADER = "tracestate";
  var VERSION = "00";
  var VERSION_PART = "(?!ff)[\\da-f]{2}";
  var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
  var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
  var FLAGS_PART = "[\\da-f]{2}";
  var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?\$`);
  function parseTraceParent(traceParent) {
    const match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
      return null;
    if (match[1] === "00" && match[5])
      return null;
    return {
      traceId: match[2],
      spanId: match[3],
      traceFlags: parseInt(match[4], 16)
    };
  }
  exports.parseTraceParent = parseTraceParent;

  class W3CTraceContextPropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
        return;
      const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
      setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    }
    extract(context, carrier, getter) {
      const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context;
      const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context;
      const spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context;
      spanContext.isRemote = true;
      const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
      if (traceStateHeader) {
        const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : undefined);
      }
      return api_1.trace.setSpanContext(context, spanContext);
    }
    fields() {
      return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
    }
  }
  exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
});

// ../node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = undefined;
  var api_1 = require_src();
  var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
  var RPCType;
  (function(RPCType2) {
    RPCType2["HTTP"] = "http";
  })(RPCType = exports.RPCType || (exports.RPCType = {}));
  function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
  }
  exports.setRPCMetadata = setRPCMetadata;
  function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
  }
  exports.deleteRPCMetadata = deleteRPCMetadata;
  function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
  }
  exports.getRPCMetadata = getRPCMetadata;
});

// ../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOffSampler = undefined;
  var api_1 = require_src();

  class AlwaysOffSampler {
    shouldSample() {
      return {
        decision: api_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  exports.AlwaysOffSampler = AlwaysOffSampler;
});

// ../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOnSampler = undefined;
  var api_1 = require_src();

  class AlwaysOnSampler {
    shouldSample() {
      return {
        decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
      };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  exports.AlwaysOnSampler = AlwaysOnSampler;
});

// ../node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentBasedSampler = undefined;
  var api_1 = require_src();
  var global_error_handler_1 = require_global_error_handler();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();

  class ParentBasedSampler {
    constructor(config) {
      var _a, _b, _c, _d;
      this._root = config.root;
      if (!this._root) {
        (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler_1.AlwaysOnSampler;
      }
      this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== undefined ? _a : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== undefined ? _b : new AlwaysOffSampler_1.AlwaysOffSampler;
      this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== undefined ? _c : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== undefined ? _d : new AlwaysOffSampler_1.AlwaysOffSampler;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
      const parentContext = api_1.trace.getSpanContext(context);
      if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
        return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  exports.ParentBasedSampler = ParentBasedSampler;
});

// ../node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = undefined;
  var api_1 = require_src();

  class TraceIdRatioBasedSampler {
    constructor(_ratio = 0) {
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    shouldSample(context, traceId) {
      return {
        decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
      let accumulation = 0;
      for (let i = 0;i < traceId.length / 8; i++) {
        const pos = i * 8;
        const part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    }
  }
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});

// ../node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPlainObject = undefined;
  var objectTag = "[object Object]";
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  var objectCtorString = funcToString.call(Object);
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  var nativeObjectToString = objectProto.toString;
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
      return false;
    }
    const proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  exports.isPlainObject = isPlainObject2;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function getRawTag(value) {
    const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    let unmasked = false;
    try {
      value[symToStringTag] = undefined;
      unmasked = true;
    } catch (e) {
    }
    const result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
});

// ../node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lodash_merge_1 = require_lodash_merge();
  var MAX_LEVEL = 20;
  function merge(...args) {
    let result = args.shift();
    const objects = new WeakMap;
    while (args.length > 0) {
      result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
  }
  exports.merge = merge;
  function takeValue(value) {
    if (isArray(value)) {
      return value.slice();
    }
    return value;
  }
  function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (level > MAX_LEVEL) {
      return;
    }
    level++;
    if (isPrimitive2(one) || isPrimitive2(two) || isFunction(two)) {
      result = takeValue(two);
    } else if (isArray(one)) {
      result = one.slice();
      if (isArray(two)) {
        for (let i = 0, j = two.length;i < j; i++) {
          result.push(takeValue(two[i]));
        }
      } else if (isObject(two)) {
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          result[key] = takeValue(two[key]);
        }
      }
    } else if (isObject(one)) {
      if (isObject(two)) {
        if (!shouldMerge(one, two)) {
          return two;
        }
        result = Object.assign({}, one);
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          const twoValue = two[key];
          if (isPrimitive2(twoValue)) {
            if (typeof twoValue === "undefined") {
              delete result[key];
            } else {
              result[key] = twoValue;
            }
          } else {
            const obj1 = result[key];
            const obj2 = twoValue;
            if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
              delete result[key];
            } else {
              if (isObject(obj1) && isObject(obj2)) {
                const arr1 = objects.get(obj1) || [];
                const arr2 = objects.get(obj2) || [];
                arr1.push({ obj: one, key });
                arr2.push({ obj: two, key });
                objects.set(obj1, arr1);
                objects.set(obj2, arr2);
              }
              result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
            }
          }
        }
      } else {
        result = two;
      }
    }
    return result;
  }
  function wasObjectReferenced(obj, key, objects) {
    const arr = objects.get(obj[key]) || [];
    for (let i = 0, j = arr.length;i < j; i++) {
      const info = arr[i];
      if (info.key === key && info.obj === obj) {
        return true;
      }
    }
    return false;
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isObject(value) {
    return !isPrimitive2(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
  }
  function isPrimitive2(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
  }
  function shouldMerge(one, two) {
    if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
      return false;
    }
    return true;
  }
});

// ../node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callWithTimeout = exports.TimeoutError = undefined;

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, TimeoutError.prototype);
    }
  }
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle;
    const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
      timeoutHandle = setTimeout(function timeoutHandler() {
        reject(new TimeoutError("Operation timed out."));
      }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    }, (reason) => {
      clearTimeout(timeoutHandle);
      throw reason;
    });
  }
  exports.callWithTimeout = callWithTimeout;
});

// ../node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isUrlIgnored = exports.urlMatches = undefined;
  function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === "string") {
      return url === urlToMatch;
    } else {
      return !!url.match(urlToMatch);
    }
  }
  exports.urlMatches = urlMatches;
  function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) {
      return false;
    }
    for (const ignoreUrl of ignoredUrls) {
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
    return false;
  }
  exports.isUrlIgnored = isUrlIgnored;
});

// ../node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = undefined;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    constructor() {
      this._promise = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    get promise() {
      return this._promise;
    }
    resolve(val2) {
      this._resolve(val2);
    }
    reject(err) {
      this._reject(err);
    }
  }
  exports.Deferred = Deferred;
});

// ../node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BindOnceFuture = undefined;
  var promise_1 = require_promise();

  class BindOnceFuture {
    constructor(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
      this._isCalled = false;
      this._deferred = new promise_1.Deferred;
    }
    get isCalled() {
      return this._isCalled;
    }
    get promise() {
      return this._deferred.promise;
    }
    call(...args) {
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve(this._callback.call(this._that, ...args)).then((val2) => this._deferred.resolve(val2), (err) => this._deferred.reject(err));
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    }
  }
  exports.BindOnceFuture = BindOnceFuture;
});

// ../node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._export = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  function _export(exporter, arg) {
    return new Promise((resolve2) => {
      api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
        exporter.export(arg, (result) => {
          resolve2(result);
        });
      });
    });
  }
  exports._export = _export;
});

// ../node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = exports.baggageUtils = exports.ExportResultCode = exports.hexToBinary = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.isAttributeKey = exports.AnchoredClock = exports.W3CBaggagePropagator = undefined;
  exports.internal = exports.VERSION = exports.BindOnceFuture = exports.isWrapped = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.TracesSamplerValues = exports.merge = exports.parseEnvironment = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ENVIRONMENT = undefined;
  var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
  Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: function() {
    return W3CBaggagePropagator_1.W3CBaggagePropagator;
  } });
  var anchored_clock_1 = require_anchored_clock();
  Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: function() {
    return anchored_clock_1.AnchoredClock;
  } });
  var attributes_1 = require_attributes();
  Object.defineProperty(exports, "isAttributeKey", { enumerable: true, get: function() {
    return attributes_1.isAttributeKey;
  } });
  Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: function() {
    return attributes_1.isAttributeValue;
  } });
  Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: function() {
    return attributes_1.sanitizeAttributes;
  } });
  var global_error_handler_1 = require_global_error_handler();
  Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.globalErrorHandler;
  } });
  Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.setGlobalErrorHandler;
  } });
  var logging_error_handler_1 = require_logging_error_handler();
  Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: function() {
    return logging_error_handler_1.loggingErrorHandler;
  } });
  var time_1 = require_time();
  Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: function() {
    return time_1.addHrTimes;
  } });
  Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: function() {
    return time_1.getTimeOrigin;
  } });
  Object.defineProperty(exports, "hrTime", { enumerable: true, get: function() {
    return time_1.hrTime;
  } });
  Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: function() {
    return time_1.hrTimeDuration;
  } });
  Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMicroseconds;
  } });
  Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMilliseconds;
  } });
  Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToNanoseconds;
  } });
  Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: function() {
    return time_1.hrTimeToTimeStamp;
  } });
  Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: function() {
    return time_1.isTimeInput;
  } });
  Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: function() {
    return time_1.isTimeInputHrTime;
  } });
  Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: function() {
    return time_1.millisToHrTime;
  } });
  Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: function() {
    return time_1.timeInputToHrTime;
  } });
  var hex_to_binary_1 = require_hex_to_binary();
  Object.defineProperty(exports, "hexToBinary", { enumerable: true, get: function() {
    return hex_to_binary_1.hexToBinary;
  } });
  var ExportResult_1 = require_ExportResult();
  Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: function() {
    return ExportResult_1.ExportResultCode;
  } });
  var utils_1 = require_utils3();
  exports.baggageUtils = {
    getKeyPairs: utils_1.getKeyPairs,
    serializeKeyPairs: utils_1.serializeKeyPairs,
    parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
    parsePairKeyValue: utils_1.parsePairKeyValue
  };
  var platform_1 = require_platform2();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return platform_1.RandomIdGenerator;
  } });
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return platform_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return platform_1._globalThis;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return platform_1.getEnv;
  } });
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return platform_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return platform_1.hexToBase64;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return platform_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return platform_1.unrefTimer;
  } });
  var composite_1 = require_composite();
  Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: function() {
    return composite_1.CompositePropagator;
  } });
  var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
  Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
  } });
  Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
  } });
  Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
  } });
  Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.parseTraceParent;
  } });
  var rpc_metadata_1 = require_rpc_metadata();
  Object.defineProperty(exports, "RPCType", { enumerable: true, get: function() {
    return rpc_metadata_1.RPCType;
  } });
  Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.deleteRPCMetadata;
  } });
  Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.getRPCMetadata;
  } });
  Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.setRPCMetadata;
  } });
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return AlwaysOffSampler_1.AlwaysOffSampler;
  } });
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return AlwaysOnSampler_1.AlwaysOnSampler;
  } });
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return ParentBasedSampler_1.ParentBasedSampler;
  } });
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
  } });
  var suppress_tracing_1 = require_suppress_tracing();
  Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: function() {
    return suppress_tracing_1.isTracingSuppressed;
  } });
  Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.suppressTracing;
  } });
  Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.unsuppressTracing;
  } });
  var TraceState_1 = require_TraceState();
  Object.defineProperty(exports, "TraceState", { enumerable: true, get: function() {
    return TraceState_1.TraceState;
  } });
  var environment_1 = require_environment();
  Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_ENVIRONMENT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ENVIRONMENT;
  } });
  Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "parseEnvironment", { enumerable: true, get: function() {
    return environment_1.parseEnvironment;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var sampling_1 = require_sampling();
  Object.defineProperty(exports, "TracesSamplerValues", { enumerable: true, get: function() {
    return sampling_1.TracesSamplerValues;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: function() {
    return timeout_1.callWithTimeout;
  } });
  var url_1 = require_url();
  Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: function() {
    return url_1.isUrlIgnored;
  } });
  Object.defineProperty(exports, "urlMatches", { enumerable: true, get: function() {
    return url_1.urlMatches;
  } });
  var wrap_1 = require_wrap();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return wrap_1.isWrapped;
  } });
  var callback_1 = require_callback();
  Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: function() {
    return callback_1.BindOnceFuture;
  } });
  var version_1 = require_version2();
  Object.defineProperty(exports, "VERSION", { enumerable: true, get: function() {
    return version_1.VERSION;
  } });
  var exporter_1 = require_exporter();
  exports.internal = {
    _export: exporter_1._export
  };
});

// ../node_modules/semver/internal/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// ../node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants2();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:\$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// ../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../node_modules/semver/classes/semver.js
var require_semver2 = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// ../node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse;
});

// ../node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse();
  var valid = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// ../node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse();
  var clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// ../node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// ../node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// ../node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// ../node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// ../node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// ../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// ../node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// ../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// ../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// ../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// ../node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// ../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// ../node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// ../node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// ../node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// ../node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// ../node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// ../node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// ../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// ../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var parse = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// ../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// ../node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver2();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver2();
  var Range = require_range();
});

// ../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// ../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// ../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// ../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// ../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// ../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// ../node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// ../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// ../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// ../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// ../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// ../node_modules/semver/index.js
var require_semver3 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants2();
  var SemVer = require_semver2();
  var identifiers = require_identifiers();
  var parse = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js
var require_AttributeNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["HTTP_ERROR_NAME"] = "http.error_name";
    AttributeNames2["HTTP_ERROR_MESSAGE"] = "http.error_message";
    AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-http/build/src/utils.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headerCapture = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.isIgnored = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var core_1 = require_src3();
  var url = import.meta.require("url");
  var AttributeNames_1 = require_AttributeNames();
  var getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = "http:") => {
    const reqUrlObject = requestUrl || {};
    const protocol = reqUrlObject.protocol || fallbackProtocol;
    const port = (reqUrlObject.port || "").toString();
    const path = reqUrlObject.path || "/";
    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || "localhost";
    if (host.indexOf(":") === -1 && port && port !== "80" && port !== "443") {
      host += `:${port}`;
    }
    return `${protocol}//${host}${path}`;
  };
  exports.getAbsoluteUrl = getAbsoluteUrl;
  var parseResponseStatus = (kind, statusCode) => {
    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;
    if (statusCode && statusCode >= 100 && statusCode < upperBound) {
      return api_1.SpanStatusCode.UNSET;
    }
    return api_1.SpanStatusCode.ERROR;
  };
  exports.parseResponseStatus = parseResponseStatus;
  var satisfiesPattern = (constant, pattern) => {
    if (typeof pattern === "string") {
      return pattern === constant;
    } else if (pattern instanceof RegExp) {
      return pattern.test(constant);
    } else if (typeof pattern === "function") {
      return pattern(constant);
    } else {
      throw new TypeError("Pattern is in unsupported datatype");
    }
  };
  exports.satisfiesPattern = satisfiesPattern;
  var isIgnored = (constant, list, onException) => {
    if (!list) {
      return false;
    }
    try {
      for (const pattern of list) {
        if ((0, exports.satisfiesPattern)(constant, pattern)) {
          return true;
        }
      }
    } catch (e) {
      if (onException) {
        onException(e);
      }
    }
    return false;
  };
  exports.isIgnored = isIgnored;
  var setSpanWithError = (span, error) => {
    const message = error.message;
    span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);
    span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);
    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });
    span.recordException(error);
  };
  exports.setSpanWithError = setSpanWithError;
  var setRequestContentLengthAttribute = (request, attributes) => {
    const length = getContentLength(request.headers);
    if (length === null)
      return;
    if ((0, exports.isCompressed)(request.headers)) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;
    } else {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;
    }
  };
  exports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;
  var setResponseContentLengthAttribute = (response, attributes) => {
    const length = getContentLength(response.headers);
    if (length === null)
      return;
    if ((0, exports.isCompressed)(response.headers)) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;
    } else {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;
    }
  };
  exports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;
  function getContentLength(headers) {
    const contentLengthHeader = headers["content-length"];
    if (contentLengthHeader === undefined)
      return null;
    const contentLength = parseInt(contentLengthHeader, 10);
    if (isNaN(contentLength))
      return null;
    return contentLength;
  }
  var isCompressed = (headers) => {
    const encoding = headers["content-encoding"];
    return !!encoding && encoding !== "identity";
  };
  exports.isCompressed = isCompressed;
  var getRequestInfo = (options, extraOptions) => {
    let pathname = "/";
    let origin = "";
    let optionsParsed;
    if (typeof options === "string") {
      optionsParsed = url.parse(options);
      pathname = optionsParsed.pathname || "/";
      origin = `${optionsParsed.protocol || "http:"}//${optionsParsed.host}`;
      if (extraOptions !== undefined) {
        Object.assign(optionsParsed, extraOptions);
      }
    } else if (options instanceof url.URL) {
      optionsParsed = {
        protocol: options.protocol,
        hostname: typeof options.hostname === "string" && options.hostname.startsWith("[") ? options.hostname.slice(1, -1) : options.hostname,
        path: `${options.pathname || ""}${options.search || ""}`
      };
      if (options.port !== "") {
        optionsParsed.port = Number(options.port);
      }
      if (options.username || options.password) {
        optionsParsed.auth = `${options.username}:${options.password}`;
      }
      pathname = options.pathname;
      origin = options.origin;
      if (extraOptions !== undefined) {
        Object.assign(optionsParsed, extraOptions);
      }
    } else {
      optionsParsed = Object.assign({ protocol: options.host ? "http:" : undefined }, options);
      pathname = options.pathname;
      if (!pathname && optionsParsed.path) {
        pathname = url.parse(optionsParsed.path).pathname || "/";
      }
      const hostname = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);
      origin = `${optionsParsed.protocol || "http:"}//${hostname}`;
    }
    const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : "GET";
    return { origin, pathname, method, optionsParsed };
  };
  exports.getRequestInfo = getRequestInfo;
  var isValidOptionsType = (options) => {
    if (!options) {
      return false;
    }
    const type = typeof options;
    return type === "string" || type === "object" && !Array.isArray(options);
  };
  exports.isValidOptionsType = isValidOptionsType;
  var extractHostnameAndPort = (requestOptions) => {
    var _a;
    if (requestOptions.hostname && requestOptions.port) {
      return { hostname: requestOptions.hostname, port: requestOptions.port };
    }
    const matches = ((_a = requestOptions.host) === null || _a === undefined ? undefined : _a.match(/^([^:/ ]+)(:\d{1,5})?/)) || null;
    const hostname = requestOptions.hostname || (matches === null ? "localhost" : matches[1]);
    let port = requestOptions.port;
    if (!port) {
      if (matches && matches[2]) {
        port = matches[2].substring(1);
      } else {
        port = requestOptions.protocol === "https:" ? "443" : "80";
      }
    }
    return { hostname, port };
  };
  exports.extractHostnameAndPort = extractHostnameAndPort;
  var getOutgoingRequestAttributes = (requestOptions, options) => {
    var _a;
    const hostname = options.hostname;
    const port = options.port;
    const requestMethod = requestOptions.method;
    const method = requestMethod ? requestMethod.toUpperCase() : "GET";
    const headers = requestOptions.headers || {};
    const userAgent = headers["user-agent"];
    const attributes = {
      [semantic_conventions_1.SEMATTRS_HTTP_URL]: (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`),
      [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
      [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || "/",
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname,
      [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_a = headers.host) !== null && _a !== undefined ? _a : `${hostname}:${port}`
    };
    if (userAgent !== undefined) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
    }
    return Object.assign(attributes, options.hookAttributes);
  };
  exports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;
  var getOutgoingRequestMetricAttributes = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];
    return metricAttributes;
  };
  exports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;
  var setAttributesFromHttpKind = (kind, attributes) => {
    if (kind) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;
      if (kind.toUpperCase() !== "QUIC") {
        attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;
      } else {
        attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;
      }
    }
  };
  exports.setAttributesFromHttpKind = setAttributesFromHttpKind;
  var getOutgoingRequestAttributesOnResponse = (response) => {
    const { statusCode, statusMessage, httpVersion, socket } = response;
    const attributes = {};
    if (socket) {
      const { remoteAddress, remotePort } = socket;
      attributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
      attributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
    }
    (0, exports.setResponseContentLengthAttribute)(response, attributes);
    if (statusCode) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
      attributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
    }
    (0, exports.setAttributesFromHttpKind)(httpVersion, attributes);
    return attributes;
  };
  exports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;
  var getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
    return metricAttributes;
  };
  exports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;
  var getIncomingRequestAttributes = (request, options) => {
    const headers = request.headers;
    const userAgent = headers["user-agent"];
    const ips = headers["x-forwarded-for"];
    const method = request.method || "GET";
    const httpVersion = request.httpVersion;
    const requestUrl = request.url ? url.parse(request.url) : null;
    const host = (requestUrl === null || requestUrl === undefined ? undefined : requestUrl.host) || headers.host;
    const hostname = (requestUrl === null || requestUrl === undefined ? undefined : requestUrl.hostname) || (host === null || host === undefined ? undefined : host.replace(/^(.*)(:[0-9]{1,5})/, "$1")) || "localhost";
    const serverName = options.serverName;
    const attributes = {
      [semantic_conventions_1.SEMATTRS_HTTP_URL]: (0, exports.getAbsoluteUrl)(requestUrl, headers, `${options.component}:`),
      [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,
      [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname,
      [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
      [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component
    };
    if (typeof ips === "string") {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(",")[0];
    }
    if (typeof serverName === "string") {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;
    }
    if (requestUrl) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] = requestUrl.path || "/";
    }
    if (userAgent !== undefined) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
    }
    (0, exports.setRequestContentLengthAttribute)(request, attributes);
    (0, exports.setAttributesFromHttpKind)(httpVersion, attributes);
    return Object.assign(attributes, options.hookAttributes);
  };
  exports.getIncomingRequestAttributes = getIncomingRequestAttributes;
  var getIncomingRequestMetricAttributes = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
    return metricAttributes;
  };
  exports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;
  var getIncomingRequestAttributesOnResponse = (request, response) => {
    const { socket } = request;
    const { statusCode, statusMessage } = response;
    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
    const attributes = {};
    if (socket) {
      const { localAddress, localPort, remoteAddress, remotePort } = socket;
      attributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;
      attributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;
      attributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
      attributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
    }
    attributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
    attributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
    if ((rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP && rpcMetadata.route !== undefined) {
      attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;
    }
    return attributes;
  };
  exports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;
  var getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];
    if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== undefined) {
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
    }
    return metricAttributes;
  };
  exports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;
  function headerCapture(type, headers) {
    const normalizedHeaders = new Map;
    for (let i = 0, len = headers.length;i < len; i++) {
      const capturedHeader = headers[i].toLowerCase();
      normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, "_"));
    }
    return (span, getHeader) => {
      for (const capturedHeader of normalizedHeaders.keys()) {
        const value = getHeader(capturedHeader);
        if (value === undefined) {
          continue;
        }
        const normalizedHeader = normalizedHeaders.get(capturedHeader);
        const key = `http.${type}.header.${normalizedHeader}`;
        if (typeof value === "string") {
          span.setAttribute(key, [value]);
        } else if (Array.isArray(value)) {
          span.setAttribute(key, value);
        } else {
          span.setAttribute(key, [value]);
        }
      }
    };
  }
  exports.headerCapture = headerCapture;
});

// ../node_modules/@opentelemetry/instrumentation-http/build/src/version.js
var require_version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.53.0";
});

// ../node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// ../node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {
    }
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// ../node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// ../node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var globalThis_1 = require_globalThis3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
});

// ../node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var node_1 = require_node3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
});

// ../node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform3();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version) => version === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// ../node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils2();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();

  class LogsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      return provider;
    }
    getLoggerProvider() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === undefined ? undefined : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== undefined ? _b : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    getLogger(name, version, options) {
      return this.getLoggerProvider().getLogger(name, version, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
    }
  }
  exports.LogsAPI = LogsAPI;
});

// ../node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = undefined;
  var LogRecord_1 = require_LogRecord();
  Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: function() {
    return LogRecord_1.SeverityNumber;
  } });
  var NoopLogger_1 = require_NoopLogger();
  Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: function() {
    return NoopLogger_1.NOOP_LOGGER;
  } });
  Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: function() {
    return NoopLogger_1.NoopLogger;
  } });
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
  } });
  Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NoopLoggerProvider;
  } });
  var logs_1 = require_logs();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// ../node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i = 0, j = instrumentations.length;i < j; i++) {
      const instrumentation = instrumentations[i];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var autoLoaderUtils_1 = require_autoLoaderUtils();
  function registerInstrumentations(options) {
    var _a, _b;
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = (_b = (_a = options.instrumentations) === null || _a === undefined ? undefined : _a.flat()) !== null && _b !== undefined ? _b : [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations;
});

// ../node_modules/shimmer/index.js
var require_shimmer = __commonJS((exports, module) => {
  function isFunction(funktion) {
    return typeof funktion === "function";
  }
  var logger2 = console.error.bind(console);
  function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  }
  function shimmer(options) {
    if (options && options.logger) {
      if (!isFunction(options.logger))
        logger2("new logger isn't a function, not replacing");
      else
        logger2 = options.logger;
    }
  }
  function wrap(nodule, name, wrapper) {
    if (!nodule || !nodule[name]) {
      logger2("no original function " + name + " to wrap");
      return;
    }
    if (!wrapper) {
      logger2("no wrapper function");
      logger2(new Error().stack);
      return;
    }
    if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
      logger2("original object and wrapper must be functions");
      return;
    }
    var original = nodule[name];
    var wrapped = wrapper(original, name);
    defineProperty(wrapped, "__original", original);
    defineProperty(wrapped, "__unwrap", function() {
      if (nodule[name] === wrapped)
        defineProperty(nodule, name, original);
    });
    defineProperty(wrapped, "__wrapped", true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
  }
  function massWrap(nodules, names, wrapper) {
    if (!nodules) {
      logger2("must provide one or more modules to patch");
      logger2(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger2("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        wrap(nodule, name, wrapper);
      });
    });
  }
  function unwrap(nodule, name) {
    if (!nodule || !nodule[name]) {
      logger2("no function to unwrap.");
      logger2(new Error().stack);
      return;
    }
    if (!nodule[name].__unwrap) {
      logger2("no original to unwrap to -- has " + name + " already been unwrapped?");
    } else {
      return nodule[name].__unwrap();
    }
  }
  function massUnwrap(nodules, names) {
    if (!nodules) {
      logger2("must provide one or more modules to patch");
      logger2(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger2("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        unwrap(nodule, name);
      });
    });
  }
  shimmer.wrap = wrap;
  shimmer.massWrap = massWrap;
  shimmer.unwrap = unwrap;
  shimmer.massUnwrap = massUnwrap;
  module.exports = shimmer;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var shimmer = require_shimmer();

  class InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this._config = {};
      this._wrap = shimmer.wrap;
      this._unwrap = shimmer.unwrap;
      this._massWrap = shimmer.massWrap;
      this._massUnwrap = shimmer.massUnwrap;
      this.setConfig(config);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      var _a;
      const initResult = (_a = this.init()) !== null && _a !== undefined ? _a : [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config) {
      this._config = Object.assign({ enabled: true }, config);
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  module.exports = os.homedir || function homedir() {
    var home = "/Users/mo";
    var user = "mo";
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  module.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// ../node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe2 = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe2.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module.exports = win32.parse;
  else
    module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var parse = path.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports, module) => {
  module.exports = function(x, opts) {
    return opts || {};
  };
});

// ../node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// ../node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// ../node_modules/is-core-module/core.json
var require_core = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports, module) => {
  var hasOwn = require_hasown();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0;i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0;i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0;i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core();
  module.exports = function isCore(x, nodeVersion) {
    return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/async.js
var require_async = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var getHomedir = require_homedir();
  var path = import.meta.require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, undefined, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path.dirname(dir), cb2);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                var dir = path.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, undefined);
      var dir = dirs[0];
      isDirectory(path.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/core.json
var require_core2 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/core.js
var require_core3 = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  var data = require_core2();
  var core = {};
  for (mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = isCoreModule(mod);
    }
  }
  var mod;
  module.exports = core;
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  module.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports, module) => {
  var isCore = require_is_core_module();
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0;i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return { pkg, dir };
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0;i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// ../node_modules/require-in-the-middle/node_modules/resolve/index.js
var require_resolve = __commonJS((exports, module) => {
  var async = require_async();
  async.core = require_core3();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module.exports = async;
});

// ../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val2, options) {
    options = options || {};
    var type = typeof val2;
    if (type === "string" && val2.length > 0) {
      return parse(val2);
    } else if (type === "number" && isFinite(val2)) {
      return options.long ? fmtLong(val2) : fmtShort(val2);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val2));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val2 = args[index];
            match = formatter.call(self2, val2);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val2) {
      if (val2 instanceof Error) {
        return val2.stack || val2.message;
      }
      return val2;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var tty = import.meta.require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var require_node4 = __commonJS((exports, module) => {
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val2 = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val2)) {
      val2 = true;
    } else if (/^(no|off|false|disabled)$/i.test(val2)) {
      val2 = false;
    } else if (val2 === "null") {
      val2 = null;
    } else {
      val2 = Number(val2);
    }
    obj[prop] = val2;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var require_src5 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node4();
  }
});

// ../node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  module.exports = function(file) {
    var segments = file.split(path.sep);
    var index = segments.lastIndexOf("node_modules");
    if (index === -1)
      return;
    if (!segments[index + 1])
      return;
    var scoped = segments[index + 1][0] === "@";
    var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
    var offset = scoped ? 3 : 2;
    return {
      name,
      basedir: segments.slice(0, index + offset).join(path.sep),
      path: segments.slice(index + offset).join(path.sep)
    };
  };
});

// ../node_modules/require-in-the-middle/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "require-in-the-middle",
    version: "7.4.0",
    description: "Module to hook into the Node.js require function",
    main: "index.js",
    types: "types/index.d.ts",
    dependencies: {
      debug: "^4.3.5",
      "module-details-from-path": "^1.0.3",
      resolve: "^1.22.8"
    },
    devDependencies: {
      "@babel/core": "^7.9.0",
      "@babel/preset-env": "^7.9.5",
      "@babel/preset-typescript": "^7.9.0",
      "@babel/register": "^7.9.0",
      "ipp-printer": "^1.0.0",
      patterns: "^1.0.3",
      roundround: "^0.2.0",
      semver: "^6.3.0",
      standard: "^14.3.1",
      tape: "^4.11.0"
    },
    scripts: {
      test: "npm run test:lint && npm run test:tape && npm run test:babel",
      "test:lint": "standard",
      "test:tape": "tape test/*.js",
      "test:babel": "node test/babel/babel-register.js"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/elastic/require-in-the-middle.git"
    },
    keywords: [
      "require",
      "hook",
      "shim",
      "shimmer",
      "shimming",
      "patch",
      "monkey",
      "monkeypatch",
      "module",
      "load"
    ],
    files: [
      "types"
    ],
    author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
    license: "MIT",
    bugs: {
      url: "https://github.com/elastic/require-in-the-middle/issues"
    },
    homepage: "https://github.com/elastic/require-in-the-middle#readme",
    engines: {
      node: ">=8.6.0"
    }
  };
});

// ../node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var Module = import.meta.require("module");
  var resolve2 = require_resolve();
  var debug = require_src5()("require-in-the-middle");
  var moduleDetailsFromPath = require_module_details_from_path();
  module.exports = Hook;
  module.exports.Hook = Hook;
  var isCore;
  if (Module.isBuiltin) {
    isCore = Module.isBuiltin;
  } else {
    const [major, minor] = process.versions.node.split(".").map(Number);
    if (major === 8 && minor < 8) {
      isCore = (moduleName) => {
        if (moduleName === "http2") {
          return true;
        }
        return !!resolve2.core[moduleName];
      };
    } else {
      isCore = (moduleName) => {
        return !!resolve2.core[moduleName];
      };
    }
  }
  var normalize2 = /([/\\]index)?(\.js)?$/;

  class ExportsCache {
    constructor() {
      this._localCache = new Map;
      this._kRitmExports = Symbol("RitmExports");
    }
    has(filename, isBuiltin2) {
      if (this._localCache.has(filename)) {
        return true;
      } else if (!isBuiltin2) {
        const mod = import.meta.require.cache[filename];
        return !!(mod && (this._kRitmExports in mod));
      } else {
        return false;
      }
    }
    get(filename, isBuiltin2) {
      const cachedExports = this._localCache.get(filename);
      if (cachedExports !== undefined) {
        return cachedExports;
      } else if (!isBuiltin2) {
        const mod = import.meta.require.cache[filename];
        return mod && mod[this._kRitmExports];
      }
    }
    set(filename, exports2, isBuiltin2) {
      if (isBuiltin2) {
        this._localCache.set(filename, exports2);
      } else if (filename in import.meta.require.cache) {
        import.meta.require.cache[filename][this._kRitmExports] = exports2;
      } else {
        debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
        this._localCache.set(filename, exports2);
      }
    }
  }
  function Hook(modules, options, onrequire) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, onrequire);
    if (typeof modules === "function") {
      onrequire = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      onrequire = options;
      options = null;
    }
    if (typeof Module._resolveFilename !== "function") {
      console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
      console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package().bugs.url);
      return;
    }
    this._cache = new ExportsCache;
    this._unhooked = false;
    this._origRequire = Module.prototype.require;
    const self2 = this;
    const patching = new Set;
    const internals = options ? options.internals === true : false;
    const hasWhitelist = Array.isArray(modules);
    debug("registering require hook");
    this._require = Module.prototype.require = function(id) {
      if (self2._unhooked === true) {
        debug("ignoring require call - module is soft-unhooked");
        return self2._origRequire.apply(this, arguments);
      }
      return patchedRequire.call(this, arguments, false);
    };
    if (typeof process.getBuiltinModule === "function") {
      this._origGetBuiltinModule = process.getBuiltinModule;
      this._getBuiltinModule = process.getBuiltinModule = function(id) {
        if (self2._unhooked === true) {
          debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
          return self2._origGetBuiltinModule.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, true);
      };
    }
    function patchedRequire(args, coreOnly) {
      const id = args[0];
      const core = isCore(id);
      let filename;
      if (core) {
        filename = id;
        if (id.startsWith("node:")) {
          const idWithoutPrefix = id.slice(5);
          if (isCore(idWithoutPrefix)) {
            filename = idWithoutPrefix;
          }
        }
      } else if (coreOnly) {
        debug("call to process.getBuiltinModule with unknown built-in id");
        return self2._origGetBuiltinModule.apply(this, args);
      } else {
        try {
          filename = Module._resolveFilename(id, this);
        } catch (resolveErr) {
          debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
          return self2._origRequire.apply(this, args);
        }
      }
      let moduleName, basedir;
      debug("processing %s module require(\'%s\'): %s", core === true ? "core" : "non-core", id, filename);
      if (self2._cache.has(filename, core) === true) {
        debug("returning already patched cached module: %s", filename);
        return self2._cache.get(filename, core);
      }
      const isPatching = patching.has(filename);
      if (isPatching === false) {
        patching.add(filename);
      }
      const exports2 = coreOnly ? self2._origGetBuiltinModule.apply(this, args) : self2._origRequire.apply(this, args);
      if (isPatching === true) {
        debug("module is in the process of being patched already - ignoring: %s", filename);
        return exports2;
      }
      patching.delete(filename);
      if (core === true) {
        if (hasWhitelist === true && modules.includes(filename) === false) {
          debug("ignoring core module not on whitelist: %s", filename);
          return exports2;
        }
        moduleName = filename;
      } else if (hasWhitelist === true && modules.includes(filename)) {
        const parsedPath = path.parse(filename);
        moduleName = parsedPath.name;
        basedir = parsedPath.dir;
      } else {
        const stat = moduleDetailsFromPath(filename);
        if (stat === undefined) {
          debug("could not parse filename: %s", filename);
          return exports2;
        }
        moduleName = stat.name;
        basedir = stat.basedir;
        const fullModuleName = resolveModuleName(stat);
        debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
        let matchFound = false;
        if (hasWhitelist) {
          if (!id.startsWith(".") && modules.includes(id)) {
            moduleName = id;
            matchFound = true;
          }
          if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
            return exports2;
          }
          if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
            moduleName = fullModuleName;
            matchFound = true;
          }
        }
        if (!matchFound) {
          let res;
          try {
            res = resolve2.sync(moduleName, { basedir });
          } catch (e) {
            debug("could not resolve module: %s", moduleName);
            self2._cache.set(filename, exports2, core);
            return exports2;
          }
          if (res !== filename) {
            if (internals === true) {
              moduleName = moduleName + path.sep + path.relative(basedir, filename);
              debug("preparing to process require of internal file: %s", moduleName);
            } else {
              debug("ignoring require of non-main module file: %s", res);
              self2._cache.set(filename, exports2, core);
              return exports2;
            }
          }
        }
      }
      self2._cache.set(filename, exports2, core);
      debug("calling require hook: %s", moduleName);
      const patchedExports = onrequire(exports2, moduleName, basedir);
      self2._cache.set(filename, patchedExports, core);
      debug("returning module: %s", moduleName);
      return patchedExports;
    }
  }
  Hook.prototype.unhook = function() {
    this._unhooked = true;
    if (this._require === Module.prototype.require) {
      Module.prototype.require = this._origRequire;
      debug("require unhook successful");
    } else {
      debug("require unhook unsuccessful");
    }
    if (process.getBuiltinModule !== undefined) {
      if (this._getBuiltinModule === process.getBuiltinModule) {
        process.getBuiltinModule = this._origGetBuiltinModule;
        debug("process.getBuiltinModule unhook successful");
      } else {
        debug("process.getBuiltinModule unhook unsuccessful");
      }
    }
  };
  function resolveModuleName(stat) {
    const normalizedPath = path.sep !== "/" ? stat.path.split(path.sep).join("/") : stat.path;
    return path.posix.join(stat.name, normalizedPath).replace(normalize2, "");
  }
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    constructor() {
      this.hooks = [];
      this.children = new Map;
    }
  }

  class ModuleNameTrie {
    constructor() {
      this._trie = new ModuleNameTrieNode;
      this._counter = 0;
    }
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a, b) => a.insertedId - b.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path = import.meta.require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    constructor() {
      this._moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName, onRequire) {
      const hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      var _a;
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = (_a = this._instance) !== null && _a !== undefined ? _a : new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// ../node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS((exports) => {
  var importHooks = [];
  var setters = new WeakMap;
  var specifiers = new Map;
  var toHook = [];
  var proxyHandler = {
    set(target, name, value) {
      return setters.get(target)[name](value);
    },
    defineProperty(target, property, descriptor) {
      if (!("value" in descriptor)) {
        throw new Error("Getters/setters are not supported for exports property descriptors.");
      }
      return setters.get(target)[property](descriptor.value);
    }
  };
  function register(name, namespace, set, specifier) {
    specifiers.set(name, specifier);
    setters.set(namespace, set);
    const proxy = new Proxy(namespace, proxyHandler);
    importHooks.forEach((hook) => hook(name, proxy));
    toHook.push([name, proxy]);
  }
  exports.register = register;
  exports.importHooks = importHooks;
  exports.specifiers = specifiers;
  exports.toHook = toHook;
});

// ../node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var parse = require_module_details_from_path();
  var { fileURLToPath } = import.meta.require("url");
  var { MessageChannel } = import.meta.require("worker_threads");
  var {
    importHooks,
    specifiers,
    toHook
  } = require_register();
  function addHook(hook) {
    importHooks.push(hook);
    toHook.forEach(([name, namespace]) => hook(name, namespace));
  }
  function removeHook(hook) {
    const index = importHooks.indexOf(hook);
    if (index > -1) {
      importHooks.splice(index, 1);
    }
  }
  function callHookFn(hookFn, namespace, name, baseDir) {
    const newDefault = hookFn(namespace, name, baseDir);
    if (newDefault && newDefault !== namespace) {
      namespace.default = newDefault;
    }
  }
  var sendModulesToLoader;
  function createAddHookMessageChannel() {
    const { port1, port2 } = new MessageChannel;
    let pendingAckCount = 0;
    let resolveFn;
    sendModulesToLoader = (modules) => {
      pendingAckCount++;
      port1.postMessage(modules);
    };
    port1.on("message", () => {
      pendingAckCount--;
      if (resolveFn && pendingAckCount <= 0) {
        resolveFn();
      }
    }).unref();
    function waitForAllMessagesAcknowledged() {
      const timer = setInterval(() => {
      }, 1000);
      const promise = new Promise((resolve2) => {
        resolveFn = resolve2;
      }).then(() => {
        clearInterval(timer);
      });
      if (pendingAckCount === 0) {
        resolveFn();
      }
      return promise;
    }
    const addHookMessagePort = port2;
    const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
    return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
  }
  function Hook(modules, options, hookFn) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, hookFn);
    if (typeof modules === "function") {
      hookFn = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      hookFn = options;
      options = null;
    }
    const internals = options ? options.internals === true : false;
    if (sendModulesToLoader && Array.isArray(modules)) {
      sendModulesToLoader(modules);
    }
    this._iitmHook = (name, namespace) => {
      const filename = name;
      const isBuiltin2 = name.startsWith("node:");
      let baseDir;
      if (isBuiltin2) {
        name = name.replace(/^node:/, "");
      } else {
        if (name.startsWith("file://")) {
          try {
            name = fileURLToPath(name);
          } catch (e) {
          }
        }
        const details = parse(name);
        if (details) {
          name = details.name;
          baseDir = details.basedir;
        }
      }
      if (modules) {
        for (const moduleName of modules) {
          if (moduleName === name) {
            if (baseDir) {
              if (internals) {
                name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
              } else {
                if (!baseDir.endsWith(specifiers.get(filename)))
                  continue;
              }
            }
            callHookFn(hookFn, namespace, name, baseDir);
          }
        }
      } else {
        callHookFn(hookFn, namespace, name, baseDir);
      }
    };
    addHook(this._iitmHook);
  }
  Hook.prototype.unhook = function() {
    removeHook(this._iitmHook);
  };
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.addHook = addHook;
  module.exports.removeHook = removeHook;
  module.exports.createAddHookMessageChannel = createAddHookMessageChannel;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = await execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path = import.meta.require("path");
  var util_1 = import.meta.require("util");
  var semver_1 = require_semver3();
  var shimmer_1 = require_shimmer();
  var instrumentation_1 = require_instrumentation();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = import.meta.require("fs");
  var utils_1 = require_utils6();

  class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config) {
      super(instrumentationName, instrumentationVersion, config);
      this._hooks = [];
      this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
      this._enabled = false;
      this._wrap = (moduleExports, name, wrapper) => {
        if ((0, utils_1.isWrapped)(moduleExports[name])) {
          this._unwrap(moduleExports, name);
        }
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
        } else {
          const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
          Object.defineProperty(moduleExports, name, {
            value: wrapped
          });
          return wrapped;
        }
      };
      this._unwrap = (moduleExports, name) => {
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.unwrap)(moduleExports, name);
        } else {
          return Object.defineProperty(moduleExports, name, {
            value: moduleExports[name]
          });
        }
      };
      this._massWrap = (moduleExportsArray, names, wrapper) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._wrap(moduleExports, name, wrapper);
          });
        });
      };
      this._massUnwrap = (moduleExportsArray, names) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._unwrap(moduleExports, name);
          });
        });
      };
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._config.enabled) {
        this.enable();
      }
    }
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = import.meta.require.resolve(name);
          if (import.meta.require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch (_a) {
        }
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version = JSON.parse(json).version;
        return typeof version === "string" ? version : undefined;
      } catch (error) {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      var _a;
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files = (_a = module2.files) !== null && _a !== undefined ? _a : [];
      const normalizedName = path.normalize(name);
      const supportedFileInstrumentations = files.filter((f) => f.name === normalizedName).filter((f) => isSupported(f.supportedVersions, version, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase;
  function isSupported(supportedVersions, version, includePrerelease) {
    if (typeof version === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version, supportedVersion, { includePrerelease });
    });
  }
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = import.meta.require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation2();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// ../node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node5();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// ../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition {
    constructor(name, supportedVersions, patch, unpatch, files) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform4();

  class InstrumentationNodeModuleFile {
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
});

// ../node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = exports.isWrapped = exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform4();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  var utils_1 = require_utils6();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return utils_1.isWrapped;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddle;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddleAsync;
  } });
});

// ../node_modules/@opentelemetry/instrumentation-http/build/src/http.js
var require_http = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpInstrumentation = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var semver = require_semver3();
  var url = import.meta.require("url");
  var utils = require_utils5();
  var version_1 = require_version3();
  var instrumentation_1 = require_src6();
  var core_2 = require_src3();
  var events_1 = import.meta.require("events");
  var semantic_conventions_1 = require_src2();

  class HttpInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super("@opentelemetry/instrumentation-http", version_1.VERSION, config);
      this._spanNotEnded = new WeakSet;
      this._headerCapture = this._createHeaderCapture();
    }
    _updateMetricInstruments() {
      this._httpServerDurationHistogram = this.meter.createHistogram("http.server.duration", {
        description: "Measures the duration of inbound HTTP requests.",
        unit: "ms",
        valueType: api_1.ValueType.DOUBLE
      });
      this._httpClientDurationHistogram = this.meter.createHistogram("http.client.duration", {
        description: "Measures the duration of outbound HTTP requests.",
        unit: "ms",
        valueType: api_1.ValueType.DOUBLE
      });
    }
    setConfig(config = {}) {
      super.setConfig(config);
      this._headerCapture = this._createHeaderCapture();
    }
    init() {
      return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
    }
    _getHttpInstrumentation() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("http", ["*"], (moduleExports) => {
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          const patchedRequest = this._wrap(moduleExports, "request", this._getPatchOutgoingRequestFunction("http"));
          this._wrap(moduleExports, "get", this._getPatchOutgoingGetFunction(patchedRequest));
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("http"));
        }
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports === undefined)
          return;
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._unwrap(moduleExports.Server.prototype, "emit");
        }
      });
    }
    _getHttpsInstrumentation() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("https", ["*"], (moduleExports) => {
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          const patchedRequest = this._wrap(moduleExports, "request", this._getPatchHttpsOutgoingRequestFunction("https"));
          this._wrap(moduleExports, "get", this._getPatchHttpsOutgoingGetFunction(patchedRequest));
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("https"));
        }
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports === undefined)
          return;
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._unwrap(moduleExports.Server.prototype, "emit");
        }
      });
    }
    _getPatchIncomingRequestFunction(component) {
      return (original) => {
        return this._incomingRequestFunction(component, original);
      };
    }
    _getPatchOutgoingRequestFunction(component) {
      return (original) => {
        return this._outgoingRequestFunction(component, original);
      };
    }
    _getPatchOutgoingGetFunction(clientRequest) {
      return (_original) => {
        return function outgoingGetRequest(options, ...args) {
          const req = clientRequest(options, ...args);
          req.end();
          return req;
        };
      };
    }
    _getPatchHttpsOutgoingRequestFunction(component) {
      return (original) => {
        const instrumentation = this;
        return function httpsOutgoingRequest(options, ...args) {
          var _a;
          if (component === "https" && typeof options === "object" && ((_a = options === null || options === undefined ? undefined : options.constructor) === null || _a === undefined ? undefined : _a.name) !== "URL") {
            options = Object.assign({}, options);
            instrumentation._setDefaultOptions(options);
          }
          return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);
        };
      };
    }
    _setDefaultOptions(options) {
      options.protocol = options.protocol || "https:";
      options.port = options.port || 443;
    }
    _getPatchHttpsOutgoingGetFunction(clientRequest) {
      return (original) => {
        const instrumentation = this;
        return function httpsOutgoingRequest(options, ...args) {
          return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);
        };
      };
    }
    _traceClientRequest(request, span, startTime, metricAttributes) {
      if (this.getConfig().requestHook) {
        this._callRequestHook(span, request);
      }
      let responseFinished = false;
      request.prependListener("response", (response) => {
        this._diag.debug("outgoingRequest on response()");
        if (request.listenerCount("response") <= 1) {
          response.resume();
        }
        const responseAttributes = utils.getOutgoingRequestAttributesOnResponse(response);
        span.setAttributes(responseAttributes);
        metricAttributes = Object.assign(metricAttributes, utils.getOutgoingRequestMetricAttributesOnResponse(responseAttributes));
        if (this.getConfig().responseHook) {
          this._callResponseHook(span, response);
        }
        this._headerCapture.client.captureRequestHeaders(span, (header) => request.getHeader(header));
        this._headerCapture.client.captureResponseHeaders(span, (header) => response.headers[header]);
        api_1.context.bind(api_1.context.active(), response);
        const endHandler = () => {
          this._diag.debug("outgoingRequest on end()");
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          let status;
          if (response.aborted && !response.complete) {
            status = { code: api_1.SpanStatusCode.ERROR };
          } else {
            status = {
              code: utils.parseResponseStatus(api_1.SpanKind.CLIENT, response.statusCode)
            };
          }
          span.setStatus(status);
          if (this.getConfig().applyCustomAttributesOnSpan) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
            }, true);
          }
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
        };
        response.on("end", endHandler);
        if (semver.lt(process.version, "16.0.0")) {
          response.on("close", endHandler);
        }
        response.on(events_1.errorMonitor, (error) => {
          this._diag.debug("outgoingRequest on error()", error);
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          utils.setSpanWithError(span, error);
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: error.message
          });
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
        });
      });
      request.on("close", () => {
        this._diag.debug("outgoingRequest on request close()");
        if (request.aborted || responseFinished) {
          return;
        }
        responseFinished = true;
        this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
      });
      request.on(events_1.errorMonitor, (error) => {
        this._diag.debug("outgoingRequest on request error()", error);
        if (responseFinished) {
          return;
        }
        responseFinished = true;
        utils.setSpanWithError(span, error);
        this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
      });
      this._diag.debug("http.ClientRequest return request");
      return request;
    }
    _incomingRequestFunction(component, original) {
      const instrumentation = this;
      return function incomingRequest(event, ...args) {
        if (event !== "request") {
          return original.apply(this, [event, ...args]);
        }
        const request = args[0];
        const response = args[1];
        const pathname = request.url ? url.parse(request.url).pathname || "/" : "/";
        const method = request.method || "GET";
        instrumentation._diag.debug(`${component} instrumentation incomingRequest`);
        if (utils.isIgnored(pathname, instrumentation.getConfig().ignoreIncomingPaths, (e) => instrumentation._diag.error("caught ignoreIncomingPaths error: ", e)) || (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a, _b;
          return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === undefined ? undefined : _b.call(_a, request);
        }, (e) => {
          if (e != null) {
            instrumentation._diag.error("caught ignoreIncomingRequestHook error: ", e);
          }
        }, true)) {
          return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            api_1.context.bind(api_1.context.active(), request);
            api_1.context.bind(api_1.context.active(), response);
            return original.apply(this, [event, ...args]);
          });
        }
        const headers = request.headers;
        const spanAttributes = utils.getIncomingRequestAttributes(request, {
          component,
          serverName: instrumentation.getConfig().serverName,
          hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook)
        });
        const spanOptions = {
          kind: api_1.SpanKind.SERVER,
          attributes: spanAttributes
        };
        const startTime = (0, core_1.hrTime)();
        const metricAttributes = utils.getIncomingRequestMetricAttributes(spanAttributes);
        const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
        const span = instrumentation._startHttpSpan(method, spanOptions, ctx);
        const rpcMetadata = {
          type: core_2.RPCType.HTTP,
          span
        };
        return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () => {
          api_1.context.bind(api_1.context.active(), request);
          api_1.context.bind(api_1.context.active(), response);
          if (instrumentation.getConfig().requestHook) {
            instrumentation._callRequestHook(span, request);
          }
          if (instrumentation.getConfig().responseHook) {
            instrumentation._callResponseHook(span, response);
          }
          instrumentation._headerCapture.server.captureRequestHeaders(span, (header) => request.headers[header]);
          let hasError = false;
          response.on("close", () => {
            if (hasError) {
              return;
            }
            instrumentation._onServerResponseFinish(request, response, span, metricAttributes, startTime);
          });
          response.on(events_1.errorMonitor, (err) => {
            hasError = true;
            instrumentation._onServerResponseError(span, metricAttributes, startTime, err);
          });
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [event, ...args]), (error) => {
            if (error) {
              utils.setSpanWithError(span, error);
              instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
              throw error;
            }
          });
        });
      };
    }
    _outgoingRequestFunction(component, original) {
      const instrumentation = this;
      return function outgoingRequest(options, ...args) {
        if (!utils.isValidOptionsType(options)) {
          return original.apply(this, [options, ...args]);
        }
        const extraOptions = typeof args[0] === "object" && (typeof options === "string" || options instanceof url.URL) ? args.shift() : undefined;
        const { origin, pathname, method, optionsParsed } = utils.getRequestInfo(options, extraOptions);
        if (component === "http" && semver.lt(process.version, "9.0.0") && optionsParsed.protocol === "https:") {
          return original.apply(this, [optionsParsed, ...args]);
        }
        if (utils.isIgnored(origin + pathname, instrumentation.getConfig().ignoreOutgoingUrls, (e) => instrumentation._diag.error("caught ignoreOutgoingUrls error: ", e)) || (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a, _b;
          return (_b = (_a = instrumentation.getConfig()).ignoreOutgoingRequestHook) === null || _b === undefined ? undefined : _b.call(_a, optionsParsed);
        }, (e) => {
          if (e != null) {
            instrumentation._diag.error("caught ignoreOutgoingRequestHook error: ", e);
          }
        }, true)) {
          return original.apply(this, [optionsParsed, ...args]);
        }
        const { hostname, port } = utils.extractHostnameAndPort(optionsParsed);
        const attributes = utils.getOutgoingRequestAttributes(optionsParsed, {
          component,
          port,
          hostname,
          hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook)
        });
        const startTime = (0, core_1.hrTime)();
        const metricAttributes = utils.getOutgoingRequestMetricAttributes(attributes);
        const spanOptions = {
          kind: api_1.SpanKind.CLIENT,
          attributes
        };
        const span = instrumentation._startHttpSpan(method, spanOptions);
        const parentContext = api_1.context.active();
        const requestContext = api_1.trace.setSpan(parentContext, span);
        if (!optionsParsed.headers) {
          optionsParsed.headers = {};
        } else {
          optionsParsed.headers = Object.assign({}, optionsParsed.headers);
        }
        api_1.propagation.inject(requestContext, optionsParsed.headers);
        return api_1.context.with(requestContext, () => {
          const cb = args[args.length - 1];
          if (typeof cb === "function") {
            args[args.length - 1] = api_1.context.bind(parentContext, cb);
          }
          const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [optionsParsed, ...args]), (error) => {
            if (error) {
              utils.setSpanWithError(span, error);
              instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
              throw error;
            }
          });
          instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);
          api_1.context.bind(parentContext, request);
          return instrumentation._traceClientRequest(request, span, startTime, metricAttributes);
        });
      };
    }
    _onServerResponseFinish(request, response, span, metricAttributes, startTime) {
      const attributes = utils.getIncomingRequestAttributesOnResponse(request, response);
      metricAttributes = Object.assign(metricAttributes, utils.getIncomingRequestMetricAttributesOnResponse(attributes));
      this._headerCapture.server.captureResponseHeaders(span, (header) => response.getHeader(header));
      span.setAttributes(attributes).setStatus({
        code: utils.parseResponseStatus(api_1.SpanKind.SERVER, response.statusCode)
      });
      const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
      if (route) {
        span.updateName(`${request.method || "GET"} ${route}`);
      }
      if (this.getConfig().applyCustomAttributesOnSpan) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
        }, true);
      }
      this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
    }
    _onServerResponseError(span, metricAttributes, startTime, error) {
      utils.setSpanWithError(span, error);
      this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
    }
    _startHttpSpan(name, options, ctx = api_1.context.active()) {
      const requireParent = options.kind === api_1.SpanKind.CLIENT ? this.getConfig().requireParentforOutgoingSpans : this.getConfig().requireParentforIncomingSpans;
      let span;
      const currentSpan = api_1.trace.getSpan(ctx);
      if (requireParent === true && currentSpan === undefined) {
        span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
      } else if (requireParent === true && (currentSpan === null || currentSpan === undefined ? undefined : currentSpan.spanContext().isRemote)) {
        span = currentSpan;
      } else {
        span = this.tracer.startSpan(name, options, ctx);
      }
      this._spanNotEnded.add(span);
      return span;
    }
    _closeHttpSpan(span, spanKind, startTime, metricAttributes) {
      if (!this._spanNotEnded.has(span)) {
        return;
      }
      span.end();
      this._spanNotEnded.delete(span);
      const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));
      if (spanKind === api_1.SpanKind.SERVER) {
        this._httpServerDurationHistogram.record(duration, metricAttributes);
      } else if (spanKind === api_1.SpanKind.CLIENT) {
        this._httpClientDurationHistogram.record(duration, metricAttributes);
      }
    }
    _callResponseHook(span, response) {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(span, response), () => {
      }, true);
    }
    _callRequestHook(span, request) {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, request), () => {
      }, true);
    }
    _callStartSpanHook(request, hookFunc) {
      if (typeof hookFunc === "function") {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => hookFunc(request), () => {
        }, true);
      }
    }
    _createHeaderCapture() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const config = this.getConfig();
      return {
        client: {
          captureRequestHeaders: utils.headerCapture("request", (_c = (_b = (_a = config.headersToSpanAttributes) === null || _a === undefined ? undefined : _a.client) === null || _b === undefined ? undefined : _b.requestHeaders) !== null && _c !== undefined ? _c : []),
          captureResponseHeaders: utils.headerCapture("response", (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === undefined ? undefined : _d.client) === null || _e === undefined ? undefined : _e.responseHeaders) !== null && _f !== undefined ? _f : [])
        },
        server: {
          captureRequestHeaders: utils.headerCapture("request", (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === undefined ? undefined : _g.server) === null || _h === undefined ? undefined : _h.requestHeaders) !== null && _j !== undefined ? _j : []),
          captureResponseHeaders: utils.headerCapture("response", (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === undefined ? undefined : _k.server) === null || _l === undefined ? undefined : _l.responseHeaders) !== null && _m !== undefined ? _m : [])
        }
      };
    }
  }
  exports.HttpInstrumentation = HttpInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-http/build/src/index.js
var require_src7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setSpanWithError = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setAttributesFromHttpKind = exports.satisfiesPattern = exports.parseResponseStatus = exports.isValidOptionsType = exports.isIgnored = exports.isCompressed = exports.headerCapture = exports.getRequestInfo = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributesOnResponse = exports.getOutgoingRequestAttributes = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestAttributes = exports.getAbsoluteUrl = exports.extractHostnameAndPort = exports.HttpInstrumentation = undefined;
  var http_1 = require_http();
  Object.defineProperty(exports, "HttpInstrumentation", { enumerable: true, get: function() {
    return http_1.HttpInstrumentation;
  } });
  var utils_1 = require_utils5();
  Object.defineProperty(exports, "extractHostnameAndPort", { enumerable: true, get: function() {
    return utils_1.extractHostnameAndPort;
  } });
  Object.defineProperty(exports, "getAbsoluteUrl", { enumerable: true, get: function() {
    return utils_1.getAbsoluteUrl;
  } });
  Object.defineProperty(exports, "getIncomingRequestAttributes", { enumerable: true, get: function() {
    return utils_1.getIncomingRequestAttributes;
  } });
  Object.defineProperty(exports, "getIncomingRequestAttributesOnResponse", { enumerable: true, get: function() {
    return utils_1.getIncomingRequestAttributesOnResponse;
  } });
  Object.defineProperty(exports, "getIncomingRequestMetricAttributes", { enumerable: true, get: function() {
    return utils_1.getIncomingRequestMetricAttributes;
  } });
  Object.defineProperty(exports, "getIncomingRequestMetricAttributesOnResponse", { enumerable: true, get: function() {
    return utils_1.getIncomingRequestMetricAttributesOnResponse;
  } });
  Object.defineProperty(exports, "getOutgoingRequestAttributes", { enumerable: true, get: function() {
    return utils_1.getOutgoingRequestAttributes;
  } });
  Object.defineProperty(exports, "getOutgoingRequestAttributesOnResponse", { enumerable: true, get: function() {
    return utils_1.getOutgoingRequestAttributesOnResponse;
  } });
  Object.defineProperty(exports, "getOutgoingRequestMetricAttributes", { enumerable: true, get: function() {
    return utils_1.getOutgoingRequestMetricAttributes;
  } });
  Object.defineProperty(exports, "getOutgoingRequestMetricAttributesOnResponse", { enumerable: true, get: function() {
    return utils_1.getOutgoingRequestMetricAttributesOnResponse;
  } });
  Object.defineProperty(exports, "getRequestInfo", { enumerable: true, get: function() {
    return utils_1.getRequestInfo;
  } });
  Object.defineProperty(exports, "headerCapture", { enumerable: true, get: function() {
    return utils_1.headerCapture;
  } });
  Object.defineProperty(exports, "isCompressed", { enumerable: true, get: function() {
    return utils_1.isCompressed;
  } });
  Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
    return utils_1.isIgnored;
  } });
  Object.defineProperty(exports, "isValidOptionsType", { enumerable: true, get: function() {
    return utils_1.isValidOptionsType;
  } });
  Object.defineProperty(exports, "parseResponseStatus", { enumerable: true, get: function() {
    return utils_1.parseResponseStatus;
  } });
  Object.defineProperty(exports, "satisfiesPattern", { enumerable: true, get: function() {
    return utils_1.satisfiesPattern;
  } });
  Object.defineProperty(exports, "setAttributesFromHttpKind", { enumerable: true, get: function() {
    return utils_1.setAttributesFromHttpKind;
  } });
  Object.defineProperty(exports, "setRequestContentLengthAttribute", { enumerable: true, get: function() {
    return utils_1.setRequestContentLengthAttribute;
  } });
  Object.defineProperty(exports, "setResponseContentLengthAttribute", { enumerable: true, get: function() {
    return utils_1.setResponseContentLengthAttribute;
  } });
  Object.defineProperty(exports, "setSpanWithError", { enumerable: true, get: function() {
    return utils_1.setSpanWithError;
  } });
});

// ../node_modules/@opentelemetry/instrumentation-undici/build/src/version.js
var require_version4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.6.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-undici";
});

// ../node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js
var require_SemanticAttributes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SemanticAttributes = undefined;
  exports.SemanticAttributes = {
    HTTP_CONNECTION_STATE: "http.connection.state",
    ERROR_TYPE: "error.type",
    HTTP_REQUEST_BODY_SIZE: "http.request.body.size",
    HTTP_REQUEST_METHOD: "http.request.method",
    HTTP_REQUEST_METHOD_ORIGINAL: "http.request.method_original",
    HTTP_REQUEST_RESEND_COUNT: "http.request.resend_count",
    HTTP_RESPONSE_BODY_SIZE: "http.response.body.size",
    HTTP_RESPONSE_STATUS_CODE: "http.response.status_code",
    HTTP_ROUTE: "http.route",
    NETWORK_PEER_ADDRESS: "network.peer.address",
    NETWORK_PEER_PORT: "network.peer.port",
    NETWORK_PROTOCOL_NAME: "network.protocol.name",
    NETWORK_PROTOCOL_VERSION: "network.protocol.version",
    SERVER_ADDRESS: "server.address",
    SERVER_PORT: "server.port",
    URL_FULL: "url.full",
    URL_PATH: "url.path",
    URL_QUERY: "url.query",
    URL_SCHEME: "url.scheme",
    USER_AGENT_ORIGINAL: "user_agent.original"
  };
});

// ../node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js
var require_undici = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UndiciInstrumentation = undefined;
  var diagch = import.meta.require("diagnostics_channel");
  var url_1 = import.meta.require("url");
  var instrumentation_1 = require_src6();
  var api_1 = require_src();
  var version_1 = require_version4();
  var SemanticAttributes_1 = require_SemanticAttributes2();
  var core_1 = require_src3();

  class UndiciInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._recordFromReq = new WeakMap;
    }
    init() {
      return;
    }
    disable() {
      super.disable();
      this._channelSubs.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));
      this._channelSubs.length = 0;
    }
    enable() {
      super.enable();
      this._channelSubs = this._channelSubs || [];
      if (this._channelSubs.length > 0) {
        return;
      }
      this.subscribeToChannel("undici:request:create", this.onRequestCreated.bind(this));
      this.subscribeToChannel("undici:client:sendHeaders", this.onRequestHeaders.bind(this));
      this.subscribeToChannel("undici:request:headers", this.onResponseHeaders.bind(this));
      this.subscribeToChannel("undici:request:trailers", this.onDone.bind(this));
      this.subscribeToChannel("undici:request:error", this.onError.bind(this));
    }
    _updateMetricInstruments() {
      this._httpClientDurationHistogram = this.meter.createHistogram("http.client.request.duration", {
        description: "Measures the duration of outbound HTTP requests.",
        unit: "s",
        valueType: api_1.ValueType.DOUBLE,
        advice: {
          explicitBucketBoundaries: [
            0.005,
            0.01,
            0.025,
            0.05,
            0.075,
            0.1,
            0.25,
            0.5,
            0.75,
            1,
            2.5,
            5,
            7.5,
            10
          ]
        }
      });
    }
    subscribeToChannel(diagnosticChannel, onMessage) {
      const channel = diagch.channel(diagnosticChannel);
      channel.subscribe(onMessage);
      this._channelSubs.push({
        name: diagnosticChannel,
        channel,
        onMessage
      });
    }
    onRequestCreated({ request }) {
      const config = this.getConfig();
      const enabled = config.enabled !== false;
      const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        var _a2;
        return !enabled || request.method === "CONNECT" || ((_a2 = config.ignoreRequestHook) === null || _a2 === undefined ? undefined : _a2.call(config, request));
      }, (e) => e && this._diag.error("caught ignoreRequestHook error: ", e), true);
      if (shouldIgnoreReq) {
        return;
      }
      const startTime = (0, core_1.hrTime)();
      const requestUrl = new url_1.URL(request.origin + request.path);
      const urlScheme = requestUrl.protocol.replace(":", "");
      const requestMethod = this.getRequestMethod(request.method);
      const attributes = {
        [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD]: requestMethod,
        [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD_ORIGINAL]: request.method,
        [SemanticAttributes_1.SemanticAttributes.URL_FULL]: requestUrl.toString(),
        [SemanticAttributes_1.SemanticAttributes.URL_PATH]: requestUrl.pathname,
        [SemanticAttributes_1.SemanticAttributes.URL_QUERY]: requestUrl.search,
        [SemanticAttributes_1.SemanticAttributes.URL_SCHEME]: urlScheme
      };
      const schemePorts = { https: "443", http: "80" };
      const serverAddress = requestUrl.hostname;
      const serverPort = requestUrl.port || schemePorts[urlScheme];
      attributes[SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS] = serverAddress;
      if (serverPort && !isNaN(Number(serverPort))) {
        attributes[SemanticAttributes_1.SemanticAttributes.SERVER_PORT] = Number(serverPort);
      }
      let userAgent;
      if (Array.isArray(request.headers)) {
        const idx = request.headers.findIndex((h) => h.toLowerCase() === "user-agent");
        if (idx >= 0) {
          userAgent = request.headers[idx + 1];
        }
      } else if (typeof request.headers === "string") {
        const headers = request.headers.split("\r\n");
        const uaHeader = headers.find((h) => h.toLowerCase().startsWith("user-agent"));
        userAgent = uaHeader && uaHeader.substring(uaHeader.indexOf(":") + 1).trim();
      }
      if (userAgent) {
        attributes[SemanticAttributes_1.SemanticAttributes.USER_AGENT_ORIGINAL] = userAgent;
      }
      const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        var _a2;
        return (_a2 = config.startSpanHook) === null || _a2 === undefined ? undefined : _a2.call(config, request);
      }, (e) => e && this._diag.error("caught startSpanHook error: ", e), true);
      if (hookAttributes) {
        Object.entries(hookAttributes).forEach(([key, val2]) => {
          attributes[key] = val2;
        });
      }
      const activeCtx = api_1.context.active();
      const currentSpan = api_1.trace.getSpan(activeCtx);
      let span;
      if (config.requireParentforSpans && (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {
        span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
      } else {
        span = this.tracer.startSpan(requestMethod === "_OTHER" ? "HTTP" : requestMethod, {
          kind: api_1.SpanKind.CLIENT,
          attributes
        }, activeCtx);
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        var _a2;
        return (_a2 = config.requestHook) === null || _a2 === undefined ? undefined : _a2.call(config, span, request);
      }, (e) => e && this._diag.error("caught requestHook error: ", e), true);
      const requestContext = api_1.trace.setSpan(api_1.context.active(), span);
      const addedHeaders = {};
      api_1.propagation.inject(requestContext, addedHeaders);
      const headerEntries = Object.entries(addedHeaders);
      for (let i = 0;i < headerEntries.length; i++) {
        const [k, v] = headerEntries[i];
        if (typeof request.addHeader === "function") {
          request.addHeader(k, v);
        } else if (typeof request.headers === "string") {
          request.headers += `${k}: ${v}\r\n`;
        } else if (Array.isArray(request.headers)) {
          request.headers.push(k, v);
        }
      }
      this._recordFromReq.set(request, { span, attributes, startTime });
    }
    onRequestHeaders({ request, socket }) {
      var _a2;
      const record = this._recordFromReq.get(request);
      if (!record) {
        return;
      }
      const config = this.getConfig();
      const { span } = record;
      const { remoteAddress, remotePort } = socket;
      const spanAttributes = {
        [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_ADDRESS]: remoteAddress,
        [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_PORT]: remotePort
      };
      if ((_a2 = config.headersToSpanAttributes) === null || _a2 === undefined ? undefined : _a2.requestHeaders) {
        const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map((n) => n.toLowerCase()));
        const rawHeaders = Array.isArray(request.headers) ? request.headers : request.headers.split("\r\n");
        rawHeaders.forEach((h, idx) => {
          const sepIndex = h.indexOf(":");
          const hasSeparator = sepIndex !== -1;
          const name = (hasSeparator ? h.substring(0, sepIndex) : h).toLowerCase();
          const value = hasSeparator ? h.substring(sepIndex + 1) : rawHeaders[idx + 1];
          if (headersToAttribs.has(name)) {
            spanAttributes[`http.request.header.${name}`] = value.trim();
          }
        });
      }
      span.setAttributes(spanAttributes);
    }
    onResponseHeaders({ request, response }) {
      var _a2, _b;
      const record = this._recordFromReq.get(request);
      if (!record) {
        return;
      }
      const { span, attributes } = record;
      const spanAttributes = {
        [SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE]: response.statusCode
      };
      const config = this.getConfig();
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        var _a3;
        return (_a3 = config.responseHook) === null || _a3 === undefined ? undefined : _a3.call(config, span, { request, response });
      }, (e) => e && this._diag.error("caught responseHook error: ", e), true);
      const headersToAttribs = new Set;
      if ((_a2 = config.headersToSpanAttributes) === null || _a2 === undefined ? undefined : _a2.responseHeaders) {
        (_b = config.headersToSpanAttributes) === null || _b === undefined || _b.responseHeaders.forEach((name) => headersToAttribs.add(name.toLowerCase()));
      }
      for (let idx = 0;idx < response.headers.length; idx = idx + 2) {
        const name = response.headers[idx].toString().toLowerCase();
        const value = response.headers[idx + 1];
        if (headersToAttribs.has(name)) {
          spanAttributes[`http.response.header.${name}`] = value.toString();
        }
        if (name === "content-length") {
          const contentLength = Number(value.toString());
          if (!isNaN(contentLength)) {
            spanAttributes["http.response.header.content-length"] = contentLength;
          }
        }
      }
      span.setAttributes(spanAttributes);
      span.setStatus({
        code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.UNSET
      });
      record.attributes = Object.assign(attributes, spanAttributes);
    }
    onDone({ request }) {
      const record = this._recordFromReq.get(request);
      if (!record) {
        return;
      }
      const { span, attributes, startTime } = record;
      span.end();
      this._recordFromReq.delete(request);
      this.recordRequestDuration(attributes, startTime);
    }
    onError({ request, error }) {
      const record = this._recordFromReq.get(request);
      if (!record) {
        return;
      }
      const { span, attributes, startTime } = record;
      span.recordException(error);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: error.message
      });
      span.end();
      this._recordFromReq.delete(request);
      attributes[SemanticAttributes_1.SemanticAttributes.ERROR_TYPE] = error.message;
      this.recordRequestDuration(attributes, startTime);
    }
    recordRequestDuration(attributes, startTime) {
      const metricsAttributes = {};
      const keysToCopy = [
        SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE,
        SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD,
        SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS,
        SemanticAttributes_1.SemanticAttributes.SERVER_PORT,
        SemanticAttributes_1.SemanticAttributes.URL_SCHEME,
        SemanticAttributes_1.SemanticAttributes.ERROR_TYPE
      ];
      keysToCopy.forEach((key) => {
        if (key in attributes) {
          metricsAttributes[key] = attributes[key];
        }
      });
      const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;
      this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);
    }
    getRequestMethod(original) {
      const knownMethods = {
        CONNECT: true,
        OPTIONS: true,
        HEAD: true,
        GET: true,
        POST: true,
        PUT: true,
        PATCH: true,
        DELETE: true,
        TRACE: true
      };
      if (original.toUpperCase() in knownMethods) {
        return original.toUpperCase();
      }
      return "_OTHER";
    }
  }
  exports.UndiciInstrumentation = UndiciInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-undici/build/src/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-undici/build/src/index.js
var require_src8 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_undici(), exports);
  __exportStar(require_types2(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js
var require_ExpressLayerType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpressLayerType = undefined;
  var ExpressLayerType;
  (function(ExpressLayerType2) {
    ExpressLayerType2["ROUTER"] = "router";
    ExpressLayerType2["MIDDLEWARE"] = "middleware";
    ExpressLayerType2["REQUEST_HANDLER"] = "request_handler";
  })(ExpressLayerType = exports.ExpressLayerType || (exports.ExpressLayerType = {}));
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js
var require_AttributeNames2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["EXPRESS_TYPE"] = "express.type";
    AttributeNames2["EXPRESS_NAME"] = "express.name";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js
var require_internal_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._LAYERS_STORE_PROPERTY = exports.kLayerPatched = undefined;
  exports.kLayerPatched = Symbol("express-layer-patched");
  exports._LAYERS_STORE_PROPERTY = "__ot_middlewares";
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/utils.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getLayerPath = exports.asErrorAndMessage = exports.isLayerIgnored = exports.getLayerMetadata = exports.storeLayerPath = undefined;
  var ExpressLayerType_1 = require_ExpressLayerType();
  var AttributeNames_1 = require_AttributeNames2();
  var internal_types_1 = require_internal_types();
  var storeLayerPath = (request, value) => {
    if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
      Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
        enumerable: false,
        value: []
      });
    }
    if (value === undefined)
      return;
    request[internal_types_1._LAYERS_STORE_PROPERTY].push(value);
  };
  exports.storeLayerPath = storeLayerPath;
  var getLayerMetadata = (layer, layerPath) => {
    if (layer.name === "router") {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layerPath,
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.ROUTER
        },
        name: `router - ${layerPath}`
      };
    } else if (layer.name === "bound dispatch") {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layerPath !== null && layerPath !== undefined ? layerPath : "request handler",
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.REQUEST_HANDLER
        },
        name: `request handler${layer.path ? ` - ${layerPath}` : ""}`
      };
    } else {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layer.name,
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.MIDDLEWARE
        },
        name: `middleware - ${layer.name}`
      };
    }
  };
  exports.getLayerMetadata = getLayerMetadata;
  var satisfiesPattern = (constant, pattern) => {
    if (typeof pattern === "string") {
      return pattern === constant;
    } else if (pattern instanceof RegExp) {
      return pattern.test(constant);
    } else if (typeof pattern === "function") {
      return pattern(constant);
    } else {
      throw new TypeError("Pattern is in unsupported datatype");
    }
  };
  var isLayerIgnored = (name, type, config) => {
    var _a2;
    if (Array.isArray(config === null || config === undefined ? undefined : config.ignoreLayersType) && ((_a2 = config === null || config === undefined ? undefined : config.ignoreLayersType) === null || _a2 === undefined ? undefined : _a2.includes(type))) {
      return true;
    }
    if (Array.isArray(config === null || config === undefined ? undefined : config.ignoreLayers) === false)
      return false;
    try {
      for (const pattern of config.ignoreLayers) {
        if (satisfiesPattern(name, pattern)) {
          return true;
        }
      }
    } catch (e) {
    }
    return false;
  };
  exports.isLayerIgnored = isLayerIgnored;
  var asErrorAndMessage = (error) => error instanceof Error ? [error, error.message] : [String(error), String(error)];
  exports.asErrorAndMessage = asErrorAndMessage;
  var getLayerPath = (args) => {
    if (Array.isArray(args[0])) {
      return args[0].map((arg) => extractLayerPathSegment(arg) || "").join(",");
    }
    return extractLayerPathSegment(args[0]);
  };
  exports.getLayerPath = getLayerPath;
  var extractLayerPathSegment = (arg) => {
    if (typeof arg === "string") {
      return arg;
    }
    if (arg instanceof RegExp || typeof arg === "number") {
      return arg.toString();
    }
    return;
  };
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/version.js
var require_version5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.42.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-express";
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js
var require_instrumentation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpressInstrumentation = undefined;
  var core_1 = require_src3();
  var api_1 = require_src();
  var ExpressLayerType_1 = require_ExpressLayerType();
  var AttributeNames_1 = require_AttributeNames2();
  var utils_1 = require_utils7();
  var version_1 = require_version5();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types();

  class ExpressInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("express", [">=4.0.0 <5"], (moduleExports) => {
          const routerProto = moduleExports.Router;
          if ((0, instrumentation_1.isWrapped)(routerProto.route)) {
            this._unwrap(routerProto, "route");
          }
          this._wrap(routerProto, "route", this._getRoutePatch());
          if ((0, instrumentation_1.isWrapped)(routerProto.use)) {
            this._unwrap(routerProto, "use");
          }
          this._wrap(routerProto, "use", this._getRouterUsePatch());
          if ((0, instrumentation_1.isWrapped)(moduleExports.application.use)) {
            this._unwrap(moduleExports.application, "use");
          }
          this._wrap(moduleExports.application, "use", this._getAppUsePatch());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          const routerProto = moduleExports.Router;
          this._unwrap(routerProto, "route");
          this._unwrap(routerProto, "use");
          this._unwrap(moduleExports.application, "use");
        })
      ];
    }
    _getRoutePatch() {
      const instrumentation = this;
      return function(original) {
        return function route_trace(...args) {
          const route = original.apply(this, args);
          const layer = this.stack[this.stack.length - 1];
          instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          return route;
        };
      };
    }
    _getRouterUsePatch() {
      const instrumentation = this;
      return function(original) {
        return function use(...args) {
          const route = original.apply(this, args);
          const layer = this.stack[this.stack.length - 1];
          instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          return route;
        };
      };
    }
    _getAppUsePatch() {
      const instrumentation = this;
      return function(original) {
        return function use(...args) {
          const route = original.apply(this, args);
          const layer = this._router.stack[this._router.stack.length - 1];
          instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          return route;
        };
      };
    }
    _applyPatch(layer, layerPath) {
      const instrumentation = this;
      if (layer[internal_types_1.kLayerPatched] === true)
        return;
      layer[internal_types_1.kLayerPatched] = true;
      this._wrap(layer, "handle", (original) => {
        if (original.length === 4)
          return original;
        const patched = function(req, res) {
          (0, utils_1.storeLayerPath)(req, layerPath);
          const route = req[internal_types_1._LAYERS_STORE_PROPERTY].filter((path3) => path3 !== "/" && path3 !== "/*").join("").replace(/\/{2,}/g, "/");
          const attributes = {
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.length > 0 ? route : "/"
          };
          const metadata = (0, utils_1.getLayerMetadata)(layer, layerPath);
          const type = metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE];
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          if ((rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = route || "/";
          }
          if ((0, utils_1.isLayerIgnored)(metadata.name, type, instrumentation.getConfig())) {
            if (type === ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
              req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
            }
            return original.apply(this, arguments);
          }
          if (api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return original.apply(this, arguments);
          }
          const spanName = instrumentation._getSpanName({
            request: req,
            layerType: type,
            route
          }, metadata.name);
          const span = instrumentation.tracer.startSpan(spanName, {
            attributes: Object.assign(attributes, metadata.attributes)
          });
          const { requestHook } = instrumentation.getConfig();
          if (requestHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook(span, {
              request: req,
              layerType: type,
              route
            }), (e) => {
              if (e) {
                api_1.diag.error("express instrumentation: request hook failed", e);
              }
            }, true);
          }
          let spanHasEnded = false;
          if (metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE] !== ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
            span.end();
            spanHasEnded = true;
          }
          const onResponseFinish = () => {
            if (spanHasEnded === false) {
              spanHasEnded = true;
              span.end();
            }
          };
          const args = Array.from(arguments);
          const callbackIdx = args.findIndex((arg) => typeof arg === "function");
          if (callbackIdx >= 0) {
            arguments[callbackIdx] = function() {
              var _a2;
              const maybeError = arguments[0];
              const isError2 = ![undefined, null, "route", "router"].includes(maybeError);
              if (!spanHasEnded && isError2) {
                const [error, message] = (0, utils_1.asErrorAndMessage)(maybeError);
                span.recordException(error);
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message
                });
              }
              if (spanHasEnded === false) {
                spanHasEnded = true;
                (_a2 = req.res) === null || _a2 === undefined || _a2.removeListener("finish", onResponseFinish);
                span.end();
              }
              if (!(req.route && isError2)) {
                req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
              }
              const callback = args[callbackIdx];
              return callback.apply(this, arguments);
            };
          }
          try {
            return original.apply(this, arguments);
          } catch (anyError) {
            const [error, message] = (0, utils_1.asErrorAndMessage)(anyError);
            span.recordException(error);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message
            });
            throw anyError;
          } finally {
            if (!spanHasEnded) {
              res.once("finish", onResponseFinish);
            }
          }
        };
        for (const key in original) {
          Object.defineProperty(patched, key, {
            get() {
              return original[key];
            },
            set(value) {
              original[key] = value;
            }
          });
        }
        return patched;
      });
    }
    _getSpanName(info, defaultName) {
      var _a2;
      const { spanNameHook } = this.getConfig();
      if (!(spanNameHook instanceof Function)) {
        return defaultName;
      }
      try {
        return (_a2 = spanNameHook(info, defaultName)) !== null && _a2 !== undefined ? _a2 : defaultName;
      } catch (err) {
        api_1.diag.error("express instrumentation: error calling span name rewrite hook", err);
        return defaultName;
      }
    }
  }
  exports.ExpressInstrumentation = ExpressInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-express/build/src/index.js
var require_src9 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation3(), exports);
  __exportStar(require_ExpressLayerType(), exports);
  __exportStar(require_AttributeNames2(), exports);
  __exportStar(require_types3(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/enums/AttributeNames.js
var require_AttributeNames3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FastifyNames = exports.FastifyTypes = exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["FASTIFY_NAME"] = "fastify.name";
    AttributeNames2["FASTIFY_TYPE"] = "fastify.type";
    AttributeNames2["HOOK_NAME"] = "hook.name";
    AttributeNames2["PLUGIN_NAME"] = "plugin.name";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  var FastifyTypes;
  (function(FastifyTypes2) {
    FastifyTypes2["MIDDLEWARE"] = "middleware";
    FastifyTypes2["REQUEST_HANDLER"] = "request_handler";
  })(FastifyTypes = exports.FastifyTypes || (exports.FastifyTypes = {}));
  var FastifyNames;
  (function(FastifyNames2) {
    FastifyNames2["MIDDLEWARE"] = "middleware";
    FastifyNames2["REQUEST_HANDLER"] = "request handler";
  })(FastifyNames = exports.FastifyNames || (exports.FastifyNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hooksNamesToWrap = exports.spanRequestSymbol = undefined;
  exports.spanRequestSymbol = Symbol("opentelemetry.instrumentation.fastify.request_active_span");
  exports.hooksNamesToWrap = new Set([
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError"
  ]);
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/utils.js
var require_utils8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeExecuteInTheMiddleMaybePromise = exports.endSpan = exports.startSpan = undefined;
  var api_1 = require_src();
  var constants_1 = require_constants3();
  function startSpan3(reply, tracer, spanName, spanAttributes = {}) {
    const span = tracer.startSpan(spanName, { attributes: spanAttributes });
    const spans = reply[constants_1.spanRequestSymbol] || [];
    spans.push(span);
    Object.defineProperty(reply, constants_1.spanRequestSymbol, {
      enumerable: false,
      configurable: true,
      value: spans
    });
    return span;
  }
  exports.startSpan = startSpan3;
  function endSpan(reply, err) {
    const spans = reply[constants_1.spanRequestSymbol] || [];
    if (!spans.length) {
      return;
    }
    spans.forEach((span) => {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
        span.recordException(err);
      }
      span.end();
    });
    delete reply[constants_1.spanRequestSymbol];
  }
  exports.endSpan = endSpan;
  function safeExecuteInTheMiddleMaybePromise(execute, onFinish, preventThrowingError) {
    let error;
    let result = undefined;
    try {
      result = execute();
      if (isPromise(result)) {
        result.then((res) => onFinish(undefined, res), (err) => onFinish(err));
      }
    } catch (e) {
      error = e;
    } finally {
      if (!isPromise(result)) {
        onFinish(error, result);
        if (error && !preventThrowingError) {
          throw error;
        }
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleMaybePromise = safeExecuteInTheMiddleMaybePromise;
  function isPromise(val2) {
    var _a2;
    return typeof val2 === "object" && val2 && typeof ((_a2 = Object.getOwnPropertyDescriptor(val2, "then")) === null || _a2 === undefined ? undefined : _a2.value) === "function" || false;
  }
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/version.js
var require_version6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.39.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-fastify";
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/instrumentation.js
var require_instrumentation4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FastifyInstrumentation = exports.ANONYMOUS_NAME = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var constants_1 = require_constants3();
  var AttributeNames_1 = require_AttributeNames3();
  var utils_1 = require_utils8();
  var version_1 = require_version6();
  exports.ANONYMOUS_NAME = "anonymous";

  class FastifyInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("fastify", [">=3.0.0 <5"], (moduleExports) => {
          return this._patchConstructor(moduleExports);
        })
      ];
    }
    _hookOnRequest() {
      const instrumentation = this;
      return function onRequest(request, reply, done) {
        if (!instrumentation.isEnabled()) {
          return done();
        }
        instrumentation._wrap(reply, "send", instrumentation._patchSend());
        const anyRequest = request;
        const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
        const routeName = anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath;
        if (routeName && (rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP) {
          rpcMetadata.route = routeName;
        }
        done();
      };
    }
    _wrapHandler(pluginName, hookName, original, syncFunctionWithDone) {
      const instrumentation = this;
      this._diag.debug("Patching fastify route.handler function");
      return function(...args) {
        if (!instrumentation.isEnabled()) {
          return original.apply(this, args);
        }
        const name = original.name || pluginName || exports.ANONYMOUS_NAME;
        const spanName = `${AttributeNames_1.FastifyNames.MIDDLEWARE} - ${name}`;
        const reply = args[1];
        const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, {
          [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.MIDDLEWARE,
          [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName,
          [AttributeNames_1.AttributeNames.HOOK_NAME]: hookName
        });
        const origDone = syncFunctionWithDone && args[args.length - 1];
        if (origDone) {
          args[args.length - 1] = function(...doneArgs) {
            (0, utils_1.endSpan)(reply);
            origDone.apply(this, doneArgs);
          };
        }
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return (0, utils_1.safeExecuteInTheMiddleMaybePromise)(() => {
            return original.apply(this, args);
          }, (err) => {
            if (err instanceof Error) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message
              });
              span.recordException(err);
            }
            if (!syncFunctionWithDone) {
              (0, utils_1.endSpan)(reply);
            }
          });
        });
      };
    }
    _wrapAddHook() {
      const instrumentation = this;
      this._diag.debug("Patching fastify server.addHook function");
      return function(original) {
        return function wrappedAddHook(...args) {
          const name = args[0];
          const handler = args[1];
          const pluginName = this.pluginName;
          if (!constants_1.hooksNamesToWrap.has(name)) {
            return original.apply(this, args);
          }
          const syncFunctionWithDone = typeof args[args.length - 1] === "function" && handler.constructor.name !== "AsyncFunction";
          return original.apply(this, [
            name,
            instrumentation._wrapHandler(pluginName, name, handler, syncFunctionWithDone)
          ]);
        };
      };
    }
    _patchConstructor(moduleExports) {
      const instrumentation = this;
      function fastify(...args) {
        const app = moduleExports.fastify.apply(this, args);
        app.addHook("onRequest", instrumentation._hookOnRequest());
        app.addHook("preHandler", instrumentation._hookPreHandler());
        instrumentation._wrap(app, "addHook", instrumentation._wrapAddHook());
        return app;
      }
      fastify.fastify = fastify;
      fastify.default = fastify;
      return fastify;
    }
    _patchSend() {
      const instrumentation = this;
      this._diag.debug("Patching fastify reply.send function");
      return function patchSend(original) {
        return function send(...args) {
          const maybeError = args[0];
          if (!instrumentation.isEnabled()) {
            return original.apply(this, args);
          }
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            return original.apply(this, args);
          }, (err) => {
            if (!err && maybeError instanceof Error) {
              err = maybeError;
            }
            (0, utils_1.endSpan)(this, err);
          });
        };
      };
    }
    _hookPreHandler() {
      const instrumentation = this;
      this._diag.debug("Patching fastify preHandler function");
      return function preHandler(request, reply, done) {
        var _a2, _b;
        if (!instrumentation.isEnabled()) {
          return done();
        }
        const anyRequest = request;
        const handler = ((_a2 = anyRequest.routeOptions) === null || _a2 === undefined ? undefined : _a2.handler) || ((_b = anyRequest.context) === null || _b === undefined ? undefined : _b.handler);
        const handlerName = (handler === null || handler === undefined ? undefined : handler.name.startsWith("bound ")) ? handler.name.substr(6) : handler === null || handler === undefined ? undefined : handler.name;
        const spanName = `${AttributeNames_1.FastifyNames.REQUEST_HANDLER} - ${handlerName || this.pluginName || exports.ANONYMOUS_NAME}`;
        const spanAttributes = {
          [AttributeNames_1.AttributeNames.PLUGIN_NAME]: this.pluginName,
          [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.REQUEST_HANDLER,
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath
        };
        if (handlerName) {
          spanAttributes[AttributeNames_1.AttributeNames.FASTIFY_NAME] = handlerName;
        }
        const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, spanAttributes);
        const { requestHook } = instrumentation.getConfig();
        if (requestHook) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook(span, { request }), (e) => {
            if (e) {
              instrumentation._diag.error("request hook failed", e);
            }
          }, true);
        }
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          done();
        });
      };
    }
  }
  exports.FastifyInstrumentation = FastifyInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-fastify/build/src/index.js
var require_src10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_AttributeNames3(), exports);
  __exportStar(require_types4(), exports);
  __exportStar(require_instrumentation4(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanNames = exports.TokenKind = exports.AllowedOperationTypes = undefined;
  var AllowedOperationTypes;
  (function(AllowedOperationTypes2) {
    AllowedOperationTypes2["QUERY"] = "query";
    AllowedOperationTypes2["MUTATION"] = "mutation";
    AllowedOperationTypes2["SUBSCRIPTION"] = "subscription";
  })(AllowedOperationTypes = exports.AllowedOperationTypes || (exports.AllowedOperationTypes = {}));
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind = exports.TokenKind || (exports.TokenKind = {}));
  var SpanNames;
  (function(SpanNames2) {
    SpanNames2["EXECUTE"] = "graphql.execute";
    SpanNames2["PARSE"] = "graphql.parse";
    SpanNames2["RESOLVE"] = "graphql.resolve";
    SpanNames2["VALIDATE"] = "graphql.validate";
    SpanNames2["SCHEMA_VALIDATE"] = "graphql.validateSchema";
    SpanNames2["SCHEMA_PARSE"] = "graphql.parseSchema";
  })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js
var require_AttributeNames4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["SOURCE"] = "graphql.source";
    AttributeNames2["FIELD_NAME"] = "graphql.field.name";
    AttributeNames2["FIELD_PATH"] = "graphql.field.path";
    AttributeNames2["FIELD_TYPE"] = "graphql.field.type";
    AttributeNames2["OPERATION_TYPE"] = "graphql.operation.type";
    AttributeNames2["OPERATION_NAME"] = "graphql.operation.name";
    AttributeNames2["VARIABLES"] = "graphql.variables.";
    AttributeNames2["ERROR_VALIDATION_NAME"] = "graphql.validation.error";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTEL_GRAPHQL_DATA_SYMBOL = exports.OTEL_PATCHED_SYMBOL = undefined;
  exports.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched");
  exports.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data");
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js
var require_internal_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OPERATION_NOT_SUPPORTED = undefined;
  var symbols_1 = require_symbols();
  exports.OPERATION_NOT_SUPPORTED = "Operation$operationName$not" + " supported";
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js
var require_utils9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapFieldResolver = exports.wrapFields = exports.getSourceFromLocation = exports.getOperation = exports.endSpan = exports.addSpanSource = exports.addInputVariableAttributes = exports.isPromise = undefined;
  var api3 = require_src();
  var enum_1 = require_enum();
  var AttributeNames_1 = require_AttributeNames4();
  var symbols_1 = require_symbols();
  var OPERATION_VALUES = Object.values(enum_1.AllowedOperationTypes);
  var isPromise = (value) => {
    return typeof (value === null || value === undefined ? undefined : value.then) === "function";
  };
  exports.isPromise = isPromise;
  var isObjectLike2 = (value) => {
    return typeof value == "object" && value !== null;
  };
  function addInputVariableAttribute(span, key, variable) {
    if (Array.isArray(variable)) {
      variable.forEach((value, idx) => {
        addInputVariableAttribute(span, `${key}.${idx}`, value);
      });
    } else if (variable instanceof Object) {
      Object.entries(variable).forEach(([nestedKey, value]) => {
        addInputVariableAttribute(span, `${key}.${nestedKey}`, value);
      });
    } else {
      span.setAttribute(`${AttributeNames_1.AttributeNames.VARIABLES}${String(key)}`, variable);
    }
  }
  function addInputVariableAttributes(span, variableValues) {
    Object.entries(variableValues).forEach(([key, value]) => {
      addInputVariableAttribute(span, key, value);
    });
  }
  exports.addInputVariableAttributes = addInputVariableAttributes;
  function addSpanSource(span, loc, allowValues, start, end) {
    const source = getSourceFromLocation(loc, allowValues, start, end);
    span.setAttribute(AttributeNames_1.AttributeNames.SOURCE, source);
  }
  exports.addSpanSource = addSpanSource;
  function createFieldIfNotExists(tracer, getConfig, contextValue, info, path3) {
    let field = getField(contextValue, path3);
    let spanAdded = false;
    if (!field) {
      spanAdded = true;
      const parent = getParentField(contextValue, path3);
      field = {
        parent,
        span: createResolverSpan(tracer, getConfig, contextValue, info, path3, parent.span),
        error: null
      };
      addField(contextValue, path3, field);
    }
    return { spanAdded, field };
  }
  function createResolverSpan(tracer, getConfig, contextValue, info, path3, parentSpan) {
    var _a2, _b;
    const attributes = {
      [AttributeNames_1.AttributeNames.FIELD_NAME]: info.fieldName,
      [AttributeNames_1.AttributeNames.FIELD_PATH]: path3.join("."),
      [AttributeNames_1.AttributeNames.FIELD_TYPE]: info.returnType.toString()
    };
    const span = tracer.startSpan(`${enum_1.SpanNames.RESOLVE} ${attributes[AttributeNames_1.AttributeNames.FIELD_PATH]}`, {
      attributes
    }, parentSpan ? api3.trace.setSpan(api3.context.active(), parentSpan) : undefined);
    const document2 = contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].source;
    const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
    if (fieldNode) {
      addSpanSource(span, document2.loc, getConfig().allowValues, (_a2 = fieldNode.loc) === null || _a2 === undefined ? undefined : _a2.start, (_b = fieldNode.loc) === null || _b === undefined ? undefined : _b.end);
    }
    return span;
  }
  function endSpan(span, error) {
    if (error) {
      span.recordException(error);
    }
    span.end();
  }
  exports.endSpan = endSpan;
  function getOperation(document2, operationName) {
    if (!document2 || !Array.isArray(document2.definitions)) {
      return;
    }
    if (operationName) {
      return document2.definitions.filter((definition) => {
        var _a2;
        return OPERATION_VALUES.indexOf((_a2 = definition) === null || _a2 === undefined ? undefined : _a2.operation) !== -1;
      }).find((definition) => {
        var _a2, _b;
        return operationName === ((_b = (_a2 = definition) === null || _a2 === undefined ? undefined : _a2.name) === null || _b === undefined ? undefined : _b.value);
      });
    } else {
      return document2.definitions.find((definition) => {
        var _a2;
        return OPERATION_VALUES.indexOf((_a2 = definition) === null || _a2 === undefined ? undefined : _a2.operation) !== -1;
      });
    }
  }
  exports.getOperation = getOperation;
  function addField(contextValue, path3, field) {
    return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path3.join(".")] = field;
  }
  function getField(contextValue, path3) {
    return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path3.join(".")];
  }
  function getParentField(contextValue, path3) {
    for (let i = path3.length - 1;i > 0; i--) {
      const field = getField(contextValue, path3.slice(0, i));
      if (field) {
        return field;
      }
    }
    return {
      span: contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].span
    };
  }
  function pathToArray(mergeItems, path3) {
    const flattened = [];
    let curr = path3;
    while (curr) {
      let key = curr.key;
      if (mergeItems && typeof key === "number") {
        key = "*";
      }
      flattened.push(String(key));
      curr = curr.prev;
    }
    return flattened.reverse();
  }
  function repeatBreak(i) {
    return repeatChar("\n", i);
  }
  function repeatSpace(i) {
    return repeatChar(" ", i);
  }
  function repeatChar(char, to) {
    let text = "";
    for (let i = 0;i < to; i++) {
      text += char;
    }
    return text;
  }
  var KindsToBeRemoved = [
    enum_1.TokenKind.FLOAT,
    enum_1.TokenKind.STRING,
    enum_1.TokenKind.INT,
    enum_1.TokenKind.BLOCK_STRING
  ];
  function getSourceFromLocation(loc, allowValues = false, inputStart, inputEnd) {
    var _a2, _b;
    let source = "";
    if (loc === null || loc === undefined ? undefined : loc.startToken) {
      const start = typeof inputStart === "number" ? inputStart : loc.start;
      const end = typeof inputEnd === "number" ? inputEnd : loc.end;
      let next = loc.startToken.next;
      let previousLine = 1;
      while (next) {
        if (next.start < start) {
          next = next.next;
          previousLine = next === null || next === undefined ? undefined : next.line;
          continue;
        }
        if (next.end > end) {
          next = next.next;
          previousLine = next === null || next === undefined ? undefined : next.line;
          continue;
        }
        let value = next.value || next.kind;
        let space = "";
        if (!allowValues && KindsToBeRemoved.indexOf(next.kind) >= 0) {
          value = "*";
        }
        if (next.kind === enum_1.TokenKind.STRING) {
          value = `"${value}"`;
        }
        if (next.kind === enum_1.TokenKind.EOF) {
          value = "";
        }
        if (next.line > previousLine) {
          source += repeatBreak(next.line - previousLine);
          previousLine = next.line;
          space = repeatSpace(next.column - 1);
        } else {
          if (next.line === ((_a2 = next.prev) === null || _a2 === undefined ? undefined : _a2.line)) {
            space = repeatSpace(next.start - (((_b = next.prev) === null || _b === undefined ? undefined : _b.end) || 0));
          }
        }
        source += space + value;
        if (next) {
          next = next.next;
        }
      }
    }
    return source;
  }
  exports.getSourceFromLocation = getSourceFromLocation;
  function wrapFields(type, tracer, getConfig) {
    if (!type || typeof type.getFields !== "function" || type[symbols_1.OTEL_PATCHED_SYMBOL]) {
      return;
    }
    const fields = type.getFields();
    type[symbols_1.OTEL_PATCHED_SYMBOL] = true;
    Object.keys(fields).forEach((key) => {
      const field = fields[key];
      if (!field) {
        return;
      }
      if (field.resolve) {
        field.resolve = wrapFieldResolver(tracer, getConfig, field.resolve);
      }
      if (field.type) {
        let unwrappedType = field.type;
        while (unwrappedType.ofType) {
          unwrappedType = unwrappedType.ofType;
        }
        wrapFields(unwrappedType, tracer, getConfig);
      }
    });
  }
  exports.wrapFields = wrapFields;
  var handleResolveSpanError = (resolveSpan, err, shouldEndSpan) => {
    if (!shouldEndSpan) {
      return;
    }
    resolveSpan.recordException(err);
    resolveSpan.setStatus({
      code: api3.SpanStatusCode.ERROR,
      message: err.message
    });
    resolveSpan.end();
  };
  var handleResolveSpanSuccess = (resolveSpan, shouldEndSpan) => {
    if (!shouldEndSpan) {
      return;
    }
    resolveSpan.end();
  };
  function wrapFieldResolver(tracer, getConfig, fieldResolver, isDefaultResolver = false) {
    if (wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] || typeof fieldResolver !== "function") {
      return fieldResolver;
    }
    function wrappedFieldResolver(source, args, contextValue, info) {
      if (!fieldResolver) {
        return;
      }
      const config = getConfig();
      if (config.ignoreTrivialResolveSpans && isDefaultResolver && (isObjectLike2(source) || typeof source === "function")) {
        const property = source[info.fieldName];
        if (typeof property !== "function") {
          return fieldResolver.call(this, source, args, contextValue, info);
        }
      }
      if (!contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL]) {
        return fieldResolver.call(this, source, args, contextValue, info);
      }
      const path3 = pathToArray(config.mergeItems, info && info.path);
      const depth = path3.filter((item) => typeof item === "string").length;
      let field;
      let shouldEndSpan = false;
      if (config.depth >= 0 && config.depth < depth) {
        field = getParentField(contextValue, path3);
      } else {
        const newField = createFieldIfNotExists(tracer, getConfig, contextValue, info, path3);
        field = newField.field;
        shouldEndSpan = newField.spanAdded;
      }
      return api3.context.with(api3.trace.setSpan(api3.context.active(), field.span), () => {
        try {
          const res = fieldResolver.call(this, source, args, contextValue, info);
          if ((0, exports.isPromise)(res)) {
            return res.then((r) => {
              handleResolveSpanSuccess(field.span, shouldEndSpan);
              return r;
            }, (err) => {
              handleResolveSpanError(field.span, err, shouldEndSpan);
              throw err;
            });
          } else {
            handleResolveSpanSuccess(field.span, shouldEndSpan);
            return res;
          }
        } catch (err) {
          handleResolveSpanError(field.span, err, shouldEndSpan);
          throw err;
        }
      });
    }
    wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] = true;
    return wrappedFieldResolver;
  }
  exports.wrapFieldResolver = wrapFieldResolver;
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js
var require_version7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.43.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-graphql";
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js
var require_instrumentation5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GraphQLInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var enum_1 = require_enum();
  var AttributeNames_1 = require_AttributeNames4();
  var symbols_1 = require_symbols();
  var internal_types_1 = require_internal_types2();
  var utils_1 = require_utils9();
  var version_1 = require_version7();
  var DEFAULT_CONFIG = {
    mergeItems: false,
    depth: -1,
    allowValues: false,
    ignoreResolveSpans: false
  };
  var supportedVersions = [">=14.0.0 <17"];

  class GraphQLInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    setConfig(config = {}) {
      super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    init() {
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("graphql", supportedVersions);
      module2.files.push(this._addPatchingExecute());
      module2.files.push(this._addPatchingParser());
      module2.files.push(this._addPatchingValidate());
      return module2;
    }
    _addPatchingExecute() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/execution/execute.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.execute)) {
          this._unwrap(moduleExports, "execute");
        }
        this._wrap(moduleExports, "execute", this._patchExecute(moduleExports.defaultFieldResolver));
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "execute");
        }
      });
    }
    _addPatchingParser() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/language/parser.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.parse)) {
          this._unwrap(moduleExports, "parse");
        }
        this._wrap(moduleExports, "parse", this._patchParse());
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "parse");
        }
      });
    }
    _addPatchingValidate() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/validation/validate.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.validate)) {
          this._unwrap(moduleExports, "validate");
        }
        this._wrap(moduleExports, "validate", this._patchValidate());
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "validate");
        }
      });
    }
    _patchExecute(defaultFieldResolved) {
      const instrumentation = this;
      return function execute(original) {
        return function patchExecute() {
          let processedArgs;
          if (arguments.length >= 2) {
            const args = arguments;
            processedArgs = instrumentation._wrapExecuteArgs(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], defaultFieldResolved);
          } else {
            const args = arguments[0];
            processedArgs = instrumentation._wrapExecuteArgs(args.schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.typeResolver, defaultFieldResolved);
          }
          const operation = (0, utils_1.getOperation)(processedArgs.document, processedArgs.operationName);
          const span = instrumentation._createExecuteSpan(operation, processedArgs);
          processedArgs.contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] = {
            source: processedArgs.document ? processedArgs.document || processedArgs.document[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] : undefined,
            span,
            fields: {}
          };
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              return original.apply(this, [
                processedArgs
              ]);
            }, (err, result) => {
              instrumentation._handleExecutionResult(span, err, result);
            });
          });
        };
      };
    }
    _handleExecutionResult(span, err, result) {
      const config = this.getConfig();
      if (result === undefined || err) {
        (0, utils_1.endSpan)(span, err);
        return;
      }
      if ((0, utils_1.isPromise)(result)) {
        result.then((resultData) => {
          if (typeof config.responseHook !== "function") {
            (0, utils_1.endSpan)(span);
            return;
          }
          this._executeResponseHook(span, resultData);
        }, (error) => {
          (0, utils_1.endSpan)(span, error);
        });
      } else {
        if (typeof config.responseHook !== "function") {
          (0, utils_1.endSpan)(span);
          return;
        }
        this._executeResponseHook(span, result);
      }
    }
    _executeResponseHook(span, result) {
      const { responseHook } = this.getConfig();
      if (!responseHook) {
        return;
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        responseHook(span, result);
      }, (err) => {
        if (err) {
          this._diag.error("Error running response hook", err);
        }
        (0, utils_1.endSpan)(span, undefined);
      }, true);
    }
    _patchParse() {
      const instrumentation = this;
      return function parse(original) {
        return function patchParse(source, options) {
          return instrumentation._parse(this, original, source, options);
        };
      };
    }
    _patchValidate() {
      const instrumentation = this;
      return function validate(original) {
        return function patchValidate(schema, documentAST, rules, options, typeInfo) {
          return instrumentation._validate(this, original, schema, documentAST, rules, typeInfo, options);
        };
      };
    }
    _parse(obj, original, source, options) {
      const config = this.getConfig();
      const span = this.tracer.startSpan(enum_1.SpanNames.PARSE);
      return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          return original.call(obj, source, options);
        }, (err, result) => {
          if (result) {
            const operation = (0, utils_1.getOperation)(result);
            if (!operation) {
              span.updateName(enum_1.SpanNames.SCHEMA_PARSE);
            } else if (result.loc) {
              (0, utils_1.addSpanSource)(span, result.loc, config.allowValues);
            }
          }
          (0, utils_1.endSpan)(span, err);
        });
      });
    }
    _validate(obj, original, schema, documentAST, rules, typeInfo, options) {
      const span = this.tracer.startSpan(enum_1.SpanNames.VALIDATE, {});
      return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          return original.call(obj, schema, documentAST, rules, options, typeInfo);
        }, (err, errors) => {
          if (!documentAST.loc) {
            span.updateName(enum_1.SpanNames.SCHEMA_VALIDATE);
          }
          if (errors && errors.length) {
            span.recordException({
              name: AttributeNames_1.AttributeNames.ERROR_VALIDATION_NAME,
              message: JSON.stringify(errors)
            });
          }
          (0, utils_1.endSpan)(span, err);
        });
      });
    }
    _createExecuteSpan(operation, processedArgs) {
      var _a2;
      const config = this.getConfig();
      const span = this.tracer.startSpan(enum_1.SpanNames.EXECUTE, {});
      if (operation) {
        const { operation: operationType, name: nameNode } = operation;
        span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_TYPE, operationType);
        const operationName = nameNode === null || nameNode === undefined ? undefined : nameNode.value;
        if (operationName) {
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
          span.updateName(`${operationType} ${operationName}`);
        } else {
          span.updateName(operationType);
        }
      } else {
        let operationName = " ";
        if (processedArgs.operationName) {
          operationName = ` "${processedArgs.operationName}" `;
        }
        operationName = internal_types_1.OPERATION_NOT_SUPPORTED.replace("$operationName$", operationName);
        span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
      }
      if ((_a2 = processedArgs.document) === null || _a2 === undefined ? undefined : _a2.loc) {
        (0, utils_1.addSpanSource)(span, processedArgs.document.loc, config.allowValues);
      }
      if (processedArgs.variableValues && config.allowValues) {
        (0, utils_1.addInputVariableAttributes)(span, processedArgs.variableValues);
      }
      return span;
    }
    _wrapExecuteArgs(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver, defaultFieldResolved) {
      if (!contextValue) {
        contextValue = {};
      }
      if (contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] || this.getConfig().ignoreResolveSpans) {
        return {
          schema,
          document: document2,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        };
      }
      const isUsingDefaultResolver = fieldResolver == null;
      const fieldResolverForExecute = fieldResolver !== null && fieldResolver !== undefined ? fieldResolver : defaultFieldResolved;
      fieldResolver = (0, utils_1.wrapFieldResolver)(this.tracer, () => this.getConfig(), fieldResolverForExecute, isUsingDefaultResolver);
      if (schema) {
        (0, utils_1.wrapFields)(schema.getQueryType(), this.tracer, () => this.getConfig());
        (0, utils_1.wrapFields)(schema.getMutationType(), this.tracer, () => this.getConfig());
      }
      return {
        schema,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      };
    }
  }
  exports.GraphQLInstrumentation = GraphQLInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/types.js
var require_types5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js
var require_src11 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation5(), exports);
  __exportStar(require_types5(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js
var require_version8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.3.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-kafkajs";
});

// ../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js
var require_propagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTextMapGetter = undefined;
  exports.bufferTextMapGetter = {
    get(carrier, key) {
      var _a2;
      if (!carrier) {
        return;
      }
      const keys = Object.keys(carrier);
      for (const carrierKey of keys) {
        if (carrierKey === key || carrierKey.toLowerCase() === key) {
          return (_a2 = carrier[carrierKey]) === null || _a2 === undefined ? undefined : _a2.toString();
        }
      }
      return;
    },
    keys(carrier) {
      return carrier ? Object.keys(carrier) : [];
    }
  };
});

// ../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js
var require_instrumentation6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KafkaJsInstrumentation = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var version_1 = require_version8();
  var propagator_1 = require_propagator();
  var instrumentation_1 = require_src6();

  class KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      const unpatch = (moduleExports) => {
        var _a2, _b;
        if ((0, instrumentation_1.isWrapped)((_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.Kafka) === null || _a2 === undefined ? undefined : _a2.prototype.producer)) {
          this._unwrap(moduleExports.Kafka.prototype, "producer");
        }
        if ((0, instrumentation_1.isWrapped)((_b = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.Kafka) === null || _b === undefined ? undefined : _b.prototype.consumer)) {
          this._unwrap(moduleExports.Kafka.prototype, "consumer");
        }
      };
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("kafkajs", [">=0.1.0 <3"], (moduleExports) => {
        var _a2, _b;
        unpatch(moduleExports);
        this._wrap((_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.Kafka) === null || _a2 === undefined ? undefined : _a2.prototype, "producer", this._getProducerPatch());
        this._wrap((_b = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.Kafka) === null || _b === undefined ? undefined : _b.prototype, "consumer", this._getConsumerPatch());
        return moduleExports;
      }, unpatch);
      return module2;
    }
    _getConsumerPatch() {
      const instrumentation = this;
      return (original) => {
        return function consumer(...args) {
          const newConsumer = original.apply(this, args);
          if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {
            instrumentation._unwrap(newConsumer, "run");
          }
          instrumentation._wrap(newConsumer, "run", instrumentation._getConsumerRunPatch());
          return newConsumer;
        };
      };
    }
    _getProducerPatch() {
      const instrumentation = this;
      return (original) => {
        return function consumer(...args) {
          const newProducer = original.apply(this, args);
          if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {
            instrumentation._unwrap(newProducer, "sendBatch");
          }
          instrumentation._wrap(newProducer, "sendBatch", instrumentation._getProducerSendBatchPatch());
          if ((0, instrumentation_1.isWrapped)(newProducer.send)) {
            instrumentation._unwrap(newProducer, "send");
          }
          instrumentation._wrap(newProducer, "send", instrumentation._getProducerSendPatch());
          return newProducer;
        };
      };
    }
    _getConsumerRunPatch() {
      const instrumentation = this;
      return (original) => {
        return function run(...args) {
          const config = args[0];
          if (config === null || config === undefined ? undefined : config.eachMessage) {
            if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {
              instrumentation._unwrap(config, "eachMessage");
            }
            instrumentation._wrap(config, "eachMessage", instrumentation._getConsumerEachMessagePatch());
          }
          if (config === null || config === undefined ? undefined : config.eachBatch) {
            if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {
              instrumentation._unwrap(config, "eachBatch");
            }
            instrumentation._wrap(config, "eachBatch", instrumentation._getConsumerEachBatchPatch());
          }
          return original.call(this, config);
        };
      };
    }
    _getConsumerEachMessagePatch() {
      const instrumentation = this;
      return (original) => {
        return function eachMessage(...args) {
          const payload = args[0];
          const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);
          const span = instrumentation._startConsumerSpan(payload.topic, payload.message, semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, propagatedContext);
          const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {
            return original.apply(this, args);
          });
          return instrumentation._endSpansOnPromise([span], eachMessagePromise);
        };
      };
    }
    _getConsumerEachBatchPatch() {
      return (original) => {
        const instrumentation = this;
        return function eachBatch(...args) {
          const payload = args[0];
          const receivingSpan = instrumentation._startConsumerSpan(payload.batch.topic, undefined, semantic_conventions_1.MESSAGINGOPERATIONVALUES_RECEIVE, api_1.ROOT_CONTEXT);
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {
            const spans = payload.batch.messages.map((message) => {
              var _a2;
              const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);
              const spanContext = (_a2 = api_1.trace.getSpan(propagatedContext)) === null || _a2 === undefined ? undefined : _a2.spanContext();
              let origSpanLink;
              if (spanContext) {
                origSpanLink = {
                  context: spanContext
                };
              }
              return instrumentation._startConsumerSpan(payload.batch.topic, message, semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, undefined, origSpanLink);
            });
            const batchMessagePromise = original.apply(this, args);
            spans.unshift(receivingSpan);
            return instrumentation._endSpansOnPromise(spans, batchMessagePromise);
          });
        };
      };
    }
    _getProducerSendBatchPatch() {
      const instrumentation = this;
      return (original) => {
        return function sendBatch(...args) {
          const batch = args[0];
          const messages = batch.topicMessages || [];
          const spans = messages.map((topicMessage) => topicMessage.messages.map((message) => instrumentation._startProducerSpan(topicMessage.topic, message))).reduce((acc, val2) => acc.concat(val2), []);
          const origSendResult = original.apply(this, args);
          return instrumentation._endSpansOnPromise(spans, origSendResult);
        };
      };
    }
    _getProducerSendPatch() {
      const instrumentation = this;
      return (original) => {
        return function send(...args) {
          const record = args[0];
          const spans = record.messages.map((message) => {
            return instrumentation._startProducerSpan(record.topic, message);
          });
          const origSendResult = original.apply(this, args);
          return instrumentation._endSpansOnPromise(spans, origSendResult);
        };
      };
    }
    _endSpansOnPromise(spans, sendPromise) {
      return Promise.resolve(sendPromise).catch((reason) => {
        let errorMessage;
        if (typeof reason === "string")
          errorMessage = reason;
        else if (typeof reason === "object" && Object.prototype.hasOwnProperty.call(reason, "message"))
          errorMessage = reason.message;
        spans.forEach((span) => span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: errorMessage
        }));
        throw reason;
      }).finally(() => {
        spans.forEach((span) => span.end());
      });
    }
    _startConsumerSpan(topic, message, operation, context8, link) {
      const span = this.tracer.startSpan(topic, {
        kind: api_1.SpanKind.CONSUMER,
        attributes: {
          [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "kafka",
          [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: topic,
          [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: operation
        },
        links: link ? [link] : []
      }, context8);
      const { consumerHook } = this.getConfig();
      if (consumerHook && message) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), (e) => {
          if (e)
            this._diag.error("consumerHook error", e);
        }, true);
      }
      return span;
    }
    _startProducerSpan(topic, message) {
      var _a2;
      const span = this.tracer.startSpan(topic, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
          [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "kafka",
          [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: topic
        }
      });
      message.headers = (_a2 = message.headers) !== null && _a2 !== undefined ? _a2 : {};
      api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);
      const { producerHook } = this.getConfig();
      if (producerHook) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), (e) => {
          if (e)
            this._diag.error("producerHook error", e);
        }, true);
      }
      return span;
    }
  }
  exports.KafkaJsInstrumentation = KafkaJsInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/types.js
var require_types6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js
var require_src12 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation6(), exports);
  __exportStar(require_types6(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js
var require_internal_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongodbCommandType = undefined;
  var MongodbCommandType;
  (function(MongodbCommandType2) {
    MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
    MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
    MongodbCommandType2["IS_MASTER"] = "isMaster";
    MongodbCommandType2["COUNT"] = "count";
    MongodbCommandType2["AGGREGATE"] = "aggregate";
    MongodbCommandType2["UNKNOWN"] = "unknown";
  })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
});

// ../node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js
var require_version9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.47.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongodb";
});

// ../node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js
var require_instrumentation7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types3();
  var version_1 = require_version9();

  class MongoDBInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    _updateMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
        description: "The number of connections that are currently in state described by the state attribute.",
        unit: "{connection}"
      });
    }
    init() {
      const { v3PatchConnection, v3UnpatchConnection } = this._getV3ConnectionPatches();
      const { v4PatchConnect, v4UnpatchConnect } = this._getV4ConnectPatches();
      const { v4PatchConnectionCallback, v4PatchConnectionPromise, v4UnpatchConnection } = this._getV4ConnectionPatches();
      const { v4PatchConnectionPool, v4UnpatchConnectionPool } = this._getV4ConnectionPoolPatches();
      const { v4PatchSessions, v4UnpatchSessions } = this._getV4SessionsPatches();
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=3.3.0 <4"], undefined, undefined, [
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/core/wireprotocol/index.js", [">=3.3.0 <4"], v3PatchConnection, v3UnpatchConnection)
        ]),
        new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=4.0.0 <7"], undefined, undefined, [
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=4.0.0 <6.4"], v4PatchConnectionCallback, v4UnpatchConnection),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=6.4.0 <7"], v4PatchConnectionPromise, v4UnpatchConnection),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection_pool.js", [">=4.0.0 <6.4"], v4PatchConnectionPool, v4UnpatchConnectionPool),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connect.js", [">=4.0.0 <7"], v4PatchConnect, v4UnpatchConnect),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/sessions.js", [">=4.0.0 <7"], v4PatchSessions, v4UnpatchSessions)
        ])
      ];
    }
    _getV3ConnectionPatches() {
      return {
        v3PatchConnection: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.insert)) {
            this._unwrap(moduleExports, "insert");
          }
          this._wrap(moduleExports, "insert", this._getV3PatchOperation("insert"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.remove)) {
            this._unwrap(moduleExports, "remove");
          }
          this._wrap(moduleExports, "remove", this._getV3PatchOperation("remove"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.update)) {
            this._unwrap(moduleExports, "update");
          }
          this._wrap(moduleExports, "update", this._getV3PatchOperation("update"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.command)) {
            this._unwrap(moduleExports, "command");
          }
          this._wrap(moduleExports, "command", this._getV3PatchCommand());
          if ((0, instrumentation_1.isWrapped)(moduleExports.query)) {
            this._unwrap(moduleExports, "query");
          }
          this._wrap(moduleExports, "query", this._getV3PatchFind());
          if ((0, instrumentation_1.isWrapped)(moduleExports.getMore)) {
            this._unwrap(moduleExports, "getMore");
          }
          this._wrap(moduleExports, "getMore", this._getV3PatchCursor());
          return moduleExports;
        },
        v3UnpatchConnection: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "insert");
          this._unwrap(moduleExports, "remove");
          this._unwrap(moduleExports, "update");
          this._unwrap(moduleExports, "command");
          this._unwrap(moduleExports, "query");
          this._unwrap(moduleExports, "getMore");
        }
      };
    }
    _getV4SessionsPatches() {
      return {
        v4PatchSessions: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
            this._unwrap(moduleExports, "acquire");
          }
          this._wrap(moduleExports.ServerSessionPool.prototype, "acquire", this._getV4AcquireCommand());
          if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
            this._unwrap(moduleExports, "release");
          }
          this._wrap(moduleExports.ServerSessionPool.prototype, "release", this._getV4ReleaseCommand());
          return moduleExports;
        },
        v4UnpatchSessions: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
            this._unwrap(moduleExports, "acquire");
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
            this._unwrap(moduleExports, "release");
          }
        }
      };
    }
    _getV4AcquireCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchAcquire() {
          const nSessionsBeforeAcquire = this.sessions.length;
          const session = original.call(this);
          const nSessionsAfterAcquire = this.sessions.length;
          if (nSessionsBeforeAcquire === nSessionsAfterAcquire) {
            instrumentation._connectionsUsage.add(1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
          } else if (nSessionsBeforeAcquire - 1 === nSessionsAfterAcquire) {
            instrumentation._connectionsUsage.add(-1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
            instrumentation._connectionsUsage.add(1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
          }
          return session;
        };
      };
    }
    _getV4ReleaseCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchRelease(session) {
          const cmdPromise = original.call(this, session);
          instrumentation._connectionsUsage.add(-1, {
            state: "used",
            "pool.name": instrumentation._poolName
          });
          instrumentation._connectionsUsage.add(1, {
            state: "idle",
            "pool.name": instrumentation._poolName
          });
          return cmdPromise;
        };
      };
    }
    _getV4ConnectionPoolPatches() {
      return {
        v4PatchConnectionPool: (moduleExports) => {
          const poolPrototype = moduleExports.ConnectionPool.prototype;
          if ((0, instrumentation_1.isWrapped)(poolPrototype.checkOut)) {
            this._unwrap(poolPrototype, "checkOut");
          }
          this._wrap(poolPrototype, "checkOut", this._getV4ConnectionPoolCheckOut());
          return moduleExports;
        },
        v4UnpatchConnectionPool: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports.ConnectionPool.prototype, "checkOut");
        }
      };
    }
    _getV4ConnectPatches() {
      return {
        v4PatchConnect: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
            this._unwrap(moduleExports, "connect");
          }
          this._wrap(moduleExports, "connect", this._getV4ConnectCommand());
          return moduleExports;
        },
        v4UnpatchConnect: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "connect");
        }
      };
    }
    _getV4ConnectionPoolCheckOut() {
      return (original) => {
        return function patchedCheckout(callback) {
          const patchedCallback = api_1.context.bind(api_1.context.active(), callback);
          return original.call(this, patchedCallback);
        };
      };
    }
    _getV4ConnectCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchedConnect(options, callback) {
          if (original.length === 1) {
            const result = original.call(this, options);
            if (result && typeof result.then === "function") {
              result.then(() => instrumentation.setPoolName(options), () => {
                return;
              });
            }
            return result;
          }
          const patchedCallback = function(err, conn) {
            if (err || !conn) {
              callback(err, conn);
              return;
            }
            instrumentation.setPoolName(options);
            callback(err, conn);
          };
          return original.call(this, options, patchedCallback);
        };
      };
    }
    _getV4ConnectionPatches() {
      return {
        v4PatchConnectionCallback: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
          this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandCallback());
          return moduleExports;
        },
        v4PatchConnectionPromise: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
          this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandPromise());
          return moduleExports;
        },
        v4UnpatchConnection: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports.Connection.prototype, "command");
        }
      };
    }
    _getV3PatchOperation(operationName) {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, ops, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const resultHandler = typeof options === "function" ? options : callback;
          if (!currentSpan || typeof resultHandler !== "function" || typeof ops !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, ops, options);
            } else {
              return original.call(this, server, ns, ops, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, ops[0], operationName);
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, ops, patchedCallback);
          } else {
            return original.call(this, server, ns, ops, options, patchedCallback);
          }
        };
      };
    }
    _getV3PatchCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cmd, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const resultHandler = typeof options === "function" ? options : callback;
          if (!currentSpan || typeof resultHandler !== "function" || typeof cmd !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, options);
            } else {
              return original.call(this, server, ns, cmd, options, callback);
            }
          }
          const commandType = MongoDBInstrumentation._getCommandType(cmd);
          const type = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? "command" : commandType;
          const span = instrumentation.tracer.startSpan(`mongodb.${type}`, {
            kind: api_1.SpanKind.CLIENT
          });
          const operation = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? undefined : commandType;
          instrumentation._populateV3Attributes(span, ns, server, cmd, operation);
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cmd, patchedCallback);
          } else {
            return original.call(this, server, ns, cmd, options, patchedCallback);
          }
        };
      };
    }
    _getV4PatchCommandCallback() {
      const instrumentation = this;
      return (original) => {
        return function patchedV4ServerCommand(ns, cmd, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const resultHandler = callback;
          const commandType = Object.keys(cmd)[0];
          if (typeof resultHandler !== "function" || typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
            return original.call(this, ns, cmd, options, callback);
          }
          let span = undefined;
          if (currentSpan) {
            span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
          }
          const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
          return original.call(this, ns, cmd, options, patchedCallback);
        };
      };
    }
    _getV4PatchCommandPromise() {
      const instrumentation = this;
      return (original) => {
        return function patchedV4ServerCommand(...args) {
          const [ns, cmd] = args;
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const commandType = Object.keys(cmd)[0];
          const resultHandler = () => {
            return;
          };
          if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
            return original.apply(this, args);
          }
          let span = undefined;
          if (currentSpan) {
            span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
          }
          const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
          const result = original.apply(this, args);
          result.then((res) => patchedCallback(null, res), (err) => patchedCallback(err));
          return result;
        };
      };
    }
    _getV3PatchFind() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cmd, cursorState, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const resultHandler = typeof options === "function" ? options : callback;
          if (!currentSpan || typeof resultHandler !== "function" || typeof cmd !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, cursorState, options);
            } else {
              return original.call(this, server, ns, cmd, cursorState, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan("mongodb.find", {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, cmd, "find");
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cmd, cursorState, patchedCallback);
          } else {
            return original.call(this, server, ns, cmd, cursorState, options, patchedCallback);
          }
        };
      };
    }
    _getV3PatchCursor() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cursorState, batchSize, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const resultHandler = typeof options === "function" ? options : callback;
          if (!currentSpan || typeof resultHandler !== "function") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cursorState, batchSize, options);
            } else {
              return original.call(this, server, ns, cursorState, batchSize, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan("mongodb.getMore", {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, cursorState.cmd, "getMore");
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cursorState, batchSize, patchedCallback);
          } else {
            return original.call(this, server, ns, cursorState, batchSize, options, patchedCallback);
          }
        };
      };
    }
    static _getCommandType(command) {
      if (command.createIndexes !== undefined) {
        return internal_types_1.MongodbCommandType.CREATE_INDEXES;
      } else if (command.findandmodify !== undefined) {
        return internal_types_1.MongodbCommandType.FIND_AND_MODIFY;
      } else if (command.ismaster !== undefined) {
        return internal_types_1.MongodbCommandType.IS_MASTER;
      } else if (command.count !== undefined) {
        return internal_types_1.MongodbCommandType.COUNT;
      } else if (command.aggregate !== undefined) {
        return internal_types_1.MongodbCommandType.AGGREGATE;
      } else {
        return internal_types_1.MongodbCommandType.UNKNOWN;
      }
    }
    _populateV4Attributes(span, connectionCtx, ns, command, operation) {
      let host, port;
      if (connectionCtx) {
        const hostParts = typeof connectionCtx.address === "string" ? connectionCtx.address.split(":") : "";
        if (hostParts.length === 2) {
          host = hostParts[0];
          port = hostParts[1];
        }
      }
      let commandObj;
      if ((command === null || command === undefined ? undefined : command.documents) && command.documents[0]) {
        commandObj = command.documents[0];
      } else if (command === null || command === undefined ? undefined : command.cursors) {
        commandObj = command.cursors;
      } else {
        commandObj = command;
      }
      this._addAllSpanAttributes(span, ns.db, ns.collection, host, port, commandObj, operation);
    }
    _populateV3Attributes(span, ns, topology, command, operation) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      let host;
      let port;
      if (topology && topology.s) {
        host = (_b = (_a2 = topology.s.options) === null || _a2 === undefined ? undefined : _a2.host) !== null && _b !== undefined ? _b : topology.s.host;
        port = (_e = (_d = (_c = topology.s.options) === null || _c === undefined ? undefined : _c.port) !== null && _d !== undefined ? _d : topology.s.port) === null || _e === undefined ? undefined : _e.toString();
        if (host == null || port == null) {
          const address = (_f = topology.description) === null || _f === undefined ? undefined : _f.address;
          if (address) {
            const addressSegments = address.split(":");
            host = addressSegments[0];
            port = addressSegments[1];
          }
        }
      }
      const [dbName, dbCollection] = ns.toString().split(".");
      const commandObj = (_h = (_g = command === null || command === undefined ? undefined : command.query) !== null && _g !== undefined ? _g : command === null || command === undefined ? undefined : command.q) !== null && _h !== undefined ? _h : command;
      this._addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation);
    }
    _addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation) {
      span.setAttributes({
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MONGODB,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: dbName,
        [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: dbCollection,
        [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `mongodb://${host}:${port}/${dbName}`
      });
      if (host && port) {
        span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_NAME, host);
        const portNumber = parseInt(port, 10);
        if (!isNaN(portNumber)) {
          span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_PORT, portNumber);
        }
      }
      if (!commandObj)
        return;
      const { dbStatementSerializer: configDbStatementSerializer } = this.getConfig();
      const dbStatementSerializer = typeof configDbStatementSerializer === "function" ? configDbStatementSerializer : this._defaultDbStatementSerializer.bind(this);
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        const query = dbStatementSerializer(commandObj);
        span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, query);
      }, (err) => {
        if (err) {
          this._diag.error("Error running dbStatementSerializer hook", err);
        }
      }, true);
    }
    _defaultDbStatementSerializer(commandObj) {
      const { enhancedDatabaseReporting } = this.getConfig();
      const resultObj = enhancedDatabaseReporting ? commandObj : this._scrubStatement(commandObj);
      return JSON.stringify(resultObj);
    }
    _scrubStatement(value) {
      if (Array.isArray(value)) {
        return value.map((element) => this._scrubStatement(element));
      }
      if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([key, element]) => [
          key,
          this._scrubStatement(element)
        ]));
      }
      return "?";
    }
    _handleExecutionResult(span, result) {
      const { responseHook } = this.getConfig();
      if (typeof responseHook === "function") {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          responseHook(span, { data: result });
        }, (err) => {
          if (err) {
            this._diag.error("Error running response hook", err);
          }
        }, true);
      }
    }
    _patchEnd(span, resultHandler, connectionId, commandType) {
      const activeContext = api_1.context.active();
      const instrumentation = this;
      return function patchedEnd(...args) {
        const error = args[0];
        if (span) {
          if (error instanceof Error) {
            span === null || span === undefined || span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error.message
            });
          } else {
            const result = args[1];
            instrumentation._handleExecutionResult(span, result);
          }
          span.end();
        }
        return api_1.context.with(activeContext, () => {
          if (commandType === "endSessions") {
            instrumentation._connectionsUsage.add(-1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
          }
          return resultHandler.apply(this, args);
        });
      };
    }
    setPoolName(options) {
      var _a2, _b;
      const host = (_a2 = options.hostAddress) === null || _a2 === undefined ? undefined : _a2.host;
      const port = (_b = options.hostAddress) === null || _b === undefined ? undefined : _b.port;
      const database = options.dbName;
      const poolName = `mongodb://${host}:${port}/${database}`;
      this._poolName = poolName;
    }
  }
  exports.MongoDBInstrumentation = MongoDBInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js
var require_types7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongodbCommandType = undefined;
  var MongodbCommandType;
  (function(MongodbCommandType2) {
    MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
    MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
    MongodbCommandType2["IS_MASTER"] = "isMaster";
    MongodbCommandType2["COUNT"] = "count";
    MongodbCommandType2["UNKNOWN"] = "unknown";
  })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
});

// ../node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js
var require_src13 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation7(), exports);
  __exportStar(require_types7(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js
var require_utils10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleCallbackResponse = exports.handlePromiseResponse = exports.getAttributesFromCollection = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  function getAttributesFromCollection(collection) {
    return {
      [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: collection.name,
      [semantic_conventions_1.SEMATTRS_DB_NAME]: collection.conn.name,
      [semantic_conventions_1.SEMATTRS_DB_USER]: collection.conn.user,
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: collection.conn.host,
      [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: collection.conn.port
    };
  }
  exports.getAttributesFromCollection = getAttributesFromCollection;
  function setErrorStatus(span, error = {}) {
    span.recordException(error);
    span.setStatus({
      code: api_1.SpanStatusCode.ERROR,
      message: `${error.message} ${error.code ? `\nMongoose Error Code: ${error.code}` : ""}`
    });
  }
  function applyResponseHook(span, response, responseHook, moduleVersion = undefined) {
    if (!responseHook) {
      return;
    }
    (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(span, { moduleVersion, response }), (e) => {
      if (e) {
        api_1.diag.error("mongoose instrumentation: responseHook error", e);
      }
    }, true);
  }
  function handlePromiseResponse(execResponse, span, responseHook, moduleVersion = undefined) {
    if (!(execResponse instanceof Promise)) {
      applyResponseHook(span, execResponse, responseHook, moduleVersion);
      span.end();
      return execResponse;
    }
    return execResponse.then((response) => {
      applyResponseHook(span, response, responseHook, moduleVersion);
      return response;
    }).catch((err) => {
      setErrorStatus(span, err);
      throw err;
    }).finally(() => span.end());
  }
  exports.handlePromiseResponse = handlePromiseResponse;
  function handleCallbackResponse(callback, exec, originalThis, span, args, responseHook, moduleVersion = undefined) {
    let callbackArgumentIndex = 0;
    if (args.length === 2) {
      callbackArgumentIndex = 1;
    }
    args[callbackArgumentIndex] = (err, response) => {
      err ? setErrorStatus(span, err) : applyResponseHook(span, response, responseHook, moduleVersion);
      span.end();
      return callback(err, response);
    };
    return exec.apply(originalThis, args);
  }
  exports.handleCallbackResponse = handleCallbackResponse;
});

// ../node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js
var require_version10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.42.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongoose";
});

// ../node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js
var require_mongoose = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongooseInstrumentation = exports._STORED_PARENT_SPAN = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var utils_1 = require_utils10();
  var instrumentation_1 = require_src6();
  var version_1 = require_version10();
  var semantic_conventions_1 = require_src2();
  var contextCaptureFunctionsCommon = [
    "deleteOne",
    "deleteMany",
    "find",
    "findOne",
    "estimatedDocumentCount",
    "countDocuments",
    "distinct",
    "where",
    "$where",
    "findOneAndUpdate",
    "findOneAndDelete",
    "findOneAndReplace"
  ];
  var contextCaptureFunctions6 = [
    "remove",
    "count",
    "findOneAndRemove",
    ...contextCaptureFunctionsCommon
  ];
  var contextCaptureFunctions7 = [
    "count",
    "findOneAndRemove",
    ...contextCaptureFunctionsCommon
  ];
  var contextCaptureFunctions8 = [...contextCaptureFunctionsCommon];
  function getContextCaptureFunctions(moduleVersion) {
    if (!moduleVersion) {
      return contextCaptureFunctionsCommon;
    } else if (moduleVersion.startsWith("6.") || moduleVersion.startsWith("5.")) {
      return contextCaptureFunctions6;
    } else if (moduleVersion.startsWith("7.")) {
      return contextCaptureFunctions7;
    } else {
      return contextCaptureFunctions8;
    }
  }
  function instrumentRemove(moduleVersion) {
    return moduleVersion && (moduleVersion.startsWith("5.") || moduleVersion.startsWith("6.")) || false;
  }
  exports._STORED_PARENT_SPAN = Symbol("stored-parent-span");

  class MongooseInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("mongoose", [">=5.9.7 <9"], this.patch.bind(this), this.unpatch.bind(this));
      return module2;
    }
    patch(moduleExports, moduleVersion) {
      this._wrap(moduleExports.Model.prototype, "save", this.patchOnModelMethods("save", moduleVersion));
      moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
      if (instrumentRemove(moduleVersion)) {
        this._wrap(moduleExports.Model.prototype, "remove", this.patchOnModelMethods("remove", moduleVersion));
      }
      this._wrap(moduleExports.Query.prototype, "exec", this.patchQueryExec(moduleVersion));
      this._wrap(moduleExports.Aggregate.prototype, "exec", this.patchAggregateExec(moduleVersion));
      const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
      contextCaptureFunctions.forEach((funcName) => {
        this._wrap(moduleExports.Query.prototype, funcName, this.patchAndCaptureSpanContext(funcName));
      });
      this._wrap(moduleExports.Model, "aggregate", this.patchModelAggregate());
      return moduleExports;
    }
    unpatch(moduleExports, moduleVersion) {
      const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
      this._unwrap(moduleExports.Model.prototype, "save");
      moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
      if (instrumentRemove(moduleVersion)) {
        this._unwrap(moduleExports.Model.prototype, "remove");
      }
      this._unwrap(moduleExports.Query.prototype, "exec");
      this._unwrap(moduleExports.Aggregate.prototype, "exec");
      contextCaptureFunctions.forEach((funcName) => {
        this._unwrap(moduleExports.Query.prototype, funcName);
      });
      this._unwrap(moduleExports.Model, "aggregate");
    }
    patchAggregateExec(moduleVersion) {
      const self2 = this;
      return (originalAggregate) => {
        return function exec(callback) {
          var _a2;
          if (self2.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalAggregate.apply(this, arguments);
          }
          const parentSpan = this[exports._STORED_PARENT_SPAN];
          const attributes = {};
          const { dbStatementSerializer } = self2.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer("aggregate", {
              options: this.options,
              aggregatePipeline: this._pipeline
            });
          }
          const span = self2._startSpan(this._model.collection, (_a2 = this._model) === null || _a2 === undefined ? undefined : _a2.modelName, "aggregate", attributes, parentSpan);
          return self2._handleResponse(span, originalAggregate, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchQueryExec(moduleVersion) {
      const self2 = this;
      return (originalExec) => {
        return function exec(callback) {
          if (self2.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalExec.apply(this, arguments);
          }
          const parentSpan = this[exports._STORED_PARENT_SPAN];
          const attributes = {};
          const { dbStatementSerializer } = self2.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(this.op, {
              condition: this._conditions,
              updates: this._update,
              options: this.options,
              fields: this._fields
            });
          }
          const span = self2._startSpan(this.mongooseCollection, this.model.modelName, this.op, attributes, parentSpan);
          return self2._handleResponse(span, originalExec, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchOnModelMethods(op, moduleVersion) {
      const self2 = this;
      return (originalOnModelFunction) => {
        return function method(options, callback) {
          if (self2.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalOnModelFunction.apply(this, arguments);
          }
          const serializePayload = { document: this };
          if (options && !(options instanceof Function)) {
            serializePayload.options = options;
          }
          const attributes = {};
          const { dbStatementSerializer } = self2.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(op, serializePayload);
          }
          const span = self2._startSpan(this.constructor.collection, this.constructor.modelName, op, attributes);
          if (options instanceof Function) {
            callback = options;
            options = undefined;
          }
          return self2._handleResponse(span, originalOnModelFunction, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchModelAggregate() {
      const self2 = this;
      return (original) => {
        return function captureSpanContext() {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const aggregate = self2._callOriginalFunction(() => original.apply(this, arguments));
          if (aggregate)
            aggregate[exports._STORED_PARENT_SPAN] = currentSpan;
          return aggregate;
        };
      };
    }
    patchAndCaptureSpanContext(funcName) {
      const self2 = this;
      return (original) => {
        return function captureSpanContext() {
          this[exports._STORED_PARENT_SPAN] = api_1.trace.getSpan(api_1.context.active());
          return self2._callOriginalFunction(() => original.apply(this, arguments));
        };
      };
    }
    _startSpan(collection, modelName, operation, attributes, parentSpan) {
      return this.tracer.startSpan(`mongoose.${modelName}.${operation}`, {
        kind: api_1.SpanKind.CLIENT,
        attributes: Object.assign(Object.assign(Object.assign({}, attributes), (0, utils_1.getAttributesFromCollection)(collection)), { [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation, [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: "mongoose" })
      }, parentSpan ? api_1.trace.setSpan(api_1.context.active(), parentSpan) : undefined);
    }
    _handleResponse(span, exec, originalThis, args, callback, moduleVersion = undefined) {
      const self2 = this;
      if (callback instanceof Function) {
        return self2._callOriginalFunction(() => (0, utils_1.handleCallbackResponse)(callback, exec, originalThis, span, args, self2.getConfig().responseHook, moduleVersion));
      } else {
        const response = self2._callOriginalFunction(() => exec.apply(originalThis, args));
        return (0, utils_1.handlePromiseResponse)(response, span, self2.getConfig().responseHook, moduleVersion);
      }
    }
    _callOriginalFunction(originalFunction) {
      if (this.getConfig().suppressInternalInstrumentation) {
        return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), originalFunction);
      } else {
        return originalFunction();
      }
    }
  }
  exports.MongooseInstrumentation = MongooseInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-mongoose/build/src/types.js
var require_types8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js
var require_src14 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mongoose(), exports);
  __exportStar(require_types8(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js
var require_AttributeNames5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["MYSQL_VALUES"] = "db.mysql.values";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js
var require_utils11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPoolName = exports.arrayStringifyHelper = exports.getSpanName = exports.getDbValues = exports.getDbStatement = exports.getConnectionAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  function getConnectionAttributes(config) {
    const { host, port, database, user } = getConfig(config);
    const portNumber = parseInt(port, 10);
    if (!isNaN(portNumber)) {
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    return {
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
      [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
      [semantic_conventions_1.SEMATTRS_DB_USER]: user
    };
  }
  exports.getConnectionAttributes = getConnectionAttributes;
  function getConfig(config) {
    const { host, port, database, user } = config && config.connectionConfig || config || {};
    return { host, port, database, user };
  }
  function getJDBCString(host, port, database) {
    let jdbcString = `jdbc:mysql://${host || "localhost"}`;
    if (typeof port === "number") {
      jdbcString += `:${port}`;
    }
    if (typeof database === "string") {
      jdbcString += `/${database}`;
    }
    return jdbcString;
  }
  function getDbStatement(query) {
    if (typeof query === "string") {
      return query;
    } else {
      return query.sql;
    }
  }
  exports.getDbStatement = getDbStatement;
  function getDbValues(query, values) {
    if (typeof query === "string") {
      return arrayStringifyHelper(values);
    } else {
      return arrayStringifyHelper(values || query.values);
    }
  }
  exports.getDbValues = getDbValues;
  function getSpanName(query) {
    if (typeof query === "object") {
      return query.sql;
    }
    return query.split(" ")[0];
  }
  exports.getSpanName = getSpanName;
  function arrayStringifyHelper(arr) {
    if (arr)
      return `[${arr.toString()}]`;
    return "";
  }
  exports.arrayStringifyHelper = arrayStringifyHelper;
  function getPoolName(pool) {
    const c = pool.config.connectionConfig;
    let poolName = "";
    poolName += c.host ? `host: '${c.host}', ` : "";
    poolName += c.port ? `port: ${c.port}, ` : "";
    poolName += c.database ? `database: '${c.database}', ` : "";
    poolName += c.user ? `user: '${c.user}'` : "";
    if (!c.user) {
      poolName = poolName.substring(0, poolName.length - 2);
    }
    return poolName.trim();
  }
  exports.getPoolName = getPoolName;
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js
var require_version11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.41.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql";
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js
var require_instrumentation8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQLInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var AttributeNames_1 = require_AttributeNames5();
  var utils_1 = require_utils11();
  var version_1 = require_version11();

  class MySQLInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._setMetricInstruments();
    }
    setMeterProvider(meterProvider) {
      super.setMeterProvider(meterProvider);
      this._setMetricInstruments();
    }
    _setMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
        description: "The number of connections that are currently in state described by the state attribute.",
        unit: "{connection}"
      });
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mysql", [">=2.0.0 <3"], (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.createConnection)) {
            this._unwrap(moduleExports, "createConnection");
          }
          this._wrap(moduleExports, "createConnection", this._patchCreateConnection());
          if ((0, instrumentation_1.isWrapped)(moduleExports.createPool)) {
            this._unwrap(moduleExports, "createPool");
          }
          this._wrap(moduleExports, "createPool", this._patchCreatePool());
          if ((0, instrumentation_1.isWrapped)(moduleExports.createPoolCluster)) {
            this._unwrap(moduleExports, "createPoolCluster");
          }
          this._wrap(moduleExports, "createPoolCluster", this._patchCreatePoolCluster());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "createConnection");
          this._unwrap(moduleExports, "createPool");
          this._unwrap(moduleExports, "createPoolCluster");
        })
      ];
    }
    _patchCreateConnection() {
      return (originalCreateConnection) => {
        const thisPlugin = this;
        return function createConnection(_connectionUri) {
          const originalResult = originalCreateConnection(...arguments);
          thisPlugin._wrap(originalResult, "query", thisPlugin._patchQuery(originalResult));
          return originalResult;
        };
      };
    }
    _patchCreatePool() {
      return (originalCreatePool) => {
        const thisPlugin = this;
        return function createPool(_config) {
          const pool = originalCreatePool(...arguments);
          thisPlugin._wrap(pool, "query", thisPlugin._patchQuery(pool));
          thisPlugin._wrap(pool, "getConnection", thisPlugin._patchGetConnection(pool));
          thisPlugin._wrap(pool, "end", thisPlugin._patchPoolEnd(pool));
          thisPlugin._setPoolcallbacks(pool, thisPlugin, "");
          return pool;
        };
      };
    }
    _patchPoolEnd(pool) {
      return (originalPoolEnd) => {
        const thisPlugin = this;
        return function end(callback) {
          const nAll = pool._allConnections.length;
          const nFree = pool._freeConnections.length;
          const nUsed = nAll - nFree;
          const poolName = (0, utils_1.getPoolName)(pool);
          thisPlugin._connectionsUsage.add(-nUsed, {
            state: "used",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(-nFree, {
            state: "idle",
            name: poolName
          });
          originalPoolEnd.apply(pool, arguments);
        };
      };
    }
    _patchCreatePoolCluster() {
      return (originalCreatePoolCluster) => {
        const thisPlugin = this;
        return function createPool(_config) {
          const cluster = originalCreatePoolCluster(...arguments);
          thisPlugin._wrap(cluster, "getConnection", thisPlugin._patchGetConnection(cluster));
          thisPlugin._wrap(cluster, "add", thisPlugin._patchAdd(cluster));
          return cluster;
        };
      };
    }
    _patchAdd(cluster) {
      return (originalAdd) => {
        const thisPlugin = this;
        return function add(id, config) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(cluster, "add");
            return originalAdd.apply(cluster, arguments);
          }
          originalAdd.apply(cluster, arguments);
          const nodes = cluster["_nodes"];
          if (nodes) {
            const nodeId = typeof id === "object" ? "CLUSTER::" + cluster._lastId : String(id);
            const pool = nodes[nodeId].pool;
            thisPlugin._setPoolcallbacks(pool, thisPlugin, id);
          }
        };
      };
    }
    _patchGetConnection(pool) {
      return (originalGetConnection) => {
        const thisPlugin = this;
        return function getConnection(arg1, arg2, arg3) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(pool, "getConnection");
            return originalGetConnection.apply(pool, arguments);
          }
          if (arguments.length === 1 && typeof arg1 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg1);
            return originalGetConnection.call(pool, patchFn);
          }
          if (arguments.length === 2 && typeof arg2 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg2);
            return originalGetConnection.call(pool, arg1, patchFn);
          }
          if (arguments.length === 3 && typeof arg3 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg3);
            return originalGetConnection.call(pool, arg1, arg2, patchFn);
          }
          return originalGetConnection.apply(pool, arguments);
        };
      };
    }
    _getConnectionCallbackPatchFn(cb) {
      const thisPlugin = this;
      const activeContext = api_1.context.active();
      return function(err, connection) {
        if (connection) {
          if (!(0, instrumentation_1.isWrapped)(connection.query)) {
            thisPlugin._wrap(connection, "query", thisPlugin._patchQuery(connection));
          }
        }
        if (typeof cb === "function") {
          api_1.context.with(activeContext, cb, this, err, connection);
        }
      };
    }
    _patchQuery(connection) {
      return (originalQuery) => {
        const thisPlugin = this;
        return function query(query, _valuesOrCallback, _callback) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(connection, "query");
            return originalQuery.apply(connection, arguments);
          }
          const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
            kind: api_1.SpanKind.CLIENT,
            attributes: Object.assign(Object.assign({}, MySQLInstrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(connection.config))
          });
          span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, (0, utils_1.getDbStatement)(query));
          if (thisPlugin.getConfig().enhancedDatabaseReporting) {
            let values;
            if (Array.isArray(_valuesOrCallback)) {
              values = _valuesOrCallback;
            } else if (arguments[2]) {
              values = [_valuesOrCallback];
            }
            span.setAttribute(AttributeNames_1.AttributeNames.MYSQL_VALUES, (0, utils_1.getDbValues)(query, values));
          }
          const cbIndex = Array.from(arguments).findIndex((arg) => typeof arg === "function");
          const parentContext = api_1.context.active();
          if (cbIndex === -1) {
            const streamableQuery = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalQuery.apply(connection, arguments);
            });
            api_1.context.bind(parentContext, streamableQuery);
            return streamableQuery.on("error", (err) => span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err.message
            })).on("end", () => {
              span.end();
            });
          } else {
            thisPlugin._wrap(arguments, cbIndex, thisPlugin._patchCallbackQuery(span, parentContext));
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalQuery.apply(connection, arguments);
            });
          }
        };
      };
    }
    _patchCallbackQuery(span, parentContext) {
      return (originalCallback) => {
        return function(err, results, fields) {
          if (err) {
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err.message
            });
          }
          span.end();
          return api_1.context.with(parentContext, () => originalCallback(...arguments));
        };
      };
    }
    _setPoolcallbacks(pool, thisPlugin, id) {
      const poolName = id || (0, utils_1.getPoolName)(pool);
      pool.on("connection", (connection) => {
        thisPlugin._connectionsUsage.add(1, {
          state: "idle",
          name: poolName
        });
      });
      pool.on("acquire", (connection) => {
        thisPlugin._connectionsUsage.add(-1, {
          state: "idle",
          name: poolName
        });
        thisPlugin._connectionsUsage.add(1, {
          state: "used",
          name: poolName
        });
      });
      pool.on("release", (connection) => {
        thisPlugin._connectionsUsage.add(-1, {
          state: "used",
          name: poolName
        });
        thisPlugin._connectionsUsage.add(1, {
          state: "idle",
          name: poolName
        });
      });
    }
  }
  exports.MySQLInstrumentation = MySQLInstrumentation;
  MySQLInstrumentation.COMMON_ATTRIBUTES = {
    [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
  };
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/types.js
var require_types9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js
var require_src15 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation8(), exports);
  __exportStar(require_types9(), exports);
});

// ../node_modules/@opentelemetry/sql-common/build/src/index.js
var require_src16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addSqlCommenterComment = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  function hasValidSqlComment(query) {
    const indexOpeningDashDashComment = query.indexOf("--");
    if (indexOpeningDashDashComment >= 0) {
      return true;
    }
    const indexOpeningSlashComment = query.indexOf("/*");
    if (indexOpeningSlashComment < 0) {
      return false;
    }
    const indexClosingSlashComment = query.indexOf("*/");
    return indexOpeningDashDashComment < indexClosingSlashComment;
  }
  function fixedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  }
  function addSqlCommenterComment(span, query) {
    if (typeof query !== "string" || query.length === 0) {
      return query;
    }
    if (hasValidSqlComment(query)) {
      return query;
    }
    const propagator = new core_1.W3CTraceContextPropagator;
    const headers = {};
    propagator.inject(api_1.trace.setSpan(api_1.ROOT_CONTEXT, span), headers, api_1.defaultTextMapSetter);
    const sortedKeys = Object.keys(headers).sort();
    if (sortedKeys.length === 0) {
      return query;
    }
    const commentString = sortedKeys.map((key) => {
      const encodedValue = fixedEncodeURIComponent(headers[key]);
      return `${key}='${encodedValue}'`;
    }).join(",");
    return `${query} /*${commentString}*/`;
  }
  exports.addSqlCommenterComment = addSqlCommenterComment;
});

// ../node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js
var require_utils12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.once = exports.getSpanName = exports.getDbStatement = exports.getConnectionAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  function getConnectionAttributes(config) {
    const { host, port, database, user } = getConfig(config);
    const portNumber = parseInt(port, 10);
    if (!isNaN(portNumber)) {
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    return {
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
      [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
      [semantic_conventions_1.SEMATTRS_DB_USER]: user
    };
  }
  exports.getConnectionAttributes = getConnectionAttributes;
  function getConfig(config) {
    const { host, port, database, user } = config && config.connectionConfig || config || {};
    return { host, port, database, user };
  }
  function getJDBCString(host, port, database) {
    let jdbcString = `jdbc:mysql://${host || "localhost"}`;
    if (typeof port === "number") {
      jdbcString += `:${port}`;
    }
    if (typeof database === "string") {
      jdbcString += `/${database}`;
    }
    return jdbcString;
  }
  function getDbStatement(query, format2, values) {
    if (typeof query === "string") {
      return values ? format2(query, values) : query;
    } else {
      return values || query.values ? format2(query.sql, values || query.values) : query.sql;
    }
  }
  exports.getDbStatement = getDbStatement;
  function getSpanName(query) {
    var _a2;
    const rawQuery = typeof query === "object" ? query.sql : query;
    return (_a2 = rawQuery === null || rawQuery === undefined ? undefined : rawQuery.split(" ")) === null || _a2 === undefined ? undefined : _a2[0];
  }
  exports.getSpanName = getSpanName;
  var once = (fn) => {
    let called = false;
    return (...args) => {
      if (called)
        return;
      called = true;
      return fn(...args);
    };
  };
  exports.once = once;
});

// ../node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js
var require_version12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.41.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql2";
});

// ../node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js
var require_instrumentation9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQL2Instrumentation = undefined;
  var api3 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var sql_common_1 = require_src16();
  var utils_1 = require_utils12();
  var version_1 = require_version12();

  class MySQL2Instrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mysql2", [">=1.4.2 <4"], (moduleExports) => {
          const ConnectionPrototype = moduleExports.Connection.prototype;
          if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.query)) {
            this._unwrap(ConnectionPrototype, "query");
          }
          this._wrap(ConnectionPrototype, "query", this._patchQuery(moduleExports.format, false));
          if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.execute)) {
            this._unwrap(ConnectionPrototype, "execute");
          }
          this._wrap(ConnectionPrototype, "execute", this._patchQuery(moduleExports.format, true));
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          const ConnectionPrototype = moduleExports.Connection.prototype;
          this._unwrap(ConnectionPrototype, "query");
          this._unwrap(ConnectionPrototype, "execute");
        })
      ];
    }
    _patchQuery(format2, isPrepared) {
      return (originalQuery) => {
        const thisPlugin = this;
        return function query(query, _valuesOrCallback, _callback) {
          let values;
          if (Array.isArray(_valuesOrCallback)) {
            values = _valuesOrCallback;
          } else if (arguments[2]) {
            values = [_valuesOrCallback];
          }
          const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
            kind: api3.SpanKind.CLIENT,
            attributes: Object.assign(Object.assign(Object.assign({}, MySQL2Instrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(this.config)), { [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: (0, utils_1.getDbStatement)(query, format2, values) })
          });
          if (!isPrepared && thisPlugin.getConfig().addSqlCommenterCommentToQueries) {
            arguments[0] = query = typeof query === "string" ? (0, sql_common_1.addSqlCommenterComment)(span, query) : Object.assign(query, {
              sql: (0, sql_common_1.addSqlCommenterComment)(span, query.sql)
            });
          }
          const endSpan = (0, utils_1.once)((err, results) => {
            if (err) {
              span.setStatus({
                code: api3.SpanStatusCode.ERROR,
                message: err.message
              });
            } else {
              const { responseHook } = thisPlugin.getConfig();
              if (typeof responseHook === "function") {
                (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                  responseHook(span, {
                    queryResults: results
                  });
                }, (err2) => {
                  if (err2) {
                    thisPlugin._diag.warn("Failed executing responseHook", err2);
                  }
                }, true);
              }
            }
            span.end();
          });
          if (arguments.length === 1) {
            if (typeof query.onResult === "function") {
              thisPlugin._wrap(query, "onResult", thisPlugin._patchCallbackQuery(endSpan));
            }
            const streamableQuery = originalQuery.apply(this, arguments);
            streamableQuery.once("error", (err) => {
              endSpan(err);
            }).once("result", (results) => {
              endSpan(undefined, results);
            });
            return streamableQuery;
          }
          if (typeof arguments[1] === "function") {
            thisPlugin._wrap(arguments, 1, thisPlugin._patchCallbackQuery(endSpan));
          } else if (typeof arguments[2] === "function") {
            thisPlugin._wrap(arguments, 2, thisPlugin._patchCallbackQuery(endSpan));
          }
          return originalQuery.apply(this, arguments);
        };
      };
    }
    _patchCallbackQuery(endSpan) {
      return (originalCallback) => {
        return function(err, results, fields) {
          endSpan(err, results);
          return originalCallback(...arguments);
        };
      };
    }
  }
  exports.MySQL2Instrumentation = MySQL2Instrumentation;
  MySQL2Instrumentation.COMMON_ATTRIBUTES = {
    [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
  };
});

// ../node_modules/@opentelemetry/instrumentation-mysql2/build/src/types.js
var require_types10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js
var require_src17 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation9(), exports);
  __exportStar(require_types10(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js
var require_utils13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endSpan = undefined;
  var api_1 = require_src();
  var endSpan = (span, err) => {
    if (err) {
      span.recordException(err);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: err.message
      });
    }
    span.end();
  };
  exports.endSpan = endSpan;
});

// ../node_modules/@opentelemetry/redis-common/build/src/index.js
var require_src18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultDbStatementSerializer = undefined;
  var serializationSubsets = [
    {
      regex: /^ECHO/i,
      args: 0
    },
    {
      regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
      args: 1
    },
    {
      regex: /^(HSET|HMSET|LSET|LINSERT)/i,
      args: 2
    },
    {
      regex: /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
      args: -1
    }
  ];
  var defaultDbStatementSerializer = (cmdName, cmdArgs) => {
    var _a2, _b;
    if (Array.isArray(cmdArgs) && cmdArgs.length) {
      const nArgsToSerialize = (_b = (_a2 = serializationSubsets.find(({ regex }) => {
        return regex.test(cmdName);
      })) === null || _a2 === undefined ? undefined : _a2.args) !== null && _b !== undefined ? _b : 0;
      const argsToSerialize = nArgsToSerialize >= 0 ? cmdArgs.slice(0, nArgsToSerialize) : cmdArgs;
      if (cmdArgs.length > argsToSerialize.length) {
        argsToSerialize.push(`[${cmdArgs.length - nArgsToSerialize} other arguments]`);
      }
      return `${cmdName} ${argsToSerialize.join(" ")}`;
    }
    return cmdName;
  };
  exports.defaultDbStatementSerializer = defaultDbStatementSerializer;
});

// ../node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js
var require_version13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.43.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-ioredis";
});

// ../node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js
var require_instrumentation10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IORedisInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var instrumentation_2 = require_src6();
  var utils_1 = require_utils13();
  var redis_common_1 = require_src18();
  var version_1 = require_version13();
  var DEFAULT_CONFIG = {
    requireParentSpan: true
  };

  class IORedisInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    setConfig(config = {}) {
      super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("ioredis", [">=2.0.0 <6"], (module2, moduleVersion) => {
          const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.sendCommand)) {
            this._unwrap(moduleExports.prototype, "sendCommand");
          }
          this._wrap(moduleExports.prototype, "sendCommand", this._patchSendCommand(moduleVersion));
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
          this._wrap(moduleExports.prototype, "connect", this._patchConnection());
          return module2;
        }, (module2) => {
          if (module2 === undefined)
            return;
          const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
          this._unwrap(moduleExports.prototype, "sendCommand");
          this._unwrap(moduleExports.prototype, "connect");
        })
      ];
    }
    _patchSendCommand(moduleVersion) {
      return (original) => {
        return this._traceSendCommand(original, moduleVersion);
      };
    }
    _patchConnection() {
      return (original) => {
        return this._traceConnection(original);
      };
    }
    _traceSendCommand(original, moduleVersion) {
      const instrumentation = this;
      return function(cmd) {
        if (arguments.length < 1 || typeof cmd !== "object") {
          return original.apply(this, arguments);
        }
        const config = instrumentation.getConfig();
        const dbStatementSerializer = config.dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
        if (config.requireParentSpan === true && hasNoParentSpan) {
          return original.apply(this, arguments);
        }
        const span = instrumentation.tracer.startSpan(cmd.name, {
          kind: api_1.SpanKind.CLIENT,
          attributes: {
            [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
            [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args)
          }
        });
        const { requestHook } = config;
        if (requestHook) {
          (0, instrumentation_2.safeExecuteInTheMiddle)(() => requestHook(span, {
            moduleVersion,
            cmdName: cmd.name,
            cmdArgs: cmd.args
          }), (e) => {
            if (e) {
              api_1.diag.error("ioredis instrumentation: request hook failed", e);
            }
          }, true);
        }
        const { host, port } = this.options;
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
        });
        try {
          const result = original.apply(this, arguments);
          const origResolve = cmd.resolve;
          cmd.resolve = function(result2) {
            (0, instrumentation_2.safeExecuteInTheMiddle)(() => {
              var _a2;
              return (_a2 = config.responseHook) === null || _a2 === undefined ? undefined : _a2.call(config, span, cmd.name, cmd.args, result2);
            }, (e) => {
              if (e) {
                api_1.diag.error("ioredis instrumentation: response hook failed", e);
              }
            }, true);
            (0, utils_1.endSpan)(span, null);
            origResolve(result2);
          };
          const origReject = cmd.reject;
          cmd.reject = function(err) {
            (0, utils_1.endSpan)(span, err);
            origReject(err);
          };
          return result;
        } catch (error) {
          (0, utils_1.endSpan)(span, error);
          throw error;
        }
      };
    }
    _traceConnection(original) {
      const instrumentation = this;
      return function() {
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
        if (instrumentation.getConfig().requireParentSpan === true && hasNoParentSpan) {
          return original.apply(this, arguments);
        }
        const span = instrumentation.tracer.startSpan("connect", {
          kind: api_1.SpanKind.CLIENT,
          attributes: {
            [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
            [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: "connect"
          }
        });
        const { host, port } = this.options;
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
        });
        try {
          const client = original.apply(this, arguments);
          (0, utils_1.endSpan)(span, null);
          return client;
        } catch (error) {
          (0, utils_1.endSpan)(span, error);
          throw error;
        }
      };
    }
  }
  exports.IORedisInstrumentation = IORedisInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-ioredis/build/src/types.js
var require_types11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js
var require_src19 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation10(), exports);
  __exportStar(require_types11(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-redis-4/build/src/utils.js
var require_utils14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getClientAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  function getClientAttributes(diag13, options) {
    var _a2, _b;
    return {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: (_a2 = options === null || options === undefined ? undefined : options.socket) === null || _a2 === undefined ? undefined : _a2.host,
      [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: (_b = options === null || options === undefined ? undefined : options.socket) === null || _b === undefined ? undefined : _b.port,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: removeCredentialsFromDBConnectionStringAttribute(diag13, options === null || options === undefined ? undefined : options.url)
    };
  }
  exports.getClientAttributes = getClientAttributes;
  function removeCredentialsFromDBConnectionStringAttribute(diag13, url) {
    if (typeof url !== "string") {
      return;
    }
    try {
      const u = new URL(url);
      u.searchParams.delete("user_pwd");
      u.username = "";
      u.password = "";
      return u.href;
    } catch (err) {
      diag13.error("failed to sanitize redis connection url", err);
    }
    return;
  }
});

// ../node_modules/@opentelemetry/instrumentation-redis-4/build/src/version.js
var require_version14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.42.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-redis-4";
});

// ../node_modules/@opentelemetry/instrumentation-redis-4/build/src/instrumentation.js
var require_instrumentation11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var utils_1 = require_utils14();
  var redis_common_1 = require_src18();
  var version_1 = require_version14();
  var semantic_conventions_1 = require_src2();
  var OTEL_OPEN_SPANS = Symbol("opentelemetry.instrumentation.redis.open_spans");
  var MULTI_COMMAND_OPTIONS = Symbol("opentelemetry.instrumentation.redis.multi_command_options");
  var DEFAULT_CONFIG = {
    requireParentSpan: false
  };

  class RedisInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    setConfig(config = {}) {
      super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
    }
    init() {
      return [
        this._getInstrumentationNodeModuleDefinition("@redis/client"),
        this._getInstrumentationNodeModuleDefinition("@node-redis/client")
      ];
    }
    _getInstrumentationNodeModuleDefinition(basePackageName) {
      const commanderModuleFile = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/commander.js`, ["^1.0.0"], (moduleExports, moduleVersion) => {
        const transformCommandArguments = moduleExports.transformCommandArguments;
        if (!transformCommandArguments) {
          this._diag.error("internal instrumentation error, missing transformCommandArguments function");
          return moduleExports;
        }
        const functionToPatch = (moduleVersion === null || moduleVersion === undefined ? undefined : moduleVersion.startsWith("1.0.")) ? "extendWithCommands" : "attachCommands";
        if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === undefined ? undefined : moduleExports[functionToPatch])) {
          this._unwrap(moduleExports, functionToPatch);
        }
        this._wrap(moduleExports, functionToPatch, this._getPatchExtendWithCommands(transformCommandArguments));
        return moduleExports;
      }, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === undefined ? undefined : moduleExports.extendWithCommands)) {
          this._unwrap(moduleExports, "extendWithCommands");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === undefined ? undefined : moduleExports.attachCommands)) {
          this._unwrap(moduleExports, "attachCommands");
        }
      });
      const multiCommanderModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/multi-command.js`, ["^1.0.0"], (moduleExports) => {
        var _a2;
        const redisClientMultiCommandPrototype = (_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.default) === null || _a2 === undefined ? undefined : _a2.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === undefined ? undefined : redisClientMultiCommandPrototype.exec)) {
          this._unwrap(redisClientMultiCommandPrototype, "exec");
        }
        this._wrap(redisClientMultiCommandPrototype, "exec", this._getPatchMultiCommandsExec());
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === undefined ? undefined : redisClientMultiCommandPrototype.addCommand)) {
          this._unwrap(redisClientMultiCommandPrototype, "addCommand");
        }
        this._wrap(redisClientMultiCommandPrototype, "addCommand", this._getPatchMultiCommandsAddCommand());
        return moduleExports;
      }, (moduleExports) => {
        var _a2;
        const redisClientMultiCommandPrototype = (_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.default) === null || _a2 === undefined ? undefined : _a2.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === undefined ? undefined : redisClientMultiCommandPrototype.exec)) {
          this._unwrap(redisClientMultiCommandPrototype, "exec");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === undefined ? undefined : redisClientMultiCommandPrototype.addCommand)) {
          this._unwrap(redisClientMultiCommandPrototype, "addCommand");
        }
      });
      const clientIndexModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/index.js`, ["^1.0.0"], (moduleExports) => {
        var _a2;
        const redisClientPrototype = (_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.default) === null || _a2 === undefined ? undefined : _a2.prototype;
        if (redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.multi) {
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.multi)) {
            this._unwrap(redisClientPrototype, "multi");
          }
          this._wrap(redisClientPrototype, "multi", this._getPatchRedisClientMulti());
        }
        if (redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.MULTI) {
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.MULTI)) {
            this._unwrap(redisClientPrototype, "MULTI");
          }
          this._wrap(redisClientPrototype, "MULTI", this._getPatchRedisClientMulti());
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.sendCommand)) {
          this._unwrap(redisClientPrototype, "sendCommand");
        }
        this._wrap(redisClientPrototype, "sendCommand", this._getPatchRedisClientSendCommand());
        this._wrap(redisClientPrototype, "connect", this._getPatchedClientConnect());
        return moduleExports;
      }, (moduleExports) => {
        var _a2;
        const redisClientPrototype = (_a2 = moduleExports === null || moduleExports === undefined ? undefined : moduleExports.default) === null || _a2 === undefined ? undefined : _a2.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.multi)) {
          this._unwrap(redisClientPrototype, "multi");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.MULTI)) {
          this._unwrap(redisClientPrototype, "MULTI");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === undefined ? undefined : redisClientPrototype.sendCommand)) {
          this._unwrap(redisClientPrototype, "sendCommand");
        }
      });
      return new instrumentation_1.InstrumentationNodeModuleDefinition(basePackageName, ["^1.0.0"], (moduleExports) => {
        return moduleExports;
      }, () => {
      }, [commanderModuleFile, multiCommanderModule, clientIndexModule]);
    }
    _getPatchExtendWithCommands(transformCommandArguments) {
      const plugin = this;
      return function extendWithCommandsPatchWrapper(original) {
        return function extendWithCommandsPatch(config) {
          var _a2;
          if (((_a2 = config === null || config === undefined ? undefined : config.BaseClass) === null || _a2 === undefined ? undefined : _a2.name) !== "RedisClient") {
            return original.apply(this, arguments);
          }
          const origExecutor = config.executor;
          config.executor = function(command, args) {
            const redisCommandArguments = transformCommandArguments(command, args).args;
            return plugin._traceClientCommand(origExecutor, this, arguments, redisCommandArguments);
          };
          return original.apply(this, arguments);
        };
      };
    }
    _getPatchMultiCommandsExec() {
      const plugin = this;
      return function execPatchWrapper(original) {
        return function execPatch() {
          const execRes = original.apply(this, arguments);
          if (typeof (execRes === null || execRes === undefined ? undefined : execRes.then) !== "function") {
            plugin._diag.error("got non promise result when patching RedisClientMultiCommand.exec");
            return execRes;
          }
          return execRes.then((redisRes) => {
            const openSpans = this[OTEL_OPEN_SPANS];
            plugin._endSpansWithRedisReplies(openSpans, redisRes);
            return redisRes;
          }).catch((err) => {
            const openSpans = this[OTEL_OPEN_SPANS];
            if (!openSpans) {
              plugin._diag.error("cannot find open spans to end for redis multi command");
            } else {
              const replies = err.constructor.name === "MultiErrorReply" ? err.replies : new Array(openSpans.length).fill(err);
              plugin._endSpansWithRedisReplies(openSpans, replies);
            }
            return Promise.reject(err);
          });
        };
      };
    }
    _getPatchMultiCommandsAddCommand() {
      const plugin = this;
      return function addCommandWrapper(original) {
        return function addCommandPatch(args) {
          return plugin._traceClientCommand(original, this, arguments, args);
        };
      };
    }
    _getPatchRedisClientMulti() {
      return function multiPatchWrapper(original) {
        return function multiPatch() {
          const multiRes = original.apply(this, arguments);
          multiRes[MULTI_COMMAND_OPTIONS] = this.options;
          return multiRes;
        };
      };
    }
    _getPatchRedisClientSendCommand() {
      const plugin = this;
      return function sendCommandWrapper(original) {
        return function sendCommandPatch(args) {
          return plugin._traceClientCommand(original, this, arguments, args);
        };
      };
    }
    _getPatchedClientConnect() {
      const plugin = this;
      return function connectWrapper(original) {
        return function patchedConnect() {
          const options = this.options;
          const attributes = (0, utils_1.getClientAttributes)(plugin._diag, options);
          const span = plugin.tracer.startSpan(`${RedisInstrumentation.COMPONENT}-connect`, {
            kind: api_1.SpanKind.CLIENT,
            attributes
          });
          const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return original.apply(this);
          });
          return res.then((result) => {
            span.end();
            return result;
          }).catch((error) => {
            span.recordException(error);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error.message
            });
            span.end();
            return Promise.reject(error);
          });
        };
      };
    }
    _traceClientCommand(origFunction, origThis, origArguments, redisCommandArguments) {
      const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
      if (hasNoParentSpan && this.getConfig().requireParentSpan) {
        return origFunction.apply(origThis, origArguments);
      }
      const clientOptions = origThis.options || origThis[MULTI_COMMAND_OPTIONS];
      const commandName = redisCommandArguments[0];
      const commandArgs = redisCommandArguments.slice(1);
      const dbStatementSerializer = this.getConfig().dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
      const attributes = (0, utils_1.getClientAttributes)(this._diag, clientOptions);
      try {
        const dbStatement = dbStatementSerializer(commandName, commandArgs);
        if (dbStatement != null) {
          attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatement;
        }
      } catch (e) {
        this._diag.error("dbStatementSerializer throw an exception", e, {
          commandName
        });
      }
      const span = this.tracer.startSpan(`${RedisInstrumentation.COMPONENT}-${commandName}`, {
        kind: api_1.SpanKind.CLIENT,
        attributes
      });
      const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return origFunction.apply(origThis, origArguments);
      });
      if (typeof (res === null || res === undefined ? undefined : res.then) === "function") {
        res.then((redisRes) => {
          this._endSpanWithResponse(span, commandName, commandArgs, redisRes, undefined);
        }, (err) => {
          this._endSpanWithResponse(span, commandName, commandArgs, null, err);
        });
      } else {
        const redisClientMultiCommand = res;
        redisClientMultiCommand[OTEL_OPEN_SPANS] = redisClientMultiCommand[OTEL_OPEN_SPANS] || [];
        redisClientMultiCommand[OTEL_OPEN_SPANS].push({
          span,
          commandName,
          commandArgs
        });
      }
      return res;
    }
    _endSpansWithRedisReplies(openSpans, replies) {
      if (!openSpans) {
        return this._diag.error("cannot find open spans to end for redis multi command");
      }
      if (replies.length !== openSpans.length) {
        return this._diag.error("number of multi command spans does not match response from redis");
      }
      for (let i = 0;i < openSpans.length; i++) {
        const { span, commandName, commandArgs } = openSpans[i];
        const currCommandRes = replies[i];
        const [res, err] = currCommandRes instanceof Error ? [null, currCommandRes] : [currCommandRes, undefined];
        this._endSpanWithResponse(span, commandName, commandArgs, res, err);
      }
    }
    _endSpanWithResponse(span, commandName, commandArgs, response, error) {
      const { responseHook } = this.getConfig();
      if (!error && responseHook) {
        try {
          responseHook(span, commandName, commandArgs, response);
        } catch (err) {
          this._diag.error("responseHook throw an exception", err);
        }
      }
      if (error) {
        span.recordException(error);
        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error === null || error === undefined ? undefined : error.message });
      }
      span.end();
    }
  }
  exports.RedisInstrumentation = RedisInstrumentation;
  RedisInstrumentation.COMPONENT = "redis";
});

// ../node_modules/@opentelemetry/instrumentation-redis-4/build/src/types.js
var require_types12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-redis-4/build/src/index.js
var require_src20 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation11(), exports);
  __exportStar(require_types12(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/version.js
var require_version15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.40.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-nestjs-core";
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/AttributeNames.js
var require_AttributeNames6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["VERSION"] = "nestjs.version";
    AttributeNames2["TYPE"] = "nestjs.type";
    AttributeNames2["MODULE"] = "nestjs.module";
    AttributeNames2["CONTROLLER"] = "nestjs.controller";
    AttributeNames2["CALLBACK"] = "nestjs.callback";
    AttributeNames2["PIPES"] = "nestjs.pipes";
    AttributeNames2["INTERCEPTORS"] = "nestjs.interceptors";
    AttributeNames2["GUARDS"] = "nestjs.guards";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/NestType.js
var require_NestType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NestType = undefined;
  var NestType;
  (function(NestType2) {
    NestType2["APP_CREATION"] = "app_creation";
    NestType2["REQUEST_CONTEXT"] = "request_context";
    NestType2["REQUEST_HANDLER"] = "handler";
  })(NestType = exports.NestType || (exports.NestType = {}));
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/index.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NestType = exports.AttributeNames = undefined;
  var AttributeNames_1 = require_AttributeNames6();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
  var NestType_1 = require_NestType();
  Object.defineProperty(exports, "NestType", { enumerable: true, get: function() {
    return NestType_1.NestType;
  } });
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/instrumentation.js
var require_instrumentation12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NestInstrumentation = undefined;
  var api3 = require_src();
  var instrumentation_1 = require_src6();
  var version_1 = require_version15();
  var semantic_conventions_1 = require_src2();
  var enums_1 = require_enums();
  var supportedVersions = [">=4.0.0 <11"];

  class NestInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition(NestInstrumentation.COMPONENT, supportedVersions);
      module2.files.push(this.getNestFactoryFileInstrumentation(supportedVersions), this.getRouterExecutionContextFileInstrumentation(supportedVersions));
      return module2;
    }
    getNestFactoryFileInstrumentation(versions) {
      return new instrumentation_1.InstrumentationNodeModuleFile("@nestjs/core/nest-factory.js", versions, (NestFactoryStatic, moduleVersion) => {
        this.ensureWrapped(NestFactoryStatic.NestFactoryStatic.prototype, "create", createWrapNestFactoryCreate(this.tracer, moduleVersion));
        return NestFactoryStatic;
      }, (NestFactoryStatic) => {
        this._unwrap(NestFactoryStatic.NestFactoryStatic.prototype, "create");
      });
    }
    getRouterExecutionContextFileInstrumentation(versions) {
      return new instrumentation_1.InstrumentationNodeModuleFile("@nestjs/core/router/router-execution-context.js", versions, (RouterExecutionContext, moduleVersion) => {
        this.ensureWrapped(RouterExecutionContext.RouterExecutionContext.prototype, "create", createWrapCreateHandler(this.tracer, moduleVersion));
        return RouterExecutionContext;
      }, (RouterExecutionContext) => {
        this._unwrap(RouterExecutionContext.RouterExecutionContext.prototype, "create");
      });
    }
    ensureWrapped(obj, methodName, wrapper) {
      if ((0, instrumentation_1.isWrapped)(obj[methodName])) {
        this._unwrap(obj, methodName);
      }
      this._wrap(obj, methodName, wrapper);
    }
  }
  exports.NestInstrumentation = NestInstrumentation;
  NestInstrumentation.COMPONENT = "@nestjs/core";
  NestInstrumentation.COMMON_ATTRIBUTES = {
    component: NestInstrumentation.COMPONENT
  };
  function createWrapNestFactoryCreate(tracer, moduleVersion) {
    return function wrapCreate(original) {
      return function createWithTrace(nestModule) {
        const span = tracer.startSpan("Create Nest App", {
          attributes: Object.assign(Object.assign({}, NestInstrumentation.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.TYPE]: enums_1.NestType.APP_CREATION, [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.MODULE]: nestModule.name })
        });
        const spanContext = api3.trace.setSpan(api3.context.active(), span);
        return api3.context.with(spanContext, async () => {
          try {
            return await original.apply(this, arguments);
          } catch (e) {
            throw addError(span, e);
          } finally {
            span.end();
          }
        });
      };
    };
  }
  function createWrapCreateHandler(tracer, moduleVersion) {
    return function wrapCreateHandler(original) {
      return function createHandlerWithTrace(instance, callback) {
        arguments[1] = createWrapHandler(tracer, moduleVersion, callback);
        const handler = original.apply(this, arguments);
        const callbackName = callback.name;
        const instanceName = instance.constructor && instance.constructor.name ? instance.constructor.name : "UnnamedInstance";
        const spanName = callbackName ? `${instanceName}.${callbackName}` : instanceName;
        return function(req, res, next) {
          var _a2, _b;
          const span = tracer.startSpan(spanName, {
            attributes: Object.assign(Object.assign({}, NestInstrumentation.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.TYPE]: enums_1.NestType.REQUEST_CONTEXT, [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: req.method, [semantic_conventions_1.SEMATTRS_HTTP_URL]: req.originalUrl || req.url, [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: ((_a2 = req.route) === null || _a2 === undefined ? undefined : _a2.path) || ((_b = req.routeOptions) === null || _b === undefined ? undefined : _b.url) || req.routerPath, [enums_1.AttributeNames.CONTROLLER]: instanceName, [enums_1.AttributeNames.CALLBACK]: callbackName })
          });
          const spanContext = api3.trace.setSpan(api3.context.active(), span);
          return api3.context.with(spanContext, async () => {
            try {
              return await handler.apply(this, arguments);
            } catch (e) {
              throw addError(span, e);
            } finally {
              span.end();
            }
          });
        };
      };
    };
  }
  function createWrapHandler(tracer, moduleVersion, handler) {
    const spanName = handler.name || "anonymous nest handler";
    const options = {
      attributes: Object.assign(Object.assign({}, NestInstrumentation.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.TYPE]: enums_1.NestType.REQUEST_HANDLER, [enums_1.AttributeNames.CALLBACK]: handler.name })
    };
    const wrappedHandler = function() {
      const span = tracer.startSpan(spanName, options);
      const spanContext = api3.trace.setSpan(api3.context.active(), span);
      return api3.context.with(spanContext, async () => {
        try {
          return await handler.apply(this, arguments);
        } catch (e) {
          throw addError(span, e);
        } finally {
          span.end();
        }
      });
    };
    if (handler.name) {
      Object.defineProperty(wrappedHandler, "name", { value: handler.name });
    }
    Reflect.getMetadataKeys(handler).forEach((metadataKey) => {
      Reflect.defineMetadata(metadataKey, Reflect.getMetadata(metadataKey, handler), wrappedHandler);
    });
    return wrappedHandler;
  }
  var addError = (span, error) => {
    span.recordException(error);
    span.setStatus({ code: api3.SpanStatusCode.ERROR, message: error.message });
    return error;
  };
});

// ../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/index.js
var require_src21 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation12(), exports);
  __exportStar(require_AttributeNames6(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js
var require_AttributeNames7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["PG_VALUES"] = "db.postgresql.values";
    AttributeNames2["PG_PLAN"] = "db.postgresql.plan";
    AttributeNames2["IDLE_TIMEOUT_MILLIS"] = "db.postgresql.idle.timeout.millis";
    AttributeNames2["MAX_CLIENT"] = "db.postgresql.max.client";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js
var require_SpanNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanNames = undefined;
  var SpanNames;
  (function(SpanNames2) {
    SpanNames2["QUERY_PREFIX"] = "pg.query";
    SpanNames2["CONNECT"] = "pg.connect";
    SpanNames2["POOL_CONNECT"] = "pg-pool.connect";
  })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js
var require_utils15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObjectWithTextString = exports.getErrorMessage = exports.patchClientConnectCallback = exports.patchCallbackPGPool = exports.patchCallback = exports.handleExecutionResult = exports.handleConfigQuery = exports.shouldSkipInstrumentation = exports.getSemanticAttributesFromPool = exports.getSemanticAttributesFromConnection = exports.getConnectionString = exports.getQuerySpanName = undefined;
  var api_1 = require_src();
  var AttributeNames_1 = require_AttributeNames7();
  var semantic_conventions_1 = require_src2();
  var instrumentation_1 = require_src6();
  var SpanNames_1 = require_SpanNames();
  function getQuerySpanName(dbName, queryConfig) {
    if (!queryConfig)
      return SpanNames_1.SpanNames.QUERY_PREFIX;
    const command = typeof queryConfig.name === "string" && queryConfig.name ? queryConfig.name : parseNormalizedOperationName(queryConfig.text);
    return `${SpanNames_1.SpanNames.QUERY_PREFIX}:${command}${dbName ? ` ${dbName}` : ""}`;
  }
  exports.getQuerySpanName = getQuerySpanName;
  function parseNormalizedOperationName(queryText) {
    const indexOfFirstSpace = queryText.indexOf(" ");
    let sqlCommand = indexOfFirstSpace === -1 ? queryText : queryText.slice(0, indexOfFirstSpace);
    sqlCommand = sqlCommand.toUpperCase();
    return sqlCommand.endsWith(";") ? sqlCommand.slice(0, -1) : sqlCommand;
  }
  function getConnectionString(params) {
    const host = params.host || "localhost";
    const port = params.port || 5432;
    const database = params.database || "";
    return `postgresql://${host}:${port}/${database}`;
  }
  exports.getConnectionString = getConnectionString;
  function getPort(port) {
    if (Number.isInteger(port)) {
      return port;
    }
    return;
  }
  function getSemanticAttributesFromConnection(params) {
    return {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
      [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
      [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
      [semantic_conventions_1.SEMATTRS_DB_USER]: params.user
    };
  }
  exports.getSemanticAttributesFromConnection = getSemanticAttributesFromConnection;
  function getSemanticAttributesFromPool(params) {
    return {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
      [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
      [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
      [semantic_conventions_1.SEMATTRS_DB_USER]: params.user,
      [AttributeNames_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: params.idleTimeoutMillis,
      [AttributeNames_1.AttributeNames.MAX_CLIENT]: params.maxClient
    };
  }
  exports.getSemanticAttributesFromPool = getSemanticAttributesFromPool;
  function shouldSkipInstrumentation(instrumentationConfig) {
    return instrumentationConfig.requireParentSpan === true && api_1.trace.getSpan(api_1.context.active()) === undefined;
  }
  exports.shouldSkipInstrumentation = shouldSkipInstrumentation;
  function handleConfigQuery(tracer, instrumentationConfig, queryConfig) {
    const { connectionParameters } = this;
    const dbName = connectionParameters.database;
    const spanName = getQuerySpanName(dbName, queryConfig);
    const span = tracer.startSpan(spanName, {
      kind: api_1.SpanKind.CLIENT,
      attributes: getSemanticAttributesFromConnection(connectionParameters)
    });
    if (!queryConfig) {
      return span;
    }
    if (queryConfig.text) {
      span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, queryConfig.text);
    }
    if (instrumentationConfig.enhancedDatabaseReporting && Array.isArray(queryConfig.values)) {
      try {
        const convertedValues = queryConfig.values.map((value) => {
          if (value == null) {
            return "null";
          } else if (value instanceof Buffer) {
            return value.toString();
          } else if (typeof value === "object") {
            if (typeof value.toPostgres === "function") {
              return value.toPostgres();
            }
            return JSON.stringify(value);
          } else {
            return value.toString();
          }
        });
        span.setAttribute(AttributeNames_1.AttributeNames.PG_VALUES, convertedValues);
      } catch (e) {
        api_1.diag.error("failed to stringify ", queryConfig.values, e);
      }
    }
    if (typeof queryConfig.name === "string") {
      span.setAttribute(AttributeNames_1.AttributeNames.PG_PLAN, queryConfig.name);
    }
    return span;
  }
  exports.handleConfigQuery = handleConfigQuery;
  function handleExecutionResult(config, span, pgResult) {
    if (typeof config.responseHook === "function") {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        config.responseHook(span, {
          data: pgResult
        });
      }, (err) => {
        if (err) {
          api_1.diag.error("Error running response hook", err);
        }
      }, true);
    }
  }
  exports.handleExecutionResult = handleExecutionResult;
  function patchCallback(instrumentationConfig, span, cb) {
    return function patchedCallback(err, res) {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      } else {
        handleExecutionResult(instrumentationConfig, span, res);
      }
      span.end();
      cb.call(this, err, res);
    };
  }
  exports.patchCallback = patchCallback;
  function patchCallbackPGPool(span, cb) {
    return function patchedCallback(err, res, done) {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
      cb.call(this, err, res, done);
    };
  }
  exports.patchCallbackPGPool = patchCallbackPGPool;
  function patchClientConnectCallback(span, cb) {
    return function patchedClientConnectCallback(err) {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
      cb.apply(this, arguments);
    };
  }
  exports.patchClientConnectCallback = patchClientConnectCallback;
  function getErrorMessage(e) {
    return typeof e === "object" && e !== null && "message" in e ? String(e.message) : undefined;
  }
  exports.getErrorMessage = getErrorMessage;
  function isObjectWithTextString(it) {
    var _a2;
    return typeof it === "object" && typeof ((_a2 = it) === null || _a2 === undefined ? undefined : _a2.text) === "string";
  }
  exports.isObjectWithTextString = isObjectWithTextString;
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/version.js
var require_version16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.44.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-pg";
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js
var require_instrumentation13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PgInstrumentation = undefined;
  var instrumentation_1 = require_src6();
  var api_1 = require_src();
  var utils = require_utils15();
  var sql_common_1 = require_src16();
  var version_1 = require_version16();
  var SpanNames_1 = require_SpanNames();

  class PgInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      const modulePG = new instrumentation_1.InstrumentationNodeModuleDefinition("pg", [">=8.0.0 <9"], (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.query)) {
          this._unwrap(moduleExports.Client.prototype, "query");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.connect)) {
          this._unwrap(moduleExports.Client.prototype, "connect");
        }
        this._wrap(moduleExports.Client.prototype, "query", this._getClientQueryPatch());
        this._wrap(moduleExports.Client.prototype, "connect", this._getClientConnectPatch());
        return module2;
      }, (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.query)) {
          this._unwrap(moduleExports.Client.prototype, "query");
        }
      });
      const modulePGPool = new instrumentation_1.InstrumentationNodeModuleDefinition("pg-pool", [">=2.0.0 <4"], (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
        this._wrap(moduleExports.prototype, "connect", this._getPoolConnectPatch());
        return moduleExports;
      }, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
      });
      return [modulePG, modulePGPool];
    }
    _getClientConnectPatch() {
      const plugin = this;
      return (original) => {
        return function connect(callback) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return original.call(this, callback);
          }
          const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.CONNECT, {
            kind: api_1.SpanKind.CLIENT,
            attributes: utils.getSemanticAttributesFromConnection(this)
          });
          if (callback) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            callback = utils.patchClientConnectCallback(span, callback);
            if (parentSpan) {
              callback = api_1.context.bind(api_1.context.active(), callback);
            }
          }
          const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return original.call(this, callback);
          });
          return handleConnectResult(span, connectResult);
        };
      };
    }
    _getClientQueryPatch() {
      const plugin = this;
      return (original) => {
        this._diag.debug("Patching pg.Client.prototype.query");
        return function query(...args) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return original.apply(this, args);
          }
          const arg0 = args[0];
          const firstArgIsString = typeof arg0 === "string";
          const firstArgIsQueryObjectWithText = utils.isObjectWithTextString(arg0);
          const queryConfig = firstArgIsString ? {
            text: arg0,
            values: Array.isArray(args[1]) ? args[1] : undefined
          } : firstArgIsQueryObjectWithText ? arg0 : undefined;
          const instrumentationConfig = plugin.getConfig();
          const span = utils.handleConfigQuery.call(this, plugin.tracer, instrumentationConfig, queryConfig);
          if (instrumentationConfig.addSqlCommenterCommentToQueries) {
            args[0] = firstArgIsString ? (0, sql_common_1.addSqlCommenterComment)(span, arg0) : firstArgIsQueryObjectWithText ? Object.assign(Object.assign({}, arg0), { text: (0, sql_common_1.addSqlCommenterComment)(span, arg0.text) }) : args[0];
          }
          if (args.length > 0) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            if (typeof args[args.length - 1] === "function") {
              args[args.length - 1] = utils.patchCallback(instrumentationConfig, span, args[args.length - 1]);
              if (parentSpan) {
                args[args.length - 1] = api_1.context.bind(api_1.context.active(), args[args.length - 1]);
              }
            } else if (typeof (queryConfig === null || queryConfig === undefined ? undefined : queryConfig.callback) === "function") {
              let callback = utils.patchCallback(plugin.getConfig(), span, queryConfig.callback);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
              args[0].callback = callback;
            }
          }
          const { requestHook } = instrumentationConfig;
          if (typeof requestHook === "function" && queryConfig) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              const { database, host, port, user } = this.connectionParameters;
              const connection = { database, host, port, user };
              requestHook(span, {
                connection,
                query: {
                  text: queryConfig.text,
                  values: queryConfig.values,
                  name: queryConfig.name
                }
              });
            }, (err) => {
              if (err) {
                plugin._diag.error("Error running query hook", err);
              }
            }, true);
          }
          let result;
          try {
            result = original.apply(this, args);
          } catch (e) {
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: utils.getErrorMessage(e)
            });
            span.end();
            throw e;
          }
          if (result instanceof Promise) {
            return result.then((result2) => {
              return new Promise((resolve2) => {
                utils.handleExecutionResult(plugin.getConfig(), span, result2);
                span.end();
                resolve2(result2);
              });
            }).catch((error) => {
              return new Promise((_, reject) => {
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: error.message
                });
                span.end();
                reject(error);
              });
            });
          }
          return result;
        };
      };
    }
    _getPoolConnectPatch() {
      const plugin = this;
      return (originalConnect) => {
        return function connect(callback) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return originalConnect.call(this, callback);
          }
          const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.POOL_CONNECT, {
            kind: api_1.SpanKind.CLIENT,
            attributes: utils.getSemanticAttributesFromPool(this.options)
          });
          if (callback) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            callback = utils.patchCallbackPGPool(span, callback);
            if (parentSpan) {
              callback = api_1.context.bind(api_1.context.active(), callback);
            }
          }
          const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return originalConnect.call(this, callback);
          });
          return handleConnectResult(span, connectResult);
        };
      };
    }
  }
  exports.PgInstrumentation = PgInstrumentation;
  function handleConnectResult(span, connectResult) {
    if (!(connectResult instanceof Promise)) {
      return connectResult;
    }
    const connectResultPromise = connectResult;
    return api_1.context.bind(api_1.context.active(), connectResultPromise.then((result) => {
      span.end();
      return result;
    }).catch((error) => {
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: utils.getErrorMessage(error)
      });
      span.end();
      return Promise.reject(error);
    }));
  }
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/types.js
var require_types13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-pg/build/src/index.js
var require_src22 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation13(), exports);
  __exportStar(require_types13(), exports);
  __exportStar(require_AttributeNames7(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js
var require_version17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.41.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-hapi";
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js
var require_internal_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HapiLifecycleMethodNames = exports.HapiLayerType = exports.handlerPatched = exports.HapiComponentName = undefined;
  exports.HapiComponentName = "@hapi/hapi";
  exports.handlerPatched = Symbol("hapi-handler-patched");
  exports.HapiLayerType = {
    ROUTER: "router",
    PLUGIN: "plugin",
    EXT: "server.ext"
  };
  exports.HapiLifecycleMethodNames = new Set([
    "onPreAuth",
    "onCredentials",
    "onPostAuth",
    "onPreHandler",
    "onPostHandler",
    "onPreResponse",
    "onRequest"
  ]);
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js
var require_AttributeNames8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["HAPI_TYPE"] = "hapi.type";
    AttributeNames2["PLUGIN_NAME"] = "hapi.plugin.name";
    AttributeNames2["EXT_TYPE"] = "server.ext.type";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js
var require_utils16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPluginFromInput = exports.getExtMetadata = exports.getRouteMetadata = exports.isPatchableExtMethod = exports.isDirectExtInput = exports.isLifecycleExtEventObj = exports.isLifecycleExtType = exports.getPluginName = undefined;
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types4();
  var AttributeNames_1 = require_AttributeNames8();
  function getPluginName(plugin) {
    if (plugin.name) {
      return plugin.name;
    } else {
      return plugin.pkg.name;
    }
  }
  exports.getPluginName = getPluginName;
  var isLifecycleExtType = (variableToCheck) => {
    return typeof variableToCheck === "string" && internal_types_1.HapiLifecycleMethodNames.has(variableToCheck);
  };
  exports.isLifecycleExtType = isLifecycleExtType;
  var isLifecycleExtEventObj = (variableToCheck) => {
    var _a2;
    const event = (_a2 = variableToCheck) === null || _a2 === undefined ? undefined : _a2.type;
    return event !== undefined && (0, exports.isLifecycleExtType)(event);
  };
  exports.isLifecycleExtEventObj = isLifecycleExtEventObj;
  var isDirectExtInput = (variableToCheck) => {
    return Array.isArray(variableToCheck) && variableToCheck.length <= 3 && (0, exports.isLifecycleExtType)(variableToCheck[0]) && typeof variableToCheck[1] === "function";
  };
  exports.isDirectExtInput = isDirectExtInput;
  var isPatchableExtMethod = (variableToCheck) => {
    return !Array.isArray(variableToCheck);
  };
  exports.isPatchableExtMethod = isPatchableExtMethod;
  var getRouteMetadata = (route, pluginName) => {
    if (pluginName) {
      return {
        attributes: {
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
          [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.PLUGIN,
          [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
        },
        name: `${pluginName}: route - ${route.path}`
      };
    }
    return {
      attributes: {
        [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
        [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.ROUTER
      },
      name: `route - ${route.path}`
    };
  };
  exports.getRouteMetadata = getRouteMetadata;
  var getExtMetadata = (extPoint, pluginName) => {
    if (pluginName) {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT,
          [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
        },
        name: `${pluginName}: ext - ${extPoint}`
      };
    }
    return {
      attributes: {
        [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
        [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT
      },
      name: `ext - ${extPoint}`
    };
  };
  exports.getExtMetadata = getExtMetadata;
  var getPluginFromInput = (pluginObj) => {
    if ("plugin" in pluginObj) {
      if ("plugin" in pluginObj.plugin) {
        return pluginObj.plugin.plugin;
      }
      return pluginObj.plugin;
    }
    return pluginObj;
  };
  exports.getPluginFromInput = getPluginFromInput;
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js
var require_instrumentation14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HapiInstrumentation = undefined;
  var api3 = require_src();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var version_1 = require_version17();
  var internal_types_1 = require_internal_types4();
  var utils_1 = require_utils16();

  class HapiInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition(internal_types_1.HapiComponentName, [">=17.0.0 <22"], (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if (!(0, instrumentation_1.isWrapped)(moduleExports.server)) {
          this._wrap(moduleExports, "server", this._getServerPatch.bind(this));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Server)) {
          this._wrap(moduleExports, "Server", this._getServerPatch.bind(this));
        }
        return moduleExports;
      }, (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        this._massUnwrap([moduleExports], ["server", "Server"]);
      });
    }
    _getServerPatch(original) {
      const instrumentation = this;
      const self2 = this;
      return function server(opts) {
        const newServer = original.apply(this, [opts]);
        self2._wrap(newServer, "route", (originalRouter) => {
          return instrumentation._getServerRoutePatch.bind(instrumentation)(originalRouter);
        });
        self2._wrap(newServer, "ext", (originalExtHandler) => {
          return instrumentation._getServerExtPatch.bind(instrumentation)(originalExtHandler);
        });
        self2._wrap(newServer, "register", instrumentation._getServerRegisterPatch.bind(instrumentation));
        return newServer;
      };
    }
    _getServerRegisterPatch(original) {
      const instrumentation = this;
      return function register(pluginInput, options) {
        if (Array.isArray(pluginInput)) {
          for (const pluginObj of pluginInput) {
            const plugin = (0, utils_1.getPluginFromInput)(pluginObj);
            instrumentation._wrapRegisterHandler(plugin);
          }
        } else {
          const plugin = (0, utils_1.getPluginFromInput)(pluginInput);
          instrumentation._wrapRegisterHandler(plugin);
        }
        return original.apply(this, [pluginInput, options]);
      };
    }
    _getServerExtPatch(original, pluginName) {
      const instrumentation = this;
      return function ext(...args) {
        if (Array.isArray(args[0])) {
          const eventsList = args[0];
          for (let i = 0;i < eventsList.length; i++) {
            const eventObj = eventsList[i];
            if ((0, utils_1.isLifecycleExtType)(eventObj.type)) {
              const lifecycleEventObj = eventObj;
              const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, eventObj.type, pluginName);
              lifecycleEventObj.method = handler;
              eventsList[i] = lifecycleEventObj;
            }
          }
          return original.apply(this, args);
        } else if ((0, utils_1.isDirectExtInput)(args)) {
          const extInput = args;
          const method = extInput[1];
          const handler = instrumentation._wrapExtMethods(method, extInput[0], pluginName);
          return original.apply(this, [extInput[0], handler, extInput[2]]);
        } else if ((0, utils_1.isLifecycleExtEventObj)(args[0])) {
          const lifecycleEventObj = args[0];
          const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, lifecycleEventObj.type, pluginName);
          lifecycleEventObj.method = handler;
          return original.call(this, lifecycleEventObj);
        }
        return original.apply(this, args);
      };
    }
    _getServerRoutePatch(original, pluginName) {
      const instrumentation = this;
      return function route(route) {
        if (Array.isArray(route)) {
          for (let i = 0;i < route.length; i++) {
            const newRoute = instrumentation._wrapRouteHandler.call(instrumentation, route[i], pluginName);
            route[i] = newRoute;
          }
        } else {
          route = instrumentation._wrapRouteHandler.call(instrumentation, route, pluginName);
        }
        return original.apply(this, [route]);
      };
    }
    _wrapRegisterHandler(plugin) {
      const instrumentation = this;
      const pluginName = (0, utils_1.getPluginName)(plugin);
      const oldHandler = plugin.register;
      const self2 = this;
      const newRegisterHandler = function(server, options) {
        self2._wrap(server, "route", (original) => {
          return instrumentation._getServerRoutePatch.bind(instrumentation)(original, pluginName);
        });
        self2._wrap(server, "ext", (originalExtHandler) => {
          return instrumentation._getServerExtPatch.bind(instrumentation)(originalExtHandler, pluginName);
        });
        return oldHandler(server, options);
      };
      plugin.register = newRegisterHandler;
    }
    _wrapExtMethods(method, extPoint, pluginName) {
      const instrumentation = this;
      if (method instanceof Array) {
        for (let i = 0;i < method.length; i++) {
          method[i] = instrumentation._wrapExtMethods(method[i], extPoint);
        }
        return method;
      } else if ((0, utils_1.isPatchableExtMethod)(method)) {
        if (method[internal_types_1.handlerPatched] === true)
          return method;
        method[internal_types_1.handlerPatched] = true;
        const newHandler = async function(...params) {
          if (api3.trace.getSpan(api3.context.active()) === undefined) {
            return await method.apply(this, params);
          }
          const metadata = (0, utils_1.getExtMetadata)(extPoint, pluginName);
          const span = instrumentation.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          try {
            return await api3.context.with(api3.trace.setSpan(api3.context.active(), span), method, undefined, ...params);
          } catch (err) {
            span.recordException(err);
            span.setStatus({
              code: api3.SpanStatusCode.ERROR,
              message: err.message
            });
            throw err;
          } finally {
            span.end();
          }
        };
        return newHandler;
      }
      return method;
    }
    _wrapRouteHandler(route, pluginName) {
      var _a2;
      const instrumentation = this;
      if (route[internal_types_1.handlerPatched] === true)
        return route;
      route[internal_types_1.handlerPatched] = true;
      const wrapHandler = (oldHandler) => {
        return async function(...params) {
          if (api3.trace.getSpan(api3.context.active()) === undefined) {
            return await oldHandler.call(this, ...params);
          }
          const rpcMetadata = (0, core_1.getRPCMetadata)(api3.context.active());
          if ((rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = route.path;
          }
          const metadata = (0, utils_1.getRouteMetadata)(route, pluginName);
          const span = instrumentation.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          try {
            return await api3.context.with(api3.trace.setSpan(api3.context.active(), span), () => oldHandler.call(this, ...params));
          } catch (err) {
            span.recordException(err);
            span.setStatus({
              code: api3.SpanStatusCode.ERROR,
              message: err.message
            });
            throw err;
          } finally {
            span.end();
          }
        };
      };
      if (typeof route.handler === "function") {
        route.handler = wrapHandler(route.handler);
      } else if (typeof route.options === "function") {
        const oldOptions = route.options;
        route.options = function(server) {
          const options = oldOptions(server);
          if (typeof options.handler === "function") {
            options.handler = wrapHandler(options.handler);
          }
          return options;
        };
      } else if (typeof ((_a2 = route.options) === null || _a2 === undefined ? undefined : _a2.handler) === "function") {
        route.options.handler = wrapHandler(route.options.handler);
      }
      return route;
    }
  }
  exports.HapiInstrumentation = HapiInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js
var require_src23 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation14(), exports);
  __exportStar(require_AttributeNames8(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/types.js
var require_types14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KoaLayerType = undefined;
  var KoaLayerType;
  (function(KoaLayerType2) {
    KoaLayerType2["ROUTER"] = "router";
    KoaLayerType2["MIDDLEWARE"] = "middleware";
  })(KoaLayerType = exports.KoaLayerType || (exports.KoaLayerType = {}));
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/version.js
var require_version18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.43.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-koa";
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js
var require_AttributeNames9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["KOA_TYPE"] = "koa.type";
    AttributeNames2["KOA_NAME"] = "koa.name";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js
var require_utils17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLayerIgnored = exports.getMiddlewareMetadata = undefined;
  var types_1 = require_types14();
  var AttributeNames_1 = require_AttributeNames9();
  var semantic_conventions_1 = require_src2();
  var getMiddlewareMetadata = (context8, layer, isRouter, layerPath) => {
    var _a2;
    if (isRouter) {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.KOA_NAME]: layerPath === null || layerPath === undefined ? undefined : layerPath.toString(),
          [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.ROUTER,
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: layerPath === null || layerPath === undefined ? undefined : layerPath.toString()
        },
        name: context8._matchedRouteName || `router - ${layerPath}`
      };
    } else {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.KOA_NAME]: (_a2 = layer.name) !== null && _a2 !== undefined ? _a2 : "middleware",
          [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.MIDDLEWARE
        },
        name: `middleware - ${layer.name}`
      };
    }
  };
  exports.getMiddlewareMetadata = getMiddlewareMetadata;
  var isLayerIgnored = (type, config) => {
    var _a2;
    return !!(Array.isArray(config === null || config === undefined ? undefined : config.ignoreLayersType) && ((_a2 = config === null || config === undefined ? undefined : config.ignoreLayersType) === null || _a2 === undefined ? undefined : _a2.includes(type)));
  };
  exports.isLayerIgnored = isLayerIgnored;
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js
var require_internal_types5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kLayerPatched = undefined;
  exports.kLayerPatched = Symbol("koa-layer-patched");
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js
var require_instrumentation15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KoaInstrumentation = undefined;
  var api3 = require_src();
  var instrumentation_1 = require_src6();
  var types_1 = require_types14();
  var version_1 = require_version18();
  var utils_1 = require_utils17();
  var core_1 = require_src3();
  var internal_types_1 = require_internal_types5();

  class KoaInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("koa", [">=2.0.0 <3"], (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if (moduleExports == null) {
          return moduleExports;
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
          this._unwrap(moduleExports.prototype, "use");
        }
        this._wrap(moduleExports.prototype, "use", this._getKoaUsePatch.bind(this));
        return module2;
      }, (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
          this._unwrap(moduleExports.prototype, "use");
        }
      });
    }
    _getKoaUsePatch(original) {
      const plugin = this;
      return function use(middlewareFunction) {
        let patchedFunction;
        if (middlewareFunction.router) {
          patchedFunction = plugin._patchRouterDispatch(middlewareFunction);
        } else {
          patchedFunction = plugin._patchLayer(middlewareFunction, false);
        }
        return original.apply(this, [patchedFunction]);
      };
    }
    _patchRouterDispatch(dispatchLayer) {
      var _a2;
      api3.diag.debug("Patching @koa/router dispatch");
      const router = dispatchLayer.router;
      const routesStack = (_a2 = router === null || router === undefined ? undefined : router.stack) !== null && _a2 !== undefined ? _a2 : [];
      for (const pathLayer of routesStack) {
        const path3 = pathLayer.path;
        const pathStack = pathLayer.stack;
        for (let j = 0;j < pathStack.length; j++) {
          const routedMiddleware = pathStack[j];
          pathStack[j] = this._patchLayer(routedMiddleware, true, path3);
        }
      }
      return dispatchLayer;
    }
    _patchLayer(middlewareLayer, isRouter, layerPath) {
      const layerType = isRouter ? types_1.KoaLayerType.ROUTER : types_1.KoaLayerType.MIDDLEWARE;
      if (middlewareLayer[internal_types_1.kLayerPatched] === true || (0, utils_1.isLayerIgnored)(layerType, this.getConfig()))
        return middlewareLayer;
      if (middlewareLayer.constructor.name === "GeneratorFunction" || middlewareLayer.constructor.name === "AsyncGeneratorFunction") {
        api3.diag.debug("ignoring generator-based Koa middleware layer");
        return middlewareLayer;
      }
      middlewareLayer[internal_types_1.kLayerPatched] = true;
      api3.diag.debug("patching Koa middleware layer");
      return async (context8, next) => {
        const parent = api3.trace.getSpan(api3.context.active());
        if (parent === undefined) {
          return middlewareLayer(context8, next);
        }
        const metadata = (0, utils_1.getMiddlewareMetadata)(context8, middlewareLayer, isRouter, layerPath);
        const span = this.tracer.startSpan(metadata.name, {
          attributes: metadata.attributes
        });
        const rpcMetadata = (0, core_1.getRPCMetadata)(api3.context.active());
        if ((rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP && context8._matchedRoute) {
          rpcMetadata.route = context8._matchedRoute.toString();
        }
        const { requestHook } = this.getConfig();
        if (requestHook) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook(span, {
            context: context8,
            middlewareLayer,
            layerType
          }), (e) => {
            if (e) {
              api3.diag.error("koa instrumentation: request hook failed", e);
            }
          }, true);
        }
        const newContext = api3.trace.setSpan(api3.context.active(), span);
        return api3.context.with(newContext, async () => {
          try {
            return await middlewareLayer(context8, next);
          } catch (err) {
            span.recordException(err);
            throw err;
          } finally {
            span.end();
          }
        });
      };
    }
  }
  exports.KoaInstrumentation = KoaInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-koa/build/src/index.js
var require_src24 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation15(), exports);
  __exportStar(require_types14(), exports);
  __exportStar(require_AttributeNames9(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js
var require_AttributeNames10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectNames = exports.ConnectTypes = exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["CONNECT_TYPE"] = "connect.type";
    AttributeNames2["CONNECT_NAME"] = "connect.name";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  var ConnectTypes;
  (function(ConnectTypes2) {
    ConnectTypes2["MIDDLEWARE"] = "middleware";
    ConnectTypes2["REQUEST_HANDLER"] = "request_handler";
  })(ConnectTypes = exports.ConnectTypes || (exports.ConnectTypes = {}));
  var ConnectNames;
  (function(ConnectNames2) {
    ConnectNames2["MIDDLEWARE"] = "middleware";
    ConnectNames2["REQUEST_HANDLER"] = "request handler";
  })(ConnectNames = exports.ConnectNames || (exports.ConnectNames = {}));
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/version.js
var require_version19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.39.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-connect";
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js
var require_internal_types6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._LAYERS_STORE_PROPERTY = undefined;
  exports._LAYERS_STORE_PROPERTY = Symbol("opentelemetry.instrumentation-connect.request-route-stack");
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js
var require_utils18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateRoute = exports.replaceCurrentStackRoute = exports.addNewStackLayer = undefined;
  var api_1 = require_src();
  var internal_types_1 = require_internal_types6();
  var addNewStackLayer = (request) => {
    if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
      Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
        enumerable: false,
        value: []
      });
    }
    request[internal_types_1._LAYERS_STORE_PROPERTY].push("/");
    const stackLength = request[internal_types_1._LAYERS_STORE_PROPERTY].length;
    return () => {
      if (stackLength === request[internal_types_1._LAYERS_STORE_PROPERTY].length) {
        request[internal_types_1._LAYERS_STORE_PROPERTY].pop();
      } else {
        api_1.diag.warn("Connect: Trying to pop the stack multiple time");
      }
    };
  };
  exports.addNewStackLayer = addNewStackLayer;
  var replaceCurrentStackRoute = (request, newRoute) => {
    if (newRoute) {
      request[internal_types_1._LAYERS_STORE_PROPERTY].splice(-1, 1, newRoute);
    }
  };
  exports.replaceCurrentStackRoute = replaceCurrentStackRoute;
  var generateRoute = (request) => {
    return request[internal_types_1._LAYERS_STORE_PROPERTY].reduce((acc, sub) => acc.replace(/\/+$/, "") + sub);
  };
  exports.generateRoute = generateRoute;
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js
var require_instrumentation16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectInstrumentation = exports.ANONYMOUS_NAME = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AttributeNames_1 = require_AttributeNames10();
  var version_1 = require_version19();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var utils_1 = require_utils18();
  exports.ANONYMOUS_NAME = "anonymous";

  class ConnectInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("connect", [">=3.0.0 <4"], (moduleExports) => {
          return this._patchConstructor(moduleExports);
        })
      ];
    }
    _patchApp(patchedApp) {
      if (!(0, instrumentation_1.isWrapped)(patchedApp.use)) {
        this._wrap(patchedApp, "use", this._patchUse.bind(this));
      }
      if (!(0, instrumentation_1.isWrapped)(patchedApp.handle)) {
        this._wrap(patchedApp, "handle", this._patchHandle.bind(this));
      }
    }
    _patchConstructor(original) {
      const instrumentation = this;
      return function(...args) {
        const app = original.apply(this, args);
        instrumentation._patchApp(app);
        return app;
      };
    }
    _patchNext(next, finishSpan) {
      return function nextFunction(err) {
        const result = next.apply(this, [err]);
        finishSpan();
        return result;
      };
    }
    _startSpan(routeName, middleWare) {
      let connectType;
      let connectName;
      let connectTypeName;
      if (routeName) {
        connectType = AttributeNames_1.ConnectTypes.REQUEST_HANDLER;
        connectTypeName = AttributeNames_1.ConnectNames.REQUEST_HANDLER;
        connectName = routeName;
      } else {
        connectType = AttributeNames_1.ConnectTypes.MIDDLEWARE;
        connectTypeName = AttributeNames_1.ConnectNames.MIDDLEWARE;
        connectName = middleWare.name || exports.ANONYMOUS_NAME;
      }
      const spanName = `${connectTypeName} - ${connectName}`;
      const options = {
        attributes: {
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: routeName.length > 0 ? routeName : "/",
          [AttributeNames_1.AttributeNames.CONNECT_TYPE]: connectType,
          [AttributeNames_1.AttributeNames.CONNECT_NAME]: connectName
        }
      };
      return this.tracer.startSpan(spanName, options);
    }
    _patchMiddleware(routeName, middleWare) {
      const instrumentation = this;
      const isErrorMiddleware = middleWare.length === 4;
      function patchedMiddleware() {
        if (!instrumentation.isEnabled()) {
          return middleWare.apply(this, arguments);
        }
        const [reqArgIdx, resArgIdx, nextArgIdx] = isErrorMiddleware ? [1, 2, 3] : [0, 1, 2];
        const req = arguments[reqArgIdx];
        const res = arguments[resArgIdx];
        const next = arguments[nextArgIdx];
        (0, utils_1.replaceCurrentStackRoute)(req, routeName);
        const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
        if (routeName && (rpcMetadata === null || rpcMetadata === undefined ? undefined : rpcMetadata.type) === core_1.RPCType.HTTP) {
          rpcMetadata.route = (0, utils_1.generateRoute)(req);
        }
        let spanName = "";
        if (routeName) {
          spanName = `request handler - ${routeName}`;
        } else {
          spanName = `middleware - ${middleWare.name || exports.ANONYMOUS_NAME}`;
        }
        const span = instrumentation._startSpan(routeName, middleWare);
        instrumentation._diag.debug("start span", spanName);
        let spanFinished = false;
        function finishSpan() {
          if (!spanFinished) {
            spanFinished = true;
            instrumentation._diag.debug(`finishing span ${span.name}`);
            span.end();
          } else {
            instrumentation._diag.debug(`span ${span.name} - already finished`);
          }
          res.removeListener("close", finishSpan);
        }
        res.addListener("close", finishSpan);
        arguments[nextArgIdx] = instrumentation._patchNext(next, finishSpan);
        return middleWare.apply(this, arguments);
      }
      Object.defineProperty(patchedMiddleware, "length", {
        value: middleWare.length,
        writable: false,
        configurable: true
      });
      return patchedMiddleware;
    }
    _patchUse(original) {
      const instrumentation = this;
      return function(...args) {
        const middleWare = args[args.length - 1];
        const routeName = args[args.length - 2] || "";
        args[args.length - 1] = instrumentation._patchMiddleware(routeName, middleWare);
        return original.apply(this, args);
      };
    }
    _patchHandle(original) {
      const instrumentation = this;
      return function() {
        const [reqIdx, outIdx] = [0, 2];
        const req = arguments[reqIdx];
        const out = arguments[outIdx];
        const completeStack = (0, utils_1.addNewStackLayer)(req);
        if (typeof out === "function") {
          arguments[outIdx] = instrumentation._patchOut(out, completeStack);
        }
        return original.apply(this, arguments);
      };
    }
    _patchOut(out, completeStack) {
      return function nextFunction(...args) {
        completeStack();
        return Reflect.apply(out, this, args);
      };
    }
  }
  exports.ConnectInstrumentation = ConnectInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-connect/build/src/index.js
var require_src25 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_AttributeNames10(), exports);
  __exportStar(require_instrumentation16(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/version.js
var require_version20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.39.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-generic-pool";
});

// ../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/instrumentation.js
var require_instrumentation17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPoolInstrumentation = undefined;
  var api3 = require_src();
  var instrumentation_1 = require_src6();
  var version_1 = require_version20();
  var MODULE_NAME = "generic-pool";

  class GenericPoolInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._isDisabled = false;
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=3.0.0 <4"], (moduleExports) => {
          const Pool = moduleExports.Pool;
          if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
            this._unwrap(Pool.prototype, "acquire");
          }
          this._wrap(Pool.prototype, "acquire", this._acquirePatcher.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          const Pool = moduleExports.Pool;
          this._unwrap(Pool.prototype, "acquire");
          return moduleExports;
        }),
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=2.4.0 <3"], (moduleExports) => {
          const Pool = moduleExports.Pool;
          if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
            this._unwrap(Pool.prototype, "acquire");
          }
          this._wrap(Pool.prototype, "acquire", this._acquireWithCallbacksPatcher.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          const Pool = moduleExports.Pool;
          this._unwrap(Pool.prototype, "acquire");
          return moduleExports;
        }),
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=2.0.0 <2.4"], (moduleExports) => {
          this._isDisabled = false;
          if ((0, instrumentation_1.isWrapped)(moduleExports.Pool)) {
            this._unwrap(moduleExports, "Pool");
          }
          this._wrap(moduleExports, "Pool", this._poolWrapper.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          this._isDisabled = true;
          return moduleExports;
        })
      ];
    }
    _acquirePatcher(original) {
      const instrumentation = this;
      return function wrapped_acquire(...args) {
        const parent = api3.context.active();
        const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
        return api3.context.with(api3.trace.setSpan(parent, span), () => {
          return original.call(this, ...args).then((value) => {
            span.end();
            return value;
          }, (err) => {
            span.recordException(err);
            span.end();
            throw err;
          });
        });
      };
    }
    _poolWrapper(original) {
      const instrumentation = this;
      return function wrapped_pool() {
        const pool = original.apply(this, arguments);
        instrumentation._wrap(pool, "acquire", instrumentation._acquireWithCallbacksPatcher.bind(instrumentation));
        return pool;
      };
    }
    _acquireWithCallbacksPatcher(original) {
      const instrumentation = this;
      return function wrapped_acquire(cb, priority) {
        if (instrumentation._isDisabled) {
          return original.call(this, cb, priority);
        }
        const parent = api3.context.active();
        const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
        return api3.context.with(api3.trace.setSpan(parent, span), () => {
          original.call(this, (err, client) => {
            span.end();
            if (cb) {
              return cb(err, client);
            }
          }, priority);
        });
      };
    }
  }
  exports.GenericPoolInstrumentation = GenericPoolInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/index.js
var require_src26 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instrumentation17(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-dataloader/build/src/types.js
var require_types15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../node_modules/@opentelemetry/instrumentation-dataloader/build/src/version.js
var require_version21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.12.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-dataloader";
});

// ../node_modules/@opentelemetry/instrumentation-dataloader/build/src/instrumentation.js
var require_instrumentation18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataloaderInstrumentation = undefined;
  var instrumentation_1 = require_src6();
  var api_1 = require_src();
  var version_1 = require_version21();
  var MODULE_NAME = "dataloader";

  class DataloaderInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=2.0.0 <3"], (dataloader) => {
          this._patchLoad(dataloader.prototype);
          this._patchLoadMany(dataloader.prototype);
          return this._getPatchedConstructor(dataloader);
        }, (dataloader) => {
          if ((0, instrumentation_1.isWrapped)(dataloader.prototype.load)) {
            this._unwrap(dataloader.prototype, "load");
          }
          if ((0, instrumentation_1.isWrapped)(dataloader.prototype.loadMany)) {
            this._unwrap(dataloader.prototype, "loadMany");
          }
        })
      ];
    }
    shouldCreateSpans() {
      const config = this.getConfig();
      const hasParentSpan = api_1.trace.getSpan(api_1.context.active()) !== undefined;
      return hasParentSpan || !config.requireParentSpan;
    }
    getSpanName(dataloader, operation) {
      const dataloaderName = dataloader.name;
      if (dataloaderName === undefined || dataloaderName === null) {
        return `${MODULE_NAME}.${operation}`;
      }
      return `${MODULE_NAME}.${operation} ${dataloaderName}`;
    }
    _getPatchedConstructor(constructor) {
      const prototype = constructor.prototype;
      const instrumentation = this;
      function PatchedDataloader(...args) {
        const inst = new constructor(...args);
        if (!instrumentation.isEnabled()) {
          return inst;
        }
        if ((0, instrumentation_1.isWrapped)(inst._batchLoadFn)) {
          instrumentation._unwrap(inst, "_batchLoadFn");
        }
        instrumentation._wrap(inst, "_batchLoadFn", (original) => {
          return function patchedBatchLoadFn(...args2) {
            var _a2;
            if (!instrumentation.isEnabled() || !instrumentation.shouldCreateSpans()) {
              return original.call(this, ...args2);
            }
            const parent = api_1.context.active();
            const span = instrumentation.tracer.startSpan(instrumentation.getSpanName(inst, "batch"), { links: (_a2 = this._batch) === null || _a2 === undefined ? undefined : _a2.spanLinks }, parent);
            return api_1.context.with(api_1.trace.setSpan(parent, span), () => {
              return original.apply(this, args2).then((value) => {
                span.end();
                return value;
              }).catch((err) => {
                span.recordException(err);
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: err.message
                });
                span.end();
                throw err;
              });
            });
          };
        });
        return inst;
      }
      PatchedDataloader.prototype = prototype;
      return PatchedDataloader;
    }
    _patchLoad(proto) {
      if ((0, instrumentation_1.isWrapped)(proto.load)) {
        this._unwrap(proto, "load");
      }
      this._wrap(proto, "load", this._getPatchedLoad.bind(this));
    }
    _getPatchedLoad(original) {
      const instrumentation = this;
      return function patchedLoad(...args) {
        if (!instrumentation.shouldCreateSpans()) {
          return original.call(this, ...args);
        }
        const parent = api_1.context.active();
        const span = instrumentation.tracer.startSpan(instrumentation.getSpanName(this, "load"), { kind: api_1.SpanKind.CLIENT }, parent);
        return api_1.context.with(api_1.trace.setSpan(parent, span), () => {
          const result = original.call(this, ...args).then((value) => {
            span.end();
            return value;
          }).catch((err) => {
            span.recordException(err);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err.message
            });
            span.end();
            throw err;
          });
          const loader = this;
          if (loader._batch) {
            if (!loader._batch.spanLinks) {
              loader._batch.spanLinks = [];
            }
            loader._batch.spanLinks.push({ context: span.spanContext() });
          }
          return result;
        });
      };
    }
    _patchLoadMany(proto) {
      if ((0, instrumentation_1.isWrapped)(proto.loadMany)) {
        this._unwrap(proto, "loadMany");
      }
      this._wrap(proto, "loadMany", this._getPatchedLoadMany.bind(this));
    }
    _getPatchedLoadMany(original) {
      const instrumentation = this;
      return function patchedLoadMany(...args) {
        if (!instrumentation.shouldCreateSpans()) {
          return original.call(this, ...args);
        }
        const parent = api_1.context.active();
        const span = instrumentation.tracer.startSpan(instrumentation.getSpanName(this, "loadMany"), { kind: api_1.SpanKind.CLIENT }, parent);
        return api_1.context.with(api_1.trace.setSpan(parent, span), () => {
          return original.call(this, ...args).then((value) => {
            span.end();
            return value;
          });
        });
      };
    }
  }
  exports.DataloaderInstrumentation = DataloaderInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-dataloader/build/src/index.js
var require_src27 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_types15(), exports);
  __exportStar(require_instrumentation18(), exports);
});

// ../node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js
var require_types16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CONFIG = exports.EndOperation = undefined;
  var EndOperation;
  (function(EndOperation2) {
    EndOperation2["AutoAck"] = "auto ack";
    EndOperation2["Ack"] = "ack";
    EndOperation2["AckAll"] = "ackAll";
    EndOperation2["Reject"] = "reject";
    EndOperation2["Nack"] = "nack";
    EndOperation2["NackAll"] = "nackAll";
    EndOperation2["ChannelClosed"] = "channel closed";
    EndOperation2["ChannelError"] = "channel error";
    EndOperation2["InstrumentationTimeout"] = "instrumentation timeout";
  })(EndOperation = exports.EndOperation || (exports.EndOperation = {}));
  exports.DEFAULT_CONFIG = {
    consumeTimeoutMs: 1000 * 60,
    useLinksForConsume: false
  };
});

// ../node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js
var require_utils19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  exports.MESSAGE_STORED_SPAN = Symbol("opentelemetry.amqplib.message.stored-span");
  exports.CHANNEL_SPANS_NOT_ENDED = Symbol("opentelemetry.amqplib.channel.spans-not-ended");
  exports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol("opentelemetry.amqplib.channel.consumer-timeout-timer");
  exports.CONNECTION_ATTRIBUTES = Symbol("opentelemetry.amqplib.connection.attributes");
  var IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)("opentelemetry.amqplib.channel.is-confirm-channel");
  var normalizeExchange = (exchangeName) => exchangeName !== "" ? exchangeName : "<default>";
  exports.normalizeExchange = normalizeExchange;
  var censorPassword = (url) => {
    return url.replace(/:[^:@/]*@/, ":***@");
  };
  var getPort = (portFromUrl, resolvedProtocol) => {
    return portFromUrl || (resolvedProtocol === "AMQP" ? 5672 : 5671);
  };
  var getProtocol = (protocolFromUrl) => {
    const resolvedProtocol = protocolFromUrl || "amqp";
    const noEndingColon = resolvedProtocol.endsWith(":") ? resolvedProtocol.substring(0, resolvedProtocol.length - 1) : resolvedProtocol;
    return noEndingColon.toUpperCase();
  };
  var getHostname = (hostnameFromUrl) => {
    return hostnameFromUrl || "localhost";
  };
  var extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) => {
    if (attributeValue) {
      return { [attributeKey]: attributeValue };
    } else {
      api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {
        url
      });
      return {};
    }
  };
  var getConnectionAttributesFromServer = (conn) => {
    var _a2, _b;
    const product = (_b = (_a2 = conn.serverProperties.product) === null || _a2 === undefined ? undefined : _a2.toLowerCase) === null || _b === undefined ? undefined : _b.call(_a2);
    if (product) {
      return {
        [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product
      };
    } else {
      return {};
    }
  };
  exports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;
  var getConnectionAttributesFromUrl = (url) => {
    const attributes = {
      [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: "0.9.1"
    };
    url = url || "amqp://localhost";
    if (typeof url === "object") {
      const connectOptions = url;
      const protocol = getProtocol(connectOptions === null || connectOptions === undefined ? undefined : connectOptions.protocol);
      Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")));
      const hostname = getHostname(connectOptions === null || connectOptions === undefined ? undefined : connectOptions.hostname);
      Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, "hostname")));
      const port = getPort(connectOptions.port, protocol);
      Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")));
    } else {
      const censoredUrl = censorPassword(url);
      attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;
      try {
        const urlParts = new URL(censoredUrl);
        const protocol = getProtocol(urlParts.protocol);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")));
        const hostname = getHostname(urlParts.hostname);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, "hostname")));
        const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")));
      } catch (err) {
        api_1.diag.error("amqplib instrumentation: error while extracting connection details from connection url", {
          censoredUrl,
          err
        });
      }
    }
    return attributes;
  };
  exports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;
  var markConfirmChannelTracing = (context8) => {
    return context8.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);
  };
  exports.markConfirmChannelTracing = markConfirmChannelTracing;
  var unmarkConfirmChannelTracing = (context8) => {
    return context8.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);
  };
  exports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;
  var isConfirmChannelTracing = (context8) => {
    return context8.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;
  };
  exports.isConfirmChannelTracing = isConfirmChannelTracing;
});

// ../node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js
var require_version22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.42.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-amqplib";
});

// ../node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js
var require_amqplib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AmqplibInstrumentation = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var types_1 = require_types16();
  var utils_1 = require_utils19();
  var version_1 = require_version22();
  var supportedVersions2 = [">=0.5.5 <1"];

  class AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));
    }
    setConfig(config = {}) {
      super.setConfig(Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));
    }
    init() {
      const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/channel_model.js", supportedVersions2, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
      const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/callback_model.js", supportedVersions2, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
      const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/connect.js", supportedVersions2, this.patchConnect.bind(this), this.unpatchConnect.bind(this));
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("amqplib", supportedVersions2, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);
      return module2;
    }
    patchConnect(moduleExports) {
      moduleExports = this.unpatchConnect(moduleExports);
      if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {
        this._wrap(moduleExports, "connect", this.getConnectPatch.bind(this));
      }
      return moduleExports;
    }
    unpatchConnect(moduleExports) {
      if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
        this._unwrap(moduleExports, "connect");
      }
      return moduleExports;
    }
    patchChannelModel(moduleExports, moduleVersion) {
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
        this._wrap(moduleExports.Channel.prototype, "publish", this.getPublishPatch.bind(this, moduleVersion));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
        this._wrap(moduleExports.Channel.prototype, "consume", this.getConsumePatch.bind(this, moduleVersion));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
        this._wrap(moduleExports.Channel.prototype, "ack", this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
        this._wrap(moduleExports.Channel.prototype, "nack", this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
        this._wrap(moduleExports.Channel.prototype, "reject", this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
        this._wrap(moduleExports.Channel.prototype, "ackAll", this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
        this._wrap(moduleExports.Channel.prototype, "nackAll", this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
        this._wrap(moduleExports.Channel.prototype, "emit", this.getChannelEmitPatch.bind(this));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
        this._wrap(moduleExports.ConfirmChannel.prototype, "publish", this.getConfirmedPublishPatch.bind(this, moduleVersion));
      }
      return moduleExports;
    }
    unpatchChannelModel(moduleExports) {
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
        this._unwrap(moduleExports.Channel.prototype, "publish");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
        this._unwrap(moduleExports.Channel.prototype, "consume");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
        this._unwrap(moduleExports.Channel.prototype, "ack");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
        this._unwrap(moduleExports.Channel.prototype, "nack");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
        this._unwrap(moduleExports.Channel.prototype, "reject");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
        this._unwrap(moduleExports.Channel.prototype, "ackAll");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
        this._unwrap(moduleExports.Channel.prototype, "nackAll");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
        this._unwrap(moduleExports.Channel.prototype, "emit");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
        this._unwrap(moduleExports.ConfirmChannel.prototype, "publish");
      }
      return moduleExports;
    }
    getConnectPatch(original) {
      return function patchedConnect(url, socketOptions, openCallback) {
        return original.call(this, url, socketOptions, function(err, conn) {
          if (err == null) {
            const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);
            const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);
            conn[utils_1.CONNECTION_ATTRIBUTES] = Object.assign(Object.assign({}, urlAttributes), serverAttributes);
          }
          openCallback.apply(this, arguments);
        });
      };
    }
    getChannelEmitPatch(original) {
      const self2 = this;
      return function emit(eventName) {
        if (eventName === "close") {
          self2.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);
          const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];
          if (activeTimer) {
            clearInterval(activeTimer);
          }
          this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;
        } else if (eventName === "error") {
          self2.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);
        }
        return original.apply(this, arguments);
      };
    }
    getAckAllPatch(isRejected, endOperation, original) {
      const self2 = this;
      return function ackAll(requeueOrEmpty) {
        self2.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);
        return original.apply(this, arguments);
      };
    }
    getAckPatch(isRejected, endOperation, original) {
      const self2 = this;
      return function ack(message, allUpToOrRequeue, requeue) {
        var _a2;
        const channel = this;
        const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;
        const spansNotEnded = (_a2 = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a2 !== undefined ? _a2 : [];
        const msgIndex = spansNotEnded.findIndex((msgDetails) => msgDetails.msg === message);
        if (msgIndex < 0) {
          self2.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
        } else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {
          for (let i = 0;i <= msgIndex; i++) {
            self2.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);
          }
          spansNotEnded.splice(0, msgIndex + 1);
        } else {
          self2.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
          spansNotEnded.splice(msgIndex, 1);
        }
        return original.apply(this, arguments);
      };
    }
    getConsumePatch(moduleVersion, original) {
      const self2 = this;
      return function consume(queue, onMessage, options) {
        const channel = this;
        if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {
          const { consumeTimeoutMs } = self2.getConfig();
          if (consumeTimeoutMs) {
            const timer = setInterval(() => {
              self2.checkConsumeTimeoutOnChannel(channel);
            }, consumeTimeoutMs);
            timer.unref();
            channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;
          }
          channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
        }
        const patchedOnMessage = function(msg) {
          var _a2, _b, _c, _d, _e;
          if (!msg) {
            return onMessage.call(this, msg);
          }
          const headers = (_a2 = msg.properties.headers) !== null && _a2 !== undefined ? _a2 : {};
          let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
          const exchange = (_b = msg.fields) === null || _b === undefined ? undefined : _b.exchange;
          let links;
          if (self2._config.useLinksForConsume) {
            const parentSpanContext = parentContext ? (_c = api_1.trace.getSpan(parentContext)) === null || _c === undefined ? undefined : _c.spanContext() : undefined;
            parentContext = undefined;
            if (parentSpanContext) {
              links = [
                {
                  context: parentSpanContext
                }
              ];
            }
          }
          const span = self2.tracer.startSpan(`${queue} process`, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: Object.assign(Object.assign({}, (_d = channel === null || channel === undefined ? undefined : channel.connection) === null || _d === undefined ? undefined : _d[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: (_e = msg.fields) === null || _e === undefined ? undefined : _e.routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg === null || msg === undefined ? undefined : msg.properties.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg === null || msg === undefined ? undefined : msg.properties.correlationId }),
            links
          }, parentContext);
          const { consumeHook } = self2.getConfig();
          if (consumeHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), (e) => {
              if (e) {
                api_1.diag.error("amqplib instrumentation: consumerHook error", e);
              }
            }, true);
          }
          if (!(options === null || options === undefined ? undefined : options.noAck)) {
            channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({
              msg,
              timeOfConsume: (0, core_1.hrTime)()
            });
            msg[utils_1.MESSAGE_STORED_SPAN] = span;
          }
          const setContext2 = parentContext ? parentContext : api_1.ROOT_CONTEXT;
          api_1.context.with(api_1.trace.setSpan(setContext2, span), () => {
            onMessage.call(this, msg);
          });
          if (options === null || options === undefined ? undefined : options.noAck) {
            self2.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);
            span.end();
          }
        };
        arguments[1] = patchedOnMessage;
        return original.apply(this, arguments);
      };
    }
    getConfirmedPublishPatch(moduleVersion, original) {
      const self2 = this;
      return function confirmedPublish(exchange, routingKey, content, options, callback) {
        const channel = this;
        const { span, modifiedOptions } = self2.createPublishSpan(self2, exchange, routingKey, channel, options);
        const { publishHook } = self2.getConfig();
        if (publishHook) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
            moduleVersion,
            exchange,
            routingKey,
            content,
            options: modifiedOptions,
            isConfirmChannel: true
          }), (e) => {
            if (e) {
              api_1.diag.error("amqplib instrumentation: publishHook error", e);
            }
          }, true);
        }
        const patchedOnConfirm = function(err, ok) {
          try {
            callback === null || callback === undefined || callback.call(this, err, ok);
          } finally {
            const { publishConfirmHook } = self2.getConfig();
            if (publishConfirmHook) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {
                moduleVersion,
                exchange,
                routingKey,
                content,
                options,
                isConfirmChannel: true,
                confirmError: err
              }), (e) => {
                if (e) {
                  api_1.diag.error("amqplib instrumentation: publishConfirmHook error", e);
                }
              }, true);
            }
            if (err) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: "message confirmation has been nack'ed"
              });
            }
            span.end();
          }
        };
        const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());
        const argumentsCopy = [...arguments];
        argumentsCopy[3] = modifiedOptions;
        argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);
        return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));
      };
    }
    getPublishPatch(moduleVersion, original) {
      const self2 = this;
      return function publish(exchange, routingKey, content, options) {
        if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {
          return original.apply(this, arguments);
        } else {
          const channel = this;
          const { span, modifiedOptions } = self2.createPublishSpan(self2, exchange, routingKey, channel, options);
          const { publishHook } = self2.getConfig();
          if (publishHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
              moduleVersion,
              exchange,
              routingKey,
              content,
              options: modifiedOptions,
              isConfirmChannel: false
            }), (e) => {
              if (e) {
                api_1.diag.error("amqplib instrumentation: publishHook error", e);
              }
            }, true);
          }
          const argumentsCopy = [...arguments];
          argumentsCopy[3] = modifiedOptions;
          const originalRes = original.apply(this, argumentsCopy);
          span.end();
          return originalRes;
        }
      };
    }
    createPublishSpan(self2, exchange, routingKey, channel, options) {
      var _a2;
      const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);
      const span = self2.tracer.startSpan(`publish ${normalizedExchange}`, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: Object.assign(Object.assign({}, channel.connection[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options === null || options === undefined ? undefined : options.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options === null || options === undefined ? undefined : options.correlationId })
      });
      const modifiedOptions = options !== null && options !== undefined ? options : {};
      modifiedOptions.headers = (_a2 = modifiedOptions.headers) !== null && _a2 !== undefined ? _a2 : {};
      api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);
      return { span, modifiedOptions };
    }
    endConsumerSpan(message, isRejected, operation, requeue) {
      const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];
      if (!storedSpan)
        return;
      if (isRejected !== false) {
        storedSpan.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: operation !== types_1.EndOperation.ChannelClosed && operation !== types_1.EndOperation.ChannelError ? `${operation} called on message${requeue === true ? " with requeue" : requeue === false ? " without requeue" : ""}` : operation
        });
      }
      this.callConsumeEndHook(storedSpan, message, isRejected, operation);
      storedSpan.end();
      message[utils_1.MESSAGE_STORED_SPAN] = undefined;
    }
    endAllSpansOnChannel(channel, isRejected, operation, requeue) {
      var _a2;
      const spansNotEnded = (_a2 = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a2 !== undefined ? _a2 : [];
      spansNotEnded.forEach((msgDetails) => {
        this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);
      });
      channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
    }
    callConsumeEndHook(span, msg, rejected, endOperation) {
      const { consumeEndHook } = this.getConfig();
      if (!consumeEndHook)
        return;
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), (e) => {
        if (e) {
          api_1.diag.error("amqplib instrumentation: consumerEndHook error", e);
        }
      }, true);
    }
    checkConsumeTimeoutOnChannel(channel) {
      var _a2;
      const currentTime = (0, core_1.hrTime)();
      const spansNotEnded = (_a2 = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a2 !== undefined ? _a2 : [];
      let i;
      const { consumeTimeoutMs } = this.getConfig();
      for (i = 0;i < spansNotEnded.length; i++) {
        const currMessage = spansNotEnded[i];
        const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);
        if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {
          break;
        }
        this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);
      }
      spansNotEnded.splice(0, i);
    }
  }
  exports.AmqplibInstrumentation = AmqplibInstrumentation;
});

// ../node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js
var require_src28 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_amqplib(), exports);
  __exportStar(require_types16(), exports);
});

// ../node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js
var require_AbstractAsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractAsyncHooksContextManager = undefined;
  var events_1 = import.meta.require("events");
  var ADD_LISTENER_METHODS = [
    "addListener",
    "on",
    "once",
    "prependListener",
    "prependOnceListener"
  ];

  class AbstractAsyncHooksContextManager {
    constructor() {
      this._kOtListeners = Symbol("OtListeners");
      this._wrapped = false;
    }
    bind(context8, target) {
      if (target instanceof events_1.EventEmitter) {
        return this._bindEventEmitter(context8, target);
      }
      if (typeof target === "function") {
        return this._bindFunction(context8, target);
      }
      return target;
    }
    _bindFunction(context8, target) {
      const manager = this;
      const contextWrapper = function(...args) {
        return manager.with(context8, () => target.apply(this, args));
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    }
    _bindEventEmitter(context8, ee) {
      const map = this._getPatchMap(ee);
      if (map !== undefined)
        return ee;
      this._createPatchMap(ee);
      ADD_LISTENER_METHODS.forEach((methodName) => {
        if (ee[methodName] === undefined)
          return;
        ee[methodName] = this._patchAddListener(ee, ee[methodName], context8);
      });
      if (typeof ee.removeListener === "function") {
        ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
      }
      if (typeof ee.off === "function") {
        ee.off = this._patchRemoveListener(ee, ee.off);
      }
      if (typeof ee.removeAllListeners === "function") {
        ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);
      }
      return ee;
    }
    _patchRemoveListener(ee, original) {
      const contextManager = this;
      return function(event, listener) {
        var _a2;
        const events = (_a2 = contextManager._getPatchMap(ee)) === null || _a2 === undefined ? undefined : _a2[event];
        if (events === undefined) {
          return original.call(this, event, listener);
        }
        const patchedListener = events.get(listener);
        return original.call(this, event, patchedListener || listener);
      };
    }
    _patchRemoveAllListeners(ee, original) {
      const contextManager = this;
      return function(event) {
        const map = contextManager._getPatchMap(ee);
        if (map !== undefined) {
          if (arguments.length === 0) {
            contextManager._createPatchMap(ee);
          } else if (map[event] !== undefined) {
            delete map[event];
          }
        }
        return original.apply(this, arguments);
      };
    }
    _patchAddListener(ee, original, context8) {
      const contextManager = this;
      return function(event, listener) {
        if (contextManager._wrapped) {
          return original.call(this, event, listener);
        }
        let map = contextManager._getPatchMap(ee);
        if (map === undefined) {
          map = contextManager._createPatchMap(ee);
        }
        let listeners = map[event];
        if (listeners === undefined) {
          listeners = new WeakMap;
          map[event] = listeners;
        }
        const patchedListener = contextManager.bind(context8, listener);
        listeners.set(listener, patchedListener);
        contextManager._wrapped = true;
        try {
          return original.call(this, event, patchedListener);
        } finally {
          contextManager._wrapped = false;
        }
      };
    }
    _createPatchMap(ee) {
      const map = Object.create(null);
      ee[this._kOtListeners] = map;
      return map;
    }
    _getPatchMap(ee) {
      return ee[this._kOtListeners];
    }
  }
  exports.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;
});

// ../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js
var require_AsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncHooksContextManager = undefined;
  var api_1 = require_src();
  var asyncHooks = import.meta.require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncHooksContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    constructor() {
      super();
      this._contexts = new Map;
      this._stack = [];
      this._asyncHook = asyncHooks.createHook({
        init: this._init.bind(this),
        before: this._before.bind(this),
        after: this._after.bind(this),
        destroy: this._destroy.bind(this),
        promiseResolve: this._destroy.bind(this)
      });
    }
    active() {
      var _a2;
      return (_a2 = this._stack[this._stack.length - 1]) !== null && _a2 !== undefined ? _a2 : api_1.ROOT_CONTEXT;
    }
    with(context8, fn, thisArg, ...args) {
      this._enterContext(context8);
      try {
        return fn.call(thisArg, ...args);
      } finally {
        this._exitContext();
      }
    }
    enable() {
      this._asyncHook.enable();
      return this;
    }
    disable() {
      this._asyncHook.disable();
      this._contexts.clear();
      this._stack = [];
      return this;
    }
    _init(uid, type) {
      if (type === "TIMERWRAP")
        return;
      const context8 = this._stack[this._stack.length - 1];
      if (context8 !== undefined) {
        this._contexts.set(uid, context8);
      }
    }
    _destroy(uid) {
      this._contexts.delete(uid);
    }
    _before(uid) {
      const context8 = this._contexts.get(uid);
      if (context8 !== undefined) {
        this._enterContext(context8);
      }
    }
    _after() {
      this._exitContext();
    }
    _enterContext(context8) {
      this._stack.push(context8);
    }
    _exitContext() {
      this._stack.pop();
    }
  }
  exports.AsyncHooksContextManager = AsyncHooksContextManager;
});

// ../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js
var require_AsyncLocalStorageContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = undefined;
  var api_1 = require_src();
  var async_hooks_1 = import.meta.require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    constructor() {
      super();
      this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage;
    }
    active() {
      var _a2;
      return (_a2 = this._asyncLocalStorage.getStore()) !== null && _a2 !== undefined ? _a2 : api_1.ROOT_CONTEXT;
    }
    with(context8, fn, thisArg, ...args) {
      const cb = thisArg == null ? fn : fn.bind(thisArg);
      return this._asyncLocalStorage.run(context8, cb, ...args);
    }
    enable() {
      return this;
    }
    disable() {
      this._asyncLocalStorage.disable();
      return this;
    }
  }
  exports.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager;
});

// ../node_modules/@opentelemetry/context-async-hooks/build/src/index.js
var require_src29 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = exports.AsyncHooksContextManager = undefined;
  var AsyncHooksContextManager_1 = require_AsyncHooksContextManager();
  Object.defineProperty(exports, "AsyncHooksContextManager", { enumerable: true, get: function() {
    return AsyncHooksContextManager_1.AsyncHooksContextManager;
  } });
  var AsyncLocalStorageContextManager_1 = require_AsyncLocalStorageContextManager();
  Object.defineProperty(exports, "AsyncLocalStorageContextManager", { enumerable: true, get: function() {
    return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager;
  } });
});

// ../node_modules/nanoid-dictionary/lowercase.js
var require_lowercase = __commonJS((exports, module) => {
  module.exports = "abcdefghijklmnopqrstuvwxyz";
});

// ../node_modules/nanoid-dictionary/uppercase.js
var require_uppercase = __commonJS((exports, module) => {
  module.exports = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
});

// ../node_modules/nanoid-dictionary/numbers.js
var require_numbers = __commonJS((exports, module) => {
  module.exports = "0123456789";
});

// ../node_modules/nanoid-dictionary/nolookalikes.js
var require_nolookalikes = __commonJS((exports, module) => {
  module.exports = "346789ABCDEFGHJKLMNPQRTUVWXYabcdefghijkmnpqrtwxyz";
});

// ../node_modules/nanoid-dictionary/nolookalikes-safe.js
var require_nolookalikes_safe = __commonJS((exports, module) => {
  module.exports = "6789BCDFGHJKLMNPQRTWbcdfghjkmnpqrtwz";
});

// ../node_modules/nanoid-dictionary/alphanumeric.js
var require_alphanumeric = __commonJS((exports, module) => {
  var numbers = require_numbers();
  var lowercase2 = require_lowercase();
  var uppercase2 = require_uppercase();
  module.exports = numbers + lowercase2 + uppercase2;
});

// ../node_modules/nanoid-dictionary/index.js
var require_nanoid_dictionary = __commonJS((exports, module) => {
  module.exports = {
    lowercase: require_lowercase(),
    uppercase: require_uppercase(),
    numbers: require_numbers(),
    nolookalikes: require_nolookalikes(),
    nolookalikesSafe: require_nolookalikes_safe(),
    alphanumeric: require_alphanumeric()
  };
});

// ../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key, value3) {
      httpHandler.updateHttpClientConfig(key, value3);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
}, resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};

// ../node_modules/@smithy/protocol-http/dist-es/extensions/index.js
var init_extensions = () => {
};

// ../node_modules/@smithy/types/dist-es/abort.js
var init_abort = () => {
};

// ../node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
var init_auth = __esm(() => {
  (function(HttpAuthLocation2) {
    HttpAuthLocation2["HEADER"] = "header";
    HttpAuthLocation2["QUERY"] = "query";
  })(HttpAuthLocation || (HttpAuthLocation = {}));
});

// ../node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
var init_HttpApiKeyAuth = __esm(() => {
  (function(HttpApiKeyAuthLocation2) {
    HttpApiKeyAuthLocation2["HEADER"] = "header";
    HttpApiKeyAuthLocation2["QUERY"] = "query";
  })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
});

// ../node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
var init_HttpAuthScheme = () => {
};

// ../node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
var init_HttpAuthSchemeProvider = () => {
};

// ../node_modules/@smithy/types/dist-es/auth/HttpSigner.js
var init_HttpSigner = () => {
};

// ../node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
var init_IdentityProviderConfig = () => {
};

// ../node_modules/@smithy/types/dist-es/auth/index.js
var init_auth2 = __esm(() => {
  init_auth();
  init_HttpApiKeyAuth();
  init_HttpAuthScheme();
  init_HttpAuthSchemeProvider();
  init_HttpSigner();
  init_IdentityProviderConfig();
});

// ../node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
var init_blob_payload_input_types = () => {
};

// ../node_modules/@smithy/types/dist-es/checksum.js
var init_checksum = () => {
};

// ../node_modules/@smithy/types/dist-es/client.js
var init_client = () => {
};

// ../node_modules/@smithy/types/dist-es/command.js
var init_command = () => {
};

// ../node_modules/@smithy/types/dist-es/connection/config.js
var init_config = () => {
};

// ../node_modules/@smithy/types/dist-es/connection/manager.js
var init_manager = () => {
};

// ../node_modules/@smithy/types/dist-es/connection/pool.js
var init_pool = () => {
};

// ../node_modules/@smithy/types/dist-es/connection/index.js
var init_connection = __esm(() => {
  init_config();
  init_manager();
  init_pool();
});

// ../node_modules/@smithy/types/dist-es/crypto.js
var init_crypto = () => {
};

// ../node_modules/@smithy/types/dist-es/encode.js
var init_encode = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
var init_endpoint = __esm(() => {
  (function(EndpointURLScheme2) {
    EndpointURLScheme2["HTTP"] = "http";
    EndpointURLScheme2["HTTPS"] = "https";
  })(EndpointURLScheme || (EndpointURLScheme = {}));
});

// ../node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
var init_EndpointRuleObject = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
var init_ErrorRuleObject = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
var init_RuleSetObject = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoints/shared.js
var init_shared = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
var init_TreeRuleObject = () => {
};

// ../node_modules/@smithy/types/dist-es/endpoints/index.js
var init_endpoints = __esm(() => {
  init_EndpointRuleObject();
  init_ErrorRuleObject();
  init_RuleSetObject();
  init_shared();
  init_TreeRuleObject();
});

// ../node_modules/@smithy/types/dist-es/eventStream.js
var init_eventStream = () => {
};

// ../node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
var init_checksum2 = __esm(() => {
  (function(AlgorithmId2) {
    AlgorithmId2["MD5"] = "md5";
    AlgorithmId2["CRC32"] = "crc32";
    AlgorithmId2["CRC32C"] = "crc32c";
    AlgorithmId2["SHA1"] = "sha1";
    AlgorithmId2["SHA256"] = "sha256";
  })(AlgorithmId || (AlgorithmId = {}));
});

// ../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
var init_defaultClientConfiguration = __esm(() => {
  init_checksum2();
});

// ../node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
var init_defaultExtensionConfiguration = () => {
};

// ../node_modules/@smithy/types/dist-es/extensions/index.js
var init_extensions2 = __esm(() => {
  init_defaultClientConfiguration();
  init_defaultExtensionConfiguration();
  init_checksum2();
});

// ../node_modules/@smithy/types/dist-es/feature-ids.js
var init_feature_ids = () => {
};

// ../node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
var init_http = __esm(() => {
  (function(FieldPosition2) {
    FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
    FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
  })(FieldPosition || (FieldPosition = {}));
});

// ../node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
var init_httpHandlerInitialization = () => {
};

// ../node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
var init_apiKeyIdentity = () => {
};

// ../node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
var init_awsCredentialIdentity = () => {
};

// ../node_modules/@smithy/types/dist-es/identity/identity.js
var init_identity = () => {
};

// ../node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
var init_tokenIdentity = () => {
};

// ../node_modules/@smithy/types/dist-es/identity/index.js
var init_identity2 = __esm(() => {
  init_apiKeyIdentity();
  init_awsCredentialIdentity();
  init_identity();
  init_tokenIdentity();
});

// ../node_modules/@smithy/types/dist-es/logger.js
var init_logger = () => {
};

// ../node_modules/@smithy/types/dist-es/middleware.js
var SMITHY_CONTEXT_KEY = "__smithy_context";

// ../node_modules/@smithy/types/dist-es/pagination.js
var init_pagination = () => {
};

// ../node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
var init_profile = __esm(() => {
  (function(IniSectionType2) {
    IniSectionType2["PROFILE"] = "profile";
    IniSectionType2["SSO_SESSION"] = "sso-session";
    IniSectionType2["SERVICES"] = "services";
  })(IniSectionType || (IniSectionType = {}));
});

// ../node_modules/@smithy/types/dist-es/response.js
var init_response = () => {
};

// ../node_modules/@smithy/types/dist-es/retry.js
var init_retry = () => {
};

// ../node_modules/@smithy/types/dist-es/serde.js
var init_serde = () => {
};

// ../node_modules/@smithy/types/dist-es/shapes.js
var init_shapes = () => {
};

// ../node_modules/@smithy/types/dist-es/signature.js
var init_signature = () => {
};

// ../node_modules/@smithy/types/dist-es/stream.js
var init_stream = () => {
};

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
var init_streaming_blob_common_types = () => {
};

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
var init_streaming_blob_payload_input_types = () => {
};

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
var init_streaming_blob_payload_output_types = () => {
};

// ../node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
var init_transfer = __esm(() => {
  (function(RequestHandlerProtocol2) {
    RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
  })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
});

// ../node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
var init_client_payload_blob_type_narrow = () => {
};

// ../node_modules/@smithy/types/dist-es/transform/no-undefined.js
var init_no_undefined = () => {
};

// ../node_modules/@smithy/types/dist-es/transform/type-transform.js
var init_type_transform = () => {
};

// ../node_modules/@smithy/types/dist-es/uri.js
var init_uri = () => {
};

// ../node_modules/@smithy/types/dist-es/util.js
var init_util = () => {
};

// ../node_modules/@smithy/types/dist-es/waiter.js
var init_waiter = () => {
};

// ../node_modules/@smithy/types/dist-es/index.js
var init_dist_es = __esm(() => {
  init_abort();
  init_auth2();
  init_blob_payload_input_types();
  init_checksum();
  init_client();
  init_command();
  init_connection();
  init_crypto();
  init_encode();
  init_endpoint();
  init_endpoints();
  init_eventStream();
  init_extensions2();
  init_feature_ids();
  init_http();
  init_httpHandlerInitialization();
  init_identity2();
  init_logger();
  init_pagination();
  init_profile();
  init_response();
  init_retry();
  init_serde();
  init_shapes();
  init_signature();
  init_stream();
  init_streaming_blob_common_types();
  init_streaming_blob_payload_input_types();
  init_streaming_blob_payload_output_types();
  init_transfer();
  init_client_payload_blob_type_narrow();
  init_no_undefined();
  init_type_transform();
  init_uri();
  init_util();
  init_waiter();
});

// ../node_modules/@smithy/protocol-http/dist-es/Field.js
var init_Field = __esm(() => {
  init_dist_es();
});
// ../node_modules/@smithy/protocol-http/dist-es/httpHandler.js
var init_httpHandler = () => {
};

// ../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static clone(request) {
    const cloned = new HttpRequest({
      ...request,
      headers: { ...request.headers }
    });
    if (cloned.query) {
      cloned.query = cloneQuery(cloned.query);
    }
    return cloned;
  }
  static isInstance(request) {
    if (!request) {
      return false;
    }
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    return HttpRequest.clone(this);
  }
}
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class HttpResponse {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response2) {
    if (!response2)
      return false;
    const resp = response2;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
}
// ../node_modules/@smithy/protocol-http/dist-es/types.js
var init_types = () => {
};

// ../node_modules/@smithy/protocol-http/dist-es/index.js
var init_dist_es2 = __esm(() => {
  init_extensions();
  init_Field();
  init_httpHandler();
  init_types();
});

// ../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
}, hostHeaderMiddlewareOptions, getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});
var init_dist_es3 = __esm(() => {
  init_dist_es2();
  hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
});

// ../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware = () => (next, context8) => async (args) => {
  try {
    const response2 = await next(args);
    const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context8.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response2.output;
    logger3?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response2;
  } catch (error5) {
    const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    logger3?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error: error5,
      metadata: error5.$metadata
    });
    throw error5;
  }
}, loggerMiddlewareOptions, getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});
var init_loggerMiddleware = __esm(() => {
  loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
});

// ../node_modules/@aws-sdk/middleware-logger/dist-es/index.js
var init_dist_es4 = __esm(() => {
  init_loggerMiddleware();
});

// ../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id", ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME", ENV_TRACE_ID = "_X_AMZN_TRACE_ID", recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
}, addRecursionDetectionMiddlewareOptions, getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});
var init_dist_es5 = __esm(() => {
  init_dist_es2();
  addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
});

// ../node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AlgorithmId: () => AlgorithmId2,
    EndpointURLScheme: () => EndpointURLScheme2,
    FieldPosition: () => FieldPosition2,
    HttpApiKeyAuthLocation: () => HttpApiKeyAuthLocation2,
    HttpAuthLocation: () => HttpAuthLocation2,
    IniSectionType: () => IniSectionType2,
    RequestHandlerProtocol: () => RequestHandlerProtocol2,
    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_KEY2,
    getDefaultClientConfiguration: () => getDefaultClientConfiguration,
    resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig
  });
  module.exports = __toCommonJS(src_exports);
  var HttpAuthLocation2 = /* @__PURE__ */ ((HttpAuthLocation22) => {
    HttpAuthLocation22["HEADER"] = "header";
    HttpAuthLocation22["QUERY"] = "query";
    return HttpAuthLocation22;
  })(HttpAuthLocation2 || {});
  var HttpApiKeyAuthLocation2 = /* @__PURE__ */ ((HttpApiKeyAuthLocation22) => {
    HttpApiKeyAuthLocation22["HEADER"] = "header";
    HttpApiKeyAuthLocation22["QUERY"] = "query";
    return HttpApiKeyAuthLocation22;
  })(HttpApiKeyAuthLocation2 || {});
  var EndpointURLScheme2 = /* @__PURE__ */ ((EndpointURLScheme22) => {
    EndpointURLScheme22["HTTP"] = "http";
    EndpointURLScheme22["HTTPS"] = "https";
    return EndpointURLScheme22;
  })(EndpointURLScheme2 || {});
  var AlgorithmId2 = /* @__PURE__ */ ((AlgorithmId22) => {
    AlgorithmId22["MD5"] = "md5";
    AlgorithmId22["CRC32"] = "crc32";
    AlgorithmId22["CRC32C"] = "crc32c";
    AlgorithmId22["SHA1"] = "sha1";
    AlgorithmId22["SHA256"] = "sha256";
    return AlgorithmId22;
  })(AlgorithmId2 || {});
  var getChecksumConfiguration2 = /* @__PURE__ */ __name((runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
      checksumAlgorithms.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => runtimeConfig.sha256
      });
    }
    if (runtimeConfig.md5 != null) {
      checksumAlgorithms.push({
        algorithmId: () => "md5",
        checksumConstructor: () => runtimeConfig.md5
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  }, "getChecksumConfiguration");
  var resolveChecksumRuntimeConfig2 = /* @__PURE__ */ __name((clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  }, "resolveChecksumRuntimeConfig");
  var getDefaultClientConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    return {
      ...getChecksumConfiguration2(runtimeConfig)
    };
  }, "getDefaultClientConfiguration");
  var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name((config3) => {
    return {
      ...resolveChecksumRuntimeConfig2(config3)
    };
  }, "resolveDefaultRuntimeConfig");
  var FieldPosition2 = /* @__PURE__ */ ((FieldPosition22) => {
    FieldPosition22[FieldPosition22["HEADER"] = 0] = "HEADER";
    FieldPosition22[FieldPosition22["TRAILER"] = 1] = "TRAILER";
    return FieldPosition22;
  })(FieldPosition2 || {});
  var SMITHY_CONTEXT_KEY2 = "__smithy_context";
  var IniSectionType2 = /* @__PURE__ */ ((IniSectionType22) => {
    IniSectionType22["PROFILE"] = "profile";
    IniSectionType22["SSO_SESSION"] = "sso-session";
    IniSectionType22["SERVICES"] = "services";
    return IniSectionType22;
  })(IniSectionType2 || {});
  var RequestHandlerProtocol2 = /* @__PURE__ */ ((RequestHandlerProtocol22) => {
    RequestHandlerProtocol22["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol22["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol22["TDS_8_0"] = "tds/8.0";
    return RequestHandlerProtocol22;
  })(RequestHandlerProtocol2 || {});
});

// ../node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    getSmithyContext: () => getSmithyContext,
    normalizeProvider: () => normalizeProvider
  });
  module.exports = __toCommonJS(src_exports);
  var import_types4 = require_dist_cjs();
  var getSmithyContext = /* @__PURE__ */ __name((context8) => context8[import_types4.SMITHY_CONTEXT_KEY] || (context8[import_types4.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");
  var normalizeProvider = /* @__PURE__ */ __name((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");
});

// ../node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    deserializerMiddleware: () => deserializerMiddleware,
    deserializerMiddlewareOption: () => deserializerMiddlewareOption,
    getSerdePlugin: () => getSerdePlugin,
    serializerMiddleware: () => serializerMiddleware,
    serializerMiddlewareOption: () => serializerMiddlewareOption
  });
  module.exports = __toCommonJS(src_exports);
  var deserializerMiddleware = /* @__PURE__ */ __name((options, deserializer) => (next) => async (args) => {
    const { response: response2 } = await next(args);
    try {
      const parsed = await deserializer(response2, options);
      return {
        response: response2,
        output: parsed
      };
    } catch (error5) {
      Object.defineProperty(error5, "$response", {
        value: response2
      });
      if (!("$metadata" in error5)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.\$response on this object.`;
        error5.message += "\n  " + hint;
        if (typeof error5.$responseBodyText !== "undefined") {
          if (error5.$response) {
            error5.$response.body = error5.$responseBodyText;
          }
        }
      }
      throw error5;
    }
  }, "deserializerMiddleware");
  var serializerMiddleware = /* @__PURE__ */ __name((options, serializer) => (next, context8) => async (args) => {
    var _a2;
    const endpoint2 = ((_a2 = context8.endpointV2) == null ? undefined : _a2.url) && options.urlParser ? async () => options.urlParser(context8.endpointV2.url) : options.endpoint;
    if (!endpoint2) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint: endpoint2 });
    return next({
      ...args,
      request
    });
  }, "serializerMiddleware");
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config3, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config3, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config3, serializer), serializerMiddlewareOption);
      }
    };
  }
  __name(getSerdePlugin, "getSerdePlugin");
});

// ../node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs4 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Field: () => Field2,
    Fields: () => Fields2,
    HttpRequest: () => HttpRequest2,
    HttpResponse: () => HttpResponse2,
    IHttpRequest: () => import_types4.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => getHttpHandlerExtensionConfiguration2,
    isValidHostname: () => isValidHostname2,
    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfig2
  });
  module.exports = __toCommonJS(src_exports);
  var getHttpHandlerExtensionConfiguration2 = /* @__PURE__ */ __name((runtimeConfig) => {
    let httpHandler2 = runtimeConfig.httpHandler;
    return {
      setHttpHandler(handler) {
        httpHandler2 = handler;
      },
      httpHandler() {
        return httpHandler2;
      },
      updateHttpClientConfig(key, value3) {
        httpHandler2.updateHttpClientConfig(key, value3);
      },
      httpHandlerConfigs() {
        return httpHandler2.httpHandlerConfigs();
      }
    };
  }, "getHttpHandlerExtensionConfiguration");
  var resolveHttpHandlerRuntimeConfig2 = /* @__PURE__ */ __name((httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  }, "resolveHttpHandlerRuntimeConfig");
  var import_types4 = require_dist_cjs();
  var _Field = class _Field2 {
    constructor({ name, kind = import_types4.FieldPosition.HEADER, values: values2 = [] }) {
      this.name = name;
      this.kind = kind;
      this.values = values2;
    }
    add(value3) {
      this.values.push(value3);
    }
    set(values2) {
      this.values = values2;
    }
    remove(value3) {
      this.values = this.values.filter((v4) => v4 !== value3);
    }
    toString() {
      return this.values.map((v4) => v4.includes(",") || v4.includes(" ") ? `"${v4}"` : v4).join(", ");
    }
    get() {
      return this.values;
    }
  };
  __name(_Field, "Field");
  var Field2 = _Field;
  var _Fields = class _Fields2 {
    constructor({ fields = [], encoding = "utf-8" }) {
      this.entries = {};
      fields.forEach(this.setField.bind(this));
      this.encoding = encoding;
    }
    setField(field) {
      this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
      return this.entries[name.toLowerCase()];
    }
    removeField(name) {
      delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
      return Object.values(this.entries).filter((field) => field.kind === kind);
    }
  };
  __name(_Fields, "Fields");
  var Fields2 = _Fields;
  var _HttpRequest = class _HttpRequest2 {
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static clone(request) {
      const cloned = new _HttpRequest2({
        ...request,
        headers: { ...request.headers }
      });
      if (cloned.query) {
        cloned.query = cloneQuery2(cloned.query);
      }
      return cloned;
    }
    static isInstance(request) {
      if (!request) {
        return false;
      }
      const req = request;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      return _HttpRequest2.clone(this);
    }
  };
  __name(_HttpRequest, "HttpRequest");
  var HttpRequest2 = _HttpRequest;
  function cloneQuery2(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
  __name(cloneQuery2, "cloneQuery");
  var _HttpResponse = class _HttpResponse2 {
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response2) {
      if (!response2)
        return false;
      const resp = response2;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  };
  __name(_HttpResponse, "HttpResponse");
  var HttpResponse2 = _HttpResponse;
  function isValidHostname2(hostname3) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname3);
  }
  __name(isValidHostname2, "isValidHostname");
});

// ../node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs5 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    isArrayBuffer: () => isArrayBuffer
  });
  module.exports = __toCommonJS(src_exports);
  var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
});

// ../node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromArrayBuffer: () => fromArrayBuffer,
    fromString: () => fromString
  });
  module.exports = __toCommonJS(src_exports);
  var import_is_array_buffer = require_dist_cjs5();
  var import_buffer = import.meta.require("buffer");
  var fromArrayBuffer = /* @__PURE__ */ __name((input, offset = 0, length = input.byteLength - offset) => {
    if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return import_buffer.Buffer.from(input, offset, length);
  }, "fromArrayBuffer");
  var fromString = /* @__PURE__ */ __name((input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? import_buffer.Buffer.from(input, encoding) : import_buffer.Buffer.from(input);
  }, "fromString");
});

// ../node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs6();
  var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
  var fromBase642 = (input) => {
    if (input.length * 3 % 4 !== 0) {
      throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
      throw new TypeError(`Invalid base64 string.`);
    }
    const buffer2 = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  };
  exports.fromBase64 = fromBase642;
});

// ../node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromUtf8: () => fromUtf8,
    toUint8Array: () => toUint8Array,
    toUtf8: () => toUtf8
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_buffer_from = require_dist_cjs6();
  var fromUtf8 = /* @__PURE__ */ __name((input) => {
    const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }, "fromUtf8");
  var toUint8Array = /* @__PURE__ */ __name((data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }, "toUint8Array");
  var toUtf8 = /* @__PURE__ */ __name((input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  }, "toUtf8");
});

// ../node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs6();
  var util_utf8_1 = require_dist_cjs7();
  var toBase642 = (_input) => {
    let input;
    if (typeof _input === "string") {
      input = (0, util_utf8_1.fromUtf8)(_input);
    } else {
      input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  };
  exports.toBase64 = toBase642;
});

// ../node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs8 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  module.exports = __toCommonJS(src_exports);
  __reExport(src_exports, require_fromBase64(), module.exports);
  __reExport(src_exports, require_toBase64(), module.exports);
});

// ../node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = undefined;
  var stream_1 = import.meta.require("stream");
  var getAwsChunkedEncodingStream2 = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => {
    } });
    readableStream.on("data", (data) => {
      const length = bodyLengthChecker(data) || 0;
      awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
      awsChunkedEncodingStream.push(data);
      awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
      awsChunkedEncodingStream.push(`0\r\n`);
      if (checksumRequired) {
        const checksum2 = base64Encoder(await digest);
        awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum2}\r\n`);
        awsChunkedEncodingStream.push(`\r\n`);
      }
      awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
  };
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream2;
});

// ../node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    escapeUri: () => escapeUri,
    escapeUriPath: () => escapeUriPath
  });
  module.exports = __toCommonJS(src_exports);
  var escapeUri = /* @__PURE__ */ __name((uri2) => encodeURIComponent(uri2).replace(/[!'()*]/g, hexEncode), "escapeUri");
  var hexEncode = /* @__PURE__ */ __name((c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode");
  var escapeUriPath = /* @__PURE__ */ __name((uri2) => uri2.split("/").map(escapeUri).join("/"), "escapeUriPath");
});

// ../node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs10 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    buildQueryString: () => buildQueryString
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_uri_escape = require_dist_cjs9();
  function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
      const value3 = query[key];
      key = (0, import_util_uri_escape.escapeUri)(key);
      if (Array.isArray(value3)) {
        for (let i3 = 0, iLen = value3.length;i3 < iLen; i3++) {
          parts.push(`${key}=${(0, import_util_uri_escape.escapeUri)(value3[i3])}`);
        }
      } else {
        let qsEntry = key;
        if (value3 || typeof value3 === "string") {
          qsEntry += `=${(0, import_util_uri_escape.escapeUri)(value3)}`;
        }
        parts.push(qsEntry);
      }
    }
    return parts.join("&");
  }
  __name(buildQueryString, "buildQueryString");
});

// ../node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs11 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DEFAULT_REQUEST_TIMEOUT: () => DEFAULT_REQUEST_TIMEOUT,
    NodeHttp2Handler: () => NodeHttp2Handler,
    NodeHttpHandler: () => NodeHttpHandler,
    streamCollector: () => streamCollector
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http3 = require_dist_cjs4();
  var import_querystring_builder = require_dist_cjs10();
  var import_http4 = import.meta.require("http");
  var import_https = import.meta.require("https");
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  var getTransformedHeaders = /* @__PURE__ */ __name((headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
      const headerValues = headers[name];
      transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
  }, "getTransformedHeaders");
  var DEFER_EVENT_LISTENER_TIME = 1000;
  var setConnectionTimeout = /* @__PURE__ */ __name((request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
      return -1;
    }
    const registerTimeout = /* @__PURE__ */ __name((offset) => {
      const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs - offset);
      const doWithSocket = /* @__PURE__ */ __name((socket) => {
        if (socket == null ? undefined : socket.connecting) {
          socket.on("connect", () => {
            clearTimeout(timeoutId);
          });
        } else {
          clearTimeout(timeoutId);
        }
      }, "doWithSocket");
      if (request.socket) {
        doWithSocket(request.socket);
      } else {
        request.on("socket", doWithSocket);
      }
    }, "registerTimeout");
    if (timeoutInMs < 2000) {
      registerTimeout(0);
      return 0;
    }
    return setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
  }, "setConnectionTimeout");
  var DEFER_EVENT_LISTENER_TIME2 = 3000;
  var setSocketKeepAlive = /* @__PURE__ */ __name((request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME2) => {
    if (keepAlive !== true) {
      return -1;
    }
    const registerListener = /* @__PURE__ */ __name(() => {
      if (request.socket) {
        request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      } else {
        request.on("socket", (socket) => {
          socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        });
      }
    }, "registerListener");
    if (deferTimeMs === 0) {
      registerListener();
      return 0;
    }
    return setTimeout(registerListener, deferTimeMs);
  }, "setSocketKeepAlive");
  var DEFER_EVENT_LISTENER_TIME3 = 3000;
  var setSocketTimeout = /* @__PURE__ */ __name((request, reject, timeoutInMs = 0) => {
    const registerTimeout = /* @__PURE__ */ __name((offset) => {
      request.setTimeout(timeoutInMs - offset, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
      });
    }, "registerTimeout");
    if (0 < timeoutInMs && timeoutInMs < 6000) {
      registerTimeout(0);
      return 0;
    }
    return setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME3), DEFER_EVENT_LISTENER_TIME3);
  }, "setSocketTimeout");
  var import_stream3 = import.meta.require("stream");
  var MIN_WAIT_TIME = 1000;
  async function writeRequestBody(httpRequest2, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
      await Promise.race([
        new Promise((resolve3) => {
          timeoutId = Number(setTimeout(resolve3, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
        }),
        new Promise((resolve3) => {
          httpRequest2.on("continue", () => {
            clearTimeout(timeoutId);
            resolve3();
          });
          httpRequest2.on("error", () => {
            hasError = true;
            clearTimeout(timeoutId);
            resolve3();
          });
        })
      ]);
    }
    if (!hasError) {
      writeBody(httpRequest2, request.body);
    }
  }
  __name(writeRequestBody, "writeRequestBody");
  function writeBody(httpRequest2, body) {
    if (body instanceof import_stream3.Readable) {
      body.pipe(httpRequest2);
      return;
    }
    if (body) {
      if (Buffer.isBuffer(body) || typeof body === "string") {
        httpRequest2.end(body);
        return;
      }
      const uint8 = body;
      if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
        httpRequest2.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
        return;
      }
      httpRequest2.end(Buffer.from(body));
      return;
    }
    httpRequest2.end();
  }
  __name(writeBody, "writeBody");
  var DEFAULT_REQUEST_TIMEOUT = 0;
  var _NodeHttpHandler = class _NodeHttpHandler2 {
    constructor(options) {
      this.socketWarningTimestamp = 0;
      this.metadata = { handlerProtocol: "http/1.1" };
      this.configProvider = new Promise((resolve3, reject) => {
        if (typeof options === "function") {
          options().then((_options) => {
            resolve3(this.resolveDefaultConfig(_options));
          }).catch(reject);
        } else {
          resolve3(this.resolveDefaultConfig(options));
        }
      });
    }
    static create(instanceOrOptions) {
      if (typeof (instanceOrOptions == null ? undefined : instanceOrOptions.handle) === "function") {
        return instanceOrOptions;
      }
      return new _NodeHttpHandler2(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger3 = console) {
      var _a2, _b, _c;
      const { sockets, requests, maxSockets } = agent;
      if (typeof maxSockets !== "number" || maxSockets === Infinity) {
        return socketWarningTimestamp;
      }
      const interval2 = 15000;
      if (Date.now() - interval2 < socketWarningTimestamp) {
        return socketWarningTimestamp;
      }
      if (sockets && requests) {
        for (const origin in sockets) {
          const socketsInUse = ((_a2 = sockets[origin]) == null ? undefined : _a2.length) ?? 0;
          const requestsEnqueued = ((_b = requests[origin]) == null ? undefined : _b.length) ?? 0;
          if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
            (_c = logger3 == null ? undefined : logger3.warn) == null || _c.call(logger3, `@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
            return Date.now();
          }
        }
      }
      return socketWarningTimestamp;
    }
    resolveDefaultConfig(options) {
      const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
      const keepAlive = true;
      const maxSockets = 50;
      return {
        connectionTimeout,
        requestTimeout: requestTimeout ?? socketTimeout,
        httpAgent: (() => {
          if (httpAgent instanceof import_http4.Agent || typeof (httpAgent == null ? undefined : httpAgent.destroy) === "function") {
            return httpAgent;
          }
          return new import_http4.Agent({ keepAlive, maxSockets, ...httpAgent });
        })(),
        httpsAgent: (() => {
          if (httpsAgent instanceof import_https.Agent || typeof (httpsAgent == null ? undefined : httpsAgent.destroy) === "function") {
            return httpsAgent;
          }
          return new import_https.Agent({ keepAlive, maxSockets, ...httpsAgent });
        })(),
        logger: console
      };
    }
    destroy() {
      var _a2, _b, _c, _d;
      (_b = (_a2 = this.config) == null ? undefined : _a2.httpAgent) == null || _b.destroy();
      (_d = (_c = this.config) == null ? undefined : _c.httpsAgent) == null || _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      return new Promise((_resolve, _reject) => {
        let writeRequestBodyPromise = undefined;
        const timeouts = [];
        const resolve3 = /* @__PURE__ */ __name(async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(clearTimeout);
          _resolve(arg);
        }, "resolve");
        const reject = /* @__PURE__ */ __name(async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(clearTimeout);
          _reject(arg);
        }, "reject");
        if (!this.config) {
          throw new Error("Node HTTP request handler config is not resolved");
        }
        if (abortSignal == null ? undefined : abortSignal.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const isSSL = request.protocol === "https:";
        const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
        timeouts.push(setTimeout(() => {
          this.socketWarningTimestamp = _NodeHttpHandler2.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);
        }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
        const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
        let auth3 = undefined;
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth3 = `${username}:${password}`;
        }
        let path4 = request.path;
        if (queryString) {
          path4 += `?${queryString}`;
        }
        if (request.fragment) {
          path4 += `#${request.fragment}`;
        }
        let hostname3 = request.hostname ?? "";
        if (hostname3[0] === "[" && hostname3.endsWith("]")) {
          hostname3 = request.hostname.slice(1, -1);
        } else {
          hostname3 = request.hostname;
        }
        const nodeHttpsOptions = {
          headers: request.headers,
          host: hostname3,
          method: request.method,
          path: path4,
          port: request.port,
          agent,
          auth: auth3
        };
        const requestFunc = isSSL ? import_https.request : import_http4.request;
        const req = requestFunc(nodeHttpsOptions, (res) => {
          const httpResponse2 = new import_protocol_http3.HttpResponse({
            statusCode: res.statusCode || -1,
            reason: res.statusMessage,
            headers: getTransformedHeaders(res.headers),
            body: res
          });
          resolve3({ response: httpResponse2 });
        });
        req.on("error", (err) => {
          if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
            reject(Object.assign(err, { name: "TimeoutError" }));
          } else {
            reject(err);
          }
        });
        if (abortSignal) {
          const onAbort = /* @__PURE__ */ __name(() => {
            req.destroy();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
        timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
        const httpAgent = nodeHttpsOptions.agent;
        if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
          timeouts.push(setSocketKeepAlive(req, {
            keepAlive: httpAgent.keepAlive,
            keepAliveMsecs: httpAgent.keepAliveMsecs
          }));
        }
        writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch((e) => {
          timeouts.forEach(clearTimeout);
          return _reject(e);
        });
      });
    }
    updateHttpClientConfig(key, value3) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config3) => {
        return {
          ...config3,
          [key]: value3
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  };
  __name(_NodeHttpHandler, "NodeHttpHandler");
  var NodeHttpHandler = _NodeHttpHandler;
  var import_http22 = import.meta.require("http2");
  var import_http23 = __toESM2(import.meta.require("http2"));
  var _NodeHttp2ConnectionPool = class _NodeHttp2ConnectionPool2 {
    constructor(sessions3) {
      this.sessions = [];
      this.sessions = sessions3 ?? [];
    }
    poll() {
      if (this.sessions.length > 0) {
        return this.sessions.shift();
      }
    }
    offerLast(session) {
      this.sessions.push(session);
    }
    contains(session) {
      return this.sessions.includes(session);
    }
    remove(session) {
      this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]();
    }
    destroy(connection3) {
      for (const session of this.sessions) {
        if (session === connection3) {
          if (!session.destroyed) {
            session.destroy();
          }
        }
      }
    }
  };
  __name(_NodeHttp2ConnectionPool, "NodeHttp2ConnectionPool");
  var NodeHttp2ConnectionPool = _NodeHttp2ConnectionPool;
  var _NodeHttp2ConnectionManager = class _NodeHttp2ConnectionManager2 {
    constructor(config3) {
      this.sessionCache = /* @__PURE__ */ new Map;
      this.config = config3;
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrency must be greater than zero.");
      }
    }
    lease(requestContext, connectionConfiguration) {
      const url = this.getUrlString(requestContext);
      const existingPool = this.sessionCache.get(url);
      if (existingPool) {
        const existingSession = existingPool.poll();
        if (existingSession && !this.config.disableConcurrency) {
          return existingSession;
        }
      }
      const session = import_http23.default.connect(url);
      if (this.config.maxConcurrency) {
        session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
          if (err) {
            throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
          }
        });
      }
      session.unref();
      const destroySessionCb = /* @__PURE__ */ __name(() => {
        session.destroy();
        this.deleteSession(url, session);
      }, "destroySessionCb");
      session.on("goaway", destroySessionCb);
      session.on("error", destroySessionCb);
      session.on("frameError", destroySessionCb);
      session.on("close", () => this.deleteSession(url, session));
      if (connectionConfiguration.requestTimeout) {
        session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
      }
      const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool;
      connectionPool.offerLast(session);
      this.sessionCache.set(url, connectionPool);
      return session;
    }
    deleteSession(authority, session) {
      const existingConnectionPool = this.sessionCache.get(authority);
      if (!existingConnectionPool) {
        return;
      }
      if (!existingConnectionPool.contains(session)) {
        return;
      }
      existingConnectionPool.remove(session);
      this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
      var _a2;
      const cacheKey = this.getUrlString(requestContext);
      (_a2 = this.sessionCache.get(cacheKey)) == null || _a2.offerLast(session);
    }
    destroy() {
      for (const [key, connectionPool] of this.sessionCache) {
        for (const session of connectionPool) {
          if (!session.destroyed) {
            session.destroy();
          }
          connectionPool.remove(session);
        }
        this.sessionCache.delete(key);
      }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrentStreams must be greater than zero.");
      }
      this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
      this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
      return request.destination.toString();
    }
  };
  __name(_NodeHttp2ConnectionManager, "NodeHttp2ConnectionManager");
  var NodeHttp2ConnectionManager = _NodeHttp2ConnectionManager;
  var _NodeHttp2Handler = class _NodeHttp2Handler2 {
    constructor(options) {
      this.metadata = { handlerProtocol: "h2" };
      this.connectionManager = new NodeHttp2ConnectionManager({});
      this.configProvider = new Promise((resolve3, reject) => {
        if (typeof options === "function") {
          options().then((opts) => {
            resolve3(opts || {});
          }).catch(reject);
        } else {
          resolve3(options || {});
        }
      });
    }
    static create(instanceOrOptions) {
      if (typeof (instanceOrOptions == null ? undefined : instanceOrOptions.handle) === "function") {
        return instanceOrOptions;
      }
      return new _NodeHttp2Handler2(instanceOrOptions);
    }
    destroy() {
      this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
        if (this.config.maxConcurrentStreams) {
          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
        }
      }
      const { requestTimeout, disableConcurrentStreams } = this.config;
      return new Promise((_resolve, _reject) => {
        var _a2;
        let fulfilled = false;
        let writeRequestBodyPromise = undefined;
        const resolve3 = /* @__PURE__ */ __name(async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        }, "resolve");
        const reject = /* @__PURE__ */ __name(async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        }, "reject");
        if (abortSignal == null ? undefined : abortSignal.aborted) {
          fulfilled = true;
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const { hostname: hostname3, method, port, protocol, query } = request;
        let auth3 = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth3 = `${username}:${password}@`;
        }
        const authority = `${protocol}//${auth3}${hostname3}${port ? `:${port}` : ""}`;
        const requestContext = { destination: new URL(authority) };
        const session = this.connectionManager.lease(requestContext, {
          requestTimeout: (_a2 = this.config) == null ? undefined : _a2.sessionTimeout,
          disableConcurrentStreams: disableConcurrentStreams || false
        });
        const rejectWithDestroy = /* @__PURE__ */ __name((err) => {
          if (disableConcurrentStreams) {
            this.destroySession(session);
          }
          fulfilled = true;
          reject(err);
        }, "rejectWithDestroy");
        const queryString = (0, import_querystring_builder.buildQueryString)(query || {});
        let path4 = request.path;
        if (queryString) {
          path4 += `?${queryString}`;
        }
        if (request.fragment) {
          path4 += `#${request.fragment}`;
        }
        const req = session.request({
          ...request.headers,
          [import_http22.constants.HTTP2_HEADER_PATH]: path4,
          [import_http22.constants.HTTP2_HEADER_METHOD]: method
        });
        session.ref();
        req.on("response", (headers) => {
          const httpResponse2 = new import_protocol_http3.HttpResponse({
            statusCode: headers[":status"] || -1,
            headers: getTransformedHeaders(headers),
            body: req
          });
          fulfilled = true;
          resolve3({ response: httpResponse2 });
          if (disableConcurrentStreams) {
            session.close();
            this.connectionManager.deleteSession(authority, session);
          }
        });
        if (requestTimeout) {
          req.setTimeout(requestTimeout, () => {
            req.close();
            const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
            timeoutError.name = "TimeoutError";
            rejectWithDestroy(timeoutError);
          });
        }
        if (abortSignal) {
          const onAbort = /* @__PURE__ */ __name(() => {
            req.close();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            rejectWithDestroy(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        req.on("frameError", (type5, code, id) => {
          rejectWithDestroy(new Error(`Frame type id ${type5} in stream id ${id} has failed with code ${code}.`));
        });
        req.on("error", rejectWithDestroy);
        req.on("aborted", () => {
          rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
        });
        req.on("close", () => {
          session.unref();
          if (disableConcurrentStreams) {
            session.destroy();
          }
          if (!fulfilled) {
            rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
          }
        });
        writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
      });
    }
    updateHttpClientConfig(key, value3) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config3) => {
        return {
          ...config3,
          [key]: value3
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
    destroySession(session) {
      if (!session.destroyed) {
        session.destroy();
      }
    }
  };
  __name(_NodeHttp2Handler, "NodeHttp2Handler");
  var NodeHttp2Handler = _NodeHttp2Handler;
  var _Collector = class _Collector2 extends import_stream3.Writable {
    constructor() {
      super(...arguments);
      this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  };
  __name(_Collector, "Collector");
  var Collector = _Collector;
  var streamCollector = /* @__PURE__ */ __name((stream2) => {
    if (isReadableStreamInstance(stream2)) {
      return collectReadableStream(stream2);
    }
    return new Promise((resolve3, reject) => {
      const collector = new Collector;
      stream2.pipe(collector);
      stream2.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve3(bytes);
      });
    });
  }, "streamCollector");
  var isReadableStreamInstance = /* @__PURE__ */ __name((stream2) => typeof ReadableStream === "function" && stream2 instanceof ReadableStream, "isReadableStreamInstance");
  async function collectReadableStream(stream2) {
    const chunks = [];
    const reader = stream2.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value: value3 } = await reader.read();
      if (value3) {
        chunks.push(value3);
        length += value3.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  __name(collectReadableStream, "collectReadableStream");
});

// ../node_modules/@smithy/util-stream/node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs12 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    FetchHttpHandler: () => FetchHttpHandler,
    keepAliveSupport: () => keepAliveSupport,
    streamCollector: () => streamCollector
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http3 = require_dist_cjs4();
  var import_querystring_builder = require_dist_cjs10();
  function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve3, reject) => {
      if (timeoutInMs) {
        setTimeout(() => {
          const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
          timeoutError.name = "TimeoutError";
          reject(timeoutError);
        }, timeoutInMs);
      }
    });
  }
  __name(requestTimeout, "requestTimeout");
  var keepAliveSupport = {
    supported: undefined
  };
  var _FetchHttpHandler = class _FetchHttpHandler2 {
    static create(instanceOrOptions) {
      if (typeof (instanceOrOptions == null ? undefined : instanceOrOptions.handle) === "function") {
        return instanceOrOptions;
      }
      return new _FetchHttpHandler2(instanceOrOptions);
    }
    constructor(options) {
      if (typeof options === "function") {
        this.configProvider = options().then((opts) => opts || {});
      } else {
        this.config = options ?? {};
        this.configProvider = Promise.resolve(this.config);
      }
      if (keepAliveSupport.supported === undefined) {
        keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"));
      }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
      var _a2;
      if (!this.config) {
        this.config = await this.configProvider;
      }
      const requestTimeoutInMs = this.config.requestTimeout;
      const keepAlive = this.config.keepAlive === true;
      const credentials = this.config.credentials;
      if (abortSignal == null ? undefined : abortSignal.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        return Promise.reject(abortError);
      }
      let path4 = request.path;
      const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
      if (queryString) {
        path4 += `?${queryString}`;
      }
      if (request.fragment) {
        path4 += `#${request.fragment}`;
      }
      let auth3 = "";
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth3 = `${username}:${password}@`;
      }
      const { port, method } = request;
      const url = `${request.protocol}//${auth3}${request.hostname}${port ? `:${port}` : ""}${path4}`;
      const body = method === "GET" || method === "HEAD" ? undefined : request.body;
      const requestOptions = {
        body,
        headers: new Headers(request.headers),
        method,
        credentials
      };
      if ((_a2 = this.config) == null ? undefined : _a2.cache) {
        requestOptions.cache = this.config.cache;
      }
      if (body) {
        requestOptions.duplex = "half";
      }
      if (typeof AbortController !== "undefined") {
        requestOptions.signal = abortSignal;
      }
      if (keepAliveSupport.supported) {
        requestOptions.keepalive = keepAlive;
      }
      if (typeof this.config.requestInit === "function") {
        Object.assign(requestOptions, this.config.requestInit(request));
      }
      let removeSignalEventListener = /* @__PURE__ */ __name(() => {
      }, "removeSignalEventListener");
      const fetchRequest = new Request(url, requestOptions);
      const raceOfPromises = [
        fetch(fetchRequest).then((response2) => {
          const fetchHeaders = response2.headers;
          const transformedHeaders = {};
          for (const pair of fetchHeaders.entries()) {
            transformedHeaders[pair[0]] = pair[1];
          }
          const hasReadableStream = response2.body != null;
          if (!hasReadableStream) {
            return response2.blob().then((body2) => ({
              response: new import_protocol_http3.HttpResponse({
                headers: transformedHeaders,
                reason: response2.statusText,
                statusCode: response2.status,
                body: body2
              })
            }));
          }
          return {
            response: new import_protocol_http3.HttpResponse({
              headers: transformedHeaders,
              reason: response2.statusText,
              statusCode: response2.status,
              body: response2.body
            })
          };
        }),
        requestTimeout(requestTimeoutInMs)
      ];
      if (abortSignal) {
        raceOfPromises.push(new Promise((resolve3, reject) => {
          const onAbort = /* @__PURE__ */ __name(() => {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            removeSignalEventListener = /* @__PURE__ */ __name(() => signal.removeEventListener("abort", onAbort), "removeSignalEventListener");
          } else {
            abortSignal.onabort = onAbort;
          }
        }));
      }
      return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value3) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config3) => {
        config3[key] = value3;
        return config3;
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  };
  __name(_FetchHttpHandler, "FetchHttpHandler");
  var FetchHttpHandler = _FetchHttpHandler;
  var streamCollector = /* @__PURE__ */ __name(async (stream2) => {
    if (typeof Blob === "function" && stream2 instanceof Blob) {
      return new Uint8Array(await stream2.arrayBuffer());
    }
    return collectStream(stream2);
  }, "streamCollector");
  async function collectStream(stream2) {
    const chunks = [];
    const reader = stream2.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value: value3 } = await reader.read();
      if (value3) {
        chunks.push(value3);
        length += value3.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  __name(collectStream, "collectStream");
});

// ../node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs13 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromHex: () => fromHex,
    toHex: () => toHex
  });
  module.exports = __toCommonJS(src_exports);
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i3 = 0;i3 < 256; i3++) {
    let encodedByte = i3.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i3] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i3;
  }
  function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i3 = 0;i3 < encoded.length; i3 += 2) {
      const encodedByte = encoded.slice(i3, i3 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i3 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  }
  __name(fromHex, "fromHex");
  function toHex(bytes) {
    let out = "";
    for (let i3 = 0;i3 < bytes.byteLength; i3++) {
      out += SHORT_TO_HEX[bytes[i3]];
    }
    return out;
  }
  __name(toHex, "toHex");
});

// ../node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStream = undefined;
  var isReadableStream2 = (stream2) => {
    var _a2;
    return typeof ReadableStream === "function" && (((_a2 = stream2 === null || stream2 === undefined ? undefined : stream2.constructor) === null || _a2 === undefined ? undefined : _a2.name) === ReadableStream.name || stream2 instanceof ReadableStream);
  };
  exports.isReadableStream = isReadableStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var fetch_http_handler_1 = require_dist_cjs12();
  var util_base64_1 = require_dist_cjs8();
  var util_hex_encoding_1 = require_dist_cjs13();
  var util_utf8_1 = require_dist_cjs7();
  var stream_type_check_1 = require_stream_type_check();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin2 = (stream2) => {
    var _a2, _b;
    if (!isBlobInstance(stream2) && !(0, stream_type_check_1.isReadableStream)(stream2)) {
      const name = ((_b = (_a2 = stream2 === null || stream2 === undefined ? undefined : stream2.__proto__) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b === undefined ? undefined : _b.name) || stream2;
      throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, fetch_http_handler_1.streamCollector)(stream2);
    };
    const blobToWebStream = (blob) => {
      if (typeof blob.stream !== "function") {
        throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
      }
      return blob.stream();
    };
    return Object.assign(stream2, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === "base64") {
          return (0, util_base64_1.toBase64)(buf);
        } else if (encoding === "hex") {
          return (0, util_hex_encoding_1.toHex)(buf);
        } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
          return (0, util_utf8_1.toUtf8)(buf);
        } else if (typeof TextDecoder === "function") {
          return new TextDecoder(encoding).decode(buf);
        } else {
          throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        if (isBlobInstance(stream2)) {
          return blobToWebStream(stream2);
        } else if ((0, stream_type_check_1.isReadableStream)(stream2)) {
          return stream2;
        } else {
          throw new Error(`Cannot transform payload to web stream, got ${stream2}`);
        }
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin2;
  var isBlobInstance = (stream2) => typeof Blob === "function" && stream2 instanceof Blob;
});

// ../node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var node_http_handler_1 = require_dist_cjs11();
  var util_buffer_from_1 = require_dist_cjs6();
  var stream_1 = import.meta.require("stream");
  var util_1 = import.meta.require("util");
  var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin2 = (stream2) => {
    var _a2, _b;
    if (!(stream2 instanceof stream_1.Readable)) {
      try {
        return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream2);
      } catch (e) {
        const name = ((_b = (_a2 = stream2 === null || stream2 === undefined ? undefined : stream2.__proto__) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b === undefined ? undefined : _b.name) || stream2;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
      }
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, node_http_handler_1.streamCollector)(stream2);
    };
    return Object.assign(stream2, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === undefined || Buffer.isEncoding(encoding)) {
          return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
        } else {
          const decoder = new util_1.TextDecoder(encoding);
          return decoder.decode(buf);
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        if (stream2.readableFlowing !== null) {
          throw new Error("The stream has been consumed by other callbacks.");
        }
        if (typeof stream_1.Readable.toWeb !== "function") {
          throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
        }
        transformed = true;
        return stream_1.Readable.toWeb(stream2);
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = undefined;
  async function splitStream2(stream2) {
    if (typeof stream2.stream === "function") {
      stream2 = stream2.stream();
    }
    const readableStream = stream2;
    return readableStream.tee();
  }
  exports.splitStream = splitStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = undefined;
  var stream_1 = import.meta.require("stream");
  var splitStream_browser_1 = require_splitStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  async function splitStream2(stream2) {
    if ((0, stream_type_check_1.isReadableStream)(stream2)) {
      return (0, splitStream_browser_1.splitStream)(stream2);
    }
    const stream1 = new stream_1.PassThrough;
    const stream22 = new stream_1.PassThrough;
    stream2.pipe(stream1);
    stream2.pipe(stream22);
    return [stream1, stream22];
  }
  exports.splitStream = splitStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  async function headStream2(stream2, bytes) {
    var _a2;
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream2.getReader();
    let isDone = false;
    while (!isDone) {
      const { done, value: value3 } = await reader.read();
      if (value3) {
        chunks.push(value3);
        byteLengthCounter += (_a2 = value3 === null || value3 === undefined ? undefined : value3.byteLength) !== null && _a2 !== undefined ? _a2 : 0;
      }
      if (byteLengthCounter >= bytes) {
        break;
      }
      isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
      if (chunk.byteLength > collected.byteLength - offset) {
        collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
        break;
      } else {
        collected.set(chunk, offset);
      }
      offset += chunk.length;
    }
    return collected;
  }
  exports.headStream = headStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  var stream_1 = import.meta.require("stream");
  var headStream_browser_1 = require_headStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  var headStream2 = (stream2, bytes) => {
    if ((0, stream_type_check_1.isReadableStream)(stream2)) {
      return (0, headStream_browser_1.headStream)(stream2, bytes);
    }
    return new Promise((resolve3, reject) => {
      const collector = new Collector;
      collector.limit = bytes;
      stream2.pipe(collector);
      stream2.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
        resolve3(bytes2);
      });
    });
  };
  exports.headStream = headStream2;

  class Collector extends stream_1.Writable {
    constructor() {
      super(...arguments);
      this.buffers = [];
      this.limit = Infinity;
      this.bytesBuffered = 0;
    }
    _write(chunk, encoding, callback) {
      var _a2;
      this.buffers.push(chunk);
      this.bytesBuffered += (_a2 = chunk.byteLength) !== null && _a2 !== undefined ? _a2 : 0;
      if (this.bytesBuffered >= this.limit) {
        const excess = this.bytesBuffered - this.limit;
        const tailBuffer = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
        this.emit("finish");
      }
      callback();
    }
  }
});

// ../node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs8();
  var stream_1 = import.meta.require("stream");

  class ChecksumStream2 extends stream_1.Duplex {
    constructor({ expectedChecksum, checksum: checksum2, source, checksumSourceLocation, base64Encoder }) {
      var _a2, _b;
      super();
      if (typeof source.pipe === "function") {
        this.source = source;
      } else {
        throw new Error(`@smithy/util-stream: unsupported source type ${(_b = (_a2 = source === null || source === undefined ? undefined : source.constructor) === null || _a2 === undefined ? undefined : _a2.name) !== null && _b !== undefined ? _b : source} in ChecksumStream.`);
      }
      this.base64Encoder = base64Encoder !== null && base64Encoder !== undefined ? base64Encoder : util_base64_1.toBase64;
      this.expectedChecksum = expectedChecksum;
      this.checksum = checksum2;
      this.checksumSourceLocation = checksumSourceLocation;
      this.source.pipe(this);
    }
    _read(size2) {
    }
    _write(chunk, encoding, callback) {
      try {
        this.checksum.update(chunk);
        this.push(chunk);
      } catch (e) {
        return callback(e);
      }
      return callback();
    }
    async _final(callback) {
      try {
        const digest = await this.checksum.digest();
        const received = this.base64Encoder(digest);
        if (this.expectedChecksum !== received) {
          return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}"` + ` in response header "${this.checksumSourceLocation}".`));
        }
      } catch (e) {
        return callback(e);
      }
      this.push(null);
      return callback();
    }
  }
  exports.ChecksumStream = ChecksumStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
  };

  class ChecksumStream2 extends ReadableStreamRef {
  }
  exports.ChecksumStream = ChecksumStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs8();
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_browser_1 = require_ChecksumStream_browser();
  var createChecksumStream2 = ({ expectedChecksum, checksum: checksum2, source, checksumSourceLocation, base64Encoder }) => {
    var _a2, _b;
    if (!(0, stream_type_check_1.isReadableStream)(source)) {
      throw new Error(`@smithy/util-stream: unsupported source type ${(_b = (_a2 = source === null || source === undefined ? undefined : source.constructor) === null || _a2 === undefined ? undefined : _a2.name) !== null && _b !== undefined ? _b : source} in ChecksumStream.`);
    }
    const encoder = base64Encoder !== null && base64Encoder !== undefined ? base64Encoder : util_base64_1.toBase64;
    if (typeof TransformStream !== "function") {
      throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform6 = new TransformStream({
      start() {
      },
      async transform(chunk, controller) {
        checksum2.update(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        const digest = await checksum2.digest();
        const received = encoder(digest);
        if (expectedChecksum !== received) {
          const error5 = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}"` + ` in response header "${checksumSourceLocation}".`);
          controller.error(error5);
        } else {
          controller.terminate();
        }
      }
    });
    source.pipeThrough(transform6);
    const readable = transform6.readable;
    Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
    return readable;
  };
  exports.createChecksumStream = createChecksumStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_1 = require_ChecksumStream();
  var createChecksumStream_browser_1 = require_createChecksumStream_browser();
  function createChecksumStream2(init3) {
    if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init3.source)) {
      return (0, createChecksumStream_browser_1.createChecksumStream)(init3);
    }
    return new ChecksumStream_1.ChecksumStream(init3);
  }
  exports.createChecksumStream = createChecksumStream2;
});

// ../node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs14 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Uint8ArrayBlobAdapter: () => Uint8ArrayBlobAdapter
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_base64 = require_dist_cjs8();
  var import_util_utf8 = require_dist_cjs7();
  function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
      return (0, import_util_base64.toBase64)(payload);
    }
    return (0, import_util_utf8.toUtf8)(payload);
  }
  __name(transformToString, "transformToString");
  function transformFromString(str, encoding) {
    if (encoding === "base64") {
      return Uint8ArrayBlobAdapter.mutate((0, import_util_base64.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter.mutate((0, import_util_utf8.fromUtf8)(str));
  }
  __name(transformFromString, "transformFromString");
  var _Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter2 extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
      switch (typeof source) {
        case "string":
          return transformFromString(source, encoding);
        default:
          throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
    }
    static mutate(source) {
      Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter2.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      return transformToString(this, encoding);
    }
  };
  __name(_Uint8ArrayBlobAdapter, "Uint8ArrayBlobAdapter");
  var Uint8ArrayBlobAdapter = _Uint8ArrayBlobAdapter;
  __reExport(src_exports, require_getAwsChunkedEncodingStream(), module.exports);
  __reExport(src_exports, require_sdk_stream_mixin(), module.exports);
  __reExport(src_exports, require_splitStream(), module.exports);
  __reExport(src_exports, require_headStream(), module.exports);
  __reExport(src_exports, require_stream_type_check(), module.exports);
  __reExport(src_exports, require_createChecksumStream(), module.exports);
  __reExport(src_exports, require_ChecksumStream(), module.exports);
});

// ../node_modules/@smithy/core/dist-cjs/submodules/protocols/index.js
var require_protocols = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var protocols_exports = {};
  __export2(protocols_exports, {
    RequestBuilder: () => RequestBuilder,
    collectBody: () => collectBody2,
    extendedEncodeURIComponent: () => extendedEncodeURIComponent2,
    requestBuilder: () => requestBuilder2,
    resolvedPath: () => resolvedPath2
  });
  module.exports = __toCommonJS(protocols_exports);
  var import_util_stream = require_dist_cjs14();
  var collectBody2 = async (streamBody = new Uint8Array, context8) => {
    if (streamBody instanceof Uint8Array) {
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
    }
    const fromContext = context8.streamCollector(streamBody);
    return import_util_stream.Uint8ArrayBlobAdapter.mutate(await fromContext);
  };
  function extendedEncodeURIComponent2(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
      return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  var import_protocols = require_protocols();
  var import_protocol_http3 = require_dist_cjs4();
  function requestBuilder2(input, context8) {
    return new RequestBuilder(input, context8);
  }
  var RequestBuilder = class {
    constructor(input, context8) {
      this.input = input;
      this.context = context8;
      this.query = {};
      this.method = "";
      this.headers = {};
      this.path = "";
      this.body = null;
      this.hostname = "";
      this.resolvePathStack = [];
    }
    async build() {
      const { hostname: hostname3, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new import_protocol_http3.HttpRequest({
        protocol,
        hostname: this.hostname || hostname3,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname3) {
      this.hostname = hostname3;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${(basePath == null ? undefined : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path4) => {
        this.path = (0, import_protocols.resolvedPath)(path4, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  };
  var resolvedPath2 = (resolvedPath3, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath3 = resolvedPath3.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent2(segment)).join("/") : extendedEncodeURIComponent2(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath3;
  };
});

// ../node_modules/@smithy/core/dist-cjs/index.js
var require_dist_cjs15 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,
    EXPIRATION_MS: () => EXPIRATION_MS,
    HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,
    HttpBearerAuthSigner: () => HttpBearerAuthSigner,
    NoAuthSigner: () => NoAuthSigner,
    createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,
    createPaginator: () => createPaginator,
    doesIdentityRequireRefresh: () => doesIdentityRequireRefresh,
    getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,
    getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,
    getHttpSigningPlugin: () => getHttpSigningPlugin,
    getSmithyContext: () => getSmithyContext,
    httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,
    httpAuthSchemeMiddleware: () => httpAuthSchemeMiddleware,
    httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,
    httpSigningMiddleware: () => httpSigningMiddleware,
    httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,
    isIdentityExpired: () => isIdentityExpired,
    memoizeIdentityProvider: () => memoizeIdentityProvider,
    normalizeProvider: () => normalizeProvider,
    requestBuilder: () => import_protocols.requestBuilder,
    setFeature: () => setFeature
  });
  module.exports = __toCommonJS(src_exports);
  var import_types4 = require_dist_cjs();
  var getSmithyContext = /* @__PURE__ */ __name((context8) => context8[import_types4.SMITHY_CONTEXT_KEY] || (context8[import_types4.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");
  var import_util_middleware = require_dist_cjs2();
  function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map5 = /* @__PURE__ */ new Map;
    for (const scheme of httpAuthSchemes) {
      map5.set(scheme.schemeId, scheme);
    }
    return map5;
  }
  __name(convertHttpAuthSchemesToMap, "convertHttpAuthSchemesToMap");
  var httpAuthSchemeMiddleware = /* @__PURE__ */ __name((config3, mwOptions) => (next, context8) => async (args) => {
    var _a2;
    const options = config3.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config3, context8, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config3.httpAuthSchemes);
    const smithyContext = (0, import_util_middleware.getSmithyContext)(context8);
    const failureReasons = [];
    for (const option of options) {
      const scheme = authSchemes.get(option.schemeId);
      if (!scheme) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
        continue;
      }
      const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config3));
      if (!identityProvider) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
        continue;
      }
      const { identityProperties = {}, signingProperties = {} } = ((_a2 = option.propertiesExtractor) == null ? undefined : _a2.call(option, config3, context8)) || {};
      option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
      option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
      smithyContext.selectedHttpAuthScheme = {
        httpAuthOption: option,
        identity: await identityProvider(option.identityProperties),
        signer: scheme.signer
      };
      break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
      throw new Error(failureReasons.join("\n"));
    }
    return next(args);
  }, "httpAuthSchemeMiddleware");
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  var getHttpAuthSchemeEndpointRuleSetPlugin = /* @__PURE__ */ __name((config3, {
    httpAuthSchemeParametersProvider,
    identityProviderConfigProvider
  }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config3, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    }
  }), "getHttpAuthSchemeEndpointRuleSetPlugin");
  var import_middleware_serde = require_dist_cjs3();
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: import_middleware_serde.serializerMiddlewareOption.name
  };
  var getHttpAuthSchemePlugin = /* @__PURE__ */ __name((config3, {
    httpAuthSchemeParametersProvider,
    identityProviderConfigProvider
  }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config3, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeMiddlewareOptions);
    }
  }), "getHttpAuthSchemePlugin");
  var import_protocol_http3 = require_dist_cjs4();
  var defaultErrorHandler = /* @__PURE__ */ __name((signingProperties) => (error5) => {
    throw error5;
  }, "defaultErrorHandler");
  var defaultSuccessHandler = /* @__PURE__ */ __name((httpResponse2, signingProperties) => {
  }, "defaultSuccessHandler");
  var httpSigningMiddleware = /* @__PURE__ */ __name((config3) => (next, context8) => async (args) => {
    if (!import_protocol_http3.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = (0, import_util_middleware.getSmithyContext)(context8);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const {
      httpAuthOption: { signingProperties = {} },
      identity: identity3,
      signer
    } = scheme;
    const output = await next({
      ...args,
      request: await signer.sign(args.request, identity3, signingProperties)
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  }, "httpSigningMiddleware");
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware"
  };
  var getHttpSigningPlugin = /* @__PURE__ */ __name((config3) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpSigningMiddleware(config3), httpSigningMiddlewareOptions);
    }
  }), "getHttpSigningPlugin");
  var normalizeProvider = /* @__PURE__ */ __name((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");
  var makePagedClientRequest = /* @__PURE__ */ __name(async (CommandCtor, client2, input, ...args) => {
    return await client2.send(new CommandCtor(input), ...args);
  }, "makePagedClientRequest");
  function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return /* @__PURE__ */ __name(async function* paginateOperation(config3, input, ...additionalArguments) {
      let token = config3.startingToken || undefined;
      let hasNext = true;
      let page;
      while (hasNext) {
        input[inputTokenName] = token;
        if (pageSizeTokenName) {
          input[pageSizeTokenName] = input[pageSizeTokenName] ?? config3.pageSize;
        }
        if (config3.client instanceof ClientCtor) {
          page = await makePagedClientRequest(CommandCtor, config3.client, input, ...additionalArguments);
        } else {
          throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
        }
        yield page;
        const prevToken = token;
        token = get(page, outputTokenName);
        hasNext = !!(token && (!config3.stopOnSameToken || token !== prevToken));
      }
      return;
    }, "paginateOperation");
  }
  __name(createPaginator, "createPaginator");
  var get = /* @__PURE__ */ __name((fromObject, path4) => {
    let cursor = fromObject;
    const pathComponents = path4.split(".");
    for (const step of pathComponents) {
      if (!cursor || typeof cursor !== "object") {
        return;
      }
      cursor = cursor[step];
    }
    return cursor;
  }, "get");
  var import_protocols = require_protocols();
  function setFeature(context8, feature, value3) {
    if (!context8.__smithy_context) {
      context8.__smithy_context = {
        features: {}
      };
    } else if (!context8.__smithy_context.features) {
      context8.__smithy_context.features = {};
    }
    context8.__smithy_context.features[feature] = value3;
  }
  __name(setFeature, "setFeature");
  var _DefaultIdentityProviderConfig = class _DefaultIdentityProviderConfig2 {
    constructor(config3) {
      this.authSchemes = /* @__PURE__ */ new Map;
      for (const [key, value3] of Object.entries(config3)) {
        if (value3 !== undefined) {
          this.authSchemes.set(key, value3);
        }
      }
    }
    getIdentityProvider(schemeId) {
      return this.authSchemes.get(schemeId);
    }
  };
  __name(_DefaultIdentityProviderConfig, "DefaultIdentityProviderConfig");
  var DefaultIdentityProviderConfig = _DefaultIdentityProviderConfig;
  var _HttpApiKeyAuthSigner = class _HttpApiKeyAuthSigner2 {
    async sign(httpRequest2, identity3, signingProperties) {
      if (!signingProperties) {
        throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
      }
      if (!signingProperties.name) {
        throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
      }
      if (!signingProperties.in) {
        throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
      }
      if (!identity3.apiKey) {
        throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
      }
      const clonedRequest = import_protocol_http3.HttpRequest.clone(httpRequest2);
      if (signingProperties.in === import_types4.HttpApiKeyAuthLocation.QUERY) {
        clonedRequest.query[signingProperties.name] = identity3.apiKey;
      } else if (signingProperties.in === import_types4.HttpApiKeyAuthLocation.HEADER) {
        clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity3.apiKey}` : identity3.apiKey;
      } else {
        throw new Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + signingProperties.in + "`");
      }
      return clonedRequest;
    }
  };
  __name(_HttpApiKeyAuthSigner, "HttpApiKeyAuthSigner");
  var HttpApiKeyAuthSigner = _HttpApiKeyAuthSigner;
  var _HttpBearerAuthSigner = class _HttpBearerAuthSigner2 {
    async sign(httpRequest2, identity3, signingProperties) {
      const clonedRequest = import_protocol_http3.HttpRequest.clone(httpRequest2);
      if (!identity3.token) {
        throw new Error("request could not be signed with `token` since the `token` is not defined");
      }
      clonedRequest.headers["Authorization"] = `Bearer ${identity3.token}`;
      return clonedRequest;
    }
  };
  __name(_HttpBearerAuthSigner, "HttpBearerAuthSigner");
  var HttpBearerAuthSigner = _HttpBearerAuthSigner;
  var _NoAuthSigner = class _NoAuthSigner2 {
    async sign(httpRequest2, identity3, signingProperties) {
      return httpRequest2;
    }
  };
  __name(_NoAuthSigner, "NoAuthSigner");
  var NoAuthSigner = _NoAuthSigner;
  var createIsIdentityExpiredFunction = /* @__PURE__ */ __name((expirationMs) => (identity3) => doesIdentityRequireRefresh(identity3) && identity3.expiration.getTime() - Date.now() < expirationMs, "createIsIdentityExpiredFunction");
  var EXPIRATION_MS = 300000;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = /* @__PURE__ */ __name((identity3) => identity3.expiration !== undefined, "doesIdentityRequireRefresh");
  var memoizeIdentityProvider = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
      return;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name(async (options) => {
      if (!pending) {
        pending = normalizedProvider(options);
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || (options == null ? undefined : options.forceRefresh)) {
          resolved = await coalesceProvider(options);
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || (options == null ? undefined : options.forceRefresh)) {
        resolved = await coalesceProvider(options);
      }
      if (isConstant) {
        return resolved;
      }
      if (!requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider(options);
        return resolved;
      }
      return resolved;
    };
  }, "memoizeIdentityProvider");
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function isValidUserAgentAppId(appId) {
  if (appId === undefined) {
    return true;
  }
  return typeof appId === "string" && appId.length <= 50;
}
function resolveUserAgentConfig(input) {
  const normalizedAppIdProvider = import_core54.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    userAgentAppId: async () => {
      const appId = await normalizedAppIdProvider();
      if (!isValidUserAgentAppId(appId)) {
        const logger3 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
        if (typeof appId !== "string") {
          logger3?.warn("userAgentAppId must be a string or undefined.");
        } else if (appId.length > 50) {
          logger3?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
        }
      }
      return appId;
    }
  };
}
var import_core54, DEFAULT_UA_APP_ID = undefined;
var init_configurations = __esm(() => {
  import_core54 = __toESM(require_dist_cjs15(), 1);
});

// ../node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js
class EndpointCache {
  constructor({ size: size2, params }) {
    this.data = new Map;
    this.parameters = [];
    this.capacity = size2 ?? 50;
    if (params) {
      this.parameters = params;
    }
  }
  get(endpointParams, resolver) {
    const key = this.hash(endpointParams);
    if (key === false) {
      return resolver();
    }
    if (!this.data.has(key)) {
      if (this.data.size > this.capacity + 10) {
        const keys = this.data.keys();
        let i3 = 0;
        while (true) {
          const { value: value3, done } = keys.next();
          this.data.delete(value3);
          if (done || ++i3 > 10) {
            break;
          }
        }
      }
      this.data.set(key, resolver());
    }
    return this.data.get(key);
  }
  size() {
    return this.data.size;
  }
  hash(endpointParams) {
    let buffer2 = "";
    const { parameters: parameters5 } = this;
    if (parameters5.length === 0) {
      return false;
    }
    for (const param of parameters5) {
      const val2 = String(endpointParams[param] ?? "");
      if (val2.includes("|;")) {
        return false;
      }
      buffer2 += val2 + "|;";
    }
    return buffer2;
  }
}

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX, isIpAddress = (value3) => IP_V4_REGEX.test(value3) || value3.startsWith("[") && value3.endsWith("]");
var init_isIpAddress = __esm(() => {
  IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}\$`);
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX, isValidHostLabel = (value3, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value3);
  }
  const labels = value3.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};
var init_isValidHostLabel = __esm(() => {
  VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-\$)(?!-)[a-zA-Z0-9-]{1,63}\$`);
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
var customEndpointFunctions;
var init_customEndpointFunctions = __esm(() => {
  customEndpointFunctions = {};
});

// ../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
var debugId = "endpoints";

// ../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `\$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// ../node_modules/@smithy/util-endpoints/dist-es/debug/index.js
var init_debug = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
var EndpointError;
var init_EndpointError = __esm(() => {
  EndpointError = class EndpointError extends Error {
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  };
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
var init_EndpointFunctions = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject2 = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject2 = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject2 = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject2 = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/shared.js
var init_shared2 = () => {
};

// ../node_modules/@smithy/util-endpoints/dist-es/types/index.js
var init_types2 = __esm(() => {
  init_EndpointError();
  init_EndpointFunctions();
  init_EndpointRuleObject2();
  init_ErrorRuleObject2();
  init_RuleSetObject2();
  init_TreeRuleObject2();
  init_shared2();
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals = (value1, value22) => value1 === value22;

// ../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList = (path4) => {
  const parts = path4.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path4}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path4}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};
var init_getAttrPathList = __esm(() => {
  init_types2();
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value3, path4) => getAttrPathList(path4).reduce((acc, index2) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index2}' in '${path4}' not found in '${JSON.stringify(value3)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index2)];
  }
  return acc[index2];
}, value3);
var init_getAttr = __esm(() => {
  init_types2();
  init_getAttrPathList();
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
var isSet = (value3) => value3 != null;

// ../node_modules/@smithy/util-endpoints/dist-es/lib/not.js
var not6 = (value3) => !value3;

// ../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS, parseURL = (value3) => {
  const whatwgURL = (() => {
    try {
      if (value3 instanceof URL) {
        return value3;
      }
      if (typeof value3 === "object" && "hostname" in value3) {
        const { hostname: hostname4, port, protocol: protocol2 = "", path: path4 = "", query = {} } = value3;
        const url = new URL(`${protocol2}//${hostname4}${port ? `:${port}` : ""}${path4}`);
        url.search = Object.entries(query).map(([k4, v4]) => `${k4}=${v4}`).join("&");
        return url;
      }
      return new URL(value3);
    } catch (error5) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value3)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname: hostname3, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname3);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value3 === "string" && value3.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};
var init_parseURL = __esm(() => {
  init_dist_es();
  init_isIpAddress();
  DEFAULT_PORTS = {
    [EndpointURLScheme.HTTP]: 80,
    [EndpointURLScheme.HTTPS]: 443
  };
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals = (value1, value22) => value1 === value22;

// ../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// ../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode = (value3) => encodeURIComponent(value3).replace(/[!*'()]/g, (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`);

// ../node_modules/@smithy/util-endpoints/dist-es/lib/index.js
var init_lib = __esm(() => {
  init_getAttr();
  init_isValidHostLabel();
  init_parseURL();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions;
var init_endpointFunctions = __esm(() => {
  init_lib();
  endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not: not6,
    parseURL,
    stringEquals,
    substring,
    uriEncode
  };
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};
var init_evaluateTemplate = __esm(() => {
  init_lib();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue = ({ ref: ref5 }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref5];
};

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
var init_evaluateExpression = __esm(() => {
  init_types2();
  init_callFunction();
  init_evaluateTemplate();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};
var init_callFunction = __esm(() => {
  init_customEndpointFunctions();
  init_endpointFunctions();
  init_evaluateExpression();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value3 = callFunction(fnArgs, options);
  options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value3)}`);
  return {
    result: value3 === "" ? true : !!value3,
    ...assign != null && { toAssign: { name: assign, value: value3 } }
  };
};
var init_evaluateCondition = __esm(() => {
  init_debug();
  init_types2();
  init_callFunction();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};
var init_evaluateConditions = __esm(() => {
  init_debug();
  init_evaluateCondition();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});
var init_getEndpointHeaders = __esm(() => {
  init_types2();
  init_evaluateExpression();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};
var init_getEndpointProperty = __esm(() => {
  init_types2();
  init_evaluateTemplate();
  init_getEndpointProperties();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});
var init_getEndpointProperties = __esm(() => {
  init_getEndpointProperty();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error5) {
      console.error(`Failed to construct URL with ${expression}`, error5);
      throw error5;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
var init_getEndpointUrl = __esm(() => {
  init_types2();
  init_evaluateExpression();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  const { conditions, endpoint: endpoint2 } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint2;
  options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint2)}`);
  return {
    ...headers != null && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != null && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};
var init_evaluateEndpointRule = __esm(() => {
  init_debug();
  init_evaluateConditions();
  init_getEndpointHeaders();
  init_getEndpointProperties();
  init_getEndpointUrl();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error: error5 } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error5, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};
var init_evaluateErrorRule = __esm(() => {
  init_types2();
  init_evaluateConditions();
  init_evaluateExpression();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};
var init_evaluateTreeRule = __esm(() => {
  init_evaluateConditions();
  init_evaluateRules();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};
var init_evaluateRules = __esm(() => {
  init_types2();
  init_evaluateEndpointRule();
  init_evaluateErrorRule();
  init_evaluateTreeRule();
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/index.js
var init_utils = __esm(() => {
  init_customEndpointFunctions();
  init_evaluateRules();
});

// ../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = (ruleSetObject, options) => {
  const { endpointParams, logger: logger3 } = options;
  const { parameters: parameters5, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters5).filter(([, v4]) => v4.default != null).map(([k4, v4]) => [k4, v4.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters5).filter(([, v4]) => v4.required).map(([k4]) => k4);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint2 = evaluateRules(rules, { endpointParams, logger: logger3, referenceRecord: {} });
  options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint2)}`);
  return endpoint2;
};
var init_resolveEndpoint = __esm(() => {
  init_debug();
  init_types2();
  init_utils();
});

// ../node_modules/@smithy/util-endpoints/dist-es/index.js
var init_dist_es6 = __esm(() => {
  init_isIpAddress();
  init_isValidHostLabel();
  init_customEndpointFunctions();
  init_resolveEndpoint();
  init_types2();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var init_isIpAddress2 = __esm(() => {
  init_dist_es6();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value3, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value3.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value3)) {
    return false;
  }
  if (value3.length < 3 || value3.length > 63) {
    return false;
  }
  if (value3 !== value3.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value3)) {
    return false;
  }
  return true;
};
var init_isVirtualHostableS3Bucket = __esm(() => {
  init_dist_es6();
  init_isIpAddress2();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var ARN_DELIMITER = ":", RESOURCE_DELIMITER = "/", parseArn = (value3) => {
  const segments = value3.split(ARN_DELIMITER);
  if (segments.length < 6)
    return null;
  const [arn, partition, service, region, accountId, ...resourcePath] = segments;
  if (arn !== "arn" || partition === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
    return null;
  const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
  return {
    partition,
    service,
    region,
    accountId,
    resourceId
  };
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default;
var init_partitions = __esm(() => {
  partitions_default = {
    partitions: [{
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "aws-global": {
          description: "AWS Standard global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    }, {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "AWS China global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    }, {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }, {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    }, {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    }, {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    }, {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {}
    }],
    version: "1.1"
  };
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo, selectedUserAgentPrefix = "", partition = (value3) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value3) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value3)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
}, getUserAgentPrefix = () => selectedUserAgentPrefix;
var init_partition = __esm(() => {
  init_partitions();
  selectedPartitionsInfo = partitions_default;
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions;
var init_aws = __esm(() => {
  init_dist_es6();
  init_isVirtualHostableS3Bucket();
  init_partition();
  awsEndpointFunctions = {
    isVirtualHostableS3Bucket,
    parseArn,
    partition
  };
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var init_resolveEndpoint2 = __esm(() => {
  init_dist_es6();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var init_EndpointError2 = __esm(() => {
  init_dist_es6();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject3 = () => {
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject3 = () => {
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject3 = () => {
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject3 = () => {
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
var init_shared3 = () => {
};

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
var init_types3 = __esm(() => {
  init_EndpointError2();
  init_EndpointRuleObject3();
  init_ErrorRuleObject3();
  init_RuleSetObject3();
  init_TreeRuleObject3();
  init_shared3();
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/index.js
var init_dist_es7 = __esm(() => {
  init_aws();
  init_partition();
  init_isIpAddress2();
  init_resolveEndpoint2();
  init_types3();
});

// ../node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends3;
  var __assign3;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values8;
  var __read7;
  var __spread;
  var __spreadArrays;
  var __spreadArray4;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root2, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root2, createExporter(exports)));
    } else {
      factory(createExporter(root2));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root2) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v4) {
        return exports2[id] = previous ? previous(id, v4) : v4;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p4 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p4))
          d4[p4] = b4[p4];
    };
    __extends3 = function(d4, b4) {
      if (typeof b4 !== "function" && b4 !== null)
        throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
      extendStatics(d4, b4);
      function __() {
        this.constructor = d4;
      }
      d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __);
    };
    __assign3 = Object.assign || function(t3) {
      for (var s, i3 = 1, n2 = arguments.length;i3 < n2; i3++) {
        s = arguments[i3];
        for (var p4 in s)
          if (Object.prototype.hasOwnProperty.call(s, p4))
            t3[p4] = s[p4];
      }
      return t3;
    };
    __rest = function(s, e) {
      var t3 = {};
      for (var p4 in s)
        if (Object.prototype.hasOwnProperty.call(s, p4) && e.indexOf(p4) < 0)
          t3[p4] = s[p4];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p4 = Object.getOwnPropertySymbols(s);i3 < p4.length; i3++) {
          if (e.indexOf(p4[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p4[i3]))
            t3[p4[i3]] = s[p4[i3]];
        }
      return t3;
    };
    __decorate = function(decorators, target, key, desc2) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d4;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc2);
      else
        for (var i3 = decorators.length - 1;i3 >= 0; i3--)
          if (d4 = decorators[i3])
            r = (c3 < 3 ? d4(r) : c3 > 3 ? d4(target, key, r) : d4(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f4) {
        if (f4 !== undefined && typeof f4 !== "function")
          throw new TypeError("Function expected");
        return f4;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _3, done = false;
      for (var i3 = decorators.length - 1;i3 >= 0; i3--) {
        var context8 = {};
        for (var p4 in contextIn)
          context8[p4] = p4 === "access" ? {} : contextIn[p4];
        for (var p4 in contextIn.access)
          context8.access[p4] = contextIn.access[p4];
        context8.addInitializer = function(f4) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f4 || null));
        };
        var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context8);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_3 = accept(result.get))
            descriptor.get = _3;
          if (_3 = accept(result.set))
            descriptor.set = _3;
          if (_3 = accept(result.init))
            initializers.unshift(_3);
        } else if (_3 = accept(result)) {
          if (kind === "field")
            initializers.unshift(_3);
          else
            descriptor[key] = _3;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value3) {
      var useValue = arguments.length > 2;
      for (var i3 = 0;i3 < initializers.length; i3++) {
        value3 = useValue ? initializers[i3].call(thisArg, value3) : initializers[i3].call(thisArg);
      }
      return useValue ? value3 : undefined;
    };
    __propKey = function(x4) {
      return typeof x4 === "symbol" ? x4 : "".concat(x4);
    };
    __setFunctionName = function(f4, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f4, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P4, generator) {
      function adopt(value3) {
        return value3 instanceof P4 ? value3 : new P4(function(resolve3) {
          resolve3(value3);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve3, reject) {
        function fulfilled(value3) {
          try {
            step(generator.next(value3));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value3) {
          try {
            step(generator["throw"](value3));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _3 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f4, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n2) {
        return function(v4) {
          return step([n2, v4]);
        };
      }
      function step(op) {
        if (f4)
          throw new TypeError("Generator is already executing.");
        while (g3 && (g3 = 0, op[0] && (_3 = 0)), _3)
          try {
            if (f4 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t3[1]) {
                  _3.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _3.label < t3[2]) {
                  _3.label = t3[2];
                  _3.ops.push(op);
                  break;
                }
                if (t3[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e) {
            op = [6, e];
            y3 = 0;
          } finally {
            f4 = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m4, o2) {
      for (var p4 in m4)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p4))
          __createBinding(o2, m4, p4);
    };
    __createBinding = Object.create ? function(o2, m4, k4, k22) {
      if (k22 === undefined)
        k22 = k4;
      var desc2 = Object.getOwnPropertyDescriptor(m4, k4);
      if (!desc2 || ("get" in desc2 ? !m4.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m4[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m4, k4, k22) {
      if (k22 === undefined)
        k22 = k4;
      o2[k22] = m4[k4];
    };
    __values8 = function(o2) {
      var s = typeof Symbol === "function" && Symbol.iterator, m4 = s && o2[s], i3 = 0;
      if (m4)
        return m4.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i3 >= o2.length)
              o2 = undefined;
            return { value: o2 && o2[i3++], done: !o2 };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read7 = function(o2, n2) {
      var m4 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m4)
        return o2;
      var i3 = m4.call(o2), r, ar = [], e;
      try {
        while ((n2 === undefined || n2-- > 0) && !(r = i3.next()).done)
          ar.push(r.value);
      } catch (error5) {
        e = { error: error5 };
      } finally {
        try {
          if (r && !r.done && (m4 = i3["return"]))
            m4.call(i3);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i3 = 0;i3 < arguments.length; i3++)
        ar = ar.concat(__read7(arguments[i3]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i3 = 0, il = arguments.length;i3 < il; i3++)
        s += arguments[i3].length;
      for (var r = Array(s), k4 = 0, i3 = 0;i3 < il; i3++)
        for (var a = arguments[i3], j4 = 0, jl = a.length;j4 < jl; j4++, k4++)
          r[k4] = a[j4];
      return r;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i3 = 0, l = from.length, ar;i3 < l; i3++) {
          if (ar || !(i3 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i3);
            ar[i3] = from[i3];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v4) {
      return this instanceof __await ? (this.v = v4, this) : new __await(v4);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g3 = generator.apply(thisArg, _arguments || []), i3, q5 = [];
      return i3 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3;
      function awaitReturn(f4) {
        return function(v4) {
          return Promise.resolve(v4).then(f4, reject);
        };
      }
      function verb(n2, f4) {
        if (g3[n2]) {
          i3[n2] = function(v4) {
            return new Promise(function(a, b4) {
              q5.push([n2, v4, a, b4]) > 1 || resume2(n2, v4);
            });
          };
          if (f4)
            i3[n2] = f4(i3[n2]);
        }
      }
      function resume2(n2, v4) {
        try {
          step(g3[n2](v4));
        } catch (e) {
          settle(q5[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q5[0][2], r);
      }
      function fulfill(value3) {
        resume2("next", value3);
      }
      function reject(value3) {
        resume2("throw", value3);
      }
      function settle(f4, v4) {
        if (f4(v4), q5.shift(), q5.length)
          resume2(q5[0][0], q5[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i3, p4;
      return i3 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i3[Symbol.iterator] = function() {
        return this;
      }, i3;
      function verb(n2, f4) {
        i3[n2] = o2[n2] ? function(v4) {
          return (p4 = !p4) ? { value: __await(o2[n2](v4)), done: false } : f4 ? f4(v4) : v4;
        } : f4;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m4 = o2[Symbol.asyncIterator], i3;
      return m4 ? m4.call(o2) : (o2 = typeof __values8 === "function" ? __values8(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3);
      function verb(n2) {
        i3[n2] = o2[n2] && function(v4) {
          return new Promise(function(resolve3, reject) {
            v4 = o2[n2](v4), settle(resolve3, reject, v4.done, v4.value);
          });
        };
      }
      function settle(resolve3, reject, d4, v4) {
        Promise.resolve(v4).then(function(v5) {
          resolve3({ value: v5, done: d4 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o2, v4) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v4 });
    } : function(o2, v4) {
      o2["default"] = v4;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4))
            __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f4) {
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value3, kind, f4) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f4.call(receiver, value3) : f4 ? f4.value = value3 : state.set(receiver, value3), value3;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value3, async) {
      if (value3 !== null && value3 !== undefined) {
        if (typeof value3 !== "object" && typeof value3 !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value3[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value3[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value: value3, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value3;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error5, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error5, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends3);
    exporter("__assign", __assign3);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values8);
    exporter("__read", __read7);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray4);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../node_modules/@aws-sdk/core/dist-cjs/submodules/client/index.js
var require_client = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var client_exports = {};
  __export2(client_exports, {
    emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
    setCredentialFeature: () => setCredentialFeature,
    setFeature: () => setFeature
  });
  module.exports = __toCommonJS(client_exports);
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name((version3) => {
    if (version3 && !warningEmitted && parseInt(version3.substring(1, version3.indexOf("."))) < 18) {
      warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
    }
  }, "emitWarningIfUnsupportedVersion");
  function setCredentialFeature(credentials, feature, value3) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value3;
    return credentials;
  }
  __name(setCredentialFeature, "setCredentialFeature");
  function setFeature(context8, feature, value3) {
    if (!context8.__aws_sdk_context) {
      context8.__aws_sdk_context = {
        features: {}
      };
    } else if (!context8.__aws_sdk_context.features) {
      context8.__aws_sdk_context.features = {};
    }
    context8.__aws_sdk_context.features[feature] = value3;
  }
  __name(setFeature, "setFeature");
});

// ../node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs16 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CredentialsProviderError: () => CredentialsProviderError,
    ProviderError: () => ProviderError,
    TokenProviderError: () => TokenProviderError,
    chain: () => chain,
    fromStatic: () => fromStatic,
    memoize: () => memoize
  });
  module.exports = __toCommonJS(src_exports);
  var _ProviderError = class _ProviderError2 extends Error {
    constructor(message, options = true) {
      var _a2;
      let logger3;
      let tryNextLink = true;
      if (typeof options === "boolean") {
        logger3 = undefined;
        tryNextLink = options;
      } else if (options != null && typeof options === "object") {
        logger3 = options.logger;
        tryNextLink = options.tryNextLink ?? true;
      }
      super(message);
      this.name = "ProviderError";
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, _ProviderError2.prototype);
      (_a2 = logger3 == null ? undefined : logger3.debug) == null || _a2.call(logger3, `@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static from(error5, options = true) {
      return Object.assign(new this(error5.message, options), error5);
    }
  };
  __name(_ProviderError, "ProviderError");
  var ProviderError = _ProviderError;
  var _CredentialsProviderError = class _CredentialsProviderError2 extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "CredentialsProviderError";
      Object.setPrototypeOf(this, _CredentialsProviderError2.prototype);
    }
  };
  __name(_CredentialsProviderError, "CredentialsProviderError");
  var CredentialsProviderError = _CredentialsProviderError;
  var _TokenProviderError = class _TokenProviderError2 extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "TokenProviderError";
      Object.setPrototypeOf(this, _TokenProviderError2.prototype);
    }
  };
  __name(_TokenProviderError, "TokenProviderError");
  var TokenProviderError = _TokenProviderError;
  var chain = /* @__PURE__ */ __name((...providers) => async () => {
    if (providers.length === 0) {
      throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
      try {
        const credentials = await provider();
        return credentials;
      } catch (err) {
        lastProviderError = err;
        if (err == null ? undefined : err.tryNextLink) {
          continue;
        }
        throw err;
      }
    }
    throw lastProviderError;
  }, "chain");
  var fromStatic = /* @__PURE__ */ __name((staticValue) => () => Promise.resolve(staticValue), "fromStatic");
  var memoize = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name(async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || (options == null ? undefined : options.forceRefresh)) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || (options == null ? undefined : options.forceRefresh)) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  }, "memoize");
});

// ../node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs17 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    SignatureV4: () => SignatureV4,
    clearCredentialCache: () => clearCredentialCache,
    createScope: () => createScope,
    getCanonicalHeaders: () => getCanonicalHeaders,
    getCanonicalQuery: () => getCanonicalQuery,
    getPayloadHash: () => getPayloadHash,
    getSigningKey: () => getSigningKey,
    moveHeadersToQuery: () => moveHeadersToQuery,
    prepareRequest: () => prepareRequest
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_middleware = require_dist_cjs2();
  var import_util_utf84 = require_dist_cjs7();
  var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var AUTH_HEADER = "authorization";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var DATE_HEADER = "date";
  var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var SHA256_HEADER = "x-amz-content-sha256";
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  var PROXY_HEADER_PATTERN = /^proxy-/;
  var SEC_HEADER_PATTERN = /^sec-/;
  var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var MAX_CACHE_SIZE = 50;
  var KEY_TYPE_IDENTIFIER = "aws4_request";
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  var import_util_hex_encoding = require_dist_cjs13();
  var import_util_utf8 = require_dist_cjs7();
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = /* @__PURE__ */ __name((shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`, "createScope");
  var getSigningKey = /* @__PURE__ */ __name(async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac2(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, import_util_hex_encoding.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
      key = await hmac2(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  }, "getSigningKey");
  var clearCredentialCache = /* @__PURE__ */ __name(() => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
      delete signingKeyCache[cacheKey];
    });
  }, "clearCredentialCache");
  var hmac2 = /* @__PURE__ */ __name((ctor, secret, data) => {
    const hash3 = new ctor(secret);
    hash3.update((0, import_util_utf8.toUint8Array)(data));
    return hash3.digest();
  }, "hmac");
  var getCanonicalHeaders = /* @__PURE__ */ __name(({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == undefined) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders == null ? undefined : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  }, "getCanonicalHeaders");
  var import_util_uri_escape = require_dist_cjs9();
  var getCanonicalQuery = /* @__PURE__ */ __name(({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
      if (key.toLowerCase() === SIGNATURE_HEADER) {
        continue;
      }
      const encodedKey = (0, import_util_uri_escape.escapeUri)(key);
      keys.push(encodedKey);
      const value3 = query[key];
      if (typeof value3 === "string") {
        serialized[encodedKey] = `${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value3)}`;
      } else if (Array.isArray(value3)) {
        serialized[encodedKey] = value3.slice(0).reduce((encoded, value22) => encoded.concat([`${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value22)}`]), []).sort().join("&");
      }
    }
    return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  }, "getCanonicalQuery");
  var import_is_array_buffer = require_dist_cjs5();
  var import_util_utf82 = require_dist_cjs7();
  var getPayloadHash = /* @__PURE__ */ __name(async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == undefined) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, import_is_array_buffer.isArrayBuffer)(body)) {
      const hashCtor = new hashConstructor;
      hashCtor.update((0, import_util_utf82.toUint8Array)(body));
      return (0, import_util_hex_encoding.toHex)(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
  }, "getPayloadHash");
  var import_util_utf83 = require_dist_cjs7();
  var _HeaderFormatter = class _HeaderFormatter2 {
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = (0, import_util_utf83.fromUtf8)(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = (0, import_util_utf83.fromUtf8)(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set((0, import_util_hex_encoding.fromHex)(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
  };
  __name(_HeaderFormatter, "HeaderFormatter");
  var HeaderFormatter = _HeaderFormatter;
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  var _Int64 = class _Int642 {
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number5) {
      if (number5 > 9223372036854776000 || number5 < -9223372036854776000) {
        throw new Error(`${number5} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i3 = 7, remaining = Math.abs(Math.round(number5));i3 > -1 && remaining > 0; i3--, remaining /= 256) {
        bytes[i3] = remaining;
      }
      if (number5 < 0) {
        negate(bytes);
      }
      return new _Int642(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt((0, import_util_hex_encoding.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  };
  __name(_Int64, "Int64");
  var Int64 = _Int64;
  function negate(bytes) {
    for (let i3 = 0;i3 < 8; i3++) {
      bytes[i3] ^= 255;
    }
    for (let i3 = 7;i3 > -1; i3--) {
      bytes[i3]++;
      if (bytes[i3] !== 0)
        break;
    }
  }
  __name(negate, "negate");
  var hasHeader = /* @__PURE__ */ __name((soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  }, "hasHeader");
  var import_protocol_http3 = require_dist_cjs4();
  var moveHeadersToQuery = /* @__PURE__ */ __name((request, options = {}) => {
    var _a2, _b;
    const { headers, query = {} } = import_protocol_http3.HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !((_a2 = options.unhoistableHeaders) == null ? undefined : _a2.has(lname)) || ((_b = options.hoistableHeaders) == null ? undefined : _b.has(lname))) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  }, "moveHeadersToQuery");
  var prepareRequest = /* @__PURE__ */ __name((request) => {
    request = import_protocol_http3.HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  }, "prepareRequest");
  var iso8601 = /* @__PURE__ */ __name((time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601");
  var toDate = /* @__PURE__ */ __name((time2) => {
    if (typeof time2 === "number") {
      return new Date(time2 * 1000);
    }
    if (typeof time2 === "string") {
      if (Number(time2)) {
        return new Date(Number(time2) * 1000);
      }
      return new Date(time2);
    }
    return time2;
  }, "toDate");
  var _SignatureV4 = class _SignatureV42 {
    constructor({
      applyChecksum,
      credentials,
      region,
      service,
      sha256: sha2562,
      uriEscapePath = true
    }) {
      this.headerFormatter = new HeaderFormatter;
      this.service = service;
      this.sha256 = sha2562;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = (0, import_util_middleware.normalizeProvider)(region);
      this.credentialProvider = (0, import_util_middleware.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options = {}) {
      const {
        signingDate = /* @__PURE__ */ new Date,
        expiresIn = 3600,
        unsignableHeaders,
        unhoistableHeaders,
        signableHeaders,
        hoistableHeaders,
        signingRegion,
        signingService
      } = options;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { longDate, shortDate } = formatDate(signingDate);
      if (expiresIn > MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
      }
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
      if (credentials.sessionToken) {
        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
      request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options);
      } else if (toSign.message) {
        return this.signMessage(toSign, options);
      } else {
        return this.signRequest(toSign, options);
      }
    }
    async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date, priorSignature, signingRegion, signingService }) {
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate, longDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
      const hash3 = new this.sha256;
      hash3.update(headers);
      const hashedHeaders = (0, import_util_hex_encoding.toHex)(await hash3.digest());
      const stringToSign = [
        EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join("\n");
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date, signingRegion, signingService }) {
      const promise5 = this.signEvent({
        headers: this.headerFormatter.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise5.then((signature2) => {
        return { message: signableMessage.message, signature: signature2 };
      });
    }
    async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate } = formatDate(signingDate);
      const hash3 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash3.update((0, import_util_utf84.toUint8Array)(stringToSign));
      return (0, import_util_hex_encoding.toHex)(await hash3.digest());
    }
    async signRequest(requestToSign, {
      signingDate = /* @__PURE__ */ new Date,
      signableHeaders,
      unsignableHeaders,
      signingRegion,
      signingService
    } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const request = prepareRequest(requestToSign);
      const { longDate, shortDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      request.headers[AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await getPayloadHash(request, this.sha256);
      if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      const signature2 = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature2}`;
      return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
      const hash3 = new this.sha256;
      hash3.update((0, import_util_utf84.toUint8Array)(canonicalRequest));
      const hashedRequest = await hash3.digest();
      return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, import_util_hex_encoding.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path: path4 }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path4.split("/")) {
          if ((pathSegment == null ? undefined : pathSegment.length) === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${(path4 == null ? undefined : path4.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path4 == null ? undefined : path4.endsWith("/")) ? "/" : ""}`;
        const doubleEncoded = (0, import_util_uri_escape.escapeUri)(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path4;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
      const hash3 = new this.sha256(await keyPromise);
      hash3.update((0, import_util_utf84.toUint8Array)(stringToSign));
      return (0, import_util_hex_encoding.toHex)(await hash3.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
  };
  __name(_SignatureV4, "SignatureV4");
  var SignatureV4 = _SignatureV4;
  var formatDate = /* @__PURE__ */ __name((now) => {
    const longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
      longDate,
      shortDate: longDate.slice(0, 8)
    };
  }, "formatDate");
  var getCanonicalHeaderList = /* @__PURE__ */ __name((headers) => Object.keys(headers).sort().join(";"), "getCanonicalHeaderList");
});

// ../node_modules/@aws-sdk/core/dist-cjs/submodules/httpAuthSchemes/index.js
var require_httpAuthSchemes = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var httpAuthSchemes_exports = {};
  __export2(httpAuthSchemes_exports, {
    AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
    AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
    AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
    NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
    resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
    resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
    resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
    validateSigningProperties: () => validateSigningProperties
  });
  module.exports = __toCommonJS(httpAuthSchemes_exports);
  var import_protocol_http22 = require_dist_cjs4();
  var import_protocol_http3 = require_dist_cjs4();
  var getDateHeader = /* @__PURE__ */ __name((response2) => {
    var _a2, _b;
    return import_protocol_http3.HttpResponse.isInstance(response2) ? ((_a2 = response2.headers) == null ? undefined : _a2.date) ?? ((_b = response2.headers) == null ? undefined : _b.Date) : undefined;
  }, "getDateHeader");
  var getSkewCorrectedDate = /* @__PURE__ */ __name((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");
  var isClockSkewed = /* @__PURE__ */ __name((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000, "isClockSkewed");
  var getUpdatedSystemClockOffset = /* @__PURE__ */ __name((clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  }, "getUpdatedSystemClockOffset");
  var throwSigningPropertyError = /* @__PURE__ */ __name((name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  }, "throwSigningPropertyError");
  var validateSigningProperties = /* @__PURE__ */ __name(async (signingProperties) => {
    var _a2, _b, _c;
    const context8 = throwSigningPropertyError("context", signingProperties.context);
    const config3 = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = (_c = (_b = (_a2 = context8.endpointV2) == null ? undefined : _a2.properties) == null ? undefined : _b.authSchemes) == null ? undefined : _c[0];
    const signerFunction = throwSigningPropertyError("signer", config3.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties == null ? undefined : signingProperties.signingRegion;
    const signingRegionSet = signingProperties == null ? undefined : signingProperties.signingRegionSet;
    const signingName = signingProperties == null ? undefined : signingProperties.signingName;
    return {
      config: config3,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  }, "validateSigningProperties");
  var _AwsSdkSigV4Signer = class _AwsSdkSigV4Signer2 {
    async sign(httpRequest2, identity3, signingProperties) {
      var _a2;
      if (!import_protocol_http22.HttpRequest.isInstance(httpRequest2)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config: config3, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (((_a2 = handlerExecutionContext == null ? undefined : handlerExecutionContext.authSchemes) == null ? undefined : _a2.length) ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if ((first == null ? undefined : first.name) === "sigv4a" && (second == null ? undefined : second.name) === "sigv4") {
          signingRegion = (second == null ? undefined : second.signingRegion) ?? signingRegion;
          signingName = (second == null ? undefined : second.signingName) ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest2, {
        signingDate: getSkewCorrectedDate(config3.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error5) => {
        const serverTime = error5.ServerTime ?? getDateHeader(error5.$response);
        if (serverTime) {
          const config3 = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config3.systemClockOffset;
          config3.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config3.systemClockOffset);
          const clockSkewCorrected = config3.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error5.$metadata) {
            error5.$metadata.clockSkewCorrected = true;
          }
        }
        throw error5;
      };
    }
    successHandler(httpResponse2, signingProperties) {
      const dateHeader = getDateHeader(httpResponse2);
      if (dateHeader) {
        const config3 = throwSigningPropertyError("config", signingProperties.config);
        config3.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config3.systemClockOffset);
      }
    }
  };
  __name(_AwsSdkSigV4Signer, "AwsSdkSigV4Signer");
  var AwsSdkSigV4Signer = _AwsSdkSigV4Signer;
  var AWSSDKSigV4Signer = AwsSdkSigV4Signer;
  var import_protocol_http32 = require_dist_cjs4();
  var _AwsSdkSigV4ASigner = class _AwsSdkSigV4ASigner2 extends AwsSdkSigV4Signer {
    async sign(httpRequest2, identity3, signingProperties) {
      var _a2;
      if (!import_protocol_http32.HttpRequest.isInstance(httpRequest2)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config: config3, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await ((_a2 = config3.sigv4aSigningRegionSet) == null ? undefined : _a2.call(config3));
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest2, {
        signingDate: getSkewCorrectedDate(config3.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  };
  __name(_AwsSdkSigV4ASigner, "AwsSdkSigV4ASigner");
  var AwsSdkSigV4ASigner = _AwsSdkSigV4ASigner;
  var import_core55 = require_dist_cjs15();
  var import_property_provider = require_dist_cjs16();
  var resolveAwsSdkSigV4AConfig = /* @__PURE__ */ __name((config3) => {
    config3.sigv4aSigningRegionSet = (0, import_core55.normalizeProvider)(config3.sigv4aSigningRegionSet);
    return config3;
  }, "resolveAwsSdkSigV4AConfig");
  var NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env2) {
      if (env2.AWS_SIGV4A_SIGNING_REGION_SET) {
        return env2.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_3) => _3.trim());
      }
      throw new import_property_provider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
        tryNextLink: true
      });
    },
    configFileSelector(profile2) {
      if (profile2.sigv4a_signing_region_set) {
        return (profile2.sigv4a_signing_region_set ?? "").split(",").map((_3) => _3.trim());
      }
      throw new import_property_provider.ProviderError("sigv4a_signing_region_set not set in profile.", {
        tryNextLink: true
      });
    },
    default: undefined
  };
  var import_client3 = require_client();
  var import_core210 = require_dist_cjs15();
  var import_signature_v4 = require_dist_cjs17();
  var resolveAwsSdkSigV4Config = /* @__PURE__ */ __name((config3) => {
    let isUserSupplied = false;
    let normalizedCreds;
    if (config3.credentials) {
      isUserSupplied = true;
      normalizedCreds = (0, import_core210.memoizeIdentityProvider)(config3.credentials, import_core210.isIdentityExpired, import_core210.doesIdentityRequireRefresh);
    }
    if (!normalizedCreds) {
      if (config3.credentialDefaultProvider) {
        normalizedCreds = (0, import_core210.normalizeProvider)(config3.credentialDefaultProvider(Object.assign({}, config3, {
          parentClientConfig: config3
        })));
      } else {
        normalizedCreds = /* @__PURE__ */ __name(async () => {
          throw new Error("`credentials` is missing");
        }, "normalizedCreds");
      }
    }
    const {
      signingEscapePath = true,
      systemClockOffset = config3.systemClockOffset || 0,
      sha256: sha2562
    } = config3;
    let signer;
    if (config3.signer) {
      signer = (0, import_core210.normalizeProvider)(config3.signer);
    } else if (config3.regionInfoProvider) {
      signer = /* @__PURE__ */ __name(() => (0, import_core210.normalizeProvider)(config3.region)().then(async (region) => [
        await config3.regionInfoProvider(region, {
          useFipsEndpoint: await config3.useFipsEndpoint(),
          useDualstackEndpoint: await config3.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config3.signingRegion = config3.signingRegion || signingRegion || region;
        config3.signingName = config3.signingName || signingService || config3.serviceId;
        const params = {
          ...config3,
          credentials: normalizedCreds,
          region: config3.signingRegion,
          service: config3.signingName,
          sha256: sha2562,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config3.signerConstructor || import_signature_v4.SignatureV4;
        return new SignerCtor(params);
      }), "signer");
    } else {
      signer = /* @__PURE__ */ __name(async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config3.signingName || config3.defaultSigningName,
          signingRegion: await (0, import_core210.normalizeProvider)(config3.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config3.signingRegion = config3.signingRegion || signingRegion;
        config3.signingName = config3.signingName || signingService || config3.serviceId;
        const params = {
          ...config3,
          credentials: normalizedCreds,
          region: config3.signingRegion,
          service: config3.signingName,
          sha256: sha2562,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config3.signerConstructor || import_signature_v4.SignatureV4;
        return new SignerCtor(params);
      }, "signer");
    }
    return {
      ...config3,
      systemClockOffset,
      signingEscapePath,
      credentials: isUserSupplied ? async () => normalizedCreds().then((creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_CODE", "e")) : normalizedCreds,
      signer
    };
  }, "resolveAwsSdkSigV4Config");
  var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
});

// ../node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs18 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    constructStack: () => constructStack
  });
  module.exports = __toCommonJS(src_exports);
  var getAllAliases = /* @__PURE__ */ __name((name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  }, "getAllAliases");
  var getMiddlewareNameWithAliases = /* @__PURE__ */ __name((name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  }, "getMiddlewareNameWithAliases");
  var constructStack = /* @__PURE__ */ __name(() => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = /* @__PURE__ */ new Set;
    const sort = /* @__PURE__ */ __name((entries) => entries.sort((a, b4) => stepWeights[b4.step] - stepWeights[a.step] || priorityWeights[b4.priority || "normal"] - priorityWeights[a.priority || "normal"]), "sort");
    const removeByName = /* @__PURE__ */ __name((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name((entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByName");
    const removeByReference = /* @__PURE__ */ __name((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name((entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByReference");
    const cloneTo = /* @__PURE__ */ __name((toStack) => {
      var _a2;
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      (_a2 = toStack.identifyOnResolve) == null || _a2.call(toStack, stack.identifyOnResolve());
      return toStack;
    }, "cloneTo");
    const expandRelativeMiddlewareList = /* @__PURE__ */ __name((from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    }, "expandRelativeMiddlewareList");
    const getMiddlewareList = /* @__PURE__ */ __name((debug3 = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === undefined) {
            if (debug3) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    }, "getMiddlewareList");
    const stack = {
      add: (middleware2, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware: middleware2,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => {
                var _a2;
                return entry2.name === alias || ((_a2 = entry2.aliases) == null ? undefined : _a2.some((a) => a === alias));
              });
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware2, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware: middleware2,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => {
                var _a2;
                return entry2.name === alias || ((_a2 = entry2.aliases) == null ? undefined : _a2.some((a) => a === alias));
              });
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = /* @__PURE__ */ __name((entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        }, "filterCb");
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        var _a2;
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (((_a2 = from.identifyOnResolve) == null ? undefined : _a2.call(from)) ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context8) => {
        for (const middleware2 of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware2(handler, context8);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  }, "constructStack");
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
});

// ../node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs19 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Client: () => Client,
    Command: () => Command,
    LazyJsonString: () => LazyJsonString,
    NoOpLogger: () => NoOpLogger,
    SENSITIVE_STRING: () => SENSITIVE_STRING,
    ServiceException: () => ServiceException,
    StringWrapper: () => StringWrapper,
    _json: () => _json,
    collectBody: () => import_protocols.collectBody,
    convertMap: () => convertMap,
    createAggregatedClient: () => createAggregatedClient,
    dateToUtcString: () => dateToUtcString,
    decorateServiceException: () => decorateServiceException,
    emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
    expectBoolean: () => expectBoolean,
    expectByte: () => expectByte,
    expectFloat32: () => expectFloat32,
    expectInt: () => expectInt,
    expectInt32: () => expectInt32,
    expectLong: () => expectLong,
    expectNonNull: () => expectNonNull,
    expectNumber: () => expectNumber,
    expectObject: () => expectObject,
    expectShort: () => expectShort,
    expectString: () => expectString,
    expectUnion: () => expectUnion,
    extendedEncodeURIComponent: () => import_protocols.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => getArrayIfSingleItem,
    getDefaultClientConfiguration: () => getDefaultClientConfiguration,
    getDefaultExtensionConfiguration: () => getDefaultExtensionConfiguration,
    getValueFromTextNode: () => getValueFromTextNode,
    handleFloat: () => handleFloat,
    isSerializableHeaderValue: () => isSerializableHeaderValue,
    limitedParseDouble: () => limitedParseDouble,
    limitedParseFloat: () => limitedParseFloat,
    limitedParseFloat32: () => limitedParseFloat32,
    loadConfigsForDefaultMode: () => loadConfigsForDefaultMode,
    logger: () => logger3,
    map: () => map5,
    parseBoolean: () => parseBoolean2,
    parseEpochTimestamp: () => parseEpochTimestamp,
    parseRfc3339DateTime: () => parseRfc3339DateTime,
    parseRfc3339DateTimeWithOffset: () => parseRfc3339DateTimeWithOffset,
    parseRfc7231DateTime: () => parseRfc7231DateTime,
    quoteHeader: () => quoteHeader,
    resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig,
    resolvedPath: () => import_protocols.resolvedPath,
    serializeDateTime: () => serializeDateTime,
    serializeFloat: () => serializeFloat,
    splitEvery: () => splitEvery,
    splitHeader: () => splitHeader,
    strictParseByte: () => strictParseByte,
    strictParseDouble: () => strictParseDouble,
    strictParseFloat: () => strictParseFloat,
    strictParseFloat32: () => strictParseFloat32,
    strictParseInt: () => strictParseInt,
    strictParseInt32: () => strictParseInt32,
    strictParseLong: () => strictParseLong,
    strictParseShort: () => strictParseShort,
    take: () => take,
    throwDefaultError: () => throwDefaultError,
    withBaseException: () => withBaseException
  });
  module.exports = __toCommonJS(src_exports);
  var import_middleware_stack = require_dist_cjs18();
  var _Client = class _Client2 {
    constructor(config3) {
      this.config = config3;
      this.middlewareStack = (0, import_middleware_stack.constructStack)();
    }
    send(command2, optionsOrCb, cb) {
      const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
      const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
      let handler;
      if (useHandlerCache) {
        if (!this.handlers) {
          this.handlers = /* @__PURE__ */ new WeakMap;
        }
        const handlers2 = this.handlers;
        if (handlers2.has(command2.constructor)) {
          handler = handlers2.get(command2.constructor);
        } else {
          handler = command2.resolveMiddleware(this.middlewareStack, this.config, options);
          handlers2.set(command2.constructor, handler);
        }
      } else {
        delete this.handlers;
        handler = command2.resolveMiddleware(this.middlewareStack, this.config, options);
      }
      if (callback) {
        handler(command2).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
        });
      } else {
        return handler(command2).then((result) => result.output);
      }
    }
    destroy() {
      var _a2, _b, _c;
      (_c = (_b = (_a2 = this.config) == null ? undefined : _a2.requestHandler) == null ? undefined : _b.destroy) == null || _c.call(_b);
      delete this.handlers;
    }
  };
  __name(_Client, "Client");
  var Client = _Client;
  var import_protocols = require_protocols();
  var import_types15 = require_dist_cjs();
  var _Command = class _Command2 {
    constructor() {
      this.middlewareStack = (0, import_middleware_stack.constructStack)();
    }
    static classBuilder() {
      return new ClassBuilder;
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, {
      middlewareFn,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      smithyContext,
      additionalContext,
      CommandCtor
    }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger: logger22 } = configuration;
      const handlerExecutionContext = {
        logger: logger22,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [import_types15.SMITHY_CONTEXT_KEY]: {
          commandInstance: this,
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
  };
  __name(_Command, "Command");
  var Command = _Command;
  var _ClassBuilder = class _ClassBuilder2 {
    constructor() {
      this._init = () => {
      };
      this._ep = {};
      this._middlewareFn = () => [];
      this._commandName = "";
      this._clientName = "";
      this._additionalContext = {};
      this._smithyContext = {};
      this._inputFilterSensitiveLog = (_3) => _3;
      this._outputFilterSensitiveLog = (_3) => _3;
      this._serializer = null;
      this._deserializer = null;
    }
    init(cb) {
      this._init = cb;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_3) => _3, outputFilter = (_3) => _3) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    build() {
      var _a2;
      const closure = this;
      let CommandRef;
      return CommandRef = (_a2 = class extends Command {
        constructor(...[input]) {
          super();
          this.serialize = closure._serializer;
          this.deserialize = closure._deserializer;
          this.input = input ?? {};
          closure._init(this);
        }
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        resolveMiddleware(stack, configuration, options) {
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
      }, __name(_a2, "CommandRef"), _a2);
    }
  };
  __name(_ClassBuilder, "ClassBuilder");
  var ClassBuilder = _ClassBuilder;
  var SENSITIVE_STRING = "***SensitiveInformation***";
  var createAggregatedClient = /* @__PURE__ */ __name((commands, Client2) => {
    for (const command2 of Object.keys(commands)) {
      const CommandCtor = commands[command2];
      const methodImpl = /* @__PURE__ */ __name(async function(args, optionsOrCb, cb) {
        const command22 = new CommandCtor(args);
        if (typeof optionsOrCb === "function") {
          this.send(command22, optionsOrCb);
        } else if (typeof cb === "function") {
          if (typeof optionsOrCb !== "object")
            throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
          this.send(command22, optionsOrCb || {}, cb);
        } else {
          return this.send(command22, optionsOrCb);
        }
      }, "methodImpl");
      const methodName = (command2[0].toLowerCase() + command2.slice(1)).replace(/Command$/, "");
      Client2.prototype[methodName] = methodImpl;
    }
  }, "createAggregatedClient");
  var parseBoolean2 = /* @__PURE__ */ __name((value3) => {
    switch (value3) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value3}"`);
    }
  }, "parseBoolean");
  var expectBoolean = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 === "number") {
      if (value3 === 0 || value3 === 1) {
        logger3.warn(stackTraceWarning(`Expected boolean, got ${typeof value3}: ${value3}`));
      }
      if (value3 === 0) {
        return false;
      }
      if (value3 === 1) {
        return true;
      }
    }
    if (typeof value3 === "string") {
      const lower2 = value3.toLowerCase();
      if (lower2 === "false" || lower2 === "true") {
        logger3.warn(stackTraceWarning(`Expected boolean, got ${typeof value3}: ${value3}`));
      }
      if (lower2 === "false") {
        return false;
      }
      if (lower2 === "true") {
        return true;
      }
    }
    if (typeof value3 === "boolean") {
      return value3;
    }
    throw new TypeError(`Expected boolean, got ${typeof value3}: ${value3}`);
  }, "expectBoolean");
  var expectNumber = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 === "string") {
      const parsed = parseFloat(value3);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value3)) {
          logger3.warn(stackTraceWarning(`Expected number but observed string: ${value3}`));
        }
        return parsed;
      }
    }
    if (typeof value3 === "number") {
      return value3;
    }
    throw new TypeError(`Expected number, got ${typeof value3}: ${value3}`);
  }, "expectNumber");
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = /* @__PURE__ */ __name((value3) => {
    const expected = expectNumber(value3);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value3}`);
      }
    }
    return expected;
  }, "expectFloat32");
  var expectLong = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (Number.isInteger(value3) && !Number.isNaN(value3)) {
      return value3;
    }
    throw new TypeError(`Expected integer, got ${typeof value3}: ${value3}`);
  }, "expectLong");
  var expectInt = expectLong;
  var expectInt32 = /* @__PURE__ */ __name((value3) => expectSizedInt(value3, 32), "expectInt32");
  var expectShort = /* @__PURE__ */ __name((value3) => expectSizedInt(value3, 16), "expectShort");
  var expectByte = /* @__PURE__ */ __name((value3) => expectSizedInt(value3, 8), "expectByte");
  var expectSizedInt = /* @__PURE__ */ __name((value3, size2) => {
    const expected = expectLong(value3);
    if (expected !== undefined && castInt(expected, size2) !== expected) {
      throw new TypeError(`Expected ${size2}-bit integer, got ${value3}`);
    }
    return expected;
  }, "expectSizedInt");
  var castInt = /* @__PURE__ */ __name((value3, size2) => {
    switch (size2) {
      case 32:
        return Int32Array.of(value3)[0];
      case 16:
        return Int16Array.of(value3)[0];
      case 8:
        return Int8Array.of(value3)[0];
    }
  }, "castInt");
  var expectNonNull = /* @__PURE__ */ __name((value3, location) => {
    if (value3 === null || value3 === undefined) {
      if (location) {
        throw new TypeError(`Expected a non-null value for ${location}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value3;
  }, "expectNonNull");
  var expectObject = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return value3;
    }
    const receivedType = Array.isArray(value3) ? "array" : typeof value3;
    throw new TypeError(`Expected object, got ${receivedType}: ${value3}`);
  }, "expectObject");
  var expectString = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 === "string") {
      return value3;
    }
    if (["boolean", "number", "bigint"].includes(typeof value3)) {
      logger3.warn(stackTraceWarning(`Expected string, got ${typeof value3}: ${value3}`));
      return String(value3);
    }
    throw new TypeError(`Expected string, got ${typeof value3}: ${value3}`);
  }, "expectString");
  var expectUnion = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    const asObject = expectObject(value3);
    const setKeys = Object.entries(asObject).filter(([, v4]) => v4 != null).map(([k4]) => k4);
    if (setKeys.length === 0) {
      throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
      throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
  }, "expectUnion");
  var strictParseDouble = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 == "string") {
      return expectNumber(parseNumber2(value3));
    }
    return expectNumber(value3);
  }, "strictParseDouble");
  var strictParseFloat = strictParseDouble;
  var strictParseFloat32 = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 == "string") {
      return expectFloat32(parseNumber2(value3));
    }
    return expectFloat32(value3);
  }, "strictParseFloat32");
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber2 = /* @__PURE__ */ __name((value3) => {
    const matches = value3.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value3.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value3);
  }, "parseNumber");
  var limitedParseDouble = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 == "string") {
      return parseFloatString(value3);
    }
    return expectNumber(value3);
  }, "limitedParseDouble");
  var handleFloat = limitedParseDouble;
  var limitedParseFloat = limitedParseDouble;
  var limitedParseFloat32 = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 == "string") {
      return parseFloatString(value3);
    }
    return expectFloat32(value3);
  }, "limitedParseFloat32");
  var parseFloatString = /* @__PURE__ */ __name((value3) => {
    switch (value3) {
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error(`Unable to parse float value: ${value3}`);
    }
  }, "parseFloatString");
  var strictParseLong = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 === "string") {
      return expectLong(parseNumber2(value3));
    }
    return expectLong(value3);
  }, "strictParseLong");
  var strictParseInt = strictParseLong;
  var strictParseInt32 = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 === "string") {
      return expectInt32(parseNumber2(value3));
    }
    return expectInt32(value3);
  }, "strictParseInt32");
  var strictParseShort = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 === "string") {
      return expectShort(parseNumber2(value3));
    }
    return expectShort(value3);
  }, "strictParseShort");
  var strictParseByte = /* @__PURE__ */ __name((value3) => {
    if (typeof value3 === "string") {
      return expectByte(parseNumber2(value3));
    }
    return expectByte(value3);
  }, "strictParseByte");
  var stackTraceWarning = /* @__PURE__ */ __name((message) => {
    return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join("\n");
  }, "stackTraceWarning");
  var logger3 = {
    warn: console.warn
  };
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date6) {
    const year = date6.getUTCFullYear();
    const month = date6.getUTCMonth();
    const dayOfWeek = date6.getUTCDay();
    const dayOfMonthInt = date6.getUTCDate();
    const hoursInt = date6.getUTCHours();
    const minutesInt = date6.getUTCMinutes();
    const secondsInt = date6.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  __name(dateToUtcString, "dateToUtcString");
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var parseRfc3339DateTime = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value3);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  }, "parseRfc3339DateTime");
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value3);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date6 = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date6.setTime(date6.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date6;
  }, "parseRfc3339DateTimeWithOffset");
  var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    if (typeof value3 !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value3);
    if (match) {
      const [_3, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value3);
    if (match) {
      const [_3, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME.exec(value3);
    if (match) {
      const [_3, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  }, "parseRfc7231DateTime");
  var parseEpochTimestamp = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return;
    }
    let valueAsDouble;
    if (typeof value3 === "number") {
      valueAsDouble = value3;
    } else if (typeof value3 === "string") {
      valueAsDouble = strictParseDouble(value3);
    } else if (typeof value3 === "object" && value3.tag === 1) {
      valueAsDouble = value3.value;
    } else {
      throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
      throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
  }, "parseEpochTimestamp");
  var buildDate = /* @__PURE__ */ __name((year, month, day, time2) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
  }, "buildDate");
  var parseTwoDigitYear = /* @__PURE__ */ __name((value3) => {
    const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value3));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  }, "parseTwoDigitYear");
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  var adjustRfc850Year = /* @__PURE__ */ __name((input) => {
    if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  }, "adjustRfc850Year");
  var parseMonthByShortName = /* @__PURE__ */ __name((value3) => {
    const monthIdx = MONTHS.indexOf(value3);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value3}`);
    }
    return monthIdx + 1;
  }, "parseMonthByShortName");
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = /* @__PURE__ */ __name((year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
  }, "validateDayOfMonth");
  var isLeapYear = /* @__PURE__ */ __name((year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }, "isLeapYear");
  var parseDateValue = /* @__PURE__ */ __name((value3, type5, lower2, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value3));
    if (dateVal < lower2 || dateVal > upper) {
      throw new TypeError(`${type5} must be between ${lower2} and ${upper}, inclusive`);
    }
    return dateVal;
  }, "parseDateValue");
  var parseMilliseconds = /* @__PURE__ */ __name((value3) => {
    if (value3 === null || value3 === undefined) {
      return 0;
    }
    return strictParseFloat32("0." + value3) * 1000;
  }, "parseMilliseconds");
  var parseOffsetToMilliseconds = /* @__PURE__ */ __name((value3) => {
    const directionStr = value3[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value3.substring(1, 3));
    const minute = Number(value3.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
  }, "parseOffsetToMilliseconds");
  var stripLeadingZeroes = /* @__PURE__ */ __name((value3) => {
    let idx = 0;
    while (idx < value3.length - 1 && value3.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value3;
    }
    return value3.slice(idx);
  }, "stripLeadingZeroes");
  var _ServiceException = class _ServiceException2 extends Error {
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, _ServiceException2.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
  };
  __name(_ServiceException, "ServiceException");
  var ServiceException = _ServiceException;
  var decorateServiceException = /* @__PURE__ */ __name((exception, additions = {}) => {
    Object.entries(additions).filter(([, v4]) => v4 !== undefined).forEach(([k4, v4]) => {
      if (exception[k4] == undefined || exception[k4] === "") {
        exception[k4] = v4;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  }, "decorateServiceException");
  var throwDefaultError = /* @__PURE__ */ __name(({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response2 = new exceptionCtor({
      name: (parsedBody == null ? undefined : parsedBody.code) || (parsedBody == null ? undefined : parsedBody.Code) || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response2, parsedBody);
  }, "throwDefaultError");
  var withBaseException = /* @__PURE__ */ __name((ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  }, "withBaseException");
  var deserializeMetadata = /* @__PURE__ */ __name((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");
  var loadConfigsForDefaultMode = /* @__PURE__ */ __name((mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 30000
        };
      default:
        return {};
    }
  }, "loadConfigsForDefaultMode");
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name((version3) => {
    if (version3 && !warningEmitted && parseInt(version3.substring(1, version3.indexOf("."))) < 16) {
      warningEmitted = true;
    }
  }, "emitWarningIfUnsupportedVersion");
  var getChecksumConfiguration2 = /* @__PURE__ */ __name((runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in import_types15.AlgorithmId) {
      const algorithmId = import_types15.AlgorithmId[id];
      if (runtimeConfig[algorithmId] === undefined) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  }, "getChecksumConfiguration");
  var resolveChecksumRuntimeConfig2 = /* @__PURE__ */ __name((clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  }, "resolveChecksumRuntimeConfig");
  var getRetryConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
      setRetryStrategy(retryStrategy) {
        _retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return _retryStrategy;
      }
    };
  }, "getRetryConfiguration");
  var resolveRetryRuntimeConfig = /* @__PURE__ */ __name((retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  }, "resolveRetryRuntimeConfig");
  var getDefaultExtensionConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    return {
      ...getChecksumConfiguration2(runtimeConfig),
      ...getRetryConfiguration(runtimeConfig)
    };
  }, "getDefaultExtensionConfiguration");
  var getDefaultClientConfiguration = getDefaultExtensionConfiguration;
  var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name((config3) => {
    return {
      ...resolveChecksumRuntimeConfig2(config3),
      ...resolveRetryRuntimeConfig(config3)
    };
  }, "resolveDefaultRuntimeConfig");
  var getArrayIfSingleItem = /* @__PURE__ */ __name((mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray], "getArrayIfSingleItem");
  var getValueFromTextNode = /* @__PURE__ */ __name((obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  }, "getValueFromTextNode");
  var isSerializableHeaderValue = /* @__PURE__ */ __name((value3) => {
    return value3 != null;
  }, "isSerializableHeaderValue");
  var StringWrapper = /* @__PURE__ */ __name(function() {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor3 = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor3;
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
  }, "StringWrapper");
  StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: StringWrapper,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Object.setPrototypeOf(StringWrapper, String);
  var _LazyJsonString = class _LazyJsonString2 extends StringWrapper {
    deserializeJSON() {
      return JSON.parse(super.toString());
    }
    toJSON() {
      return super.toString();
    }
    static fromObject(object5) {
      if (object5 instanceof _LazyJsonString2) {
        return object5;
      } else if (object5 instanceof String || typeof object5 === "string") {
        return new _LazyJsonString2(object5);
      }
      return new _LazyJsonString2(JSON.stringify(object5));
    }
  };
  __name(_LazyJsonString, "LazyJsonString");
  var LazyJsonString = _LazyJsonString;
  var _NoOpLogger = class _NoOpLogger2 {
    trace() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
  };
  __name(_NoOpLogger, "NoOpLogger");
  var NoOpLogger = _NoOpLogger;
  function map5(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  __name(map5, "map");
  var convertMap = /* @__PURE__ */ __name((target) => {
    const output = {};
    for (const [k4, v4] of Object.entries(target || {})) {
      output[k4] = [, v4];
    }
    return output;
  }, "convertMap");
  var take = /* @__PURE__ */ __name((source, instructions) => {
    const out = {};
    for (const key in instructions) {
      applyInstruction(out, source, instructions, key);
    }
    return out;
  }, "take");
  var mapWithFilter = /* @__PURE__ */ __name((target, filter, instructions) => {
    return map5(target, Object.entries(instructions).reduce((_instructions, [key, value3]) => {
      if (Array.isArray(value3)) {
        _instructions[key] = value3;
      } else {
        if (typeof value3 === "function") {
          _instructions[key] = [filter, value3()];
        } else {
          _instructions[key] = [filter, value3];
        }
      }
      return _instructions;
    }, {}));
  }, "mapWithFilter");
  var applyInstruction = /* @__PURE__ */ __name((target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value3] = instructions[targetKey];
    if (typeof value3 === "function") {
      let _value;
      const defaultFilterPassed = filter === undefined && (_value = value3()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value3();
      }
    } else {
      const defaultFilterPassed = filter === undefined && value3 != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value3) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value3;
      }
    }
  }, "applyInstruction");
  var nonNullish = /* @__PURE__ */ __name((_3) => _3 != null, "nonNullish");
  var pass = /* @__PURE__ */ __name((_3) => _3, "pass");
  function quoteHeader(part) {
    if (part.includes(",") || part.includes('"')) {
      part = `"${part.replace(/"/g, '\\"')}"`;
    }
    return part;
  }
  __name(quoteHeader, "quoteHeader");
  var serializeFloat = /* @__PURE__ */ __name((value3) => {
    if (value3 !== value3) {
      return "NaN";
    }
    switch (value3) {
      case Infinity:
        return "Infinity";
      case -Infinity:
        return "-Infinity";
      default:
        return value3;
    }
  }, "serializeFloat");
  var serializeDateTime = /* @__PURE__ */ __name((date6) => date6.toISOString().replace(".000Z", "Z"), "serializeDateTime");
  var _json = /* @__PURE__ */ __name((obj) => {
    if (obj == null) {
      return {};
    }
    if (Array.isArray(obj)) {
      return obj.filter((_3) => _3 != null).map(_json);
    }
    if (typeof obj === "object") {
      const target = {};
      for (const key of Object.keys(obj)) {
        if (obj[key] == null) {
          continue;
        }
        target[key] = _json(obj[key]);
      }
      return target;
    }
    return obj;
  }, "_json");
  function splitEvery(value3, delimiter2, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
      throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value3.split(delimiter2);
    if (numDelimiters === 1) {
      return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i3 = 0;i3 < segments.length; i3++) {
      if (currentSegment === "") {
        currentSegment = segments[i3];
      } else {
        currentSegment += delimiter2 + segments[i3];
      }
      if ((i3 + 1) % numDelimiters === 0) {
        compoundSegments.push(currentSegment);
        currentSegment = "";
      }
    }
    if (currentSegment !== "") {
      compoundSegments.push(currentSegment);
    }
    return compoundSegments;
  }
  __name(splitEvery, "splitEvery");
  var splitHeader = /* @__PURE__ */ __name((value3) => {
    const z4 = value3.length;
    const values2 = [];
    let withinQuotes = false;
    let prevChar = undefined;
    let anchor = 0;
    for (let i3 = 0;i3 < z4; ++i3) {
      const char2 = value3[i3];
      switch (char2) {
        case `"`:
          if (prevChar !== "\\") {
            withinQuotes = !withinQuotes;
          }
          break;
        case ",":
          if (!withinQuotes) {
            values2.push(value3.slice(anchor, i3));
            anchor = i3 + 1;
          }
          break;
        default:
      }
      prevChar = char2;
    }
    values2.push(value3.slice(anchor));
    return values2.map((v4) => {
      v4 = v4.trim();
      const z22 = v4.length;
      if (z22 < 2) {
        return v4;
      }
      if (v4[0] === `"` && v4[z22 - 1] === `"`) {
        v4 = v4.slice(1, z22 - 1);
      }
      return v4.replace(/\\"/g, '"');
    });
  }, "splitHeader");
});

// ../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string5, regex) {
    const matches = [];
    let match = regex.exec(string5);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index2 = 0;index2 < len; index2++) {
        allmatches.push(match[index2]);
      }
      matches.push(allmatches);
      match = regex.exec(string5);
    }
    return matches;
  };
  var isName = function(string5) {
    const match = regexName.exec(string5);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v4) {
    return typeof v4 !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i3 = 0;i3 < len; i3++) {
        if (arrayMode === "strict") {
          target[keys[i3]] = [a[keys[i3]]];
        } else {
          target[keys[i3]] = a[keys[i3]];
        }
      }
    }
  };
  exports.getValue = function(v4) {
    if (exports.isExist(v4)) {
      return v4;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// ../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS((exports) => {
  var util3 = require_util();
  var defaultOptions = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i3 = 0;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
        i3 += 2;
        i3 = readPI(xmlData, i3);
        if (i3.err)
          return i3;
      } else if (xmlData[i3] === "<") {
        let tagStartPos = i3;
        i3++;
        if (xmlData[i3] === "!") {
          i3 = readCommentAndCDATA(xmlData, i3);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i3] === "/") {
            closingTag = true;
            i3++;
          }
          let tagName = "";
          for (;i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "\t" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
            tagName += xmlData[i3];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i3--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
          }
          const result = readAttributeStr(xmlData, i3);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
          }
          let attrStr = result.value;
          i3 = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i3 - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
            } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i3++;i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<") {
              if (xmlData[i3 + 1] === "!") {
                i3++;
                i3 = readCommentAndCDATA(xmlData, i3);
                continue;
              } else if (xmlData[i3 + 1] === "?") {
                i3 = readPI(xmlData, ++i3);
                if (i3.err)
                  return i3;
              } else {
                break;
              }
            } else if (xmlData[i3] === "&") {
              const afterAmp = validateAmpersand(xmlData, i3);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
              i3 = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
              }
            }
          }
          if (xmlData[i3] === "<") {
            i3--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i3])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  function isWhiteSpace(char2) {
    return char2 === " " || char2 === "\t" || char2 === "\n" || char2 === "\r";
  }
  function readPI(xmlData, i3) {
    const start = i3;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] == "?" || xmlData[i3] == " ") {
        const tagname = xmlData.substr(start, i3 - start);
        if (i3 > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
        } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
          i3++;
          break;
        } else {
          continue;
        }
      }
    }
    return i3;
  }
  function readCommentAndCDATA(xmlData, i3) {
    if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
      for (i3 += 3;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
          i3 += 2;
          break;
        }
      }
    } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
      let angleBracketsCount = 1;
      for (i3 += 8;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i3] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
      for (i3 += 8;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
          i3 += 2;
          break;
        }
      }
    }
    return i3;
  }
  var doubleQuote = '"';
  var singleQuote = "'";
  function readAttributeStr(xmlData, i3) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i3];
        } else if (startChar !== xmlData[i3]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i3] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i3];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i3,
      tagClosed
    };
  }
  var validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', "g");
  function validateAttributeString(attrStr, options) {
    const matches = util3.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i3 = 0;i3 < matches.length; i3++) {
      if (matches[i3][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
      } else if (matches[i3][3] !== undefined && matches[i3][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
      } else if (matches[i3][3] === undefined && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
      }
      const attrName = matches[i3][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i3) {
    let re = /\d/;
    if (xmlData[i3] === "x") {
      i3++;
      re = /[\da-fA-F]/;
    }
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === ";")
        return i3;
      if (!xmlData[i3].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i3) {
    i3++;
    if (xmlData[i3] === ";")
      return -1;
    if (xmlData[i3] === "#") {
      i3++;
      return validateNumberAmpersand(xmlData, i3);
    }
    let count = 0;
    for (;i3 < xmlData.length; i3++, count++) {
      if (xmlData[i3].match(/\w/) && count < 20)
        continue;
      if (xmlData[i3] === ";")
        break;
      return -1;
    }
    return i3;
  }
  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return util3.isName(attrName);
  }
  function validateTagName(tagname) {
    return util3.isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index2) {
    const lines = xmlData.substring(0, index2).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val2) {
      return val2;
    },
    attributeValueProcessor: function(attrName, val2) {
      return val2;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions;
});

// ../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val2) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val2 });
    }
    addChild(node2) {
      if (node2.tagname === "__proto__")
        node2.tagname = "#__proto__";
      if (node2[":@"] && Object.keys(node2[":@"]).length > 0) {
        this.child.push({ [node2.tagname]: node2.child, [":@"]: node2[":@"] });
      } else {
        this.child.push({ [node2.tagname]: node2.child });
      }
    }
  }
  module.exports = XmlNode;
});

// ../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  var util3 = require_util();
  function readDocType(xmlData, i3) {
    const entities = {};
    if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
      i3 = i3 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i3)) {
            i3 += 7;
            [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement2(xmlData, i3))
            i3 += 8;
          else if (hasBody && isAttlist(xmlData, i3))
            i3 += 8;
          else if (hasBody && isNotation(xmlData, i3))
            i3 += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i3] === ">") {
          if (comment) {
            if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i3] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i3];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i3 };
  }
  function readEntityExp(xmlData, i3) {
    let entityName2 = "";
    for (;i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
      entityName2 += xmlData[i3];
    }
    entityName2 = entityName2.trim();
    if (entityName2.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i3++];
    let val2 = "";
    for (;i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
      val2 += xmlData[i3];
    }
    return [entityName2, val2, i3];
  }
  function isComment(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
      return true;
    return false;
  }
  function isEntity(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
      return true;
    return false;
  }
  function isElement2(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
      return true;
    return false;
  }
  function isAttlist(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
      return true;
    return false;
  }
  function isNotation(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
      return true;
    return false;
  }
  function validateEntityName(name) {
    if (util3.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  module.exports = readDocType;
});

// ../node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr))
      return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  module.exports = toNumber;
});

// ../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  var util3 = require_util();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();

  class OrderedObjParser {
    constructor(options) {
      this.options = options;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: "\"" }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "\xA2" },
        pound: { regex: /&(pound|#163);/g, val: "\xA3" },
        yen: { regex: /&(yen|#165);/g, val: "\xA5" },
        euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
        copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
        reg: { regex: /&(reg|#174);/g, val: "\xAE" },
        inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (_3, str) => String.fromCharCode(Number.parseInt(str, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_3, str) => String.fromCharCode(Number.parseInt(str, 16)) }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
    }
  }
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i3 = 0;i3 < entKeys.length; i3++) {
      const ent = entKeys[i3];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val2 !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val2 = val2.trim();
      }
      if (val2.length > 0) {
        if (!escapeEntities)
          val2 = this.replaceEntitiesValue(val2);
        const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val2;
        } else if (typeof newval !== typeof val2 || newval !== val2) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val2.trim();
          if (trimmedVal === val2) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val2;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  var attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', "gm");
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (!this.options.ignoreAttributes && typeof attrStr === "string") {
      const matches = util3.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i3 = 0;i3 < len; i3++) {
        const attrName = this.resolveNameSpace(matches[i3][1]);
        let oldVal = matches[i3][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i3 = 0;i3 < xmlData.length; i3++) {
      const ch = xmlData[i3];
      if (ch === "<") {
        if (xmlData[i3 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i3 = closeIndex;
        } else if (xmlData[i3 + 1] === "?") {
          let tagData = readTagExp(xmlData, i3, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i3 = tagData.closeIndex + 1;
        } else if (xmlData.substr(i3 + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i3 + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i3 = endIndex;
        } else if (xmlData.substr(i3 + 1, 2) === "!D") {
          const result = readDocType(xmlData, i3);
          this.docTypeEntities = result.entities;
          i3 = result.i;
        } else if (xmlData.substr(i3 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i3 + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
          if (val2 == undefined)
            val2 = "";
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            currentNode.add(this.options.textNodeName, val2);
          }
          i3 = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
          let tagName = result.tagName;
          const rawTagName = result.rawTagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              i3 = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i3 = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${rawTagName}`);
              i3 = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i3 = closeIndex;
          }
        }
      } else {
        textData += xmlData[i3];
      }
    }
    return xmlObj.child;
  };
  function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  var replaceEntitiesValue = function(val2) {
    if (this.options.processEntities) {
      for (let entityName2 in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName2];
        val2 = val2.replace(entity.regx, entity.val);
      }
      for (let entityName2 in this.lastEntities) {
        const entity = this.lastEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName2 in this.htmlEntities) {
          const entity = this.htmlEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
      }
      val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val2;
  };
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index2 = i3;index2 < xmlData.length; index2++) {
      let ch = xmlData[index2];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index2 + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index: index2
            };
          }
        } else {
          return {
            data: tagExp,
            index: index2
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i3, errMsg) {
    const closingIndex = xmlData.indexOf(str, i3);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i3) {
    const startIndex = i3;
    let openTagCount = 1;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === "<") {
        if (xmlData[i3 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i3),
                i: closeIndex
              };
            }
          }
          i3 = closeIndex;
        } else if (xmlData[i3 + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
          i3 = closeIndex;
        } else if (xmlData.substr(i3 + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
          i3 = closeIndex;
        } else if (xmlData.substr(i3 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
          i3 = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i3, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i3 = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val2, shouldParse, options) {
    if (shouldParse && typeof val2 === "string") {
      const newval = val2.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val2, options);
    } else {
      if (util3.isExist(val2)) {
        return val2;
      } else {
        return "";
      }
    }
  }
  module.exports = OrderedObjParser;
});

// ../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  function prettify(node2, options) {
    return compress(node2, options);
  }
  function compress(arr, options, jPath) {
    let text4;
    const compressedObj = {};
    for (let i3 = 0;i3 < arr.length; i3++) {
      const tagObj = arr[i3];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text4 === undefined)
          text4 = tagObj[property];
        else
          text4 += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val2 = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val2, options);
        if (tagObj[":@"]) {
          assignAttributes(val2, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
          val2 = val2[options.textNodeName];
        } else if (Object.keys(val2).length === 0) {
          if (options.alwaysCreateTextNode)
            val2[options.textNodeName] = "";
          else
            val2 = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val2);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val2];
          } else {
            compressedObj[property] = val2;
          }
        }
      }
    }
    if (typeof text4 === "string") {
      if (text4.length > 0)
        compressedObj[options.textNodeName] = text4;
    } else if (text4 !== undefined)
      compressedObj[options.textNodeName] = text4;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i3 = 0;i3 < keys.length; i3++) {
      const key = keys[i3];
      if (key !== ":@")
        return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i3 = 0;i3 < len; i3++) {
        const atrrName = keys[i3];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  exports.prettify = prettify;
});

// ../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator = require_validator();

  class XMLParser {
    constructor(options) {
      this.externalEntities = {};
      this.options = buildOptions(options);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value3) {
      if (value3.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value3 === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value3;
      }
    }
  }
  module.exports = XMLParser;
});

// ../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  var EOL = "\n";
  function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
  }
  function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i3 = 0;i3 < arr.length; i3++) {
      const tagObj = arr[i3];
      const tagName = propName(tagObj);
      if (tagName === undefined)
        continue;
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options)) {
          tagText = options.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
      if (options.unpairedTags.indexOf(tagName) !== -1) {
        if (options.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i3 = 0;i3 < keys.length; i3++) {
      const key = keys[i3];
      if (!obj.hasOwnProperty(key))
        continue;
      if (key !== ":@")
        return key;
    }
  }
  function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
      for (let attr in attrMap) {
        if (!attrMap.hasOwnProperty(attr))
          continue;
        let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options);
        if (attrVal === true && options.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index2 in options.stopNodes) {
      if (options.stopNodes[index2] === jPath || options.stopNodes[index2] === "*." + tagName)
        return true;
    }
    return false;
  }
  function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
      for (let i3 = 0;i3 < options.entities.length; i3++) {
        const entity = options.entities[i3];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  module.exports = toXml;
});

// ../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  var buildFromOrderedJs = require_orderedJs2Xml();
  var defaultOptions = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
      return a;
    },
    attributeValueProcessor: function(attrName, a) {
      return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("\'", "g"), val: "&apos;" },
      { regex: new RegExp("\"", "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  function Builder2(options) {
    this.options = Object.assign({}, defaultOptions, options);
    if (this.options.ignoreAttributes || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = ">\n";
      this.newLine = "\n";
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  Builder2.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0).val;
    }
  };
  Builder2.prototype.j2x = function(jObj, level) {
    let attrStr = "";
    let val2 = "";
    for (let key in jObj) {
      if (!Object.prototype.hasOwnProperty.call(jObj, key))
        continue;
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val2 += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val2 += "";
        } else if (key[0] === "?") {
          val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val2 += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val2 += this.replaceEntitiesValue(newval);
          } else {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        let listTagAttr = "";
        for (let j4 = 0;j4 < arrLen; j4++) {
          const item = jObj[key][j4];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              const result = this.j2x(item, level + 1);
              listTagVal += result.val;
              if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                listTagAttr += result.attrStr;
              }
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level);
            }
          } else {
            if (this.options.oneListGroup) {
              let textValue = this.options.tagValueProcessor(key, item);
              textValue = this.replaceEntitiesValue(textValue);
              listTagVal += textValue;
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
        }
        val2 += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L3 = Ks.length;
          for (let j4 = 0;j4 < L3; j4++) {
            attrStr += this.buildAttrPairStr(Ks[j4], "" + jObj[key][Ks[j4]]);
          }
        } else {
          val2 += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }
    return { attrStr, val: val2 };
  };
  Builder2.prototype.buildAttrPairStr = function(attrName, val2) {
    val2 = this.options.attributeValueProcessor(attrName, "" + val2);
    val2 = this.replaceEntitiesValue(val2);
    if (this.options.suppressBooleanAttributes && val2 === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val2 + '"';
  };
  function processTextOrObjNode(object5, key, level) {
    const result = this.j2x(object5, level + 1);
    if (object5[this.options.textNodeName] !== undefined && Object.keys(object5).length === 1) {
      return this.buildTextValNode(object5[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  }
  Builder2.prototype.buildObjectNode = function(val2, key, attrStr, level) {
    if (val2 === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder2.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder2.prototype.buildTextValNode = function(val2, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val2);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder2.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i3 = 0;i3 < this.options.entities.length; i3++) {
        const entity = this.options.entities[i3];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  module.exports = Builder2;
});

// ../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator = require_validator();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
});

// ../node_modules/@aws-sdk/core/dist-cjs/submodules/protocols/index.js
var require_protocols2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var protocols_exports = {};
  __export2(protocols_exports, {
    _toBool: () => _toBool,
    _toNum: () => _toNum,
    _toStr: () => _toStr,
    awsExpectUnion: () => awsExpectUnion,
    loadRestJsonErrorCode: () => loadRestJsonErrorCode,
    loadRestXmlErrorCode: () => loadRestXmlErrorCode,
    parseJsonBody: () => parseJsonBody,
    parseJsonErrorBody: () => parseJsonErrorBody,
    parseXmlBody: () => parseXmlBody,
    parseXmlErrorBody: () => parseXmlErrorBody
  });
  module.exports = __toCommonJS(protocols_exports);
  var _toStr = /* @__PURE__ */ __name((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number" || typeof val2 === "bigint") {
      const warning = new Error(`Received number ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    if (typeof val2 === "boolean") {
      const warning = new Error(`Received boolean ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    return val2;
  }, "_toStr");
  var _toBool = /* @__PURE__ */ __name((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number") {
    }
    if (typeof val2 === "string") {
      const lowercase3 = val2.toLowerCase();
      if (val2 !== "" && lowercase3 !== "false" && lowercase3 !== "true") {
        const warning = new Error(`Received string "${val2}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val2 !== "" && lowercase3 !== "false";
    }
    return val2;
  }, "_toBool");
  var _toNum = /* @__PURE__ */ __name((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "boolean") {
    }
    if (typeof val2 === "string") {
      const num = Number(val2);
      if (num.toString() !== val2) {
        const warning = new Error(`Received string "${val2}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val2;
      }
      return num;
    }
    return val2;
  }, "_toNum");
  var import_smithy_client = require_dist_cjs19();
  var awsExpectUnion = /* @__PURE__ */ __name((value3) => {
    if (value3 == null) {
      return;
    }
    if (typeof value3 === "object" && "__type" in value3) {
      delete value3.__type;
    }
    return (0, import_smithy_client.expectUnion)(value3);
  }, "awsExpectUnion");
  var import_smithy_client2 = require_dist_cjs19();
  var collectBodyString = /* @__PURE__ */ __name((streamBody, context8) => (0, import_smithy_client2.collectBody)(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
  var parseJsonBody = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString(streamBody, context8).then((encoded) => {
    if (encoded.length) {
      try {
        return JSON.parse(encoded);
      } catch (e) {
        if ((e == null ? undefined : e.name) === "SyntaxError") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
    }
    return {};
  }), "parseJsonBody");
  var parseJsonErrorBody = /* @__PURE__ */ __name(async (errorBody, context8) => {
    const value3 = await parseJsonBody(errorBody, context8);
    value3.message = value3.message ?? value3.Message;
    return value3;
  }, "parseJsonErrorBody");
  var loadRestJsonErrorCode = /* @__PURE__ */ __name((output, data) => {
    const findKey = /* @__PURE__ */ __name((object5, key) => Object.keys(object5).find((k4) => k4.toLowerCase() === key.toLowerCase()), "findKey");
    const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    }, "sanitizeErrorCode");
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
      return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
      return sanitizeErrorCode(data["__type"]);
    }
  }, "loadRestJsonErrorCode");
  var import_smithy_client3 = require_dist_cjs19();
  var import_fast_xml_parser = require_fxp();
  var parseXmlBody = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString(streamBody, context8).then((encoded) => {
    if (encoded.length) {
      const parser = new import_fast_xml_parser.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_3, val2) => val2.trim() === "" && val2.includes("\n") ? "" : undefined
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", "\n");
      let parsedObj;
      try {
        parsedObj = parser.parse(encoded, true);
      } catch (e) {
        if (e && typeof e === "object") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return (0, import_smithy_client3.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
  }), "parseXmlBody");
  var parseXmlErrorBody = /* @__PURE__ */ __name(async (errorBody, context8) => {
    const value3 = await parseXmlBody(errorBody, context8);
    if (value3.Error) {
      value3.Error.message = value3.Error.message ?? value3.Error.Message;
    }
    return value3;
  }, "parseXmlErrorBody");
  var loadRestXmlErrorCode = /* @__PURE__ */ __name((output, data) => {
    var _a2;
    if (((_a2 = data == null ? undefined : data.Error) == null ? undefined : _a2.Code) !== undefined) {
      return data.Error.Code;
    }
    if ((data == null ? undefined : data.Code) !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  }, "loadRestXmlErrorCode");
});

// ../node_modules/@aws-sdk/core/dist-cjs/index.js
var require_dist_cjs20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_client(), exports);
  tslib_1.__exportStar(require_httpAuthSchemes(), exports);
  tslib_1.__exportStar(require_protocols2(), exports);
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js
async function checkFeatures(context8, config3, args) {
  const request = args.request;
  if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
    import_core55.setFeature(context8, "PROTOCOL_RPC_V2_CBOR", "M");
  }
  if (typeof config3.retryStrategy === "function") {
    const retryStrategy = await config3.retryStrategy();
    if (typeof retryStrategy.acquireInitialRetryToken === "function") {
      if (retryStrategy.constructor?.name?.includes("Adaptive")) {
        import_core55.setFeature(context8, "RETRY_MODE_ADAPTIVE", "F");
      } else {
        import_core55.setFeature(context8, "RETRY_MODE_STANDARD", "E");
      }
    } else {
      import_core55.setFeature(context8, "RETRY_MODE_LEGACY", "D");
    }
  }
  if (typeof config3.accountIdEndpointMode === "function") {
    const endpointV2 = context8.endpointV2;
    if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
      import_core55.setFeature(context8, "ACCOUNT_ID_ENDPOINT", "O");
    }
    switch (await config3.accountIdEndpointMode?.()) {
      case "disabled":
        import_core55.setFeature(context8, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        import_core55.setFeature(context8, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        import_core55.setFeature(context8, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  const identity3 = context8.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (identity3?.$source) {
    const credentials = identity3;
    if (credentials.accountId) {
      import_core55.setFeature(context8, "RESOLVED_ACCOUNT_ID", "T");
    }
    for (const [key, value3] of Object.entries(credentials.$source ?? {})) {
      import_core55.setFeature(context8, key, value3);
    }
  }
}
var import_core55, ACCOUNT_ID_ENDPOINT_REGEX;
var init_check_features = __esm(() => {
  import_core55 = __toESM(require_dist_cjs20(), 1);
  ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT = "user-agent", X_AMZ_USER_AGENT = "x-amz-user-agent", SPACE = " ", UA_NAME_SEPARATOR = "/", UA_NAME_ESCAPE_REGEX, UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR = "-";
var init_constants = __esm(() => {
  UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js
function encodeFeatures(features) {
  let buffer2 = "";
  for (const key in features) {
    const val2 = features[key];
    if (buffer2.length + val2.length + 1 <= BYTE_LIMIT) {
      if (buffer2.length) {
        buffer2 += "," + val2;
      } else {
        buffer2 += val2;
      }
      continue;
    }
    break;
  }
  return buffer2;
}
var BYTE_LIMIT = 1024;

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context8) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request)) {
    return next(args);
  }
  const { headers } = request;
  const userAgent = context8?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  await checkFeatures(context8, options, args);
  const awsContext = context8;
  defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context8.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const appId = await options.userAgentAppId();
  if (appId) {
    defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
  }
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
}, escapeUserAgent = (userAgentPair) => {
  const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version3 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version3].filter((item) => item && item.length > 0).reduce((acc, item, index2) => {
    switch (index2) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
}, getUserAgentMiddlewareOptions, getUserAgentPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config3), getUserAgentMiddlewareOptions);
  }
});
var init_user_agent_middleware = __esm(() => {
  init_dist_es7();
  init_dist_es2();
  init_check_features();
  init_constants();
  getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
var init_dist_es8 = __esm(() => {
  init_configurations();
  init_user_agent_middleware();
});

// ../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var booleanSelector = (obj, key, type5) => {
  if (!(key in obj))
    return;
  if (obj[key] === "true")
    return true;
  if (obj[key] === "false")
    return false;
  throw new Error(`Cannot load ${type5} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
// ../node_modules/@smithy/util-config-provider/dist-es/types.js
var SelectorType;
var init_types4 = __esm(() => {
  (function(SelectorType2) {
    SelectorType2["ENV"] = "env";
    SelectorType2["CONFIG"] = "shared config entry";
  })(SelectorType || (SelectorType = {}));
});

// ../node_modules/@smithy/util-config-provider/dist-es/index.js
var init_dist_es9 = __esm(() => {
  init_types4();
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT", CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint", NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseDualstackEndpointConfigOptions = __esm(() => {
  init_dist_es9();
  NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => booleanSelector(env2, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
    configFileSelector: (profile2) => booleanSelector(profile2, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
    default: false
  };
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT", CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint", NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseFipsEndpointConfigOptions = __esm(() => {
  init_dist_es9();
  NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => booleanSelector(env2, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
    configFileSelector: (profile2) => booleanSelector(profile2, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
    default: false
  };
});

// ../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
var getSmithyContext = (context8) => context8[SMITHY_CONTEXT_KEY] || (context8[SMITHY_CONTEXT_KEY] = {});
var init_getSmithyContext = __esm(() => {
  init_dist_es();
});

// ../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider2 = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// ../node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es10 = __esm(() => {
  init_getSmithyContext();
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
var init_resolveCustomEndpointsConfig = __esm(() => {
  init_dist_es10();
});
// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
var init_resolveEndpointsConfig = __esm(() => {
  init_dist_es10();
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
var init_endpointsConfig = __esm(() => {
  init_NodeUseDualstackEndpointConfigOptions();
  init_NodeUseFipsEndpointConfigOptions();
  init_resolveCustomEndpointsConfig();
  init_resolveEndpointsConfig();
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME = "AWS_REGION", REGION_INI_NAME = "region", NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS;
var init_config2 = __esm(() => {
  NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[REGION_ENV_NAME],
    configFileSelector: (profile2) => profile2[REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
var init_getRealRegion = () => {
};

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};
var init_resolveRegionConfig = __esm(() => {
  init_getRealRegion();
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
var init_regionConfig = __esm(() => {
  init_config2();
  init_resolveRegionConfig();
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
var init_PartitionHash = () => {
};

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
var init_RegionHash = () => {
};
// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
var init_getRegionInfo = () => {
};

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
var init_regionInfo = __esm(() => {
  init_PartitionHash();
  init_RegionHash();
  init_getRegionInfo();
});

// ../node_modules/@smithy/config-resolver/dist-es/index.js
var init_dist_es11 = __esm(() => {
  init_endpointsConfig();
  init_regionConfig();
  init_regionInfo();
});

// ../node_modules/@smithy/middleware-content-length/dist-es/index.js
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error5) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var CONTENT_LENGTH_HEADER = "content-length", contentLengthMiddlewareOptions, getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});
var init_dist_es12 = __esm(() => {
  init_dist_es2();
  contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
}, DOMAIN_PATTERN, IP_ADDRESS_PATTERN, DOTS_PATTERN, isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName), isArnBucketName = (bucketName) => {
  const [arn, partition3, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition3 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};
var init_s3 = __esm(() => {
  DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  DOTS_PATTERN = /\.\./;
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
var init_service_customizations = __esm(() => {
  init_s3();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config4) => {
  const configProvider = async () => {
    const configValue = config4[configKey] ?? config4[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
      const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
      return configValue;
    };
  }
  if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
    return async () => {
      const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
      const configValue = credentials?.accountId ?? credentials?.AccountId;
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint2 = await configProvider();
      if (endpoint2 && typeof endpoint2 === "object") {
        if ("url" in endpoint2) {
          return endpoint2.url.href;
        }
        if ("hostname" in endpoint2) {
          const { protocol, hostname: hostname3, port, path: path4 } = endpoint2;
          return `${protocol}//${hostname3}${port ? ":" + port : ""}${path4}`;
        }
      }
      return endpoint2;
    };
  }
  return configProvider;
};

// ../node_modules/@smithy/property-provider/dist-es/ProviderError.js
var ProviderError;
var init_ProviderError = __esm(() => {
  ProviderError = class ProviderError extends Error {
    constructor(message, options = true) {
      let logger3;
      let tryNextLink = true;
      if (typeof options === "boolean") {
        logger3 = undefined;
        tryNextLink = options;
      } else if (options != null && typeof options === "object") {
        logger3 = options.logger;
        tryNextLink = options.tryNextLink ?? true;
      }
      super(message);
      this.name = "ProviderError";
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, ProviderError.prototype);
      logger3?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static from(error5, options = true) {
      return Object.assign(new this(error5.message, options), error5);
    }
  };
});

// ../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var CredentialsProviderError;
var init_CredentialsProviderError = __esm(() => {
  init_ProviderError();
  CredentialsProviderError = class CredentialsProviderError extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "CredentialsProviderError";
      Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
  };
});

// ../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var TokenProviderError;
var init_TokenProviderError = __esm(() => {
  init_ProviderError();
  TokenProviderError = class TokenProviderError extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "TokenProviderError";
      Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
  };
});

// ../node_modules/@smithy/property-provider/dist-es/chain.js
var chain = (...providers) => async () => {
  if (providers.length === 0) {
    throw new ProviderError("No providers in chain");
  }
  let lastProviderError;
  for (const provider of providers) {
    try {
      const credentials = await provider();
      return credentials;
    } catch (err) {
      lastProviderError = err;
      if (err?.tryNextLink) {
        continue;
      }
      throw err;
    }
  }
  throw lastProviderError;
};
var init_chain = __esm(() => {
  init_ProviderError();
});

// ../node_modules/@smithy/property-provider/dist-es/fromStatic.js
var fromStatic = (staticValue) => () => Promise.resolve(staticValue);

// ../node_modules/@smithy/property-provider/dist-es/memoize.js
var memoize = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = undefined;
    }
    return resolved;
  };
  if (isExpired === undefined) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// ../node_modules/@smithy/property-provider/dist-es/index.js
var init_dist_es13 = __esm(() => {
  init_CredentialsProviderError();
  init_ProviderError();
  init_TokenProviderError();
  init_chain();
});

// ../node_modules/@smithy/node-config-provider/dist-es/getSelectorName.js
function getSelectorName(functionString) {
  try {
    const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
    constants.delete("CONFIG");
    constants.delete("CONFIG_PREFIX_SEPARATOR");
    constants.delete("ENV");
    return [...constants].join(", ");
  } catch (e) {
    return functionString;
  }
}

// ../node_modules/@smithy/node-config-provider/dist-es/fromEnv.js
var fromEnv = (envVarSelector, logger3) => async () => {
  try {
    const config4 = envVarSelector(process.env);
    if (config4 === undefined) {
      throw new Error;
    }
    return config4;
  } catch (e) {
    throw new CredentialsProviderError(e.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: logger3 });
  }
};
var init_fromEnv = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js
import { homedir } from "os";
import { sep as sep4 } from "path";
var homeDirCache, getHomeDirCacheKey = () => {
  if (process && process.geteuid) {
    return `${process.geteuid()}`;
  }
  return "DEFAULT";
}, getHomeDir = () => {
  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep4}` } = process.env;
  if (HOME)
    return HOME;
  if (USERPROFILE)
    return USERPROFILE;
  if (HOMEPATH)
    return `${HOMEDRIVE}${HOMEPATH}`;
  const homeDirCacheKey = getHomeDirCacheKey();
  if (!homeDirCache[homeDirCacheKey])
    homeDirCache[homeDirCacheKey] = homedir();
  return homeDirCache[homeDirCacheKey];
};
var init_getHomeDir = __esm(() => {
  homeDirCache = {};
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE = "AWS_PROFILE", DEFAULT_PROFILE = "default", getProfileName = (init3) => init3.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
import { createHash } from "crypto";
import { join as join6 } from "path";
var getSSOTokenFilepath = (id) => {
  const hasher = createHash("sha1");
  const cacheName = hasher.update(id).digest("hex");
  return join6(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};
var init_getSSOTokenFilepath = __esm(() => {
  init_getHomeDir();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
import { promises as fsPromises } from "fs";
var readFile2, getSSOTokenFromFile = async (id) => {
  const ssoTokenFilepath = getSSOTokenFilepath(id);
  const ssoTokenText = await readFile2(ssoTokenFilepath, "utf8");
  return JSON.parse(ssoTokenText);
};
var init_getSSOTokenFromFile = __esm(() => {
  init_getSSOTokenFilepath();
  ({ readFile: readFile2 } = fsPromises);
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js
var getConfigData = (data) => Object.entries(data).filter(([key]) => {
  const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
  if (indexOfSeparator === -1) {
    return false;
  }
  return Object.values(IniSectionType).includes(key.substring(0, indexOfSeparator));
}).reduce((acc, [key, value3]) => {
  const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
  const updatedKey = key.substring(0, indexOfSeparator) === IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
  acc[updatedKey] = value3;
  return acc;
}, {
  ...data.default && { default: data.default }
});
var init_getConfigData = __esm(() => {
  init_dist_es();
  init_loadSharedConfigFiles();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js
import { join as join7 } from "path";
var ENV_CONFIG_PATH = "AWS_CONFIG_FILE", getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || join7(getHomeDir(), ".aws", "config");
var init_getConfigFilepath = __esm(() => {
  init_getHomeDir();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
import { join as join8 } from "path";
var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE", getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || join8(getHomeDir(), ".aws", "credentials");
var init_getCredentialsFilepath = __esm(() => {
  init_getHomeDir();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js
var prefixKeyRegex, profileNameBlockList, parseIni = (iniData) => {
  const map5 = {};
  let currentSection;
  let currentSubSection;
  for (const iniLine of iniData.split(/\r?\n/)) {
    const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
    const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
    if (isSection) {
      currentSection = undefined;
      currentSubSection = undefined;
      const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
      const matches = prefixKeyRegex.exec(sectionName);
      if (matches) {
        const [, prefix, , name] = matches;
        if (Object.values(IniSectionType).includes(prefix)) {
          currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
        }
      } else {
        currentSection = sectionName;
      }
      if (profileNameBlockList.includes(sectionName)) {
        throw new Error(`Found invalid profile name "${sectionName}"`);
      }
    } else if (currentSection) {
      const indexOfEqualsSign = trimmedLine.indexOf("=");
      if (![0, -1].includes(indexOfEqualsSign)) {
        const [name, value3] = [
          trimmedLine.substring(0, indexOfEqualsSign).trim(),
          trimmedLine.substring(indexOfEqualsSign + 1).trim()
        ];
        if (value3 === "") {
          currentSubSection = name;
        } else {
          if (currentSubSection && iniLine.trimStart() === iniLine) {
            currentSubSection = undefined;
          }
          map5[currentSection] = map5[currentSection] || {};
          const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
          map5[currentSection][key] = value3;
        }
      }
    }
  }
  return map5;
};
var init_parseIni = __esm(() => {
  init_dist_es();
  init_loadSharedConfigFiles();
  prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
  profileNameBlockList = ["__proto__", "profile __proto__"];
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js
import { promises as fsPromises2 } from "fs";
var readFile3, filePromisesHash, slurpFile = (path4, options) => {
  if (!filePromisesHash[path4] || options?.ignoreCache) {
    filePromisesHash[path4] = readFile3(path4, "utf8");
  }
  return filePromisesHash[path4];
};
var init_slurpFile = __esm(() => {
  ({ readFile: readFile3 } = fsPromises2);
  filePromisesHash = {};
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
import { join as join9 } from "path";
var swallowError = () => ({}), CONFIG_PREFIX_SEPARATOR = ".", loadSharedConfigFiles = async (init3 = {}) => {
  const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init3;
  const homeDir = getHomeDir();
  const relativeHomeDirPrefix = "~/";
  let resolvedFilepath = filepath;
  if (filepath.startsWith(relativeHomeDirPrefix)) {
    resolvedFilepath = join9(homeDir, filepath.slice(2));
  }
  let resolvedConfigFilepath = configFilepath;
  if (configFilepath.startsWith(relativeHomeDirPrefix)) {
    resolvedConfigFilepath = join9(homeDir, configFilepath.slice(2));
  }
  const parsedFiles = await Promise.all([
    slurpFile(resolvedConfigFilepath, {
      ignoreCache: init3.ignoreCache
    }).then(parseIni).then(getConfigData).catch(swallowError),
    slurpFile(resolvedFilepath, {
      ignoreCache: init3.ignoreCache
    }).then(parseIni).catch(swallowError)
  ]);
  return {
    configFile: parsedFiles[0],
    credentialsFile: parsedFiles[1]
  };
};
var init_loadSharedConfigFiles = __esm(() => {
  init_getConfigData();
  init_getConfigFilepath();
  init_getCredentialsFilepath();
  init_getHomeDir();
  init_parseIni();
  init_slurpFile();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js
var getSsoSessionData = (data) => Object.entries(data).filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value3]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value3 }), {});
var init_getSsoSessionData = __esm(() => {
  init_dist_es();
  init_loadSharedConfigFiles();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError2 = () => ({}), loadSsoSessionData = async (init3 = {}) => slurpFile(init3.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2);
var init_loadSsoSessionData = __esm(() => {
  init_getConfigFilepath();
  init_getSsoSessionData();
  init_parseIni();
  init_slurpFile();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
var mergeConfigFiles = (...files) => {
  const merged = {};
  for (const file of files) {
    for (const [key, values2] of Object.entries(file)) {
      if (merged[key] !== undefined) {
        Object.assign(merged[key], values2);
      } else {
        merged[key] = values2;
      }
    }
  }
  return merged;
};

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles = async (init3) => {
  const parsedFiles = await loadSharedConfigFiles(init3);
  return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};
var init_parseKnownFiles = __esm(() => {
  init_loadSharedConfigFiles();
});

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/types.js
var init_types5 = () => {
};

// ../node_modules/@smithy/shared-ini-file-loader/dist-es/index.js
var init_dist_es14 = __esm(() => {
  init_getHomeDir();
  init_getSSOTokenFilepath();
  init_getSSOTokenFromFile();
  init_loadSharedConfigFiles();
  init_loadSsoSessionData();
  init_parseKnownFiles();
  init_types5();
});

// ../node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js
var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init3 } = {}) => async () => {
  const profile2 = getProfileName(init3);
  const { configFile, credentialsFile } = await loadSharedConfigFiles(init3);
  const profileFromCredentials = credentialsFile[profile2] || {};
  const profileFromConfig = configFile[profile2] || {};
  const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
  try {
    const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
    const configValue = configSelector(mergedProfile, cfgFile);
    if (configValue === undefined) {
      throw new Error;
    }
    return configValue;
  } catch (e) {
    throw new CredentialsProviderError(e.message || `Not found in config files w/ profile [${profile2}]: ${getSelectorName(configSelector.toString())}`, { logger: init3.logger });
  }
};
var init_fromSharedConfigFiles = __esm(() => {
  init_dist_es13();
  init_dist_es14();
});

// ../node_modules/@smithy/node-config-provider/dist-es/fromStatic.js
var isFunction2 = (func) => typeof func === "function", fromStatic3 = (defaultValue) => isFunction2(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);
var init_fromStatic = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@smithy/node-config-provider/dist-es/configLoader.js
var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic3(defaultValue)));
var init_configLoader = __esm(() => {
  init_dist_es13();
  init_fromEnv();
  init_fromSharedConfigFiles();
  init_fromStatic();
});

// ../node_modules/@smithy/node-config-provider/dist-es/index.js
var init_dist_es15 = __esm(() => {
  init_configLoader();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js
var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL", CONFIG_ENDPOINT_URL = "endpoint_url", getEndpointUrlConfig = (serviceId) => ({
  environmentVariableSelector: (env2) => {
    const serviceSuffixParts = serviceId.split(" ").map((w3) => w3.toUpperCase());
    const serviceEndpointUrl = env2[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
    if (serviceEndpointUrl)
      return serviceEndpointUrl;
    const endpointUrl = env2[ENV_ENDPOINT_URL];
    if (endpointUrl)
      return endpointUrl;
    return;
  },
  configFileSelector: (profile2, config4) => {
    if (config4 && profile2.services) {
      const servicesSection = config4[["services", profile2.services].join(CONFIG_PREFIX_SEPARATOR)];
      if (servicesSection) {
        const servicePrefixParts = serviceId.split(" ").map((w3) => w3.toLowerCase());
        const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(CONFIG_PREFIX_SEPARATOR)];
        if (endpointUrl2)
          return endpointUrl2;
      }
    }
    const endpointUrl = profile2[CONFIG_ENDPOINT_URL];
    if (endpointUrl)
      return endpointUrl;
    return;
  },
  default: undefined
});
var init_getEndpointUrlConfig = __esm(() => {
  init_dist_es14();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js
var getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId ?? ""))();
var init_getEndpointFromConfig = __esm(() => {
  init_dist_es15();
  init_getEndpointUrlConfig();
});

// ../node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value3 = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value3) {
        value3 = decodeURIComponent(value3);
      }
      if (!(key in query)) {
        query[key] = value3;
      } else if (Array.isArray(query[key])) {
        query[key].push(value3);
      } else {
        query[key] = [query[key], value3];
      }
    }
  }
  return query;
}

// ../node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl3 = (url) => {
  if (typeof url === "string") {
    return parseUrl3(new URL(url));
  }
  const { hostname: hostname3, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname: hostname3,
    port: port ? parseInt(port) : undefined,
    protocol,
    path: pathname,
    query
  };
};
var init_dist_es16 = () => {
};

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint2) => {
  if (typeof endpoint2 === "object") {
    if ("url" in endpoint2) {
      return parseUrl3(endpoint2.url);
    }
    return endpoint2;
  }
  return parseUrl3(endpoint2);
};
var init_toEndpointV1 = __esm(() => {
  init_dist_es16();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context8) => {
  if (!clientConfig.endpoint) {
    let endpointFromConfig;
    if (clientConfig.serviceConfiguredEndpoint) {
      endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
    } else {
      endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
    }
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint2 = clientConfig.endpointProvider(endpointParams, context8);
  return endpoint2;
}, resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};
var init_getEndpointFromInstructions = __esm(() => {
  init_service_customizations();
  init_getEndpointFromConfig();
  init_toEndpointV1();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
var init_adaptors = __esm(() => {
  init_getEndpointFromInstructions();
  init_toEndpointV1();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var import_core56, endpointMiddleware = ({ config: config4, instructions }) => {
  return (next, context8) => async (args) => {
    if (config4.endpoint) {
      import_core56.setFeature(context8, "ENDPOINT_OVERRIDE", "N");
    }
    const endpoint2 = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config4 }, context8);
    context8.endpointV2 = endpoint2;
    context8.authSchemes = endpoint2.properties?.authSchemes;
    const authScheme = context8.authSchemes?.[0];
    if (authScheme) {
      context8["signing_region"] = authScheme.signingRegion;
      context8["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context8);
      const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};
var init_endpointMiddleware = __esm(() => {
  import_core56 = __toESM(require_dist_cjs15(), 1);
  init_dist_es10();
  init_getEndpointFromInstructions();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var import_middleware_serde, endpointMiddlewareOptions, getEndpointPlugin = (config4, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config: config4,
      instructions
    }), endpointMiddlewareOptions);
  }
});
var init_getEndpointPlugin = __esm(() => {
  import_middleware_serde = __toESM(require_dist_cjs3(), 1);
  init_endpointMiddleware();
  endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: import_middleware_serde.serializerMiddlewareOption.name
  };
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig = (input) => {
  const tls3 = input.tls ?? true;
  const { endpoint: endpoint2 } = input;
  const customEndpointProvider = endpoint2 != null ? async () => toEndpointV1(await normalizeProvider2(endpoint2)()) : undefined;
  const isCustomEndpoint = !!endpoint2;
  const resolvedConfig = {
    ...input,
    endpoint: customEndpointProvider,
    tls: tls3,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider2(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider2(input.useFipsEndpoint ?? false)
  };
  let configuredEndpointPromise = undefined;
  resolvedConfig.serviceConfiguredEndpoint = async () => {
    if (input.serviceId && !configuredEndpointPromise) {
      configuredEndpointPromise = getEndpointFromConfig(input.serviceId);
    }
    return configuredEndpointPromise;
  };
  return resolvedConfig;
};
var init_resolveEndpointConfig = __esm(() => {
  init_dist_es10();
  init_getEndpointFromConfig();
  init_toEndpointV1();
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/types.js
var init_types6 = () => {
};

// ../node_modules/@smithy/middleware-endpoint/dist-es/index.js
var init_dist_es17 = __esm(() => {
  init_adaptors();
  init_endpointMiddleware();
  init_getEndpointPlugin();
  init_resolveEndpointConfig();
  init_types6();
});

// ../node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES, DEFAULT_MAX_ATTEMPTS = 3, DEFAULT_RETRY_MODE;
var init_config3 = __esm(() => {
  (function(RETRY_MODES2) {
    RETRY_MODES2["STANDARD"] = "standard";
    RETRY_MODES2["ADAPTIVE"] = "adaptive";
  })(RETRY_MODES || (RETRY_MODES = {}));
  DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
});

// ../node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, NODEJS_TIMEOUT_ERROR_CODES;
var init_constants2 = __esm(() => {
  THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
});

// ../node_modules/@smithy/service-error-classification/dist-es/index.js
var isClockSkewCorrectedError = (error5) => error5.$metadata?.clockSkewCorrected, isThrottlingError = (error5) => error5.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error5.name) || error5.$retryable?.throttling == true, isTransientError = (error5) => isClockSkewCorrectedError(error5) || TRANSIENT_ERROR_CODES.includes(error5.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error5?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error5.$metadata?.httpStatusCode || 0), isServerError = (error5) => {
  if (error5.$metadata?.httpStatusCode !== undefined) {
    const statusCode = error5.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error5)) {
      return true;
    }
    return false;
  }
  return false;
};
var init_dist_es18 = __esm(() => {
  init_constants2();
});

// ../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
class DefaultRateLimiter {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1000;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
      await new Promise((resolve3) => setTimeout(resolve3, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp4 = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp4;
      return;
    }
    const fillAmount = (timestamp4 - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp4;
  }
  updateClientSendingRate(response2) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response2)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp4) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp4 - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t3 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t3 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
}
var init_DefaultRateLimiter = __esm(() => {
  init_dist_es18();
});

// ../node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE = 100, MAXIMUM_RETRY_DELAY, THROTTLING_RETRY_DELAY_BASE = 500, INITIAL_RETRY_TOKENS = 500, RETRY_COST = 5, TIMEOUT_RETRY_COST = 10, NO_RETRY_INCREMENT = 1, INVOCATION_ID_HEADER = "amz-sdk-invocation-id", REQUEST_HEADER = "amz-sdk-request";
var init_constants3 = __esm(() => {
  MAXIMUM_RETRY_DELAY = 20 * 1000;
});

// ../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};
var init_defaultRetryBackoffStrategy = __esm(() => {
  init_constants3();
});

// ../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};
var init_defaultRetryToken = __esm(() => {
  init_constants3();
});

// ../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
class StandardRetryStrategy {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error5) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
}
var init_StandardRetryStrategy = __esm(() => {
  init_config3();
  init_constants3();
  init_defaultRetryBackoffStrategy();
  init_defaultRetryToken();
});

// ../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
class AdaptiveRetryStrategy {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter;
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
}
var init_AdaptiveRetryStrategy = __esm(() => {
  init_config3();
  init_DefaultRateLimiter();
  init_StandardRetryStrategy();
});

// ../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
var init_ConfiguredRetryStrategy = __esm(() => {
  init_constants3();
  init_StandardRetryStrategy();
});

// ../node_modules/@smithy/util-retry/dist-es/types.js
var init_types7 = () => {
};

// ../node_modules/@smithy/util-retry/dist-es/index.js
var init_dist_es19 = __esm(() => {
  init_AdaptiveRetryStrategy();
  init_ConfiguredRetryStrategy();
  init_DefaultRateLimiter();
  init_StandardRetryStrategy();
  init_config3();
  init_constants3();
  init_types7();
});

// ../node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// ../node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// ../node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(uuid2) {
    return typeof uuid2 === "string" && _regex.default.test(uuid2);
  }
  var _default = validate;
  exports.default = _default;
});

// ../node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i3 = 0;i3 < 256; ++i3) {
    byteToHex.push((i3 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify2(arr, offset = 0) {
    const uuid2 = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid2;
  }
  var _default = stringify2;
  exports.default = _default;
});

// ../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v12(options, buf, offset) {
    let i3 = buf && offset || 0;
    const b4 = buf || new Array(16);
    options = options || {};
    let node2 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node2 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node2 == null) {
        node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b4[i3++] = tl >>> 24 & 255;
    b4[i3++] = tl >>> 16 & 255;
    b4[i3++] = tl >>> 8 & 255;
    b4[i3++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b4[i3++] = tmh >>> 8 & 255;
    b4[i3++] = tmh & 255;
    b4[i3++] = tmh >>> 24 & 15 | 16;
    b4[i3++] = tmh >>> 16 & 255;
    b4[i3++] = clockseq >>> 8 | 128;
    b4[i3++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b4[i3 + n2] = node2[n2];
    }
    return buf || (0, _stringify.unsafeStringify)(b4);
  }
  var _default = v12;
  exports.default = _default;
});

// ../node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse5(uuid2) {
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    let v4;
    const arr = new Uint8Array(16);
    arr[0] = (v4 = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
    arr[1] = v4 >>> 16 & 255;
    arr[2] = v4 >>> 8 & 255;
    arr[3] = v4 & 255;
    arr[4] = (v4 = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
    arr[5] = v4 & 255;
    arr[6] = (v4 = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
    arr[7] = v4 & 255;
    arr[8] = (v4 = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
    arr[9] = v4 & 255;
    arr[10] = (v4 = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v4 / 4294967296 & 255;
    arr[12] = v4 >>> 24 & 255;
    arr[13] = v4 >>> 16 & 255;
    arr[14] = v4 >>> 8 & 255;
    arr[15] = v4 & 255;
    return arr;
  }
  var _default = parse5;
  exports.default = _default;
});

// ../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i3 = 0;i3 < str.length; ++i3) {
      bytes.push(str.charCodeAt(i3));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
  function v35(name, version3, hashfunc) {
    function generateUUID(value3, namespace, buf, offset) {
      var _namespace;
      if (typeof value3 === "string") {
        value3 = stringToBytes(value3);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value3.length);
      bytes.set(namespace);
      bytes.set(value3, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version3;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i3 = 0;i3 < 16; ++i3) {
          buf[offset + i3] = bytes[i3];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// ../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md52(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md52;
  exports.default = _default;
});

// ../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v32 = (0, _v.default)("v3", 48, _md.default);
  var _default = v32;
  exports.default = _default;
});

// ../node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// ../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i3 = 0;i3 < 16; ++i3) {
        buf[offset + i3] = rnds[i3];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// ../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// ../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// ../node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// ../node_modules/uuid/dist/version.js
var require_version23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version3(uuid2) {
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid2.slice(14, 15), 16);
  }
  var _default = version3;
  exports.default = _default;
});

// ../node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version23());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// ../node_modules/uuid/wrapper.mjs
var import_dist, v12, v32, v4, v5, NIL, version3, validate, stringify2, parse5;
var init_wrapper = __esm(() => {
  import_dist = __toESM(require_dist(), 1);
  v12 = import_dist.default.v1;
  v32 = import_dist.default.v3;
  v4 = import_dist.default.v4;
  v5 = import_dist.default.v5;
  NIL = import_dist.default.NIL;
  version3 = import_dist.default.version;
  validate = import_dist.default.validate;
  stringify2 = import_dist.default.stringify;
  parse5 = import_dist.default.parse;
});

// ../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
var init_defaultRetryQuota = __esm(() => {
  init_dist_es19();
});

// ../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
var init_delayDecider = __esm(() => {
  init_dist_es19();
});

// ../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
var init_retryDecider = __esm(() => {
  init_dist_es18();
});

// ../node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError = (error5) => {
  if (error5 instanceof Error)
    return error5;
  if (error5 instanceof Object)
    return Object.assign(new Error, error5);
  if (typeof error5 === "string")
    return new Error(error5);
  return new Error(`AWS SDK error wrapper for ${error5}`);
};

// ../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
var init_StandardRetryStrategy2 = __esm(() => {
  init_dist_es2();
  init_dist_es18();
  init_dist_es19();
  init_defaultRetryQuota();
  init_delayDecider();
  init_retryDecider();
});

// ../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
var init_AdaptiveRetryStrategy2 = __esm(() => {
  init_dist_es19();
  init_StandardRetryStrategy2();
});

// ../node_modules/@smithy/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS", CONFIG_MAX_ATTEMPTS = "max_attempts", NODE_MAX_ATTEMPT_CONFIG_OPTIONS, resolveRetryConfig = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider2(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider2(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
}, ENV_RETRY_MODE = "AWS_RETRY_MODE", CONFIG_RETRY_MODE = "retry_mode", NODE_RETRY_MODE_CONFIG_OPTIONS;
var init_configurations2 = __esm(() => {
  init_dist_es10();
  init_dist_es19();
  NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => {
      const value3 = env2[ENV_MAX_ATTEMPTS];
      if (!value3)
        return;
      const maxAttempt = parseInt(value3);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value3}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile2) => {
      const value3 = profile2[CONFIG_MAX_ATTEMPTS];
      if (!value3)
        return;
      const maxAttempt = parseInt(value3);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value3}"`);
      }
      return maxAttempt;
    },
    default: DEFAULT_MAX_ATTEMPTS
  };
  NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_RETRY_MODE],
    configFileSelector: (profile2) => profile2[CONFIG_RETRY_MODE],
    default: DEFAULT_RETRY_MODE
  };
});

// ../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
var init_omitRetryHeadersMiddleware = __esm(() => {
  init_dist_es2();
  init_dist_es19();
});

// ../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var getAllAliases = (name, aliases) => {
  const _aliases = [];
  if (name) {
    _aliases.push(name);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
}, getMiddlewareNameWithAliases = (name, aliases) => {
  return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
}, constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = new Set;
  const sort = (entries) => entries.sort((a, b4) => stepWeights[b4.step] - stepWeights[a.step] || priorityWeights[b4.priority || "normal"] - priorityWeights[a.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    toStack.identifyOnResolve?.(stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug3 = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === undefined) {
          if (debug3) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ` + `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` + `middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware2, options = {}) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware: middleware2,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` + `${toOverride.priority} priority in ${toOverride.step} step cannot ` + `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` + `${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware2, options) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        middleware: middleware2,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` + `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` + `"${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context8) => {
      for (const middleware2 of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware2(handler, context8);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
}, stepWeights, priorityWeights;
var init_MiddlewareStack = __esm(() => {
  stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
});

// ../node_modules/@smithy/middleware-stack/dist-es/index.js
var init_dist_es20 = __esm(() => {
  init_MiddlewareStack();
});

// ../node_modules/@smithy/smithy-client/dist-es/client.js
class Client {
  constructor(config5) {
    this.config = config5;
    this.middlewareStack = constructStack();
  }
  send(command2, optionsOrCb, cb) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
    const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
    let handler;
    if (useHandlerCache) {
      if (!this.handlers) {
        this.handlers = new WeakMap;
      }
      const handlers2 = this.handlers;
      if (handlers2.has(command2.constructor)) {
        handler = handlers2.get(command2.constructor);
      } else {
        handler = command2.resolveMiddleware(this.middlewareStack, this.config, options);
        handlers2.set(command2.constructor, handler);
      }
    } else {
      delete this.handlers;
      handler = command2.resolveMiddleware(this.middlewareStack, this.config, options);
    }
    if (callback) {
      handler(command2).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command2).then((result) => result.output);
    }
  }
  destroy() {
    this.config?.requestHandler?.destroy?.();
    delete this.handlers;
  }
}
var init_client2 = __esm(() => {
  init_dist_es20();
});

// ../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var import_protocols;
var init_collect_stream_body = __esm(() => {
  import_protocols = __toESM(require_protocols(), 1);
});

// ../node_modules/@smithy/smithy-client/dist-es/command.js
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder;
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        commandInstance: this,
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
}

class ClassBuilder {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_3) => _3;
    this._outputFilterSensitiveLog = (_3) => _3;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb) {
    this._init = cb;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_3) => _3, outputFilter = (_3) => _3) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer) {
    this._serializer = serializer;
    return this;
  }
  de(deserializer) {
    this._deserializer = deserializer;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
}
var init_command2 = __esm(() => {
  init_dist_es20();
  init_dist_es();
});

// ../node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING = "***SensitiveInformation***";

// ../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var createAggregatedClient = (commands, Client2) => {
  for (const command2 of Object.keys(commands)) {
    const CommandCtor = commands[command2];
    const methodImpl = async function(args, optionsOrCb, cb) {
      const command3 = new CommandCtor(args);
      if (typeof optionsOrCb === "function") {
        this.send(command3, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object")
          throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
        this.send(command3, optionsOrCb || {}, cb);
      } else {
        return this.send(command3, optionsOrCb);
      }
    };
    const methodName = (command2[0].toLowerCase() + command2.slice(1)).replace(/Command$/, "");
    Client2.prototype[methodName] = methodImpl;
  }
};

// ../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var expectNumber = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (typeof value3 === "string") {
    const parsed = parseFloat(value3);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value3)) {
        logger3.warn(stackTraceWarning(`Expected number but observed string: ${value3}`));
      }
      return parsed;
    }
  }
  if (typeof value3 === "number") {
    return value3;
  }
  throw new TypeError(`Expected number, got ${typeof value3}: ${value3}`);
}, MAX_FLOAT, expectFloat32 = (value3) => {
  const expected = expectNumber(value3);
  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value3}`);
    }
  }
  return expected;
}, expectLong = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (Number.isInteger(value3) && !Number.isNaN(value3)) {
    return value3;
  }
  throw new TypeError(`Expected integer, got ${typeof value3}: ${value3}`);
}, expectInt32 = (value3) => expectSizedInt(value3, 32), expectShort = (value3) => expectSizedInt(value3, 16), expectByte = (value3) => expectSizedInt(value3, 8), expectSizedInt = (value3, size2) => {
  const expected = expectLong(value3);
  if (expected !== undefined && castInt(expected, size2) !== expected) {
    throw new TypeError(`Expected ${size2}-bit integer, got ${value3}`);
  }
  return expected;
}, castInt = (value3, size2) => {
  switch (size2) {
    case 32:
      return Int32Array.of(value3)[0];
    case 16:
      return Int16Array.of(value3)[0];
    case 8:
      return Int8Array.of(value3)[0];
  }
}, expectNonNull = (value3, location) => {
  if (value3 === null || value3 === undefined) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value3;
}, expectObject = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (typeof value3 === "object" && !Array.isArray(value3)) {
    return value3;
  }
  const receivedType = Array.isArray(value3) ? "array" : typeof value3;
  throw new TypeError(`Expected object, got ${receivedType}: ${value3}`);
}, expectString = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (typeof value3 === "string") {
    return value3;
  }
  if (["boolean", "number", "bigint"].includes(typeof value3)) {
    logger3.warn(stackTraceWarning(`Expected string, got ${typeof value3}: ${value3}`));
    return String(value3);
  }
  throw new TypeError(`Expected string, got ${typeof value3}: ${value3}`);
}, strictParseFloat32 = (value3) => {
  if (typeof value3 == "string") {
    return expectFloat32(parseNumber2(value3));
  }
  return expectFloat32(value3);
}, NUMBER_REGEX, parseNumber2 = (value3) => {
  const matches = value3.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value3.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value3);
}, strictParseInt32 = (value3) => {
  if (typeof value3 === "string") {
    return expectInt32(parseNumber2(value3));
  }
  return expectInt32(value3);
}, strictParseShort = (value3) => {
  if (typeof value3 === "string") {
    return expectShort(parseNumber2(value3));
  }
  return expectShort(value3);
}, strictParseByte = (value3) => {
  if (typeof value3 === "string") {
    return expectByte(parseNumber2(value3));
  }
  return expectByte(value3);
}, stackTraceWarning = (message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join("\n");
}, logger3;
var init_parse_utils = __esm(() => {
  MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  logger3 = {
    warn: console.warn
  };
});

// ../node_modules/@smithy/smithy-client/dist-es/date-utils.js
var MONTHS, RFC3339, parseRfc3339DateTime = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (typeof value3 !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339.exec(value3);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
}, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset = (value3) => {
  if (value3 === null || value3 === undefined) {
    return;
  }
  if (typeof value3 !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value3);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  const date6 = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date6.setTime(date6.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date6;
}, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, buildDate = (year, month, day, time2) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
}, FIFTY_YEARS_IN_MILLIS, DAYS_IN_MONTH, validateDayOfMonth = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
  }
}, isLeapYear = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}, parseDateValue = (value3, type5, lower2, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value3));
  if (dateVal < lower2 || dateVal > upper) {
    throw new TypeError(`${type5} must be between ${lower2} and ${upper}, inclusive`);
  }
  return dateVal;
}, parseMilliseconds = (value3) => {
  if (value3 === null || value3 === undefined) {
    return 0;
  }
  return strictParseFloat32("0." + value3) * 1000;
}, parseOffsetToMilliseconds = (value3) => {
  const directionStr = value3[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value3.substring(1, 3));
  const minute = Number(value3.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1000;
}, stripLeadingZeroes = (value3) => {
  let idx = 0;
  while (idx < value3.length - 1 && value3.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value3;
  }
  return value3.slice(idx);
};
var init_date_utils = __esm(() => {
  init_parse_utils();
  MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
});

// ../node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException, decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v6]) => v6 !== undefined).forEach(([k4, v6]) => {
    if (exception[k4] == undefined || exception[k4] === "") {
      exception[k4] = v6;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};
var init_exceptions = __esm(() => {
  ServiceException = class ServiceException extends Error {
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, ServiceException.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
  };
});

// ../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
  const response2 = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response2, parsedBody);
}, withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
}, deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var init_default_error_handler = __esm(() => {
  init_exceptions();
});

// ../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 30000
      };
    default:
      return {};
  }
};

// ../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted = false, emitWarningIfUnsupportedVersion = (version4) => {
  if (version4 && !warningEmitted && parseInt(version4.substring(1, version4.indexOf("."))) < 16) {
    warningEmitted = true;
  }
};

// ../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
var import_protocols2;
var init_extended_encode_uri_component = __esm(() => {
  import_protocols2 = __toESM(require_protocols(), 1);
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
var getChecksumConfiguration2 = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id in AlgorithmId) {
    const algorithmId = AlgorithmId[id];
    if (runtimeConfig[algorithmId] === undefined) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, resolveChecksumRuntimeConfig2 = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};
var init_checksum3 = __esm(() => {
  init_dist_es();
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
var getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
}, resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};

// ../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration2(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
}, resolveDefaultRuntimeConfig = (config5) => {
  return {
    ...resolveChecksumRuntimeConfig2(config5),
    ...resolveRetryRuntimeConfig(config5)
  };
};
var init_defaultExtensionConfiguration2 = __esm(() => {
  init_checksum3();
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/index.js
var init_extensions3 = __esm(() => {
  init_defaultExtensionConfiguration2();
});
// ../node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js
var isSerializableHeaderValue = (value3) => {
  return value3 != null;
};

// ../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor3 = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor3;
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
var init_lazy_json = __esm(() => {
  StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: StringWrapper,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Object.setPrototypeOf(StringWrapper, String);
});

// ../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}

// ../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map5(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var take = (source, instructions) => {
  const out = {};
  for (const key in instructions) {
    applyInstruction(out, source, instructions, key);
  }
  return out;
}, mapWithFilter = (target, filter, instructions) => {
  return map5(target, Object.entries(instructions).reduce((_instructions, [key, value3]) => {
    if (Array.isArray(value3)) {
      _instructions[key] = value3;
    } else {
      if (typeof value3 === "function") {
        _instructions[key] = [filter, value3()];
      } else {
        _instructions[key] = [filter, value3];
      }
    }
    return _instructions;
  }, {}));
}, applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter, value3] = instructions[targetKey];
  if (typeof value3 === "function") {
    let _value;
    const defaultFilterPassed = filter === undefined && (_value = value3()) != null;
    const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value3();
    }
  } else {
    const defaultFilterPassed = filter === undefined && value3 != null;
    const customFilterPassed = typeof filter === "function" && !!filter(value3) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value3;
    }
  }
}, nonNullish = (_3) => _3 != null, pass = (_3) => _3;
// ../node_modules/@smithy/smithy-client/dist-es/resolve-path.js
var import_protocols3;
var init_resolve_path = __esm(() => {
  import_protocols3 = __toESM(require_protocols(), 1);
});
// ../node_modules/@smithy/smithy-client/dist-es/serde-json.js
var _json = (obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_3) => _3 != null).map(_json);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key of Object.keys(obj)) {
      if (obj[key] == null) {
        continue;
      }
      target[key] = _json(obj[key]);
    }
    return target;
  }
  return obj;
};
// ../node_modules/@smithy/smithy-client/dist-es/index.js
var init_dist_es21 = __esm(() => {
  init_client2();
  init_collect_stream_body();
  init_command2();
  init_date_utils();
  init_default_error_handler();
  init_exceptions();
  init_extended_encode_uri_component();
  init_extensions3();
  init_lazy_json();
  init_parse_utils();
  init_resolve_path();
});

// ../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.js
import { Readable as Readable2 } from "stream";
var isStreamingPayload = (request) => request?.body instanceof Readable2 || typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream;
var init_isStreamingPayload = () => {
};

// ../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context8) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context8["partition_id"]);
    let lastError = new Error;
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response: response2, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response: response2, output };
      } catch (e) {
        const retryErrorInfo = getRetryErrorInfo(e);
        lastError = asSdkError(e);
        if (isRequest && isStreamingPayload(request)) {
          (context8.logger instanceof NoOpLogger ? console : context8.logger)?.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve3) => setTimeout(resolve3, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context8.userAgent = [...context8.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
}, isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", getRetryErrorInfo = (error5) => {
  const errorInfo = {
    error: error5,
    errorType: getRetryErrorType(error5)
  };
  const retryAfterHint = getRetryAfterHint(error5.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
}, getRetryErrorType = (error5) => {
  if (isThrottlingError(error5))
    return "THROTTLING";
  if (isTransientError(error5))
    return "TRANSIENT";
  if (isServerError(error5))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
}, retryMiddlewareOptions, getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
}), getRetryAfterHint = (response2) => {
  if (!HttpResponse.isInstance(response2))
    return;
  const retryAfterHeaderName = Object.keys(response2.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response2.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1000);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};
var init_retryMiddleware = __esm(() => {
  init_dist_es2();
  init_dist_es18();
  init_dist_es21();
  init_dist_es19();
  init_wrapper();
  init_isStreamingPayload();
  retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
});

// ../node_modules/@smithy/middleware-retry/dist-es/index.js
var init_dist_es22 = __esm(() => {
  init_AdaptiveRetryStrategy2();
  init_StandardRetryStrategy2();
  init_configurations2();
  init_delayDecider();
  init_omitRetryHeadersMiddleware();
  init_retryDecider();
  init_retryMiddleware();
});

// ../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var import_client3, ENV_KEY = "AWS_ACCESS_KEY_ID", ENV_SECRET = "AWS_SECRET_ACCESS_KEY", ENV_SESSION = "AWS_SESSION_TOKEN", ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION", ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE", ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID", fromEnv2 = (init3) => async () => {
  init3?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
  const accessKeyId = process.env[ENV_KEY];
  const secretAccessKey = process.env[ENV_SECRET];
  const sessionToken = process.env[ENV_SESSION];
  const expiry = process.env[ENV_EXPIRATION];
  const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
  const accountId = process.env[ENV_ACCOUNT_ID];
  if (accessKeyId && secretAccessKey) {
    const credentials = {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) },
      ...credentialScope && { credentialScope },
      ...accountId && { accountId }
    };
    import_client3.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
    return credentials;
  }
  throw new CredentialsProviderError("Unable to find environment variable credentials.", { logger: init3?.logger });
};
var init_fromEnv2 = __esm(() => {
  import_client3 = __toESM(require_client(), 1);
  init_dist_es13();
});

// ../node_modules/@aws-sdk/credential-provider-env/dist-es/index.js
var exports_dist_es = {};
__export(exports_dist_es, {
  fromEnv: () => fromEnv2,
  ENV_SESSION: () => ENV_SESSION,
  ENV_SECRET: () => ENV_SECRET,
  ENV_KEY: () => ENV_KEY,
  ENV_EXPIRATION: () => ENV_EXPIRATION,
  ENV_CREDENTIAL_SCOPE: () => ENV_CREDENTIAL_SCOPE,
  ENV_ACCOUNT_ID: () => ENV_ACCOUNT_ID
});
var init_dist_es23 = __esm(() => {
  init_fromEnv2();
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
import { Buffer as Buffer2 } from "buffer";
import { request } from "http";
function httpRequest2(options) {
  return new Promise((resolve3, reject) => {
    const req = request({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new ProviderError("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk) => {
        chunks.push(chunk);
      });
      res.on("end", () => {
        resolve3(Buffer2.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}
var init_httpRequest = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", fromImdsCredentials = (creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration),
  ...creds.AccountId && { accountId: creds.AccountId }
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT2 = 1000, DEFAULT_MAX_RETRIES = 0, providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT2 }) => ({ maxRetries, timeout });

// ../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry2 = (toRetry, maxRetries) => {
  let promise5 = toRetry();
  for (let i3 = 0;i3 < maxRetries; i3++) {
    promise5 = promise5.catch(toRetry);
  }
  return promise5;
};

// ../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
import { parse as parse6 } from "url";
var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromContainerMetadata = (init3 = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit(init3);
  return () => retry2(async () => {
    const requestOptions = await getCmdsUri({ logger: init3.logger });
    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
    if (!isImdsCredentials(credsResponse)) {
      throw new CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: init3.logger
      });
    }
    return fromImdsCredentials(credsResponse);
  }, maxRetries);
}, requestFromEcsImds = async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
    };
  }
  const buffer2 = await httpRequest2({
    ...options,
    timeout
  });
  return buffer2.toString();
}, CMDS_IP = "169.254.170.2", GREENGRASS_HOSTS, GREENGRASS_PROTOCOLS, getCmdsUri = async ({ logger: logger4 }) => {
  if (process.env[ENV_CMDS_RELATIVE_URI]) {
    return {
      hostname: CMDS_IP,
      path: process.env[ENV_CMDS_RELATIVE_URI]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI]) {
    const parsed = parse6(process.env[ENV_CMDS_FULL_URI]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
      throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
        tryNextLink: false,
        logger: logger4
      });
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
      throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
        tryNextLink: false,
        logger: logger4
      });
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : undefined
    };
  }
  throw new CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` + " variable is set", {
    tryNextLink: false,
    logger: logger4
  });
};
var init_fromContainerMetadata = __esm(() => {
  init_dist_es13();
  init_httpRequest();
  GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
  };
  GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
  };
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/error/InstanceMetadataV1FallbackError.js
var InstanceMetadataV1FallbackError;
var init_InstanceMetadataV1FallbackError = __esm(() => {
  init_dist_es13();
  InstanceMetadataV1FallbackError = class InstanceMetadataV1FallbackError extends CredentialsProviderError {
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      this.name = "InstanceMetadataV1FallbackError";
      Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
  };
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
var init_Endpoint = __esm(() => {
  (function(Endpoint2) {
    Endpoint2["IPv4"] = "http://169.254.169.254";
    Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
  })(Endpoint || (Endpoint = {}));
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT", CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint", ENDPOINT_CONFIG_OPTIONS;
var init_EndpointConfigOptions = __esm(() => {
  ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_NAME],
    configFileSelector: (profile2) => profile2[CONFIG_ENDPOINT_NAME],
    default: undefined
  };
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
var init_EndpointMode = __esm(() => {
  (function(EndpointMode2) {
    EndpointMode2["IPv4"] = "IPv4";
    EndpointMode2["IPv6"] = "IPv6";
  })(EndpointMode || (EndpointMode = {}));
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode", ENDPOINT_MODE_CONFIG_OPTIONS;
var init_EndpointModeConfigOptions = __esm(() => {
  init_EndpointMode();
  ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile2) => profile2[CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode.IPv4
  };
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint = async () => parseUrl3(await getFromEndpointConfig() || await getFromEndpointModeConfig()), getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)(), getFromEndpointModeConfig = async () => {
  const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);
  }
};
var init_getInstanceMetadataEndpoint = __esm(() => {
  init_dist_es15();
  init_dist_es16();
  init_Endpoint();
  init_EndpointConfigOptions();
  init_EndpointMode();
  init_EndpointModeConfigOptions();
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS, STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS, STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", getExtendedInstanceMetadataCredentials = (credentials, logger4) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
  const newExpiration = new Date(Date.now() + refreshInterval * 1000);
  logger4.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " + `credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: ` + STATIC_STABILITY_DOC_URL);
  const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
  return {
    ...credentials,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
};
var init_getExtendedInstanceMetadataCredentials = __esm(() => {
  STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
  STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider = (provider, options = {}) => {
  const logger4 = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials;
    try {
      credentials = await provider();
      if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
        credentials = getExtendedInstanceMetadataCredentials(credentials, logger4);
      }
    } catch (e) {
      if (pastCredentials) {
        logger4.warn("Credential renew failed: ", e);
        credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger4);
      } else {
        throw e;
      }
    }
    pastCredentials = credentials;
    return credentials;
  };
};
var init_staticStabilityProvider = __esm(() => {
  init_getExtendedInstanceMetadataCredentials();
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js
var IMDS_PATH = "/latest/meta-data/iam/security-credentials/", IMDS_TOKEN_PATH = "/latest/api/token", AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED", PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled", X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token", fromInstanceMetadata = (init3 = {}) => staticStabilityProvider(getInstanceMetadataProvider(init3), { logger: init3.logger }), getInstanceMetadataProvider = (init3 = {}) => {
  let disableFetchToken = false;
  const { logger: logger4, profile: profile2 } = init3;
  const { timeout, maxRetries } = providerConfigFromInit(init3);
  const getCredentials = async (maxRetries2, options) => {
    const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
    if (isImdsV1Fallback) {
      let fallbackBlockedFromProfile = false;
      let fallbackBlockedFromProcessEnv = false;
      const configValue = await loadConfig({
        environmentVariableSelector: (env2) => {
          const envValue = env2[AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
          if (envValue === undefined) {
            throw new CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init3.logger });
          }
          return fallbackBlockedFromProcessEnv;
        },
        configFileSelector: (profile3) => {
          const profileValue = profile3[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
          return fallbackBlockedFromProfile;
        },
        default: false
      }, {
        profile: profile2
      })();
      if (init3.ec2MetadataV1Disabled || configValue) {
        const causes = [];
        if (init3.ec2MetadataV1Disabled)
          causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
        if (fallbackBlockedFromProfile)
          causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
        if (fallbackBlockedFromProcessEnv)
          causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
        throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
      }
    }
    const imdsProfile = (await retry2(async () => {
      let profile3;
      try {
        profile3 = await getProfile(options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return profile3;
    }, maxRetries2)).trim();
    return retry2(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile(imdsProfile, options, init3);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return creds;
    }, maxRetries2);
  };
  return async () => {
    const endpoint2 = await getInstanceMetadataEndpoint();
    if (disableFetchToken) {
      logger4?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
      return getCredentials(maxRetries, { ...endpoint2, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken({ ...endpoint2, timeout })).toString();
      } catch (error5) {
        if (error5?.statusCode === 400) {
          throw Object.assign(error5, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error5.message === "TimeoutError" || [403, 404, 405].includes(error5.statusCode)) {
          disableFetchToken = true;
        }
        logger4?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
        return getCredentials(maxRetries, { ...endpoint2, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint2,
        headers: {
          [X_AWS_EC2_METADATA_TOKEN]: token
        },
        timeout
      });
    }
  };
}, getMetadataToken = async (options) => httpRequest2({
  ...options,
  path: IMDS_TOKEN_PATH,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
}), getProfile = async (options) => (await httpRequest2({ ...options, path: IMDS_PATH })).toString(), getCredentialsFromProfile = async (profile2, options, init3) => {
  const credentialsResponse = JSON.parse((await httpRequest2({
    ...options,
    path: IMDS_PATH + profile2
  })).toString());
  if (!isImdsCredentials(credentialsResponse)) {
    throw new CredentialsProviderError("Invalid response received from instance metadata service.", {
      logger: init3.logger
    });
  }
  return fromImdsCredentials(credentialsResponse);
};
var init_fromInstanceMetadata = __esm(() => {
  init_dist_es15();
  init_dist_es13();
  init_InstanceMetadataV1FallbackError();
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_staticStabilityProvider();
});

// ../node_modules/@smithy/credential-provider-imds/dist-es/types.js
var init_types8 = () => {
};

// ../node_modules/@smithy/credential-provider-imds/dist-es/index.js
var exports_dist_es2 = {};
__export(exports_dist_es2, {
  providerConfigFromInit: () => providerConfigFromInit,
  httpRequest: () => httpRequest2,
  getInstanceMetadataEndpoint: () => getInstanceMetadataEndpoint,
  fromInstanceMetadata: () => fromInstanceMetadata,
  fromContainerMetadata: () => fromContainerMetadata,
  Endpoint: () => Endpoint,
  ENV_CMDS_RELATIVE_URI: () => ENV_CMDS_RELATIVE_URI,
  ENV_CMDS_FULL_URI: () => ENV_CMDS_FULL_URI,
  ENV_CMDS_AUTH_TOKEN: () => ENV_CMDS_AUTH_TOKEN,
  DEFAULT_TIMEOUT: () => DEFAULT_TIMEOUT2,
  DEFAULT_MAX_RETRIES: () => DEFAULT_MAX_RETRIES
});
var init_dist_es24 = __esm(() => {
  init_fromContainerMetadata();
  init_fromInstanceMetadata();
  init_types8();
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_Endpoint();
});

// ../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri = (uri2) => encodeURIComponent(uri2).replace(/[!'()*]/g, hexEncode), hexEncode = (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`;

// ../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = () => {
};

// ../node_modules/@smithy/util-uri-escape/dist-es/index.js
var init_dist_es25 = __esm(() => {
  init_escape_uri_path();
});

// ../node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value3 = query[key];
    key = escapeUri(key);
    if (Array.isArray(value3)) {
      for (let i3 = 0, iLen = value3.length;i3 < iLen; i3++) {
        parts.push(`${key}=${escapeUri(value3[i3])}`);
      }
    } else {
      let qsEntry = key;
      if (value3 || typeof value3 === "string") {
        qsEntry += `=${escapeUri(value3)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
var init_dist_es26 = __esm(() => {
  init_dist_es25();
});

// ../node_modules/@smithy/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES2;
var init_constants4 = __esm(() => {
  NODEJS_TIMEOUT_ERROR_CODES2 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
});

// ../node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders = (headers) => {
  const transformedHeaders = {};
  for (const name of Object.keys(headers)) {
    const headerValues = headers[name];
    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
};
var init_get_transformed_headers = () => {
};

// ../node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
var DEFER_EVENT_LISTENER_TIME = 1000, setConnectionTimeout = (request2, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return -1;
  }
  const registerTimeout = (offset) => {
    const timeoutId = setTimeout(() => {
      request2.destroy();
      reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
        name: "TimeoutError"
      }));
    }, timeoutInMs - offset);
    const doWithSocket = (socket) => {
      if (socket?.connecting) {
        socket.on("connect", () => {
          clearTimeout(timeoutId);
        });
      } else {
        clearTimeout(timeoutId);
      }
    };
    if (request2.socket) {
      doWithSocket(request2.socket);
    } else {
      request2.on("socket", doWithSocket);
    }
  };
  if (timeoutInMs < 2000) {
    registerTimeout(0);
    return 0;
  }
  return setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
};

// ../node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
var DEFER_EVENT_LISTENER_TIME2 = 3000, setSocketKeepAlive = (request2, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME2) => {
  if (keepAlive !== true) {
    return -1;
  }
  const registerListener = () => {
    if (request2.socket) {
      request2.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    } else {
      request2.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      });
    }
  };
  if (deferTimeMs === 0) {
    registerListener();
    return 0;
  }
  return setTimeout(registerListener, deferTimeMs);
};

// ../node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
var DEFER_EVENT_LISTENER_TIME3 = 3000, setSocketTimeout = (request2, reject, timeoutInMs = 0) => {
  const registerTimeout = (offset) => {
    request2.setTimeout(timeoutInMs - offset, () => {
      request2.destroy();
      reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
  };
  if (0 < timeoutInMs && timeoutInMs < 6000) {
    registerTimeout(0);
    return 0;
  }
  return setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME3), DEFER_EVENT_LISTENER_TIME3);
};

// ../node_modules/@smithy/node-http-handler/dist-es/write-request-body.js
import { Readable as Readable3 } from "stream";
async function writeRequestBody(httpRequest3, request2, maxContinueTimeoutMs = MIN_WAIT_TIME) {
  const headers = request2.headers ?? {};
  const expect = headers["Expect"] || headers["expect"];
  let timeoutId = -1;
  let hasError = false;
  if (expect === "100-continue") {
    await Promise.race([
      new Promise((resolve3) => {
        timeoutId = Number(setTimeout(resolve3, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
      }),
      new Promise((resolve3) => {
        httpRequest3.on("continue", () => {
          clearTimeout(timeoutId);
          resolve3();
        });
        httpRequest3.on("error", () => {
          hasError = true;
          clearTimeout(timeoutId);
          resolve3();
        });
      })
    ]);
  }
  if (!hasError) {
    writeBody(httpRequest3, request2.body);
  }
}
function writeBody(httpRequest3, body) {
  if (body instanceof Readable3) {
    body.pipe(httpRequest3);
    return;
  }
  if (body) {
    if (Buffer.isBuffer(body) || typeof body === "string") {
      httpRequest3.end(body);
      return;
    }
    const uint8 = body;
    if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
      httpRequest3.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
      return;
    }
    httpRequest3.end(Buffer.from(body));
    return;
  }
  httpRequest3.end();
}
var MIN_WAIT_TIME = 1000;
var init_write_request_body = () => {
};

// ../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
import { Agent as hAgent, request as hRequest } from "http";
import { Agent as hsAgent, request as hsRequest } from "https";

class NodeHttpHandler {
  static create(instanceOrOptions) {
    if (typeof instanceOrOptions?.handle === "function") {
      return instanceOrOptions;
    }
    return new NodeHttpHandler(instanceOrOptions);
  }
  static checkSocketUsage(agent, socketWarningTimestamp, logger4 = console) {
    const { sockets, requests, maxSockets } = agent;
    if (typeof maxSockets !== "number" || maxSockets === Infinity) {
      return socketWarningTimestamp;
    }
    const interval2 = 15000;
    if (Date.now() - interval2 < socketWarningTimestamp) {
      return socketWarningTimestamp;
    }
    if (sockets && requests) {
      for (const origin in sockets) {
        const socketsInUse = sockets[origin]?.length ?? 0;
        const requestsEnqueued = requests[origin]?.length ?? 0;
        if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
          logger4?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
          return Date.now();
        }
      }
    }
    return socketWarningTimestamp;
  }
  constructor(options) {
    this.socketWarningTimestamp = 0;
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve3, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve3(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve3(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      requestTimeout: requestTimeout ?? socketTimeout,
      httpAgent: (() => {
        if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
          return httpAgent;
        }
        return new hAgent({ keepAlive, maxSockets, ...httpAgent });
      })(),
      httpsAgent: (() => {
        if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
          return httpsAgent;
        }
        return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
      })(),
      logger: console
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request2, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((_resolve, _reject) => {
      let writeRequestBodyPromise = undefined;
      const timeouts = [];
      const resolve3 = async (arg) => {
        await writeRequestBodyPromise;
        timeouts.forEach(clearTimeout);
        _resolve(arg);
      };
      const reject = async (arg) => {
        await writeRequestBodyPromise;
        timeouts.forEach(clearTimeout);
        _reject(arg);
      };
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request2.protocol === "https:";
      const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
      timeouts.push(setTimeout(() => {
        this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);
      }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
      const queryString = buildQueryString(request2.query || {});
      let auth3 = undefined;
      if (request2.username != null || request2.password != null) {
        const username = request2.username ?? "";
        const password = request2.password ?? "";
        auth3 = `${username}:${password}`;
      }
      let path4 = request2.path;
      if (queryString) {
        path4 += `?${queryString}`;
      }
      if (request2.fragment) {
        path4 += `#${request2.fragment}`;
      }
      let hostname3 = request2.hostname ?? "";
      if (hostname3[0] === "[" && hostname3.endsWith("]")) {
        hostname3 = request2.hostname.slice(1, -1);
      } else {
        hostname3 = request2.hostname;
      }
      const nodeHttpsOptions = {
        headers: request2.headers,
        host: hostname3,
        method: request2.method,
        path: path4,
        port: request2.port,
        agent,
        auth: auth3
      };
      const requestFunc = isSSL ? hsRequest : hRequest;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse2 = new HttpResponse({
          statusCode: res.statusCode || -1,
          reason: res.statusMessage,
          headers: getTransformedHeaders(res.headers),
          body: res
        });
        resolve3({ response: httpResponse2 });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES2.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      if (abortSignal) {
        const onAbort = () => {
          req.destroy();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
        if (typeof abortSignal.addEventListener === "function") {
          const signal = abortSignal;
          signal.addEventListener("abort", onAbort, { once: true });
          req.once("close", () => signal.removeEventListener("abort", onAbort));
        } else {
          abortSignal.onabort = onAbort;
        }
      }
      timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
      timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
      const httpAgent = nodeHttpsOptions.agent;
      if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
        timeouts.push(setSocketKeepAlive(req, {
          keepAlive: httpAgent.keepAlive,
          keepAliveMsecs: httpAgent.keepAliveMsecs
        }));
      }
      writeRequestBodyPromise = writeRequestBody(req, request2, this.config.requestTimeout).catch((e) => {
        timeouts.forEach(clearTimeout);
        return _reject(e);
      });
    });
  }
  updateHttpClientConfig(key, value3) {
    this.config = undefined;
    this.configProvider = this.configProvider.then((config5) => {
      return {
        ...config5,
        [key]: value3
      };
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
var init_node_http_handler = __esm(() => {
  init_dist_es2();
  init_dist_es26();
  init_constants4();
  init_get_transformed_headers();
  init_write_request_body();
});

// ../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
var init_node_http2_connection_pool = () => {
};

// ../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js
var init_node_http2_connection_manager = __esm(() => {
  init_node_http2_connection_pool();
});

// ../node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js
var init_node_http2_handler = __esm(() => {
  init_dist_es2();
  init_dist_es26();
  init_get_transformed_headers();
  init_node_http2_connection_manager();
  init_write_request_body();
});

// ../node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js
import { Writable } from "stream";
var Collector;
var init_collector = __esm(() => {
  Collector = class Collector extends Writable {
    constructor() {
      super(...arguments);
      this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  };
});

// ../node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js
async function collectReadableStream(stream2) {
  const chunks = [];
  const reader = stream2.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value: value3 } = await reader.read();
    if (value3) {
      chunks.push(value3);
      length += value3.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
var streamCollector = (stream2) => {
  if (isReadableStreamInstance(stream2)) {
    return collectReadableStream(stream2);
  }
  return new Promise((resolve3, reject) => {
    const collector = new Collector;
    stream2.pipe(collector);
    stream2.on("error", (err) => {
      collector.end();
      reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function() {
      const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
      resolve3(bytes);
    });
  });
}, isReadableStreamInstance = (stream2) => typeof ReadableStream === "function" && stream2 instanceof ReadableStream;
var init_stream_collector = __esm(() => {
  init_collector();
});

// ../node_modules/@smithy/node-http-handler/dist-es/index.js
var init_dist_es27 = __esm(() => {
  init_node_http_handler();
  init_node_http2_handler();
  init_stream_collector();
});

// ../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js
var ECS_CONTAINER_HOST = "169.254.170.2", EKS_CONTAINER_HOST_IPv4 = "169.254.170.23", EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]", checkUrl = (url, logger4) => {
  if (url.protocol === "https:") {
    return;
  }
  if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
    return;
  }
  if (url.hostname.includes("[")) {
    if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
      return;
    }
  } else {
    if (url.hostname === "localhost") {
      return;
    }
    const ipComponents = url.hostname.split(".");
    const inRange = (component) => {
      const num = parseInt(component, 10);
      return 0 <= num && num <= 255;
    };
    if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
      return;
    }
  }
  throw new CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger: logger4 });
};
var init_checkUrl = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js
function createGetRequest(url) {
  return new HttpRequest({
    protocol: url.protocol,
    hostname: url.hostname,
    port: Number(url.port),
    path: url.pathname,
    query: Array.from(url.searchParams.entries()).reduce((acc, [k4, v6]) => {
      acc[k4] = v6;
      return acc;
    }, {}),
    fragment: url.hash
  });
}
async function getCredentials(response2, logger4) {
  const stream2 = import_util_stream.sdkStreamMixin(response2.body);
  const str = await stream2.transformToString();
  if (response2.statusCode === 200) {
    const parsed = JSON.parse(str);
    if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
      throw new CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " + "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger: logger4 });
    }
    return {
      accessKeyId: parsed.AccessKeyId,
      secretAccessKey: parsed.SecretAccessKey,
      sessionToken: parsed.Token,
      expiration: parseRfc3339DateTime(parsed.Expiration)
    };
  }
  if (response2.statusCode >= 400 && response2.statusCode < 500) {
    let parsedBody = {};
    try {
      parsedBody = JSON.parse(str);
    } catch (e) {
    }
    throw Object.assign(new CredentialsProviderError(`Server responded with status: ${response2.statusCode}`, { logger: logger4 }), {
      Code: parsedBody.Code,
      Message: parsedBody.Message
    });
  }
  throw new CredentialsProviderError(`Server responded with status: ${response2.statusCode}`, { logger: logger4 });
}
var import_util_stream;
var init_requestHelpers = __esm(() => {
  init_dist_es13();
  init_dist_es2();
  init_dist_es21();
  import_util_stream = __toESM(require_dist_cjs14(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js
var retryWrapper = (toRetry, maxRetries, delayMs) => {
  return async () => {
    for (let i3 = 0;i3 < maxRetries; ++i3) {
      try {
        return await toRetry();
      } catch (e) {
        await new Promise((resolve3) => setTimeout(resolve3, delayMs));
      }
    }
    return await toRetry();
  };
};

// ../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.js
import fs2 from "fs/promises";
var import_client4, AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2", AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE", AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromHttp = (options = {}) => {
  options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
  let host;
  const relative3 = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
  const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
  const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
  const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
  const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger ? console.warn : options.logger.warn;
  if (relative3 && full) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
    warn("awsContainerCredentialsFullUri will take precedence.");
  }
  if (token && tokenFile) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
    warn("awsContainerAuthorizationToken will take precedence.");
  }
  if (full) {
    host = full;
  } else if (relative3) {
    host = `${DEFAULT_LINK_LOCAL_HOST}${relative3}`;
  } else {
    throw new CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
  }
  const url = new URL(host);
  checkUrl(url, options.logger);
  const requestHandler = new NodeHttpHandler({
    requestTimeout: options.timeout ?? 1000,
    connectionTimeout: options.timeout ?? 1000
  });
  return retryWrapper(async () => {
    const request2 = createGetRequest(url);
    if (token) {
      request2.headers.Authorization = token;
    } else if (tokenFile) {
      request2.headers.Authorization = (await fs2.readFile(tokenFile)).toString();
    }
    try {
      const result = await requestHandler.handle(request2);
      return getCredentials(result.response).then((creds) => import_client4.setCredentialFeature(creds, "CREDENTIALS_HTTP", "z"));
    } catch (e) {
      throw new CredentialsProviderError(String(e), { logger: options.logger });
    }
  }, options.maxRetries ?? 3, options.timeout ?? 1000);
};
var init_fromHttp = __esm(() => {
  import_client4 = __toESM(require_client(), 1);
  init_dist_es27();
  init_dist_es13();
  init_checkUrl();
  init_requestHelpers();
});

// ../node_modules/@aws-sdk/credential-provider-http/dist-es/index.js
var exports_dist_es3 = {};
__export(exports_dist_es3, {
  fromHttp: () => fromHttp
});
var init_dist_es28 = __esm(() => {
  init_fromHttp();
});

// ../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED", remoteProvider = async (init3) => {
  const { ENV_CMDS_FULL_URI: ENV_CMDS_FULL_URI2, ENV_CMDS_RELATIVE_URI: ENV_CMDS_RELATIVE_URI2, fromContainerMetadata: fromContainerMetadata3, fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es24(), exports_dist_es2));
  if (process.env[ENV_CMDS_RELATIVE_URI2] || process.env[ENV_CMDS_FULL_URI2]) {
    init3.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
    const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es28(), exports_dist_es3));
    return chain(fromHttp2(init3), fromContainerMetadata3(init3));
  }
  if (process.env[ENV_IMDS_DISABLED]) {
    return async () => {
      throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init3.logger });
    };
  }
  init3.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
  return fromInstanceMetadata3(init3);
};
var init_remoteProvider = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// ../node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS, REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
var init_constants5 = __esm(() => {
  EXPIRE_WINDOW_MS = 5 * 60 * 1000;
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption2(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sso-oauth",
      region: authParameters.region
    },
    propertiesExtractor: (config5, context8) => ({
      signingProperties: {
        config: config5,
        context: context8
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_core58, defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config5, context8, input) => {
  return {
    operation: getSmithyContext(context8).operation,
    region: await normalizeProvider2(config5.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "CreateToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "RegisterClient": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "StartDeviceAuthorization": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
    }
  }
  return options;
}, resolveHttpAuthSchemeConfig2 = (config5) => {
  const config_0 = import_core58.resolveAwsSdkSigV4Config(config5);
  return {
    ...config_0
  };
};
var init_httpAuthSchemeProvider = __esm(() => {
  import_core58 = __toESM(require_dist_cjs20(), 1);
  init_dist_es10();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "sso-oauth"
  };
}, commonParams2;
var init_EndpointParameters = __esm(() => {
  commonParams2 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default2;
var init_package = __esm(() => {
  package_default2 = {
    name: "@aws-sdk/client-sso-oidc",
    description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
    version: "3.675.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso-oidc",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.667.0",
      "@aws-sdk/credential-provider-node": "3.675.0",
      "@aws-sdk/middleware-host-header": "3.667.0",
      "@aws-sdk/middleware-logger": "3.667.0",
      "@aws-sdk/middleware-recursion-detection": "3.667.0",
      "@aws-sdk/middleware-user-agent": "3.669.0",
      "@aws-sdk/region-config-resolver": "3.667.0",
      "@aws-sdk/types": "3.667.0",
      "@aws-sdk/util-endpoints": "3.667.0",
      "@aws-sdk/util-user-agent-browser": "3.675.0",
      "@aws-sdk/util-user-agent-node": "3.669.0",
      "@smithy/config-resolver": "^3.0.9",
      "@smithy/core": "^2.4.8",
      "@smithy/fetch-http-handler": "^3.2.9",
      "@smithy/hash-node": "^3.0.7",
      "@smithy/invalid-dependency": "^3.0.7",
      "@smithy/middleware-content-length": "^3.0.9",
      "@smithy/middleware-endpoint": "^3.1.4",
      "@smithy/middleware-retry": "^3.0.23",
      "@smithy/middleware-serde": "^3.0.7",
      "@smithy/middleware-stack": "^3.0.7",
      "@smithy/node-config-provider": "^3.1.8",
      "@smithy/node-http-handler": "^3.2.4",
      "@smithy/protocol-http": "^4.1.4",
      "@smithy/smithy-client": "^3.4.0",
      "@smithy/types": "^3.5.0",
      "@smithy/url-parser": "^3.0.7",
      "@smithy/util-base64": "^3.0.0",
      "@smithy/util-body-length-browser": "^3.0.0",
      "@smithy/util-body-length-node": "^3.0.0",
      "@smithy/util-defaults-mode-browser": "^3.0.23",
      "@smithy/util-defaults-mode-node": "^3.0.23",
      "@smithy/util-endpoints": "^2.1.3",
      "@smithy/util-middleware": "^3.0.7",
      "@smithy/util-retry": "^3.0.7",
      "@smithy/util-utf8": "^3.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node16": "16.1.3",
      "@types/node": "^16.18.96",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=16.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    peerDependencies: {
      "@aws-sdk/client-sts": "^3.675.0"
    },
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso-oidc"
    }
  };
});

// ../node_modules/@aws-sdk/util-user-agent-node/dist-es/crt-availability.js
var crtAvailability;
var init_crt_availability = __esm(() => {
  crtAvailability = {
    isCrtAvailable: false
  };
});

// ../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable = () => {
  if (crtAvailability.isCrtAvailable) {
    return ["md/crt-avail"];
  }
  return null;
};
var init_is_crt_available = __esm(() => {
  init_crt_availability();
});

// ../node_modules/@aws-sdk/util-user-agent-node/dist-es/defaultUserAgent.js
import { platform as platform2, release as release2 } from "os";
import { env as env2, versions } from "process";
var createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
  return async (config5) => {
    const sections = [
      ["aws-sdk-js", clientVersion],
      ["ua", "2.1"],
      [`os/${platform2()}`, release2()],
      ["lang/js"],
      ["md/nodejs", `${versions.node}`]
    ];
    const crtAvailable = isCrtAvailable();
    if (crtAvailable) {
      sections.push(crtAvailable);
    }
    if (serviceId) {
      sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (env2.AWS_EXECUTION_ENV) {
      sections.push([`exec-env/${env2.AWS_EXECUTION_ENV}`]);
    }
    const appId = await config5?.userAgentAppId?.();
    const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    return resolvedUserAgent;
  };
};
var init_defaultUserAgent = __esm(() => {
  init_is_crt_available();
  init_crt_availability();
});

// ../node_modules/@aws-sdk/util-user-agent-node/dist-es/nodeAppIdConfigOptions.js
var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID", UA_APP_ID_INI_NAME = "sdk-ua-app-id", NODE_APP_ID_CONFIG_OPTIONS;
var init_nodeAppIdConfigOptions = __esm(() => {
  init_dist_es8();
  NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile2) => profile2[UA_APP_ID_INI_NAME],
    default: DEFAULT_UA_APP_ID
  };
});

// ../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var init_dist_es29 = __esm(() => {
  init_defaultUserAgent();
  init_nodeAppIdConfigOptions();
});

// ../node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// ../node_modules/@smithy/util-buffer-from/dist-es/index.js
import { Buffer as Buffer3 } from "buffer";
var fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
  if (!isArrayBuffer(input)) {
    throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
  }
  return Buffer3.from(input, offset, length);
}, fromString = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? Buffer3.from(input, encoding) : Buffer3.from(input);
};
var init_dist_es30 = () => {
};

// ../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf8 = (input) => {
  const buf = fromString(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
var init_fromUtf8 = __esm(() => {
  init_dist_es30();
});

// ../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};
var init_toUint8Array = __esm(() => {
  init_fromUtf8();
});

// ../node_modules/@smithy/util-utf8/dist-es/toUtf8.js
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};
var init_toUtf8 = __esm(() => {
  init_dist_es30();
});

// ../node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es31 = __esm(() => {
  init_fromUtf8();
  init_toUint8Array();
  init_toUtf8();
});

// ../node_modules/@smithy/hash-node/dist-es/index.js
import { Buffer as Buffer4 } from "buffer";
import { createHash as createHash2, createHmac } from "crypto";

class Hash3 {
  constructor(algorithmIdentifier, secret) {
    this.algorithmIdentifier = algorithmIdentifier;
    this.secret = secret;
    this.reset();
  }
  update(toHash, encoding) {
    this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
  }
  digest() {
    return Promise.resolve(this.hash.digest());
  }
  reset() {
    this.hash = this.secret ? createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : createHash2(this.algorithmIdentifier);
  }
}
function castSourceData(toCast, encoding) {
  if (Buffer4.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer(toCast);
}
var init_dist_es32 = __esm(() => {
  init_dist_es30();
  init_dist_es31();
});

// ../node_modules/@smithy/util-body-length-node/dist-es/calculateBodyLength.js
import { fstatSync, lstatSync } from "fs";
var calculateBodyLength = (body) => {
  if (!body) {
    return 0;
  }
  if (typeof body === "string") {
    return Buffer.byteLength(body);
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  } else if (typeof body.start === "number" && typeof body.end === "number") {
    return body.end + 1 - body.start;
  } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
    return lstatSync(body.path).size;
  } else if (typeof body.fd === "number") {
    return fstatSync(body.fd).size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};
var init_calculateBodyLength = () => {
};

// ../node_modules/@smithy/util-body-length-node/dist-es/index.js
var init_dist_es33 = __esm(() => {
  init_calculateBodyLength();
});

// ../node_modules/@smithy/util-base64/dist-es/fromBase64.js
var BASE64_REGEX, fromBase642 = (input) => {
  if (input.length * 3 % 4 !== 0) {
    throw new TypeError(`Incorrect padding on base64 string.`);
  }
  if (!BASE64_REGEX.exec(input)) {
    throw new TypeError(`Invalid base64 string.`);
  }
  const buffer2 = fromString(input, "base64");
  return new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
};
var init_fromBase64 = __esm(() => {
  init_dist_es30();
  BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
});

// ../node_modules/@smithy/util-base64/dist-es/toBase64.js
var toBase642 = (_input) => {
  let input;
  if (typeof _input === "string") {
    input = fromUtf8(_input);
  } else {
    input = _input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};
var init_toBase64 = __esm(() => {
  init_dist_es30();
  init_dist_es31();
});

// ../node_modules/@smithy/util-base64/dist-es/index.js
var init_dist_es34 = __esm(() => {
  init_fromBase64();
  init_toBase64();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var u3 = "required", v6 = "fn", w3 = "argv", x5 = "ref", a = true, b5 = "isSet", c3 = "booleanEquals", d5 = "error", e = "endpoint", f5 = "tree", g3 = "PartitionResult", h5 = "getAttr", i3, j4, k5, l, m5, n2, o2, p5, q6, r, s, t3, _data, ruleSet;
var init_ruleset = __esm(() => {
  i3 = { [u3]: false, type: "String" };
  j4 = { [u3]: true, default: false, type: "Boolean" };
  k5 = { [x5]: "Endpoint" };
  l = { [v6]: c3, [w3]: [{ [x5]: "UseFIPS" }, true] };
  m5 = { [v6]: c3, [w3]: [{ [x5]: "UseDualStack" }, true] };
  n2 = {};
  o2 = { [v6]: h5, [w3]: [{ [x5]: g3 }, "supportsFIPS"] };
  p5 = { [x5]: g3 };
  q6 = { [v6]: c3, [w3]: [true, { [v6]: h5, [w3]: [p5, "supportsDualStack"] }] };
  r = [l];
  s = [m5];
  t3 = [{ [x5]: "Region" }];
  _data = { version: "1.0", parameters: { Region: i3, UseDualStack: j4, UseFIPS: j4, Endpoint: i3 }, rules: [{ conditions: [{ [v6]: b5, [w3]: [k5] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d5 }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d5 }, { endpoint: { url: k5, properties: n2, headers: n2 }, type: e }], type: f5 }, { conditions: [{ [v6]: b5, [w3]: t3 }], rules: [{ conditions: [{ [v6]: "aws.partition", [w3]: t3, assign: g3 }], rules: [{ conditions: [l, m5], rules: [{ conditions: [{ [v6]: c3, [w3]: [a, o2] }, q6], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n2, headers: n2 }, type: e }], type: f5 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d5 }], type: f5 }, { conditions: r, rules: [{ conditions: [{ [v6]: c3, [w3]: [o2, a] }], rules: [{ conditions: [{ [v6]: "stringEquals", [w3]: [{ [v6]: h5, [w3]: [p5, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n2, headers: n2 }, type: e }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n2, headers: n2 }, type: e }], type: f5 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d5 }], type: f5 }, { conditions: s, rules: [{ conditions: [q6], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n2, headers: n2 }, type: e }], type: f5 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d5 }], type: f5 }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n2, headers: n2 }, type: e }], type: f5 }], type: f5 }, { error: "Invalid Configuration: Missing Region", type: d5 }] };
  ruleSet = _data;
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var cache, defaultEndpointResolver = (endpointParams, context8 = {}) => {
  return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context8.logger
  }));
};
var init_endpointResolver = __esm(() => {
  init_dist_es7();
  init_dist_es6();
  init_ruleset();
  cache = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var import_core59, import_core60, getRuntimeConfig = (config5) => {
  return {
    apiVersion: "2019-06-10",
    base64Decoder: config5?.base64Decoder ?? fromBase642,
    base64Encoder: config5?.base64Encoder ?? toBase642,
    disableHostPrefix: config5?.disableHostPrefix ?? false,
    endpointProvider: config5?.endpointProvider ?? defaultEndpointResolver,
    extensions: config5?.extensions ?? [],
    httpAuthSchemeProvider: config5?.httpAuthSchemeProvider ?? defaultSSOOIDCHttpAuthSchemeProvider,
    httpAuthSchemes: config5?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core59.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core60.NoAuthSigner
      }
    ],
    logger: config5?.logger ?? new NoOpLogger,
    serviceId: config5?.serviceId ?? "SSO OIDC",
    urlParser: config5?.urlParser ?? parseUrl3,
    utf8Decoder: config5?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config5?.utf8Encoder ?? toUtf8
  };
};
var init_runtimeConfig_shared = __esm(() => {
  import_core59 = __toESM(require_dist_cjs20(), 1);
  import_core60 = __toESM(require_dist_cjs15(), 1);
  init_dist_es21();
  init_dist_es16();
  init_dist_es34();
  init_dist_es31();
  init_httpAuthSchemeProvider();
  init_endpointResolver();
});

// ../node_modules/@smithy/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV", AWS_REGION_ENV = "AWS_REGION", AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION", ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED", DEFAULTS_MODE_OPTIONS, IMDS_REGION_PATH = "/latest/meta-data/placement/region";
var init_constants6 = __esm(() => {
  DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
});

// ../node_modules/@smithy/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE", AWS_DEFAULTS_MODE_CONFIG = "defaults_mode", NODE_DEFAULTS_MODE_CONFIG_OPTIONS;
var init_defaultsModeConfig = __esm(() => {
  NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      return env3[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile2) => {
      return profile2[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
});

// ../node_modules/@smithy/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case undefined:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
}), resolveNodeDefaultsModeAuto = async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
}, inferPhysicalRegion = async () => {
  if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
    return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
  }
  if (!process.env[ENV_IMDS_DISABLED2]) {
    try {
      const { getInstanceMetadataEndpoint: getInstanceMetadataEndpoint2, httpRequest: httpRequest3 } = await Promise.resolve().then(() => (init_dist_es24(), exports_dist_es2));
      const endpoint2 = await getInstanceMetadataEndpoint2();
      return (await httpRequest3({ ...endpoint2, path: IMDS_REGION_PATH })).toString();
    } catch (e2) {
    }
  }
};
var init_resolveDefaultsModeConfig = __esm(() => {
  init_dist_es11();
  init_dist_es15();
  init_dist_es13();
  init_constants6();
  init_defaultsModeConfig();
});

// ../node_modules/@smithy/util-defaults-mode-node/dist-es/index.js
var init_dist_es35 = __esm(() => {
  init_resolveDefaultsModeConfig();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var import_core61, getRuntimeConfig2 = (config5) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config5);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config5);
  import_core61.emitWarningIfUnsupportedVersion(process.version);
  return {
    ...clientSharedValues,
    ...config5,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config5?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config5?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config5?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
    maxAttempts: config5?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config5?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: NodeHttpHandler.create(config5?.requestHandler ?? defaultConfigProvider),
    retryMode: config5?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config5?.sha256 ?? Hash3.bind(null, "sha256"),
    streamCollector: config5?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config5?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config5?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    userAgentAppId: config5?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS)
  };
};
var init_runtimeConfig = __esm(() => {
  init_package();
  import_core61 = __toESM(require_dist_cjs20(), 1);
  init_dist_es45();
  init_dist_es29();
  init_dist_es11();
  init_dist_es32();
  init_dist_es22();
  init_dist_es15();
  init_dist_es27();
  init_dist_es33();
  init_dist_es19();
  init_runtimeConfig_shared();
  init_dist_es21();
  init_dist_es35();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === undefined) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
}, resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
var init_config4 = () => {
};
// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js
var init_getRealRegion2 = () => {
};

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var init_resolveRegionConfig2 = __esm(() => {
  init_getRealRegion2();
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js
var init_regionConfig2 = __esm(() => {
  init_config4();
  init_resolveRegionConfig2();
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
var init_dist_es36 = __esm(() => {
  init_regionConfig2();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig = (config6) => {
  return {
    httpAuthSchemes: config6.httpAuthSchemes(),
    httpAuthSchemeProvider: config6.httpAuthSchemeProvider(),
    credentials: config6.credentials()
  };
};

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeExtensions.js
var asPartial = (t4) => t4, resolveRuntimeExtensions = (runtimeConfig, extensions5) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions5.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};
var init_runtimeExtensions = __esm(() => {
  init_dist_es36();
  init_dist_es2();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var import_core62, SSOOIDCClient;
var init_SSOOIDCClient = __esm(() => {
  init_dist_es3();
  init_dist_es4();
  init_dist_es5();
  init_dist_es8();
  init_dist_es11();
  import_core62 = __toESM(require_dist_cjs15(), 1);
  init_dist_es12();
  init_dist_es17();
  init_dist_es22();
  init_dist_es21();
  init_httpAuthSchemeProvider();
  init_EndpointParameters();
  init_runtimeConfig();
  init_runtimeExtensions();
  SSOOIDCClient = class SSOOIDCClient extends Client {
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig2(configuration || {});
      const _config_1 = resolveClientEndpointParameters2(_config_0);
      const _config_2 = resolveUserAgentConfig(_config_1);
      const _config_3 = resolveRetryConfig(_config_2);
      const _config_4 = resolveRegionConfig(_config_3);
      const _config_5 = resolveHostHeaderConfig(_config_4);
      const _config_6 = resolveEndpointConfig(_config_5);
      const _config_7 = resolveHttpAuthSchemeConfig2(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use(getUserAgentPlugin(this.config));
      this.middlewareStack.use(getRetryPlugin(this.config));
      this.middlewareStack.use(getContentLengthPlugin(this.config));
      this.middlewareStack.use(getHostHeaderPlugin(this.config));
      this.middlewareStack.use(getLoggerPlugin(this.config));
      this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core62.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultSSOOIDCHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config6) => new import_core62.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config6.credentials
        })
      }));
      this.middlewareStack.use(import_core62.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException;
var init_SSOOIDCServiceException = __esm(() => {
  init_dist_es21();
  SSOOIDCServiceException = class SSOOIDCServiceException extends ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException, AuthorizationPendingException, ExpiredTokenException, InternalServerException, InvalidClientException, InvalidGrantException, InvalidRequestException, InvalidScopeException, SlowDownException, UnauthorizedClientException, UnsupportedGrantTypeException, InvalidRequestRegionException, InvalidClientMetadataException, InvalidRedirectUriException, CreateTokenRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.clientSecret && { clientSecret: SENSITIVE_STRING },
  ...obj.refreshToken && { refreshToken: SENSITIVE_STRING },
  ...obj.codeVerifier && { codeVerifier: SENSITIVE_STRING }
}), CreateTokenResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING },
  ...obj.refreshToken && { refreshToken: SENSITIVE_STRING },
  ...obj.idToken && { idToken: SENSITIVE_STRING }
}), CreateTokenWithIAMRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.refreshToken && { refreshToken: SENSITIVE_STRING },
  ...obj.assertion && { assertion: SENSITIVE_STRING },
  ...obj.subjectToken && { subjectToken: SENSITIVE_STRING },
  ...obj.codeVerifier && { codeVerifier: SENSITIVE_STRING }
}), CreateTokenWithIAMResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING },
  ...obj.refreshToken && { refreshToken: SENSITIVE_STRING },
  ...obj.idToken && { idToken: SENSITIVE_STRING }
}), RegisterClientResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.clientSecret && { clientSecret: SENSITIVE_STRING }
}), StartDeviceAuthorizationRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.clientSecret && { clientSecret: SENSITIVE_STRING }
});
var init_models_0 = __esm(() => {
  init_dist_es21();
  init_SSOOIDCServiceException();
  AccessDeniedException = class AccessDeniedException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      this.name = "AccessDeniedException";
      this.$fault = "client";
      Object.setPrototypeOf(this, AccessDeniedException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  AuthorizationPendingException = class AuthorizationPendingException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "AuthorizationPendingException",
        $fault: "client",
        ...opts
      });
      this.name = "AuthorizationPendingException";
      this.$fault = "client";
      Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  ExpiredTokenException = class ExpiredTokenException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "ExpiredTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InternalServerException = class InternalServerException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      this.name = "InternalServerException";
      this.$fault = "server";
      Object.setPrototypeOf(this, InternalServerException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidClientException = class InvalidClientException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidClientException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidClientException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidGrantException = class InvalidGrantException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidGrantException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidGrantException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidGrantException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidRequestException = class InvalidRequestException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRequestException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidScopeException = class InvalidScopeException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidScopeException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidScopeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidScopeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  SlowDownException = class SlowDownException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "SlowDownException",
        $fault: "client",
        ...opts
      });
      this.name = "SlowDownException";
      this.$fault = "client";
      Object.setPrototypeOf(this, SlowDownException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  UnauthorizedClientException = class UnauthorizedClientException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "UnauthorizedClientException",
        $fault: "client",
        ...opts
      });
      this.name = "UnauthorizedClientException";
      this.$fault = "client";
      Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  UnsupportedGrantTypeException = class UnsupportedGrantTypeException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "UnsupportedGrantTypeException",
        $fault: "client",
        ...opts
      });
      this.name = "UnsupportedGrantTypeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidRequestRegionException = class InvalidRequestRegionException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidRequestRegionException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRequestRegionException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidRequestRegionException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
      this.endpoint = opts.endpoint;
      this.region = opts.region;
    }
  };
  InvalidClientMetadataException = class InvalidClientMetadataException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidClientMetadataException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidClientMetadataException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidClientMetadataException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  InvalidRedirectUriException = class InvalidRedirectUriException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidRedirectUriException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRedirectUriException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidRedirectUriException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var import_core63, import_core64, se_CreateTokenCommand = async (input, context8) => {
  const b4 = import_core64.requestBuilder(input, context8);
  const headers = {
    "content-type": "application/json"
  };
  b4.bp("/token");
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    code: [],
    codeVerifier: [],
    deviceCode: [],
    grantType: [],
    redirectUri: [],
    refreshToken: [],
    scope: (_3) => _json(_3)
  }));
  b4.m("POST").h(headers).b(body);
  return b4.build();
}, se_CreateTokenWithIAMCommand = async (input, context8) => {
  const b4 = import_core64.requestBuilder(input, context8);
  const headers = {
    "content-type": "application/json"
  };
  b4.bp("/token");
  const query = map5({
    [_ai]: [, "t"]
  });
  let body;
  body = JSON.stringify(take(input, {
    assertion: [],
    clientId: [],
    code: [],
    codeVerifier: [],
    grantType: [],
    redirectUri: [],
    refreshToken: [],
    requestedTokenType: [],
    scope: (_3) => _json(_3),
    subjectToken: [],
    subjectTokenType: []
  }));
  b4.m("POST").h(headers).q(query).b(body);
  return b4.build();
}, se_RegisterClientCommand = async (input, context8) => {
  const b4 = import_core64.requestBuilder(input, context8);
  const headers = {
    "content-type": "application/json"
  };
  b4.bp("/client/register");
  let body;
  body = JSON.stringify(take(input, {
    clientName: [],
    clientType: [],
    entitledApplicationArn: [],
    grantTypes: (_3) => _json(_3),
    issuerUrl: [],
    redirectUris: (_3) => _json(_3),
    scopes: (_3) => _json(_3)
  }));
  b4.m("POST").h(headers).b(body);
  return b4.build();
}, se_StartDeviceAuthorizationCommand = async (input, context8) => {
  const b4 = import_core64.requestBuilder(input, context8);
  const headers = {
    "content-type": "application/json"
  };
  b4.bp("/device_authorization");
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    startUrl: []
  }));
  b4.m("POST").h(headers).b(body);
  return b4.build();
}, de_CreateTokenCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await import_core63.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    accessToken: expectString,
    expiresIn: expectInt32,
    idToken: expectString,
    refreshToken: expectString,
    tokenType: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_CreateTokenWithIAMCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await import_core63.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    accessToken: expectString,
    expiresIn: expectInt32,
    idToken: expectString,
    issuedTokenType: expectString,
    refreshToken: expectString,
    scope: _json,
    tokenType: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_RegisterClientCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await import_core63.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    authorizationEndpoint: expectString,
    clientId: expectString,
    clientIdIssuedAt: expectLong,
    clientSecret: expectString,
    clientSecretExpiresAt: expectLong,
    tokenEndpoint: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_StartDeviceAuthorizationCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await import_core63.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    deviceCode: expectString,
    expiresIn: expectInt32,
    interval: expectInt32,
    userCode: expectString,
    verificationUri: expectString,
    verificationUriComplete: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_CommandError = async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await import_core63.parseJsonErrorBody(output.body, context8)
  };
  const errorCode = import_core63.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context8);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await de_AuthorizationPendingExceptionRes(parsedOutput, context8);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes(parsedOutput, context8);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes(parsedOutput, context8);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await de_InvalidClientExceptionRes(parsedOutput, context8);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await de_InvalidGrantExceptionRes(parsedOutput, context8);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context8);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await de_InvalidScopeExceptionRes(parsedOutput, context8);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await de_SlowDownExceptionRes(parsedOutput, context8);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await de_UnauthorizedClientExceptionRes(parsedOutput, context8);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context8);
    case "InvalidRequestRegionException":
    case "com.amazonaws.ssooidc#InvalidRequestRegionException":
      throw await de_InvalidRequestRegionExceptionRes(parsedOutput, context8);
    case "InvalidClientMetadataException":
    case "com.amazonaws.ssooidc#InvalidClientMetadataException":
      throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context8);
    case "InvalidRedirectUriException":
    case "com.amazonaws.ssooidc#InvalidRedirectUriException":
      throw await de_InvalidRedirectUriExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody,
        errorCode
      });
  }
}, throwDefaultError2, de_AccessDeniedExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AccessDeniedException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_AuthorizationPendingExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AuthorizationPendingException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_ExpiredTokenExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new ExpiredTokenException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InternalServerExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InternalServerException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidClientExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidClientMetadataExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientMetadataException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidGrantExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidGrantException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidRedirectUriExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRedirectUriException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidRequestExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidRequestRegionExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    endpoint: expectString,
    error: expectString,
    error_description: expectString,
    region: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestRegionException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_InvalidScopeExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidScopeException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_SlowDownExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new SlowDownException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_UnauthorizedClientExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedClientException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnsupportedGrantTypeException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), _ai = "aws_iam";
var init_Aws_restJson1 = __esm(() => {
  import_core63 = __toESM(require_dist_cjs20(), 1);
  import_core64 = __toESM(require_dist_cjs15(), 1);
  init_dist_es21();
  init_models_0();
  init_SSOOIDCServiceException();
  throwDefaultError2 = withBaseException(SSOOIDCServiceException);
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var import_middleware_serde2, CreateTokenCommand;
var init_CreateTokenCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde2 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  CreateTokenCommand = class CreateTokenCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs, config6, o3) {
    return [
      import_middleware_serde2.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog).ser(se_CreateTokenCommand).de(de_CreateTokenCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenWithIAMCommand.js
var import_middleware_serde3, CreateTokenWithIAMCommand;
var init_CreateTokenWithIAMCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde3 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  CreateTokenWithIAMCommand = class CreateTokenWithIAMCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs, config6, o3) {
    return [
      import_middleware_serde3.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "CreateTokenWithIAM", {}).n("SSOOIDCClient", "CreateTokenWithIAMCommand").f(CreateTokenWithIAMRequestFilterSensitiveLog, CreateTokenWithIAMResponseFilterSensitiveLog).ser(se_CreateTokenWithIAMCommand).de(de_CreateTokenWithIAMCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/RegisterClientCommand.js
var import_middleware_serde4, RegisterClientCommand;
var init_RegisterClientCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde4 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  RegisterClientCommand = class RegisterClientCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs, config6, o3) {
    return [
      import_middleware_serde4.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "RegisterClient", {}).n("SSOOIDCClient", "RegisterClientCommand").f(undefined, RegisterClientResponseFilterSensitiveLog).ser(se_RegisterClientCommand).de(de_RegisterClientCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/StartDeviceAuthorizationCommand.js
var import_middleware_serde5, StartDeviceAuthorizationCommand;
var init_StartDeviceAuthorizationCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde5 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  StartDeviceAuthorizationCommand = class StartDeviceAuthorizationCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs, config6, o3) {
    return [
      import_middleware_serde5.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "StartDeviceAuthorization", {}).n("SSOOIDCClient", "StartDeviceAuthorizationCommand").f(StartDeviceAuthorizationRequestFilterSensitiveLog, undefined).ser(se_StartDeviceAuthorizationCommand).de(de_StartDeviceAuthorizationCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDC.js
var commands, SSOOIDC;
var init_SSOOIDC = __esm(() => {
  init_dist_es21();
  init_CreateTokenCommand();
  init_CreateTokenWithIAMCommand();
  init_RegisterClientCommand();
  init_StartDeviceAuthorizationCommand();
  init_SSOOIDCClient();
  commands = {
    CreateTokenCommand,
    CreateTokenWithIAMCommand,
    RegisterClientCommand,
    StartDeviceAuthorizationCommand
  };
  SSOOIDC = class SSOOIDC extends SSOOIDCClient {
  };
  createAggregatedClient(commands, SSOOIDC);
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/index.js
var init_commands = __esm(() => {
  init_CreateTokenCommand();
  init_CreateTokenWithIAMCommand();
  init_RegisterClientCommand();
  init_StartDeviceAuthorizationCommand();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/index.js
var init_models = __esm(() => {
  init_models_0();
});

// ../node_modules/@aws-sdk/client-sso-oidc/dist-es/index.js
var exports_dist_es4 = {};
__export(exports_dist_es4, {
  __Client: () => Client,
  UnsupportedGrantTypeException: () => UnsupportedGrantTypeException,
  UnauthorizedClientException: () => UnauthorizedClientException,
  StartDeviceAuthorizationRequestFilterSensitiveLog: () => StartDeviceAuthorizationRequestFilterSensitiveLog,
  StartDeviceAuthorizationCommand: () => StartDeviceAuthorizationCommand,
  SlowDownException: () => SlowDownException,
  SSOOIDCServiceException: () => SSOOIDCServiceException,
  SSOOIDCClient: () => SSOOIDCClient,
  SSOOIDC: () => SSOOIDC,
  RegisterClientResponseFilterSensitiveLog: () => RegisterClientResponseFilterSensitiveLog,
  RegisterClientCommand: () => RegisterClientCommand,
  InvalidScopeException: () => InvalidScopeException,
  InvalidRequestRegionException: () => InvalidRequestRegionException,
  InvalidRequestException: () => InvalidRequestException,
  InvalidRedirectUriException: () => InvalidRedirectUriException,
  InvalidGrantException: () => InvalidGrantException,
  InvalidClientMetadataException: () => InvalidClientMetadataException,
  InvalidClientException: () => InvalidClientException,
  InternalServerException: () => InternalServerException,
  ExpiredTokenException: () => ExpiredTokenException,
  CreateTokenWithIAMResponseFilterSensitiveLog: () => CreateTokenWithIAMResponseFilterSensitiveLog,
  CreateTokenWithIAMRequestFilterSensitiveLog: () => CreateTokenWithIAMRequestFilterSensitiveLog,
  CreateTokenWithIAMCommand: () => CreateTokenWithIAMCommand,
  CreateTokenResponseFilterSensitiveLog: () => CreateTokenResponseFilterSensitiveLog,
  CreateTokenRequestFilterSensitiveLog: () => CreateTokenRequestFilterSensitiveLog,
  CreateTokenCommand: () => CreateTokenCommand,
  AuthorizationPendingException: () => AuthorizationPendingException,
  AccessDeniedException: () => AccessDeniedException,
  $Command: () => Command
});
var init_dist_es37 = __esm(() => {
  init_SSOOIDCClient();
  init_SSOOIDC();
  init_commands();
  init_models();
  init_SSOOIDCServiceException();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash, getSsoOidcClient = async (ssoRegion) => {
  const { SSOOIDCClient: SSOOIDCClient3 } = await Promise.resolve().then(() => (init_dist_es37(), exports_dist_es4));
  if (ssoOidcClientsHash[ssoRegion]) {
    return ssoOidcClientsHash[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient3({ region: ssoRegion });
  ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
};
var init_getSsoOidcClient = __esm(() => {
  ssoOidcClientsHash = {};
});

// ../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken = async (ssoToken, ssoRegion) => {
  const { CreateTokenCommand: CreateTokenCommand3 } = await Promise.resolve().then(() => (init_dist_es37(), exports_dist_es4));
  const ssoOidcClient = await getSsoOidcClient(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand3({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};
var init_getNewSsoOidcToken = __esm(() => {
  init_getSsoOidcClient();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenExpiry = __esm(() => {
  init_dist_es13();
  init_constants5();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey = (key, value3, forRefresh = false) => {
  if (typeof value3 === "undefined") {
    throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenKey = __esm(() => {
  init_dist_es13();
  init_constants5();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
import { promises as fsPromises3 } from "fs";
var writeFile, writeSSOTokenToFile = (id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile(tokenFilepath, tokenString);
};
var init_writeSSOTokenToFile = __esm(() => {
  init_dist_es14();
  ({ writeFile } = fsPromises3);
});

// ../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime, fromSso = (init3 = {}) => async () => {
  init3.logger?.debug("@aws-sdk/token-providers - fromSso");
  const profiles = await parseKnownFiles(init3);
  const profileName = getProfileName(init3);
  const profile2 = profiles[profileName];
  if (!profile2) {
    throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile2["sso_session"]) {
    throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile2["sso_session"];
  const ssoSessions = await loadSsoSessionData(init3);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile(ssoSessionName);
  } catch (e2) {
    throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
  }
  validateTokenKey("accessToken", ssoToken.accessToken);
  validateTokenKey("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
  validateTokenKey("clientId", ssoToken.clientId, true);
  validateTokenKey("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);
    validateTokenKey("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
    try {
      await writeSSOTokenToFile(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error5) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error5) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
};
var init_fromSso = __esm(() => {
  init_dist_es13();
  init_dist_es14();
  init_constants5();
  init_getNewSsoOidcToken();
  init_validateTokenExpiry();
  init_validateTokenKey();
  init_writeSSOTokenToFile();
  lastRefreshAttemptTime = new Date(0);
});

// ../node_modules/@aws-sdk/token-providers/dist-es/fromStatic.js
var init_fromStatic2 = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/nodeProvider.js
var init_nodeProvider = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@aws-sdk/token-providers/dist-es/index.js
var init_dist_es38 = __esm(() => {
  init_fromSso();
  init_fromStatic2();
  init_nodeProvider();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption3(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "awsssoportal",
      region: authParameters.region
    },
    propertiesExtractor: (config6, context8) => ({
      signingProperties: {
        config: config6,
        context: context8
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_core65, defaultSSOHttpAuthSchemeParametersProvider = async (config6, context8, input) => {
  return {
    operation: getSmithyContext(context8).operation,
    region: await normalizeProvider2(config6.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultSSOHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "GetRoleCredentials": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ListAccountRoles": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ListAccounts": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "Logout": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
    }
  }
  return options;
}, resolveHttpAuthSchemeConfig3 = (config6) => {
  const config_0 = import_core65.resolveAwsSdkSigV4Config(config6);
  return {
    ...config_0
  };
};
var init_httpAuthSchemeProvider2 = __esm(() => {
  import_core65 = __toESM(require_dist_cjs20(), 1);
  init_dist_es10();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
}, commonParams3;
var init_EndpointParameters2 = __esm(() => {
  commonParams3 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// ../node_modules/@aws-sdk/client-sso/package.json
var package_default3;
var init_package2 = __esm(() => {
  package_default3 = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.675.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.667.0",
      "@aws-sdk/middleware-host-header": "3.667.0",
      "@aws-sdk/middleware-logger": "3.667.0",
      "@aws-sdk/middleware-recursion-detection": "3.667.0",
      "@aws-sdk/middleware-user-agent": "3.669.0",
      "@aws-sdk/region-config-resolver": "3.667.0",
      "@aws-sdk/types": "3.667.0",
      "@aws-sdk/util-endpoints": "3.667.0",
      "@aws-sdk/util-user-agent-browser": "3.675.0",
      "@aws-sdk/util-user-agent-node": "3.669.0",
      "@smithy/config-resolver": "^3.0.9",
      "@smithy/core": "^2.4.8",
      "@smithy/fetch-http-handler": "^3.2.9",
      "@smithy/hash-node": "^3.0.7",
      "@smithy/invalid-dependency": "^3.0.7",
      "@smithy/middleware-content-length": "^3.0.9",
      "@smithy/middleware-endpoint": "^3.1.4",
      "@smithy/middleware-retry": "^3.0.23",
      "@smithy/middleware-serde": "^3.0.7",
      "@smithy/middleware-stack": "^3.0.7",
      "@smithy/node-config-provider": "^3.1.8",
      "@smithy/node-http-handler": "^3.2.4",
      "@smithy/protocol-http": "^4.1.4",
      "@smithy/smithy-client": "^3.4.0",
      "@smithy/types": "^3.5.0",
      "@smithy/url-parser": "^3.0.7",
      "@smithy/util-base64": "^3.0.0",
      "@smithy/util-body-length-browser": "^3.0.0",
      "@smithy/util-body-length-node": "^3.0.0",
      "@smithy/util-defaults-mode-browser": "^3.0.23",
      "@smithy/util-defaults-mode-node": "^3.0.23",
      "@smithy/util-endpoints": "^2.1.3",
      "@smithy/util-middleware": "^3.0.7",
      "@smithy/util-retry": "^3.0.7",
      "@smithy/util-utf8": "^3.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node16": "16.1.3",
      "@types/node": "^16.18.96",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=16.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var u5 = "required", v8 = "fn", w5 = "argv", x6 = "ref", a3 = true, b6 = "isSet", c5 = "booleanEquals", d6 = "error", e2 = "endpoint", f6 = "tree", g5 = "PartitionResult", h6 = "getAttr", i5, j6, k6, l3, m6, n3, o3, p6, q7, r3, s4, t5, _data2, ruleSet2;
var init_ruleset2 = __esm(() => {
  i5 = { [u5]: false, type: "String" };
  j6 = { [u5]: true, default: false, type: "Boolean" };
  k6 = { [x6]: "Endpoint" };
  l3 = { [v8]: c5, [w5]: [{ [x6]: "UseFIPS" }, true] };
  m6 = { [v8]: c5, [w5]: [{ [x6]: "UseDualStack" }, true] };
  n3 = {};
  o3 = { [v8]: h6, [w5]: [{ [x6]: g5 }, "supportsFIPS"] };
  p6 = { [x6]: g5 };
  q7 = { [v8]: c5, [w5]: [true, { [v8]: h6, [w5]: [p6, "supportsDualStack"] }] };
  r3 = [l3];
  s4 = [m6];
  t5 = [{ [x6]: "Region" }];
  _data2 = { version: "1.0", parameters: { Region: i5, UseDualStack: j6, UseFIPS: j6, Endpoint: i5 }, rules: [{ conditions: [{ [v8]: b6, [w5]: [k6] }], rules: [{ conditions: r3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d6 }, { conditions: s4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d6 }, { endpoint: { url: k6, properties: n3, headers: n3 }, type: e2 }], type: f6 }, { conditions: [{ [v8]: b6, [w5]: t5 }], rules: [{ conditions: [{ [v8]: "aws.partition", [w5]: t5, assign: g5 }], rules: [{ conditions: [l3, m6], rules: [{ conditions: [{ [v8]: c5, [w5]: [a3, o3] }, q7], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e2 }], type: f6 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d6 }], type: f6 }, { conditions: r3, rules: [{ conditions: [{ [v8]: c5, [w5]: [o3, a3] }], rules: [{ conditions: [{ [v8]: "stringEquals", [w5]: [{ [v8]: h6, [w5]: [p6, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n3, headers: n3 }, type: e2 }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e2 }], type: f6 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d6 }], type: f6 }, { conditions: s4, rules: [{ conditions: [q7], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e2 }], type: f6 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d6 }], type: f6 }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e2 }], type: f6 }], type: f6 }, { error: "Invalid Configuration: Missing Region", type: d6 }] };
  ruleSet2 = _data2;
});

// ../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var cache2, defaultEndpointResolver2 = (endpointParams, context8 = {}) => {
  return cache2.get(endpointParams, () => resolveEndpoint(ruleSet2, {
    endpointParams,
    logger: context8.logger
  }));
};
var init_endpointResolver2 = __esm(() => {
  init_dist_es7();
  init_dist_es6();
  init_ruleset2();
  cache2 = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var import_core66, import_core67, getRuntimeConfig3 = (config6) => {
  return {
    apiVersion: "2019-06-10",
    base64Decoder: config6?.base64Decoder ?? fromBase642,
    base64Encoder: config6?.base64Encoder ?? toBase642,
    disableHostPrefix: config6?.disableHostPrefix ?? false,
    endpointProvider: config6?.endpointProvider ?? defaultEndpointResolver2,
    extensions: config6?.extensions ?? [],
    httpAuthSchemeProvider: config6?.httpAuthSchemeProvider ?? defaultSSOHttpAuthSchemeProvider,
    httpAuthSchemes: config6?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core66.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core67.NoAuthSigner
      }
    ],
    logger: config6?.logger ?? new NoOpLogger,
    serviceId: config6?.serviceId ?? "SSO",
    urlParser: config6?.urlParser ?? parseUrl3,
    utf8Decoder: config6?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config6?.utf8Encoder ?? toUtf8
  };
};
var init_runtimeConfig_shared2 = __esm(() => {
  import_core66 = __toESM(require_dist_cjs20(), 1);
  import_core67 = __toESM(require_dist_cjs15(), 1);
  init_dist_es21();
  init_dist_es16();
  init_dist_es34();
  init_dist_es31();
  init_httpAuthSchemeProvider2();
  init_endpointResolver2();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var import_core68, getRuntimeConfig4 = (config6) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config6);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig3(config6);
  import_core68.emitWarningIfUnsupportedVersion(process.version);
  return {
    ...clientSharedValues,
    ...config6,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config6?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config6?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default3.version }),
    maxAttempts: config6?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config6?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: NodeHttpHandler.create(config6?.requestHandler ?? defaultConfigProvider),
    retryMode: config6?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config6?.sha256 ?? Hash3.bind(null, "sha256"),
    streamCollector: config6?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config6?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config6?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    userAgentAppId: config6?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS)
  };
};
var init_runtimeConfig2 = __esm(() => {
  init_package2();
  import_core68 = __toESM(require_dist_cjs20(), 1);
  init_dist_es29();
  init_dist_es11();
  init_dist_es32();
  init_dist_es22();
  init_dist_es15();
  init_dist_es27();
  init_dist_es33();
  init_dist_es19();
  init_runtimeConfig_shared2();
  init_dist_es21();
  init_dist_es35();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig2 = (config6) => {
  return {
    httpAuthSchemes: config6.httpAuthSchemes(),
    httpAuthSchemeProvider: config6.httpAuthSchemeProvider(),
    credentials: config6.credentials()
  };
};

// ../node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js
var asPartial2 = (t4) => t4, resolveRuntimeExtensions2 = (runtimeConfig, extensions5) => {
  const extensionConfiguration = {
    ...asPartial2(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getHttpAuthExtensionConfiguration2(runtimeConfig))
  };
  extensions5.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig2(extensionConfiguration)
  };
};
var init_runtimeExtensions2 = __esm(() => {
  init_dist_es36();
  init_dist_es2();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var import_core69, SSOClient;
var init_SSOClient = __esm(() => {
  init_dist_es3();
  init_dist_es4();
  init_dist_es5();
  init_dist_es8();
  init_dist_es11();
  import_core69 = __toESM(require_dist_cjs15(), 1);
  init_dist_es12();
  init_dist_es17();
  init_dist_es22();
  init_dist_es21();
  init_httpAuthSchemeProvider2();
  init_EndpointParameters2();
  init_runtimeConfig2();
  init_runtimeExtensions2();
  SSOClient = class SSOClient extends Client {
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig4(configuration || {});
      const _config_1 = resolveClientEndpointParameters3(_config_0);
      const _config_2 = resolveUserAgentConfig(_config_1);
      const _config_3 = resolveRetryConfig(_config_2);
      const _config_4 = resolveRegionConfig(_config_3);
      const _config_5 = resolveHostHeaderConfig(_config_4);
      const _config_6 = resolveEndpointConfig(_config_5);
      const _config_7 = resolveHttpAuthSchemeConfig3(_config_6);
      const _config_8 = resolveRuntimeExtensions2(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use(getUserAgentPlugin(this.config));
      this.middlewareStack.use(getRetryPlugin(this.config));
      this.middlewareStack.use(getContentLengthPlugin(this.config));
      this.middlewareStack.use(getHostHeaderPlugin(this.config));
      this.middlewareStack.use(getLoggerPlugin(this.config));
      this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core69.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultSSOHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config6) => new import_core69.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config6.credentials
        })
      }));
      this.middlewareStack.use(import_core69.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException;
var init_SSOServiceException = __esm(() => {
  init_dist_es21();
  SSOServiceException = class SSOServiceException extends ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException2, ResourceNotFoundException, TooManyRequestsException, UnauthorizedException, GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), RoleCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
}), GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
}), ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), ListAccountsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), LogoutRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
});
var init_models_02 = __esm(() => {
  init_dist_es21();
  init_SSOServiceException();
  InvalidRequestException2 = class InvalidRequestException2 extends SSOServiceException {
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRequestException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidRequestException2.prototype);
    }
  };
  ResourceNotFoundException = class ResourceNotFoundException extends SSOServiceException {
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      this.name = "ResourceNotFoundException";
      this.$fault = "client";
      Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
  };
  TooManyRequestsException = class TooManyRequestsException extends SSOServiceException {
    constructor(opts) {
      super({
        name: "TooManyRequestsException",
        $fault: "client",
        ...opts
      });
      this.name = "TooManyRequestsException";
      this.$fault = "client";
      Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
  };
  UnauthorizedException = class UnauthorizedException extends SSOServiceException {
    constructor(opts) {
      super({
        name: "UnauthorizedException",
        $fault: "client",
        ...opts
      });
      this.name = "UnauthorizedException";
      this.$fault = "client";
      Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var import_core70, import_core71, se_GetRoleCredentialsCommand = async (input, context8) => {
  const b4 = import_core71.requestBuilder(input, context8);
  const headers = map5({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b4.bp("/federation/credentials");
  const query = map5({
    [_rn]: [, expectNonNull(input[_rN], `roleName`)],
    [_ai2]: [, expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b4.m("GET").h(headers).q(query).b(body);
  return b4.build();
}, se_ListAccountRolesCommand = async (input, context8) => {
  const b4 = import_core71.requestBuilder(input, context8);
  const headers = map5({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b4.bp("/assignment/roles");
  const query = map5({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()],
    [_ai2]: [, expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b4.m("GET").h(headers).q(query).b(body);
  return b4.build();
}, se_ListAccountsCommand = async (input, context8) => {
  const b4 = import_core71.requestBuilder(input, context8);
  const headers = map5({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b4.bp("/assignment/accounts");
  const query = map5({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()]
  });
  let body;
  b4.m("GET").h(headers).q(query).b(body);
  return b4.build();
}, se_LogoutCommand = async (input, context8) => {
  const b4 = import_core71.requestBuilder(input, context8);
  const headers = map5({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b4.bp("/logout");
  let body;
  b4.m("POST").h(headers).b(body);
  return b4.build();
}, de_GetRoleCredentialsCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core70.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    roleCredentials: _json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountRolesCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core70.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    nextToken: expectString,
    roleList: _json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountsCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core70.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    accountList: _json,
    nextToken: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_LogoutCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata3(output)
  });
  await import_protocols.collectBody(output.body, context8);
  return contents;
}, de_CommandError2 = async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await import_core70.parseJsonErrorBody(output.body, context8)
  };
  const errorCode = import_core70.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes2(parsedOutput, context8);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context8);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context8);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
}, throwDefaultError3, de_InvalidRequestExceptionRes2 = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException2({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_ResourceNotFoundExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_TooManyRequestsExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_UnauthorizedExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, deserializeMetadata3 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), _aI = "accountId", _aT = "accessToken", _ai2 = "account_id", _mR = "maxResults", _mr = "max_result", _nT = "nextToken", _nt = "next_token", _rN = "roleName", _rn = "role_name", _xasbt = "x-amz-sso_bearer_token";
var init_Aws_restJson12 = __esm(() => {
  import_core70 = __toESM(require_dist_cjs20(), 1);
  import_core71 = __toESM(require_dist_cjs15(), 1);
  init_dist_es21();
  init_models_02();
  init_SSOServiceException();
  throwDefaultError3 = withBaseException(SSOServiceException);
});

// ../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var import_middleware_serde6, GetRoleCredentialsCommand;
var init_GetRoleCredentialsCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde6 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson12();
  GetRoleCredentialsCommand = class GetRoleCredentialsCommand extends Command.classBuilder().ep(commonParams3).m(function(Command2, cs, config6, o4) {
    return [
      import_middleware_serde6.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog).ser(se_GetRoleCredentialsCommand).de(de_GetRoleCredentialsCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountRolesCommand.js
var import_middleware_serde7, ListAccountRolesCommand;
var init_ListAccountRolesCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde7 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson12();
  ListAccountRolesCommand = class ListAccountRolesCommand extends Command.classBuilder().ep(commonParams3).m(function(Command2, cs, config6, o4) {
    return [
      import_middleware_serde7.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(ListAccountRolesRequestFilterSensitiveLog, undefined).ser(se_ListAccountRolesCommand).de(de_ListAccountRolesCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountsCommand.js
var import_middleware_serde8, ListAccountsCommand;
var init_ListAccountsCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde8 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson12();
  ListAccountsCommand = class ListAccountsCommand extends Command.classBuilder().ep(commonParams3).m(function(Command2, cs, config6, o4) {
    return [
      import_middleware_serde8.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(ListAccountsRequestFilterSensitiveLog, undefined).ser(se_ListAccountsCommand).de(de_ListAccountsCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/commands/LogoutCommand.js
var import_middleware_serde9, LogoutCommand;
var init_LogoutCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde9 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson12();
  LogoutCommand = class LogoutCommand extends Command.classBuilder().ep(commonParams3).m(function(Command2, cs, config6, o4) {
    return [
      import_middleware_serde9.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(LogoutRequestFilterSensitiveLog, undefined).ser(se_LogoutCommand).de(de_LogoutCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sso/dist-es/SSO.js
var commands3, SSO;
var init_SSO = __esm(() => {
  init_dist_es21();
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
  init_SSOClient();
  commands3 = {
    GetRoleCredentialsCommand,
    ListAccountRolesCommand,
    ListAccountsCommand,
    LogoutCommand
  };
  SSO = class SSO extends SSOClient {
  };
  createAggregatedClient(commands3, SSO);
});

// ../node_modules/@aws-sdk/client-sso/dist-es/commands/index.js
var init_commands2 = __esm(() => {
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/pagination/Interfaces.js
var init_Interfaces = () => {
};

// ../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountRolesPaginator.js
var import_core72, paginateListAccountRoles;
var init_ListAccountRolesPaginator = __esm(() => {
  import_core72 = __toESM(require_dist_cjs15(), 1);
  init_ListAccountRolesCommand();
  init_SSOClient();
  paginateListAccountRoles = import_core72.createPaginator(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
});

// ../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountsPaginator.js
var import_core73, paginateListAccounts;
var init_ListAccountsPaginator = __esm(() => {
  import_core73 = __toESM(require_dist_cjs15(), 1);
  init_ListAccountsCommand();
  init_SSOClient();
  paginateListAccounts = import_core73.createPaginator(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
});

// ../node_modules/@aws-sdk/client-sso/dist-es/pagination/index.js
var init_pagination2 = __esm(() => {
  init_Interfaces();
  init_ListAccountRolesPaginator();
  init_ListAccountsPaginator();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/models/index.js
var init_models2 = __esm(() => {
  init_models_02();
});

// ../node_modules/@aws-sdk/client-sso/dist-es/index.js
var init_dist_es39 = __esm(() => {
  init_SSOClient();
  init_SSO();
  init_commands2();
  init_pagination2();
  init_models2();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/loadSso.js
var exports_loadSso = {};
__export(exports_loadSso, {
  SSOClient: () => SSOClient,
  GetRoleCredentialsCommand: () => GetRoleCredentialsCommand
});
var init_loadSso = __esm(() => {
  init_dist_es39();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var import_client5, SHOULD_FAIL_CREDENTIAL_CHAIN = false, resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, profile: profile2, logger: logger4 }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso({ profile: profile2 })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e3) {
      throw new CredentialsProviderError(e3.message, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger: logger4
      });
    }
  } else {
    try {
      token = await getSSOTokenFromFile(ssoStartUrl);
    } catch (e3) {
      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger: logger4
      });
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger4
    });
  }
  const { accessToken } = token;
  const { SSOClient: SSOClient3, GetRoleCredentialsCommand: GetRoleCredentialsCommand3 } = await Promise.resolve().then(() => (init_loadSso(), exports_loadSso));
  const sso = ssoClient || new SSOClient3(Object.assign({}, clientConfig ?? {}, {
    region: clientConfig?.region ?? ssoRegion
  }));
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand3({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e3) {
    throw new CredentialsProviderError(e3, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger4
    });
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError("SSO returns an invalid temporary credential.", {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger4
    });
  }
  const credentials = {
    accessKeyId,
    secretAccessKey,
    sessionToken,
    expiration: new Date(expiration),
    ...credentialScope && { credentialScope },
    ...accountId && { accountId }
  };
  if (ssoSession) {
    import_client5.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
  } else {
    import_client5.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
  }
  return credentials;
};
var init_resolveSSOCredentials = __esm(() => {
  import_client5 = __toESM(require_client(), 1);
  init_dist_es38();
  init_dist_es13();
  init_dist_es14();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile = (profile2, logger4) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile2;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile2).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger: logger4 });
  }
  return profile2;
};
var init_validateSsoProfile = __esm(() => {
  init_dist_es13();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO = (init3 = {}) => async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init3;
  const { ssoClient } = init3;
  const profileName = getProfileName(init3);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init3);
    const profile2 = profiles[profileName];
    if (!profile2) {
      throw new CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init3.logger });
    }
    if (!isSsoProfile(profile2)) {
      throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
        logger: init3.logger
      });
    }
    if (profile2?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init3);
      const session = ssoSessions[profile2.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile2.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
          tryNextLink: false,
          logger: init3.logger
        });
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
          tryNextLink: false,
          logger: init3.logger
        });
      }
      profile2.sso_region = session.sso_region;
      profile2.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile2, init3.logger);
    return resolveSSOCredentials({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      clientConfig: init3.clientConfig,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " + '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: false, logger: init3.logger });
  } else {
    return resolveSSOCredentials({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      clientConfig: init3.clientConfig,
      profile: profileName
    });
  }
};
var init_fromSSO = __esm(() => {
  init_dist_es13();
  init_dist_es14();
  init_resolveSSOCredentials();
  init_validateSsoProfile();
});

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/types.js
var init_types9 = () => {
};

// ../node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js
var exports_dist_es5 = {};
__export(exports_dist_es5, {
  validateSsoProfile: () => validateSsoProfile,
  isSsoProfile: () => isSsoProfile,
  fromSSO: () => fromSSO
});
var init_dist_es40 = __esm(() => {
  init_fromSSO();
  init_types9();
  init_validateSsoProfile();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var import_client6, resolveCredentialSource = (credentialSource, profileName, logger4) => {
  const sourceProvidersMap = {
    EcsContainer: async (options) => {
      const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es28(), exports_dist_es3));
      const { fromContainerMetadata: fromContainerMetadata3 } = await Promise.resolve().then(() => (init_dist_es24(), exports_dist_es2));
      logger4?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
      return async () => chain(fromHttp2(options ?? {}), fromContainerMetadata3(options))().then(setNamedProvider);
    },
    Ec2InstanceMetadata: async (options) => {
      logger4?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
      const { fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es24(), exports_dist_es2));
      return async () => fromInstanceMetadata3(options)().then(setNamedProvider);
    },
    Environment: async (options) => {
      logger4?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
      const { fromEnv: fromEnv4 } = await Promise.resolve().then(() => (init_dist_es23(), exports_dist_es));
      return async () => fromEnv4(options)().then(setNamedProvider);
    }
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource];
  } else {
    throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: logger4 });
  }
}, setNamedProvider = (creds) => import_client6.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
var init_resolveCredentialSource = __esm(() => {
  import_client6 = __toESM(require_client(), 1);
  init_dist_es13();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption4(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sts",
      region: authParameters.region
    },
    propertiesExtractor: (config6, context8) => ({
      signingProperties: {
        config: config6,
        context: context8
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption3(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_core74, defaultSTSHttpAuthSchemeParametersProvider = async (config6, context8, input) => {
  return {
    operation: getSmithyContext(context8).operation,
    region: await normalizeProvider2(config6.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultSTSHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "AssumeRoleWithSAML": {
      options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
      break;
    }
    case "AssumeRoleWithWebIdentity": {
      options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption4(authParameters));
    }
  }
  return options;
}, resolveStsAuthConfig = (input) => ({
  ...input,
  stsClientCtor: STSClient
}), resolveHttpAuthSchemeConfig4 = (config6) => {
  const config_0 = resolveStsAuthConfig(config6);
  const config_1 = import_core74.resolveAwsSdkSigV4Config(config_0);
  return {
    ...config_1
  };
};
var init_httpAuthSchemeProvider3 = __esm(() => {
  import_core74 = __toESM(require_dist_cjs20(), 1);
  init_dist_es10();
  init_STSClient();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters4 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
}, commonParams4;
var init_EndpointParameters3 = __esm(() => {
  commonParams4 = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// ../node_modules/@aws-sdk/client-sts/package.json
var package_default4;
var init_package3 = __esm(() => {
  package_default4 = {
    name: "@aws-sdk/client-sts",
    description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
    version: "3.675.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sts",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "rimraf ./dist-types tsconfig.types.tsbuildinfo && tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
      test: "yarn test:unit",
      "test:unit": "jest"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/client-sso-oidc": "3.675.0",
      "@aws-sdk/core": "3.667.0",
      "@aws-sdk/credential-provider-node": "3.675.0",
      "@aws-sdk/middleware-host-header": "3.667.0",
      "@aws-sdk/middleware-logger": "3.667.0",
      "@aws-sdk/middleware-recursion-detection": "3.667.0",
      "@aws-sdk/middleware-user-agent": "3.669.0",
      "@aws-sdk/region-config-resolver": "3.667.0",
      "@aws-sdk/types": "3.667.0",
      "@aws-sdk/util-endpoints": "3.667.0",
      "@aws-sdk/util-user-agent-browser": "3.675.0",
      "@aws-sdk/util-user-agent-node": "3.669.0",
      "@smithy/config-resolver": "^3.0.9",
      "@smithy/core": "^2.4.8",
      "@smithy/fetch-http-handler": "^3.2.9",
      "@smithy/hash-node": "^3.0.7",
      "@smithy/invalid-dependency": "^3.0.7",
      "@smithy/middleware-content-length": "^3.0.9",
      "@smithy/middleware-endpoint": "^3.1.4",
      "@smithy/middleware-retry": "^3.0.23",
      "@smithy/middleware-serde": "^3.0.7",
      "@smithy/middleware-stack": "^3.0.7",
      "@smithy/node-config-provider": "^3.1.8",
      "@smithy/node-http-handler": "^3.2.4",
      "@smithy/protocol-http": "^4.1.4",
      "@smithy/smithy-client": "^3.4.0",
      "@smithy/types": "^3.5.0",
      "@smithy/url-parser": "^3.0.7",
      "@smithy/util-base64": "^3.0.0",
      "@smithy/util-body-length-browser": "^3.0.0",
      "@smithy/util-body-length-node": "^3.0.0",
      "@smithy/util-defaults-mode-browser": "^3.0.23",
      "@smithy/util-defaults-mode-node": "^3.0.23",
      "@smithy/util-endpoints": "^2.1.3",
      "@smithy/util-middleware": "^3.0.7",
      "@smithy/util-retry": "^3.0.7",
      "@smithy/util-utf8": "^3.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node16": "16.1.3",
      "@types/node": "^16.18.96",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=16.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sts"
    }
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var F3 = "required", G4 = "type", H = "fn", I4 = "argv", J4 = "ref", a5 = false, b7 = true, c6 = "booleanEquals", d7 = "stringEquals", e3 = "sigv4", f7 = "sts", g6 = "us-east-1", h7 = "endpoint", i6 = "https://sts.{Region}.{PartitionResult#dnsSuffix}", j7 = "tree", k7 = "error", l5 = "getAttr", m7, n4, o4, p7, q8, r5, s6, t6, u6, v9, w6, x7, y3, z4, A4, B, C3, D4, E4, _data3, ruleSet3;
var init_ruleset3 = __esm(() => {
  m7 = { [F3]: false, [G4]: "String" };
  n4 = { [F3]: true, default: false, [G4]: "Boolean" };
  o4 = { [J4]: "Endpoint" };
  p7 = { [H]: "isSet", [I4]: [{ [J4]: "Region" }] };
  q8 = { [J4]: "Region" };
  r5 = { [H]: "aws.partition", [I4]: [q8], assign: "PartitionResult" };
  s6 = { [J4]: "UseFIPS" };
  t6 = { [J4]: "UseDualStack" };
  u6 = { url: "https://sts.amazonaws.com", properties: { authSchemes: [{ name: e3, signingName: f7, signingRegion: g6 }] }, headers: {} };
  v9 = {};
  w6 = { conditions: [{ [H]: d7, [I4]: [q8, "aws-global"] }], [h7]: u6, [G4]: h7 };
  x7 = { [H]: c6, [I4]: [s6, true] };
  y3 = { [H]: c6, [I4]: [t6, true] };
  z4 = { [H]: l5, [I4]: [{ [J4]: "PartitionResult" }, "supportsFIPS"] };
  A4 = { [J4]: "PartitionResult" };
  B = { [H]: c6, [I4]: [true, { [H]: l5, [I4]: [A4, "supportsDualStack"] }] };
  C3 = [{ [H]: "isSet", [I4]: [o4] }];
  D4 = [x7];
  E4 = [y3];
  _data3 = { version: "1.0", parameters: { Region: m7, UseDualStack: n4, UseFIPS: n4, Endpoint: m7, UseGlobalEndpoint: n4 }, rules: [{ conditions: [{ [H]: c6, [I4]: [{ [J4]: "UseGlobalEndpoint" }, b7] }, { [H]: "not", [I4]: C3 }, p7, r5, { [H]: c6, [I4]: [s6, a5] }, { [H]: c6, [I4]: [t6, a5] }], rules: [{ conditions: [{ [H]: d7, [I4]: [q8, "ap-northeast-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "ap-south-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "ap-southeast-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "ap-southeast-2"] }], endpoint: u6, [G4]: h7 }, w6, { conditions: [{ [H]: d7, [I4]: [q8, "ca-central-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "eu-central-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "eu-north-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "eu-west-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "eu-west-2"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "eu-west-3"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "sa-east-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, g6] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "us-east-2"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "us-west-1"] }], endpoint: u6, [G4]: h7 }, { conditions: [{ [H]: d7, [I4]: [q8, "us-west-2"] }], endpoint: u6, [G4]: h7 }, { endpoint: { url: i6, properties: { authSchemes: [{ name: e3, signingName: f7, signingRegion: "{Region}" }] }, headers: v9 }, [G4]: h7 }], [G4]: j7 }, { conditions: C3, rules: [{ conditions: D4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G4]: k7 }, { conditions: E4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G4]: k7 }, { endpoint: { url: o4, properties: v9, headers: v9 }, [G4]: h7 }], [G4]: j7 }, { conditions: [p7], rules: [{ conditions: [r5], rules: [{ conditions: [x7, y3], rules: [{ conditions: [{ [H]: c6, [I4]: [b7, z4] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v9, headers: v9 }, [G4]: h7 }], [G4]: j7 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G4]: k7 }], [G4]: j7 }, { conditions: D4, rules: [{ conditions: [{ [H]: c6, [I4]: [z4, b7] }], rules: [{ conditions: [{ [H]: d7, [I4]: [{ [H]: l5, [I4]: [A4, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v9, headers: v9 }, [G4]: h7 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v9, headers: v9 }, [G4]: h7 }], [G4]: j7 }, { error: "FIPS is enabled but this partition does not support FIPS", [G4]: k7 }], [G4]: j7 }, { conditions: E4, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v9, headers: v9 }, [G4]: h7 }], [G4]: j7 }, { error: "DualStack is enabled but this partition does not support DualStack", [G4]: k7 }], [G4]: j7 }, w6, { endpoint: { url: i6, properties: v9, headers: v9 }, [G4]: h7 }], [G4]: j7 }], [G4]: j7 }, { error: "Invalid Configuration: Missing Region", [G4]: k7 }] };
  ruleSet3 = _data3;
});

// ../node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var cache3, defaultEndpointResolver3 = (endpointParams, context8 = {}) => {
  return cache3.get(endpointParams, () => resolveEndpoint(ruleSet3, {
    endpointParams,
    logger: context8.logger
  }));
};
var init_endpointResolver3 = __esm(() => {
  init_dist_es7();
  init_dist_es6();
  init_ruleset3();
  cache3 = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
  });
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var import_core75, import_core76, getRuntimeConfig5 = (config6) => {
  return {
    apiVersion: "2011-06-15",
    base64Decoder: config6?.base64Decoder ?? fromBase642,
    base64Encoder: config6?.base64Encoder ?? toBase642,
    disableHostPrefix: config6?.disableHostPrefix ?? false,
    endpointProvider: config6?.endpointProvider ?? defaultEndpointResolver3,
    extensions: config6?.extensions ?? [],
    httpAuthSchemeProvider: config6?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
    httpAuthSchemes: config6?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core75.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core76.NoAuthSigner
      }
    ],
    logger: config6?.logger ?? new NoOpLogger,
    serviceId: config6?.serviceId ?? "STS",
    urlParser: config6?.urlParser ?? parseUrl3,
    utf8Decoder: config6?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config6?.utf8Encoder ?? toUtf8
  };
};
var init_runtimeConfig_shared3 = __esm(() => {
  import_core75 = __toESM(require_dist_cjs20(), 1);
  import_core76 = __toESM(require_dist_cjs15(), 1);
  init_dist_es21();
  init_dist_es16();
  init_dist_es34();
  init_dist_es31();
  init_httpAuthSchemeProvider3();
  init_endpointResolver3();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var import_core77, import_core78, getRuntimeConfig6 = (config6) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config6);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig5(config6);
  import_core77.emitWarningIfUnsupportedVersion(process.version);
  return {
    ...clientSharedValues,
    ...config6,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config6?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config6?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config6?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default4.version }),
    httpAuthSchemes: config6?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await defaultProvider(idProps?.__config || {})()),
        signer: new import_core77.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core78.NoAuthSigner
      }
    ],
    maxAttempts: config6?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config6?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: NodeHttpHandler.create(config6?.requestHandler ?? defaultConfigProvider),
    retryMode: config6?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config6?.sha256 ?? Hash3.bind(null, "sha256"),
    streamCollector: config6?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config6?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config6?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    userAgentAppId: config6?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS)
  };
};
var init_runtimeConfig3 = __esm(() => {
  init_package3();
  import_core77 = __toESM(require_dist_cjs20(), 1);
  init_dist_es45();
  init_dist_es29();
  init_dist_es11();
  import_core78 = __toESM(require_dist_cjs15(), 1);
  init_dist_es32();
  init_dist_es22();
  init_dist_es15();
  init_dist_es27();
  init_dist_es33();
  init_dist_es19();
  init_runtimeConfig_shared3();
  init_dist_es21();
  init_dist_es35();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration3 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig3 = (config6) => {
  return {
    httpAuthSchemes: config6.httpAuthSchemes(),
    httpAuthSchemeProvider: config6.httpAuthSchemeProvider(),
    credentials: config6.credentials()
  };
};

// ../node_modules/@aws-sdk/client-sts/dist-es/runtimeExtensions.js
var asPartial3 = (t4) => t4, resolveRuntimeExtensions3 = (runtimeConfig, extensions5) => {
  const extensionConfiguration = {
    ...asPartial3(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial3(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial3(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial3(getHttpAuthExtensionConfiguration3(runtimeConfig))
  };
  extensions5.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig3(extensionConfiguration)
  };
};
var init_runtimeExtensions3 = __esm(() => {
  init_dist_es36();
  init_dist_es2();
  init_dist_es21();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var import_core79, STSClient;
var init_STSClient = __esm(() => {
  init_dist_es3();
  init_dist_es4();
  init_dist_es5();
  init_dist_es8();
  init_dist_es11();
  import_core79 = __toESM(require_dist_cjs15(), 1);
  init_dist_es12();
  init_dist_es17();
  init_dist_es22();
  init_dist_es21();
  init_httpAuthSchemeProvider3();
  init_EndpointParameters3();
  init_runtimeConfig3();
  init_runtimeExtensions3();
  STSClient = class STSClient extends Client {
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig6(configuration || {});
      const _config_1 = resolveClientEndpointParameters4(_config_0);
      const _config_2 = resolveUserAgentConfig(_config_1);
      const _config_3 = resolveRetryConfig(_config_2);
      const _config_4 = resolveRegionConfig(_config_3);
      const _config_5 = resolveHostHeaderConfig(_config_4);
      const _config_6 = resolveEndpointConfig(_config_5);
      const _config_7 = resolveHttpAuthSchemeConfig4(_config_6);
      const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use(getUserAgentPlugin(this.config));
      this.middlewareStack.use(getRetryPlugin(this.config));
      this.middlewareStack.use(getContentLengthPlugin(this.config));
      this.middlewareStack.use(getHostHeaderPlugin(this.config));
      this.middlewareStack.use(getLoggerPlugin(this.config));
      this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core79.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config6) => new import_core79.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config6.credentials
        })
      }));
      this.middlewareStack.use(import_core79.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException;
var init_STSServiceException = __esm(() => {
  init_dist_es21();
  STSServiceException = class STSServiceException extends ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, STSServiceException.prototype);
    }
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException2, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, IDPRejectedClaimException, InvalidIdentityTokenException, IDPCommunicationErrorException, InvalidAuthorizationMessageException, CredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING }
}), AssumeRoleResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SAMLAssertion && { SAMLAssertion: SENSITIVE_STRING }
}), AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.WebIdentityToken && { WebIdentityToken: SENSITIVE_STRING }
}), AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
});
var init_models_03 = __esm(() => {
  init_dist_es21();
  init_STSServiceException();
  ExpiredTokenException2 = class ExpiredTokenException2 extends STSServiceException {
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "ExpiredTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, ExpiredTokenException2.prototype);
    }
  };
  MalformedPolicyDocumentException = class MalformedPolicyDocumentException extends STSServiceException {
    constructor(opts) {
      super({
        name: "MalformedPolicyDocumentException",
        $fault: "client",
        ...opts
      });
      this.name = "MalformedPolicyDocumentException";
      this.$fault = "client";
      Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
  };
  PackedPolicyTooLargeException = class PackedPolicyTooLargeException extends STSServiceException {
    constructor(opts) {
      super({
        name: "PackedPolicyTooLargeException",
        $fault: "client",
        ...opts
      });
      this.name = "PackedPolicyTooLargeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
  };
  RegionDisabledException = class RegionDisabledException extends STSServiceException {
    constructor(opts) {
      super({
        name: "RegionDisabledException",
        $fault: "client",
        ...opts
      });
      this.name = "RegionDisabledException";
      this.$fault = "client";
      Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
  };
  IDPRejectedClaimException = class IDPRejectedClaimException extends STSServiceException {
    constructor(opts) {
      super({
        name: "IDPRejectedClaimException",
        $fault: "client",
        ...opts
      });
      this.name = "IDPRejectedClaimException";
      this.$fault = "client";
      Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
  };
  InvalidIdentityTokenException = class InvalidIdentityTokenException extends STSServiceException {
    constructor(opts) {
      super({
        name: "InvalidIdentityTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidIdentityTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
  };
  IDPCommunicationErrorException = class IDPCommunicationErrorException extends STSServiceException {
    constructor(opts) {
      super({
        name: "IDPCommunicationErrorException",
        $fault: "client",
        ...opts
      });
      this.name = "IDPCommunicationErrorException";
      this.$fault = "client";
      Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
  };
  InvalidAuthorizationMessageException = class InvalidAuthorizationMessageException extends STSServiceException {
    constructor(opts) {
      super({
        name: "InvalidAuthorizationMessageException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidAuthorizationMessageException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_core80, se_AssumeRoleCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_AssumeRoleRequest(input, context8),
    [_A]: _AR,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_AssumeRoleWithSAMLCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_AssumeRoleWithSAMLRequest(input, context8),
    [_A]: _ARWSAML,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_AssumeRoleWithWebIdentityCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_AssumeRoleWithWebIdentityRequest(input, context8),
    [_A]: _ARWWI,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_DecodeAuthorizationMessageCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DecodeAuthorizationMessageRequest(input, context8),
    [_A]: _DAM,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_GetAccessKeyInfoCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetAccessKeyInfoRequest(input, context8),
    [_A]: _GAKI,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_GetCallerIdentityCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetCallerIdentityRequest(input, context8),
    [_A]: _GCI,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_GetFederationTokenCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetFederationTokenRequest(input, context8),
    [_A]: _GFT,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, se_GetSessionTokenCommand = async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetSessionTokenRequest(input, context8),
    [_A]: _GST,
    [_V]: _3
  });
  return buildHttpRpcRequest(context8, headers, "/", undefined, body);
}, de_AssumeRoleCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleResponse(data.AssumeRoleResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_AssumeRoleWithSAMLCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_AssumeRoleWithWebIdentityCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_DecodeAuthorizationMessageCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_GetAccessKeyInfoCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_GetCallerIdentityCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_GetFederationTokenCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_GetSessionTokenCommand = async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context8);
  }
  const data = await import_core80.parseXmlBody(output.body, context8);
  let contents = {};
  contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context8);
  const response2 = {
    $metadata: deserializeMetadata4(output),
    ...contents
  };
  return response2;
}, de_CommandError3 = async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await import_core80.parseXmlErrorBody(output.body, context8)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes2(parsedOutput, context8);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context8);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context8);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes(parsedOutput, context8);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context8);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context8);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context8);
    case "InvalidAuthorizationMessageException":
    case "com.amazonaws.sts#InvalidAuthorizationMessageException":
      throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, de_ExpiredTokenExceptionRes2 = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_ExpiredTokenException(body.Error, context8);
  const exception = new ExpiredTokenException2({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPCommunicationErrorException(body.Error, context8);
  const exception = new IDPCommunicationErrorException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_IDPRejectedClaimExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPRejectedClaimException(body.Error, context8);
  const exception = new IDPRejectedClaimException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidAuthorizationMessageException(body.Error, context8);
  const exception = new InvalidAuthorizationMessageException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidIdentityTokenException(body.Error, context8);
  const exception = new InvalidIdentityTokenException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_MalformedPolicyDocumentException(body.Error, context8);
  const exception = new MalformedPolicyDocumentException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_PackedPolicyTooLargeException(body.Error, context8);
  const exception = new PackedPolicyTooLargeException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, de_RegionDisabledExceptionRes = async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_RegionDisabledException(body.Error, context8);
  const exception = new RegionDisabledException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, se_AssumeRoleRequest = (input, context8) => {
  const entries = {};
  if (input[_RA] != null) {
    entries[_RA] = input[_RA];
  }
  if (input[_RSN] != null) {
    entries[_RSN] = input[_RSN];
  }
  if (input[_PA] != null) {
    const memberEntries = se_policyDescriptorListType(input[_PA], context8);
    if (input[_PA]?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_DS] != null) {
    entries[_DS] = input[_DS];
  }
  if (input[_T] != null) {
    const memberEntries = se_tagListType(input[_T], context8);
    if (input[_T]?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_TTK] != null) {
    const memberEntries = se_tagKeyListType(input[_TTK], context8);
    if (input[_TTK]?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_EI] != null) {
    entries[_EI] = input[_EI];
  }
  if (input[_SN] != null) {
    entries[_SN] = input[_SN];
  }
  if (input[_TC] != null) {
    entries[_TC] = input[_TC];
  }
  if (input[_SI] != null) {
    entries[_SI] = input[_SI];
  }
  if (input[_PC] != null) {
    const memberEntries = se_ProvidedContextsListType(input[_PC], context8);
    if (input[_PC]?.length === 0) {
      entries.ProvidedContexts = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `ProvidedContexts.${key}`;
      entries[loc] = value3;
    });
  }
  return entries;
}, se_AssumeRoleWithSAMLRequest = (input, context8) => {
  const entries = {};
  if (input[_RA] != null) {
    entries[_RA] = input[_RA];
  }
  if (input[_PAr] != null) {
    entries[_PAr] = input[_PAr];
  }
  if (input[_SAMLA] != null) {
    entries[_SAMLA] = input[_SAMLA];
  }
  if (input[_PA] != null) {
    const memberEntries = se_policyDescriptorListType(input[_PA], context8);
    if (input[_PA]?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_DS] != null) {
    entries[_DS] = input[_DS];
  }
  return entries;
}, se_AssumeRoleWithWebIdentityRequest = (input, context8) => {
  const entries = {};
  if (input[_RA] != null) {
    entries[_RA] = input[_RA];
  }
  if (input[_RSN] != null) {
    entries[_RSN] = input[_RSN];
  }
  if (input[_WIT] != null) {
    entries[_WIT] = input[_WIT];
  }
  if (input[_PI] != null) {
    entries[_PI] = input[_PI];
  }
  if (input[_PA] != null) {
    const memberEntries = se_policyDescriptorListType(input[_PA], context8);
    if (input[_PA]?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_DS] != null) {
    entries[_DS] = input[_DS];
  }
  return entries;
}, se_DecodeAuthorizationMessageRequest = (input, context8) => {
  const entries = {};
  if (input[_EM] != null) {
    entries[_EM] = input[_EM];
  }
  return entries;
}, se_GetAccessKeyInfoRequest = (input, context8) => {
  const entries = {};
  if (input[_AKI] != null) {
    entries[_AKI] = input[_AKI];
  }
  return entries;
}, se_GetCallerIdentityRequest = (input, context8) => {
  const entries = {};
  return entries;
}, se_GetFederationTokenRequest = (input, context8) => {
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_PA] != null) {
    const memberEntries = se_policyDescriptorListType(input[_PA], context8);
    if (input[_PA]?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value3;
    });
  }
  if (input[_DS] != null) {
    entries[_DS] = input[_DS];
  }
  if (input[_T] != null) {
    const memberEntries = se_tagListType(input[_T], context8);
    if (input[_T]?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value3]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value3;
    });
  }
  return entries;
}, se_GetSessionTokenRequest = (input, context8) => {
  const entries = {};
  if (input[_DS] != null) {
    entries[_DS] = input[_DS];
  }
  if (input[_SN] != null) {
    entries[_SN] = input[_SN];
  }
  if (input[_TC] != null) {
    entries[_TC] = input[_TC];
  }
  return entries;
}, se_policyDescriptorListType = (input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_PolicyDescriptorType(entry, context8);
    Object.entries(memberEntries).forEach(([key, value3]) => {
      entries[`member.${counter}.${key}`] = value3;
    });
    counter++;
  }
  return entries;
}, se_PolicyDescriptorType = (input, context8) => {
  const entries = {};
  if (input[_a2] != null) {
    entries[_a2] = input[_a2];
  }
  return entries;
}, se_ProvidedContext = (input, context8) => {
  const entries = {};
  if (input[_PAro] != null) {
    entries[_PAro] = input[_PAro];
  }
  if (input[_CA] != null) {
    entries[_CA] = input[_CA];
  }
  return entries;
}, se_ProvidedContextsListType = (input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ProvidedContext(entry, context8);
    Object.entries(memberEntries).forEach(([key, value3]) => {
      entries[`member.${counter}.${key}`] = value3;
    });
    counter++;
  }
  return entries;
}, se_Tag = (input, context8) => {
  const entries = {};
  if (input[_K] != null) {
    entries[_K] = input[_K];
  }
  if (input[_Va] != null) {
    entries[_Va] = input[_Va];
  }
  return entries;
}, se_tagKeyListType = (input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
}, se_tagListType = (input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Tag(entry, context8);
    Object.entries(memberEntries).forEach(([key, value3]) => {
      entries[`member.${counter}.${key}`] = value3;
    });
    counter++;
  }
  return entries;
}, de_AssumedRoleUser = (output, context8) => {
  const contents = {};
  if (output[_ARI] != null) {
    contents[_ARI] = expectString(output[_ARI]);
  }
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  return contents;
}, de_AssumeRoleResponse = (output, context8) => {
  const contents = {};
  if (output[_C] != null) {
    contents[_C] = de_Credentials(output[_C], context8);
  }
  if (output[_ARU] != null) {
    contents[_ARU] = de_AssumedRoleUser(output[_ARU], context8);
  }
  if (output[_PPS] != null) {
    contents[_PPS] = strictParseInt32(output[_PPS]);
  }
  if (output[_SI] != null) {
    contents[_SI] = expectString(output[_SI]);
  }
  return contents;
}, de_AssumeRoleWithSAMLResponse = (output, context8) => {
  const contents = {};
  if (output[_C] != null) {
    contents[_C] = de_Credentials(output[_C], context8);
  }
  if (output[_ARU] != null) {
    contents[_ARU] = de_AssumedRoleUser(output[_ARU], context8);
  }
  if (output[_PPS] != null) {
    contents[_PPS] = strictParseInt32(output[_PPS]);
  }
  if (output[_S] != null) {
    contents[_S] = expectString(output[_S]);
  }
  if (output[_ST] != null) {
    contents[_ST] = expectString(output[_ST]);
  }
  if (output[_I] != null) {
    contents[_I] = expectString(output[_I]);
  }
  if (output[_Au] != null) {
    contents[_Au] = expectString(output[_Au]);
  }
  if (output[_NQ] != null) {
    contents[_NQ] = expectString(output[_NQ]);
  }
  if (output[_SI] != null) {
    contents[_SI] = expectString(output[_SI]);
  }
  return contents;
}, de_AssumeRoleWithWebIdentityResponse = (output, context8) => {
  const contents = {};
  if (output[_C] != null) {
    contents[_C] = de_Credentials(output[_C], context8);
  }
  if (output[_SFWIT] != null) {
    contents[_SFWIT] = expectString(output[_SFWIT]);
  }
  if (output[_ARU] != null) {
    contents[_ARU] = de_AssumedRoleUser(output[_ARU], context8);
  }
  if (output[_PPS] != null) {
    contents[_PPS] = strictParseInt32(output[_PPS]);
  }
  if (output[_Pr] != null) {
    contents[_Pr] = expectString(output[_Pr]);
  }
  if (output[_Au] != null) {
    contents[_Au] = expectString(output[_Au]);
  }
  if (output[_SI] != null) {
    contents[_SI] = expectString(output[_SI]);
  }
  return contents;
}, de_Credentials = (output, context8) => {
  const contents = {};
  if (output[_AKI] != null) {
    contents[_AKI] = expectString(output[_AKI]);
  }
  if (output[_SAK] != null) {
    contents[_SAK] = expectString(output[_SAK]);
  }
  if (output[_STe] != null) {
    contents[_STe] = expectString(output[_STe]);
  }
  if (output[_E] != null) {
    contents[_E] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_E]));
  }
  return contents;
}, de_DecodeAuthorizationMessageResponse = (output, context8) => {
  const contents = {};
  if (output[_DM] != null) {
    contents[_DM] = expectString(output[_DM]);
  }
  return contents;
}, de_ExpiredTokenException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_FederatedUser = (output, context8) => {
  const contents = {};
  if (output[_FUI] != null) {
    contents[_FUI] = expectString(output[_FUI]);
  }
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  return contents;
}, de_GetAccessKeyInfoResponse = (output, context8) => {
  const contents = {};
  if (output[_Ac] != null) {
    contents[_Ac] = expectString(output[_Ac]);
  }
  return contents;
}, de_GetCallerIdentityResponse = (output, context8) => {
  const contents = {};
  if (output[_UI] != null) {
    contents[_UI] = expectString(output[_UI]);
  }
  if (output[_Ac] != null) {
    contents[_Ac] = expectString(output[_Ac]);
  }
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  return contents;
}, de_GetFederationTokenResponse = (output, context8) => {
  const contents = {};
  if (output[_C] != null) {
    contents[_C] = de_Credentials(output[_C], context8);
  }
  if (output[_FU] != null) {
    contents[_FU] = de_FederatedUser(output[_FU], context8);
  }
  if (output[_PPS] != null) {
    contents[_PPS] = strictParseInt32(output[_PPS]);
  }
  return contents;
}, de_GetSessionTokenResponse = (output, context8) => {
  const contents = {};
  if (output[_C] != null) {
    contents[_C] = de_Credentials(output[_C], context8);
  }
  return contents;
}, de_IDPCommunicationErrorException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_IDPRejectedClaimException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_InvalidAuthorizationMessageException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_InvalidIdentityTokenException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_MalformedPolicyDocumentException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_PackedPolicyTooLargeException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, de_RegionDisabledException = (output, context8) => {
  const contents = {};
  if (output[_m] != null) {
    contents[_m] = expectString(output[_m]);
  }
  return contents;
}, deserializeMetadata4 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), throwDefaultError4, buildHttpRpcRequest = async (context8, headers, path4, resolvedHostname, body) => {
  const { hostname: hostname3, protocol = "https", port, path: basePath } = await context8.endpoint();
  const contents = {
    protocol,
    hostname: hostname3,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path4 : basePath + path4,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, SHARED_HEADERS, _3 = "2011-06-15", _A = "Action", _AKI = "AccessKeyId", _AR = "AssumeRole", _ARI = "AssumedRoleId", _ARU = "AssumedRoleUser", _ARWSAML = "AssumeRoleWithSAML", _ARWWI = "AssumeRoleWithWebIdentity", _Ac = "Account", _Ar = "Arn", _Au = "Audience", _C = "Credentials", _CA = "ContextAssertion", _DAM = "DecodeAuthorizationMessage", _DM = "DecodedMessage", _DS = "DurationSeconds", _E = "Expiration", _EI = "ExternalId", _EM = "EncodedMessage", _FU = "FederatedUser", _FUI = "FederatedUserId", _GAKI = "GetAccessKeyInfo", _GCI = "GetCallerIdentity", _GFT = "GetFederationToken", _GST = "GetSessionToken", _I = "Issuer", _K = "Key", _N = "Name", _NQ = "NameQualifier", _P = "Policy", _PA = "PolicyArns", _PAr = "PrincipalArn", _PAro = "ProviderArn", _PC = "ProvidedContexts", _PI = "ProviderId", _PPS = "PackedPolicySize", _Pr = "Provider", _RA = "RoleArn", _RSN = "RoleSessionName", _S = "Subject", _SAK = "SecretAccessKey", _SAMLA = "SAMLAssertion", _SFWIT = "SubjectFromWebIdentityToken", _SI = "SourceIdentity", _SN = "SerialNumber", _ST = "SubjectType", _STe = "SessionToken", _T = "Tags", _TC = "TokenCode", _TTK = "TransitiveTagKeys", _UI = "UserId", _V = "Version", _Va = "Value", _WIT = "WebIdentityToken", _a2 = "arn", _m = "message", buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value3]) => import_protocols2.extendedEncodeURIComponent(key) + "=" + import_protocols2.extendedEncodeURIComponent(value3)).join("&"), loadQueryErrorCode = (output, data) => {
  if (data.Error?.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};
var init_Aws_query = __esm(() => {
  import_core80 = __toESM(require_dist_cjs20(), 1);
  init_dist_es2();
  init_dist_es21();
  init_models_03();
  init_STSServiceException();
  throwDefaultError4 = withBaseException(STSServiceException);
  SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded"
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var import_middleware_serde10, AssumeRoleCommand;
var init_AssumeRoleCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde10 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_models_03();
  init_Aws_query();
  AssumeRoleCommand = class AssumeRoleCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde10.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(undefined, AssumeRoleResponseFilterSensitiveLog).ser(se_AssumeRoleCommand).de(de_AssumeRoleCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithSAMLCommand.js
var import_middleware_serde11, AssumeRoleWithSAMLCommand;
var init_AssumeRoleWithSAMLCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde11 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_models_03();
  init_Aws_query();
  AssumeRoleWithSAMLCommand = class AssumeRoleWithSAMLCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde11.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithSAML", {}).n("STSClient", "AssumeRoleWithSAMLCommand").f(AssumeRoleWithSAMLRequestFilterSensitiveLog, AssumeRoleWithSAMLResponseFilterSensitiveLog).ser(se_AssumeRoleWithSAMLCommand).de(de_AssumeRoleWithSAMLCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var import_middleware_serde12, AssumeRoleWithWebIdentityCommand;
var init_AssumeRoleWithWebIdentityCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde12 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_models_03();
  init_Aws_query();
  AssumeRoleWithWebIdentityCommand = class AssumeRoleWithWebIdentityCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde12.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog).ser(se_AssumeRoleWithWebIdentityCommand).de(de_AssumeRoleWithWebIdentityCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/DecodeAuthorizationMessageCommand.js
var import_middleware_serde13, DecodeAuthorizationMessageCommand;
var init_DecodeAuthorizationMessageCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde13 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_Aws_query();
  DecodeAuthorizationMessageCommand = class DecodeAuthorizationMessageCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde13.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "DecodeAuthorizationMessage", {}).n("STSClient", "DecodeAuthorizationMessageCommand").f(undefined, undefined).ser(se_DecodeAuthorizationMessageCommand).de(de_DecodeAuthorizationMessageCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/GetAccessKeyInfoCommand.js
var import_middleware_serde14, GetAccessKeyInfoCommand;
var init_GetAccessKeyInfoCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde14 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_Aws_query();
  GetAccessKeyInfoCommand = class GetAccessKeyInfoCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde14.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "GetAccessKeyInfo", {}).n("STSClient", "GetAccessKeyInfoCommand").f(undefined, undefined).ser(se_GetAccessKeyInfoCommand).de(de_GetAccessKeyInfoCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/GetCallerIdentityCommand.js
var import_middleware_serde15, GetCallerIdentityCommand;
var init_GetCallerIdentityCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde15 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_Aws_query();
  GetCallerIdentityCommand = class GetCallerIdentityCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde15.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "GetCallerIdentity", {}).n("STSClient", "GetCallerIdentityCommand").f(undefined, undefined).ser(se_GetCallerIdentityCommand).de(de_GetCallerIdentityCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/GetFederationTokenCommand.js
var import_middleware_serde16, GetFederationTokenCommand;
var init_GetFederationTokenCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde16 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_models_03();
  init_Aws_query();
  GetFederationTokenCommand = class GetFederationTokenCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde16.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "GetFederationToken", {}).n("STSClient", "GetFederationTokenCommand").f(undefined, GetFederationTokenResponseFilterSensitiveLog).ser(se_GetFederationTokenCommand).de(de_GetFederationTokenCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/GetSessionTokenCommand.js
var import_middleware_serde17, GetSessionTokenCommand;
var init_GetSessionTokenCommand = __esm(() => {
  init_dist_es17();
  import_middleware_serde17 = __toESM(require_dist_cjs3(), 1);
  init_dist_es21();
  init_EndpointParameters3();
  init_models_03();
  init_Aws_query();
  GetSessionTokenCommand = class GetSessionTokenCommand extends Command.classBuilder().ep(commonParams4).m(function(Command2, cs, config6, o5) {
    return [
      import_middleware_serde17.getSerdePlugin(config6, this.serialize, this.deserialize),
      getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "GetSessionToken", {}).n("STSClient", "GetSessionTokenCommand").f(undefined, GetSessionTokenResponseFilterSensitiveLog).ser(se_GetSessionTokenCommand).de(de_GetSessionTokenCommand).build() {
  };
});

// ../node_modules/@aws-sdk/client-sts/dist-es/STS.js
var commands5, STS;
var init_STS = __esm(() => {
  init_dist_es21();
  init_AssumeRoleCommand();
  init_AssumeRoleWithSAMLCommand();
  init_AssumeRoleWithWebIdentityCommand();
  init_DecodeAuthorizationMessageCommand();
  init_GetAccessKeyInfoCommand();
  init_GetCallerIdentityCommand();
  init_GetFederationTokenCommand();
  init_GetSessionTokenCommand();
  init_STSClient();
  commands5 = {
    AssumeRoleCommand,
    AssumeRoleWithSAMLCommand,
    AssumeRoleWithWebIdentityCommand,
    DecodeAuthorizationMessageCommand,
    GetAccessKeyInfoCommand,
    GetCallerIdentityCommand,
    GetFederationTokenCommand,
    GetSessionTokenCommand
  };
  STS = class STS extends STSClient {
  };
  createAggregatedClient(commands5, STS);
});

// ../node_modules/@aws-sdk/client-sts/dist-es/commands/index.js
var init_commands3 = __esm(() => {
  init_AssumeRoleCommand();
  init_AssumeRoleWithSAMLCommand();
  init_AssumeRoleWithWebIdentityCommand();
  init_DecodeAuthorizationMessageCommand();
  init_GetAccessKeyInfoCommand();
  init_GetCallerIdentityCommand();
  init_GetFederationTokenCommand();
  init_GetSessionTokenCommand();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/models/index.js
var init_models3 = __esm(() => {
  init_models_03();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var import_client7, ASSUME_ROLE_DEFAULT_REGION = "us-east-1", getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
  if (typeof assumedRoleUser?.Arn === "string") {
    const arnComponents = assumedRoleUser.Arn.split(":");
    if (arnComponents.length > 4 && arnComponents[4] !== "") {
      return arnComponents[4];
    }
  }
  return;
}, resolveRegion = async (_region, _parentRegion, credentialProviderLogger) => {
  const region = typeof _region === "function" ? await _region() : _region;
  const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
  credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
  return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
}, getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger4 = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
      const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
      const isCompatibleRequestHandler = !isH2(requestHandler);
      stsClient = new stsClientCtor({
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: resolvedRegion,
        requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
        logger: logger4
      });
    }
    const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
    const credentials = {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration,
      ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
      ...accountId && { accountId }
    };
    import_client7.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
    return credentials;
  };
}, getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params) => {
    if (!stsClient) {
      const { logger: logger4 = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
      const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
      const isCompatibleRequestHandler = !isH2(requestHandler);
      stsClient = new stsClientCtor({
        region: resolvedRegion,
        requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
        logger: logger4
      });
    }
    const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
    }
    const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
    const credentials = {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration,
      ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
      ...accountId && { accountId }
    };
    if (accountId) {
      import_client7.setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
    }
    import_client7.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
    return credentials;
  };
}, isH2 = (requestHandler) => {
  return requestHandler?.metadata?.handlerProtocol === "h2";
};
var init_defaultStsRoleAssumers = __esm(() => {
  import_client7 = __toESM(require_client(), 1);
  init_AssumeRoleCommand();
  init_AssumeRoleWithWebIdentityCommand();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor = (baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      constructor(config6) {
        super(config6);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
}, getDefaultRoleAssumer2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins)), getDefaultRoleAssumerWithWebIdentity2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins)), decorateDefaultCredentialProvider = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer2(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
  ...input
});
var init_defaultRoleAssumers = __esm(() => {
  init_defaultStsRoleAssumers();
  init_STSClient();
});

// ../node_modules/@aws-sdk/client-sts/dist-es/index.js
var exports_dist_es6 = {};
__export(exports_dist_es6, {
  getDefaultRoleAssumerWithWebIdentity: () => getDefaultRoleAssumerWithWebIdentity2,
  getDefaultRoleAssumer: () => getDefaultRoleAssumer2,
  decorateDefaultCredentialProvider: () => decorateDefaultCredentialProvider,
  __Client: () => Client,
  STSServiceException: () => STSServiceException,
  STSClient: () => STSClient,
  STS: () => STS,
  RegionDisabledException: () => RegionDisabledException,
  PackedPolicyTooLargeException: () => PackedPolicyTooLargeException,
  MalformedPolicyDocumentException: () => MalformedPolicyDocumentException,
  InvalidIdentityTokenException: () => InvalidIdentityTokenException,
  InvalidAuthorizationMessageException: () => InvalidAuthorizationMessageException,
  IDPRejectedClaimException: () => IDPRejectedClaimException,
  IDPCommunicationErrorException: () => IDPCommunicationErrorException,
  GetSessionTokenResponseFilterSensitiveLog: () => GetSessionTokenResponseFilterSensitiveLog,
  GetSessionTokenCommand: () => GetSessionTokenCommand,
  GetFederationTokenResponseFilterSensitiveLog: () => GetFederationTokenResponseFilterSensitiveLog,
  GetFederationTokenCommand: () => GetFederationTokenCommand,
  GetCallerIdentityCommand: () => GetCallerIdentityCommand,
  GetAccessKeyInfoCommand: () => GetAccessKeyInfoCommand,
  ExpiredTokenException: () => ExpiredTokenException2,
  DecodeAuthorizationMessageCommand: () => DecodeAuthorizationMessageCommand,
  CredentialsFilterSensitiveLog: () => CredentialsFilterSensitiveLog,
  AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
  AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
  AssumeRoleWithWebIdentityCommand: () => AssumeRoleWithWebIdentityCommand,
  AssumeRoleWithSAMLResponseFilterSensitiveLog: () => AssumeRoleWithSAMLResponseFilterSensitiveLog,
  AssumeRoleWithSAMLRequestFilterSensitiveLog: () => AssumeRoleWithSAMLRequestFilterSensitiveLog,
  AssumeRoleWithSAMLCommand: () => AssumeRoleWithSAMLCommand,
  AssumeRoleResponseFilterSensitiveLog: () => AssumeRoleResponseFilterSensitiveLog,
  AssumeRoleCommand: () => AssumeRoleCommand,
  $Command: () => Command
});
var init_dist_es41 = __esm(() => {
  init_STSClient();
  init_STS();
  init_commands3();
  init_models3();
  init_defaultRoleAssumers();
  init_STSServiceException();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var import_client8, isAssumeRoleProfile = (arg, { profile: profile2 = "default", logger: logger4 } = {}) => {
  return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile: profile2, logger: logger4 }) || isCredentialSourceProfile(arg, { profile: profile2, logger: logger4 }));
}, isAssumeRoleWithSourceProfile = (arg, { profile: profile2, logger: logger4 }) => {
  const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
  if (withSourceProfile) {
    logger4?.debug?.(`    ${profile2} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
  }
  return withSourceProfile;
}, isCredentialSourceProfile = (arg, { profile: profile2, logger: logger4 }) => {
  const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
  if (withProviderProfile) {
    logger4?.debug?.(`    ${profile2} isCredentialSourceProfile credential_source=${arg.credential_source}`);
  }
  return withProviderProfile;
}, resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
  options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    const { getDefaultRoleAssumer: getDefaultRoleAssumer3 } = await Promise.resolve().then(() => (init_dist_es41(), exports_dist_es6));
    options.roleAssumer = getDefaultRoleAssumer3({
      ...options.clientConfig,
      credentialProviderLogger: options.logger,
      parentClientConfig: options?.parentClientConfig
    }, options.clientPlugins);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
  }
  options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
  const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(data.credential_source, profileName, options.logger)(options))();
  if (isCredentialSourceWithoutRoleArn(data)) {
    return sourceCredsProvider.then((creds) => import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  } else {
    const params = {
      RoleArn: data.role_arn,
      RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
      ExternalId: data.external_id,
      DurationSeconds: parseInt(data.duration_seconds || "3600", 10)
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
      if (!options.mfaCodeProvider) {
        throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: options.logger, tryNextLink: false });
      }
      params.SerialNumber = mfa_serial;
      params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params).then((creds) => import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  }
}, isCredentialSourceWithoutRoleArn = (section) => {
  return !section.role_arn && !!section.credential_source;
};
var init_resolveAssumeRoleCredentials = __esm(() => {
  import_client8 = __toESM(require_client(), 1);
  init_dist_es13();
  init_dist_es14();
  init_resolveCredentialSource();
  init_resolveProfileData();
});

// ../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var import_client9, getValidatedProcessCredentials = (profileName, data, profiles) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = new Date;
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  let accountId = data.AccountId;
  if (!accountId && profiles?.[profileName]?.aws_account_id) {
    accountId = profiles[profileName].aws_account_id;
  }
  const credentials = {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) },
    ...data.CredentialScope && { credentialScope: data.CredentialScope },
    ...accountId && { accountId }
  };
  import_client9.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
  return credentials;
};
var init_getValidatedProcessCredentials = __esm(() => {
  import_client9 = __toESM(require_client(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
import { exec } from "child_process";
import { promisify as promisify2 } from "util";
var resolveProcessCredentials = async (profileName, profiles, logger4) => {
  const profile2 = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile2["credential_process"];
    if (credentialProcess !== undefined) {
      const execPromise = promisify2(exec);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials(profileName, data, profiles);
      } catch (error5) {
        throw new CredentialsProviderError(error5.message, { logger: logger4 });
      }
    } else {
      throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger: logger4 });
    }
  } else {
    throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
      logger: logger4
    });
  }
};
var init_resolveProcessCredentials = __esm(() => {
  init_dist_es13();
  init_getValidatedProcessCredentials();
});

// ../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess = (init3 = {}) => async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
  const profiles = await parseKnownFiles(init3);
  return resolveProcessCredentials(getProfileName(init3), profiles, init3.logger);
};
var init_fromProcess = __esm(() => {
  init_dist_es14();
  init_resolveProcessCredentials();
});

// ../node_modules/@aws-sdk/credential-provider-process/dist-es/index.js
var exports_dist_es7 = {};
__export(exports_dist_es7, {
  fromProcess: () => fromProcess
});
var init_dist_es42 = __esm(() => {
  init_fromProcess();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var import_client10, isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", resolveProcessCredentials2 = async (options, profile2) => Promise.resolve().then(() => (init_dist_es42(), exports_dist_es7)).then(({ fromProcess: fromProcess3 }) => fromProcess3({
  ...options,
  profile: profile2
})().then((creds) => import_client10.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
var init_resolveProcessCredentials2 = __esm(() => {
  import_client10 = __toESM(require_client(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var import_client11, resolveSsoCredentials = async (profile2, profileData, options = {}) => {
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es40(), exports_dist_es5));
  return fromSSO3({
    profile: profile2,
    logger: options.logger
  })().then((creds) => {
    if (profileData.sso_session) {
      return import_client11.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
    } else {
      return import_client11.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
    }
  });
}, isSsoProfile3 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
var init_resolveSsoCredentials = __esm(() => {
  import_client11 = __toESM(require_client(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var import_client12, isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1, resolveStaticCredentials = async (profile2, options) => {
  options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
  const credentials = {
    accessKeyId: profile2.aws_access_key_id,
    secretAccessKey: profile2.aws_secret_access_key,
    sessionToken: profile2.aws_session_token,
    ...profile2.aws_credential_scope && { credentialScope: profile2.aws_credential_scope },
    ...profile2.aws_account_id && { accountId: profile2.aws_account_id }
  };
  return import_client12.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
};
var init_resolveStaticCredentials = __esm(() => {
  import_client12 = __toESM(require_client(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = (init3) => async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy: policy2, durationSeconds } = init3;
  let { roleAssumerWithWebIdentity } = init3;
  if (!roleAssumerWithWebIdentity) {
    const { getDefaultRoleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3 } = await Promise.resolve().then(() => (init_dist_es41(), exports_dist_es6));
    roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity3({
      ...init3.clientConfig,
      credentialProviderLogger: init3.logger,
      parentClientConfig: init3.parentClientConfig
    }, init3.clientPlugins);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy2,
    DurationSeconds: durationSeconds
  });
};

// ../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
import { readFileSync as readFileSync3 } from "fs";
var import_client13, ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE", ENV_ROLE_ARN = "AWS_ROLE_ARN", ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME", fromTokenFile = (init3 = {}) => async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
  const webIdentityTokenFile = init3?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
  const roleArn = init3?.roleArn ?? process.env[ENV_ROLE_ARN];
  const roleSessionName = init3?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
  if (!webIdentityTokenFile || !roleArn) {
    throw new CredentialsProviderError("Web identity configuration not specified", {
      logger: init3.logger
    });
  }
  const credentials = await fromWebToken({
    ...init3,
    webIdentityToken: readFileSync3(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
  if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
    import_client13.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
  }
  return credentials;
};
var init_fromTokenFile = __esm(() => {
  import_client13 = __toESM(require_client(), 1);
  init_dist_es13();
});

// ../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js
var exports_dist_es8 = {};
__export(exports_dist_es8, {
  fromWebToken: () => fromWebToken,
  fromTokenFile: () => fromTokenFile
});
var init_dist_es43 = __esm(() => {
  init_fromTokenFile();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var import_client14, isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, resolveWebIdentityCredentials = async (profile2, options) => Promise.resolve().then(() => (init_dist_es43(), exports_dist_es8)).then(({ fromTokenFile: fromTokenFile3 }) => fromTokenFile3({
  webIdentityTokenFile: profile2.web_identity_token_file,
  roleArn: profile2.role_arn,
  roleSessionName: profile2.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
  logger: options.logger,
  parentClientConfig: options.parentClientConfig
})().then((creds) => import_client14.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
var init_resolveWebIdentityCredentials = __esm(() => {
  import_client14 = __toESM(require_client(), 1);
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data, { profile: profileName, logger: options.logger })) {
    return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isWebIdentityProfile(data)) {
    return resolveWebIdentityCredentials(data, options);
  }
  if (isProcessProfile(data)) {
    return resolveProcessCredentials2(options, profileName);
  }
  if (isSsoProfile3(data)) {
    return await resolveSsoCredentials(profileName, data, options);
  }
  throw new CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
};
var init_resolveProfileData = __esm(() => {
  init_dist_es13();
  init_resolveAssumeRoleCredentials();
  init_resolveProcessCredentials2();
  init_resolveSsoCredentials();
  init_resolveStaticCredentials();
  init_resolveWebIdentityCredentials();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni = (init3 = {}) => async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
  const profiles = await parseKnownFiles(init3);
  return resolveProfileData(getProfileName(init3), profiles, init3);
};
var init_fromIni = __esm(() => {
  init_dist_es14();
  init_resolveProfileData();
});

// ../node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js
var exports_dist_es9 = {};
__export(exports_dist_es9, {
  fromIni: () => fromIni
});
var init_dist_es44 = __esm(() => {
  init_fromIni();
});

// ../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var multipleCredentialSourceWarningEmitted = false, defaultProvider = (init3 = {}) => memoize(chain(async () => {
  const profile2 = init3.profile ?? process.env[ENV_PROFILE];
  if (profile2) {
    const envStaticCredentialsAreSet = process.env[ENV_KEY] && process.env[ENV_SECRET];
    if (envStaticCredentialsAreSet) {
      if (!multipleCredentialSourceWarningEmitted) {
        const warnFn = init3.logger?.warn && init3.logger?.constructor?.name !== "NoOpLogger" ? init3.logger.warn : console.warn;
        warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
        multipleCredentialSourceWarningEmitted = true;
      }
    }
    throw new CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
      logger: init3.logger,
      tryNextLink: true
    });
  }
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
  return fromEnv2(init3)();
}, async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init3;
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    throw new CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init3.logger });
  }
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es40(), exports_dist_es5));
  return fromSSO3(init3)();
}, async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
  const { fromIni: fromIni3 } = await Promise.resolve().then(() => (init_dist_es44(), exports_dist_es9));
  return fromIni3(init3)();
}, async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
  const { fromProcess: fromProcess3 } = await Promise.resolve().then(() => (init_dist_es42(), exports_dist_es7));
  return fromProcess3(init3)();
}, async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
  const { fromTokenFile: fromTokenFile3 } = await Promise.resolve().then(() => (init_dist_es43(), exports_dist_es8));
  return fromTokenFile3(init3)();
}, async () => {
  init3.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
  return (await remoteProvider(init3))();
}, async () => {
  throw new CredentialsProviderError("Could not load credentials from any providers", {
    tryNextLink: false,
    logger: init3.logger
  });
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh), credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined, credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;
var init_defaultProvider = __esm(() => {
  init_dist_es23();
  init_dist_es13();
  init_dist_es14();
  init_remoteProvider();
});

// ../node_modules/@aws-sdk/credential-provider-node/dist-es/index.js
var init_dist_es45 = __esm(() => {
  init_defaultProvider();
});

// ../node_modules/react/cjs/react.production.min.js
var exports_react_production_min = {};
__export(exports_react_production_min, {
  version: () => $version,
  useTransition: () => $useTransition,
  useSyncExternalStore: () => $useSyncExternalStore,
  useState: () => $useState,
  useRef: () => $useRef,
  useReducer: () => $useReducer,
  useMemo: () => $useMemo,
  useLayoutEffect: () => $useLayoutEffect,
  useInsertionEffect: () => $useInsertionEffect,
  useImperativeHandle: () => $useImperativeHandle,
  useId: () => $useId,
  useEffect: () => $useEffect,
  useDeferredValue: () => $useDeferredValue,
  useDebugValue: () => $useDebugValue,
  useContext: () => $useContext,
  useCallback: () => $useCallback,
  unstable_act: () => $unstable_act,
  startTransition: () => $startTransition,
  memo: () => $memo,
  lazy: () => $lazy,
  isValidElement: () => $isValidElement,
  forwardRef: () => $forwardRef,
  createRef: () => $createRef,
  createFactory: () => $createFactory,
  createElement: () => $createElement,
  createContext: () => $createContext,
  cloneElement: () => $cloneElement,
  act: () => $act,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => $__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Suspense: () => $Suspense,
  StrictMode: () => $StrictMode,
  PureComponent: () => $PureComponent,
  Profiler: () => $Profiler,
  Fragment: () => $Fragment,
  Component: () => $Component,
  Children: () => $Children
});
function A6(a4) {
  if (a4 === null || typeof a4 !== "object")
    return null;
  a4 = z6 && a4[z6] || a4["@@iterator"];
  return typeof a4 === "function" ? a4 : null;
}
function E6(a4, b4, e5) {
  this.props = a4;
  this.context = b4;
  this.refs = D6;
  this.updater = e5 || B4;
}
function F5() {
}
function G6(a4, b4, e5) {
  this.props = a4;
  this.context = b4;
  this.refs = D6;
  this.updater = e5 || B4;
}
function M2(a4, b4, e5) {
  var d4, c4 = {}, k4 = null, h4 = null;
  if (b4 != null)
    for (d4 in b4.ref !== undefined && (h4 = b4.ref), b4.key !== undefined && (k4 = "" + b4.key), b4)
      J6.call(b4, d4) && !L3.hasOwnProperty(d4) && (c4[d4] = b4[d4]);
  var g4 = arguments.length - 2;
  if (g4 === 1)
    c4.children = e5;
  else if (1 < g4) {
    for (var f4 = Array(g4), m4 = 0;m4 < g4; m4++)
      f4[m4] = arguments[m4 + 2];
    c4.children = f4;
  }
  if (a4 && a4.defaultProps)
    for (d4 in g4 = a4.defaultProps, g4)
      c4[d4] === undefined && (c4[d4] = g4[d4]);
  return { $$typeof: l7, type: a4, key: k4, ref: h4, props: c4, _owner: K.current };
}
function N2(a4, b4) {
  return { $$typeof: l7, type: a4.type, key: b4, ref: a4.ref, props: a4.props, _owner: a4._owner };
}
function O4(a4) {
  return typeof a4 === "object" && a4 !== null && a4.$$typeof === l7;
}
function escape2(a4) {
  var b4 = { "=": "=0", ":": "=2" };
  return "$" + a4.replace(/[=:]/g, function(a7) {
    return b4[a7];
  });
}
function Q(a4, b4) {
  return typeof a4 === "object" && a4 !== null && a4.key != null ? escape2("" + a4.key) : b4.toString(36);
}
function R(a4, b4, e5, d4, c4) {
  var k4 = typeof a4;
  if (k4 === "undefined" || k4 === "boolean")
    a4 = null;
  var h4 = false;
  if (a4 === null)
    h4 = true;
  else
    switch (k4) {
      case "string":
      case "number":
        h4 = true;
        break;
      case "object":
        switch (a4.$$typeof) {
          case l7:
          case n6:
            h4 = true;
        }
    }
  if (h4)
    return h4 = a4, c4 = c4(h4), a4 = d4 === "" ? "." + Q(h4, 0) : d4, I6(c4) ? (e5 = "", a4 != null && (e5 = a4.replace(P4, "$&/") + "/"), R(c4, b4, e5, "", function(a7) {
      return a7;
    })) : c4 != null && (O4(c4) && (c4 = N2(c4, e5 + (!c4.key || h4 && h4.key === c4.key ? "" : ("" + c4.key).replace(P4, "$&/") + "/") + a4)), b4.push(c4)), 1;
  h4 = 0;
  d4 = d4 === "" ? "." : d4 + ":";
  if (I6(a4))
    for (var g4 = 0;g4 < a4.length; g4++) {
      k4 = a4[g4];
      var f4 = d4 + Q(k4, g4);
      h4 += R(k4, b4, e5, f4, c4);
    }
  else if (f4 = A6(a4), typeof f4 === "function")
    for (a4 = f4.call(a4), g4 = 0;!(k4 = a4.next()).done; )
      k4 = k4.value, f4 = d4 + Q(k4, g4++), h4 += R(k4, b4, e5, f4, c4);
  else if (k4 === "object")
    throw b4 = String(a4), Error("Objects are not valid as a React child (found: " + (b4 === "[object Object]" ? "object with keys {" + Object.keys(a4).join(", ") + "}" : b4) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S3(a4, b4, e5) {
  if (a4 == null)
    return a4;
  var d4 = [], c4 = 0;
  R(a4, d4, "", "", function(a7) {
    return b4.call(e5, a7, c4++);
  });
  return d4;
}
function T4(a4) {
  if (a4._status === -1) {
    var b4 = a4._result;
    b4 = b4();
    b4.then(function(b9) {
      if (a4._status === 0 || a4._status === -1)
        a4._status = 1, a4._result = b9;
    }, function(b9) {
      if (a4._status === 0 || a4._status === -1)
        a4._status = 2, a4._result = b9;
    });
    a4._status === -1 && (a4._status = 0, a4._result = b4);
  }
  if (a4._status === 1)
    return a4._result.default;
  throw a4._result;
}
function X4() {
  throw Error("act(...) is not supported in production builds of React.");
}
var l7, n6, p9, q10, r7, t8, u8, v11, w7, x8, y5, z6, B4, C5, D6, H3, I6, J6, K, L3, P4, U, V6, W, $Children, $Component, $Fragment, $Profiler, $PureComponent, $StrictMode, $Suspense, $__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, $act, $cloneElement = function(a4, b4, e5) {
  if (a4 === null || a4 === undefined)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a4 + ".");
  var d4 = C5({}, a4.props), c4 = a4.key, k4 = a4.ref, h4 = a4._owner;
  if (b4 != null) {
    b4.ref !== undefined && (k4 = b4.ref, h4 = K.current);
    b4.key !== undefined && (c4 = "" + b4.key);
    if (a4.type && a4.type.defaultProps)
      var g4 = a4.type.defaultProps;
    for (f4 in b4)
      J6.call(b4, f4) && !L3.hasOwnProperty(f4) && (d4[f4] = b4[f4] === undefined && g4 !== undefined ? g4[f4] : b4[f4]);
  }
  var f4 = arguments.length - 2;
  if (f4 === 1)
    d4.children = e5;
  else if (1 < f4) {
    g4 = Array(f4);
    for (var m4 = 0;m4 < f4; m4++)
      g4[m4] = arguments[m4 + 2];
    d4.children = g4;
  }
  return { $$typeof: l7, type: a4.type, key: c4, ref: k4, props: d4, _owner: h4 };
}, $createContext = function(a4) {
  a4 = { $$typeof: u8, _currentValue: a4, _currentValue2: a4, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a4.Provider = { $$typeof: t8, _context: a4 };
  return a4.Consumer = a4;
}, $createElement, $createFactory = function(a4) {
  var b4 = M2.bind(null, a4);
  b4.type = a4;
  return b4;
}, $createRef = function() {
  return { current: null };
}, $forwardRef = function(a4) {
  return { $$typeof: v11, render: a4 };
}, $isValidElement, $lazy = function(a4) {
  return { $$typeof: y5, _payload: { _status: -1, _result: a4 }, _init: T4 };
}, $memo = function(a4, b4) {
  return { $$typeof: x8, type: a4, compare: b4 === undefined ? null : b4 };
}, $startTransition = function(a4) {
  var b4 = V6.transition;
  V6.transition = {};
  try {
    a4();
  } finally {
    V6.transition = b4;
  }
}, $unstable_act, $useCallback = function(a4, b4) {
  return U.current.useCallback(a4, b4);
}, $useContext = function(a4) {
  return U.current.useContext(a4);
}, $useDebugValue = function() {
}, $useDeferredValue = function(a4) {
  return U.current.useDeferredValue(a4);
}, $useEffect = function(a4, b4) {
  return U.current.useEffect(a4, b4);
}, $useId = function() {
  return U.current.useId();
}, $useImperativeHandle = function(a4, b4, e5) {
  return U.current.useImperativeHandle(a4, b4, e5);
}, $useInsertionEffect = function(a4, b4) {
  return U.current.useInsertionEffect(a4, b4);
}, $useLayoutEffect = function(a4, b4) {
  return U.current.useLayoutEffect(a4, b4);
}, $useMemo = function(a4, b4) {
  return U.current.useMemo(a4, b4);
}, $useReducer = function(a4, b4, e5) {
  return U.current.useReducer(a4, b4, e5);
}, $useRef = function(a4) {
  return U.current.useRef(a4);
}, $useState = function(a4) {
  return U.current.useState(a4);
}, $useSyncExternalStore = function(a4, b4, e5) {
  return U.current.useSyncExternalStore(a4, b4, e5);
}, $useTransition = function() {
  return U.current.useTransition();
}, $version = "18.3.1";
var init_react_production_min = __esm(() => {
  l7 = Symbol.for("react.element");
  n6 = Symbol.for("react.portal");
  p9 = Symbol.for("react.fragment");
  q10 = Symbol.for("react.strict_mode");
  r7 = Symbol.for("react.profiler");
  t8 = Symbol.for("react.provider");
  u8 = Symbol.for("react.context");
  v11 = Symbol.for("react.forward_ref");
  w7 = Symbol.for("react.suspense");
  x8 = Symbol.for("react.memo");
  y5 = Symbol.for("react.lazy");
  z6 = Symbol.iterator;
  B4 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } };
  C5 = Object.assign;
  D6 = {};
  E6.prototype.isReactComponent = {};
  E6.prototype.setState = function(a4, b4) {
    if (typeof a4 !== "object" && typeof a4 !== "function" && a4 != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a4, b4, "setState");
  };
  E6.prototype.forceUpdate = function(a4) {
    this.updater.enqueueForceUpdate(this, a4, "forceUpdate");
  };
  F5.prototype = E6.prototype;
  H3 = G6.prototype = new F5;
  H3.constructor = G6;
  C5(H3, E6.prototype);
  H3.isPureReactComponent = true;
  I6 = Array.isArray;
  J6 = Object.prototype.hasOwnProperty;
  K = { current: null };
  L3 = { key: true, ref: true, __self: true, __source: true };
  P4 = /\/+/g;
  U = { current: null };
  V6 = { transition: null };
  W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V6, ReactCurrentOwner: K };
  $Children = { map: S3, forEach: function(a4, b4, e5) {
    S3(a4, function() {
      b4.apply(this, arguments);
    }, e5);
  }, count: function(a4) {
    var b4 = 0;
    S3(a4, function() {
      b4++;
    });
    return b4;
  }, toArray: function(a4) {
    return S3(a4, function(a7) {
      return a7;
    }) || [];
  }, only: function(a4) {
    if (!O4(a4))
      throw Error("React.Children.only expected to receive a single React element child.");
    return a4;
  } };
  $Component = E6;
  $Fragment = p9;
  $Profiler = r7;
  $PureComponent = G6;
  $StrictMode = q10;
  $Suspense = w7;
  $__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  $act = X4;
  $createElement = M2;
  $isValidElement = O4;
  $unstable_act = X4;
});

// ../node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  init_react_production_min();
  if (true) {
    module.exports = exports_react_production_min;
  } else {
  }
});

// ../node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js
var exports_react_dom_server_legacy_node_production_min = {};
__export(exports_react_dom_server_legacy_node_production_min, {
  version: () => $version2,
  renderToString: () => $renderToString,
  renderToStaticNodeStream: () => $renderToStaticNodeStream,
  renderToStaticMarkup: () => $renderToStaticMarkup,
  renderToNodeStream: () => $renderToNodeStream
});
import * as fa from "stream";
function ka(a4) {
  if (n7.call(ja, a4))
    return true;
  if (n7.call(ia, a4))
    return false;
  if (ha.test(a4))
    return ja[a4] = true;
  ia[a4] = true;
  return false;
}
function q11(a4, b4, c4, d4, f4, e5, g4) {
  this.acceptsBooleans = b4 === 2 || b4 === 3 || b4 === 4;
  this.attributeName = d4;
  this.attributeNamespace = f4;
  this.mustUseProperty = c4;
  this.propertyName = a4;
  this.type = b4;
  this.sanitizeURL = e5;
  this.removeEmptyString = g4;
}
function ma(a4) {
  return a4[1].toUpperCase();
}
function u9(a4) {
  if (typeof a4 === "boolean" || typeof a4 === "number")
    return "" + a4;
  a4 = "" + a4;
  var b4 = oa.exec(a4);
  if (b4) {
    var c4 = "", d4, f4 = 0;
    for (d4 = b4.index;d4 < a4.length; d4++) {
      switch (a4.charCodeAt(d4)) {
        case 34:
          b4 = "&quot;";
          break;
        case 38:
          b4 = "&amp;";
          break;
        case 39:
          b4 = "&#x27;";
          break;
        case 60:
          b4 = "&lt;";
          break;
        case 62:
          b4 = "&gt;";
          break;
        default:
          continue;
      }
      f4 !== d4 && (c4 += a4.substring(f4, d4));
      f4 = d4 + 1;
      c4 += b4;
    }
    a4 = f4 !== d4 ? c4 + a4.substring(f4, d4) : c4;
  }
  return a4;
}
function v13(a4, b4) {
  return { insertionMode: a4, selectedValue: b4 };
}
function sa(a4, b4, c4) {
  switch (b4) {
    case "select":
      return v13(1, c4.value != null ? c4.value : c4.defaultValue);
    case "svg":
      return v13(2, null);
    case "math":
      return v13(3, null);
    case "foreignObject":
      return v13(1, null);
    case "table":
      return v13(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return v13(5, null);
    case "colgroup":
      return v13(7, null);
    case "tr":
      return v13(6, null);
  }
  return 4 <= a4.insertionMode || a4.insertionMode === 0 ? v13(1, null) : a4;
}
function ua(a4, b4, c4) {
  if (typeof c4 !== "object")
    throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
  b4 = true;
  for (var d4 in c4)
    if (n7.call(c4, d4)) {
      var f4 = c4[d4];
      if (f4 != null && typeof f4 !== "boolean" && f4 !== "") {
        if (d4.indexOf("--") === 0) {
          var e5 = u9(d4);
          f4 = u9(("" + f4).trim());
        } else {
          e5 = d4;
          var g4 = ta.get(e5);
          g4 !== undefined ? e5 = g4 : (g4 = u9(e5.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e5, g4), e5 = g4);
          f4 = typeof f4 === "number" ? f4 === 0 || n7.call(t9, d4) ? "" + f4 : f4 + "px" : u9(("" + f4).trim());
        }
        b4 ? (b4 = false, a4.push(' style="', e5, ":", f4)) : a4.push(";", e5, ":", f4);
      }
    }
  b4 || a4.push('"');
}
function w8(a4, b4, c4, d4) {
  switch (c4) {
    case "style":
      ua(a4, b4, d4);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c4.length) || c4[0] !== "o" && c4[0] !== "O" || c4[1] !== "n" && c4[1] !== "N") {
    if (b4 = r8.hasOwnProperty(c4) ? r8[c4] : null, b4 !== null) {
      switch (typeof d4) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b4.acceptsBooleans)
            return;
      }
      c4 = b4.attributeName;
      switch (b4.type) {
        case 3:
          d4 && a4.push(" ", c4, '=""');
          break;
        case 4:
          d4 === true ? a4.push(" ", c4, '=""') : d4 !== false && a4.push(" ", c4, '="', u9(d4), '"');
          break;
        case 5:
          isNaN(d4) || a4.push(" ", c4, '="', u9(d4), '"');
          break;
        case 6:
          !isNaN(d4) && 1 <= d4 && a4.push(" ", c4, '="', u9(d4), '"');
          break;
        default:
          b4.sanitizeURL && (d4 = "" + d4), a4.push(" ", c4, '="', u9(d4), '"');
      }
    } else if (ka(c4)) {
      switch (typeof d4) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b4 = c4.toLowerCase().slice(0, 5), b4 !== "data-" && b4 !== "aria-")
            return;
      }
      a4.push(" ", c4, '="', u9(d4), '"');
    }
  }
}
function x9(a4, b4, c4) {
  if (b4 != null) {
    if (c4 != null)
      throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
    if (typeof b4 !== "object" || !("__html" in b4))
      throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
    b4 = b4.__html;
    b4 !== null && b4 !== undefined && a4.push("" + b4);
  }
}
function va(a4) {
  var b4 = "";
  ea.Children.forEach(a4, function(a7) {
    a7 != null && (b4 += a7);
  });
  return b4;
}
function wa(a4, b4, c4, d4) {
  a4.push(z7(c4));
  var f4 = c4 = null, e5;
  for (e5 in b4)
    if (n7.call(b4, e5)) {
      var g4 = b4[e5];
      if (g4 != null)
        switch (e5) {
          case "children":
            c4 = g4;
            break;
          case "dangerouslySetInnerHTML":
            f4 = g4;
            break;
          default:
            w8(a4, d4, e5, g4);
        }
    }
  a4.push(">");
  x9(a4, f4, c4);
  return typeof c4 === "string" ? (a4.push(u9(c4)), null) : c4;
}
function z7(a4) {
  var b4 = ya.get(a4);
  if (b4 === undefined) {
    if (!xa.test(a4))
      throw Error("Invalid tag: " + a4);
    b4 = "<" + a4;
    ya.set(a4, b4);
  }
  return b4;
}
function za(a4, b4, c4, d4, f4) {
  switch (b4) {
    case "select":
      a4.push(z7("select"));
      var e5 = null, g4 = null;
      for (l4 in c4)
        if (n7.call(c4, l4)) {
          var h4 = c4[l4];
          if (h4 != null)
            switch (l4) {
              case "children":
                e5 = h4;
                break;
              case "dangerouslySetInnerHTML":
                g4 = h4;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                w8(a4, d4, l4, h4);
            }
        }
      a4.push(">");
      x9(a4, g4, e5);
      return e5;
    case "option":
      g4 = f4.selectedValue;
      a4.push(z7("option"));
      var k4 = h4 = null, m4 = null;
      var l4 = null;
      for (e5 in c4)
        if (n7.call(c4, e5)) {
          var p4 = c4[e5];
          if (p4 != null)
            switch (e5) {
              case "children":
                h4 = p4;
                break;
              case "selected":
                m4 = p4;
                break;
              case "dangerouslySetInnerHTML":
                l4 = p4;
                break;
              case "value":
                k4 = p4;
              default:
                w8(a4, d4, e5, p4);
            }
        }
      if (g4 != null)
        if (c4 = k4 !== null ? "" + k4 : va(h4), ra(g4))
          for (d4 = 0;d4 < g4.length; d4++) {
            if ("" + g4[d4] === c4) {
              a4.push(' selected=""');
              break;
            }
          }
        else
          "" + g4 === c4 && a4.push(' selected=""');
      else
        m4 && a4.push(' selected=""');
      a4.push(">");
      x9(a4, l4, h4);
      return h4;
    case "textarea":
      a4.push(z7("textarea"));
      l4 = g4 = e5 = null;
      for (h4 in c4)
        if (n7.call(c4, h4) && (k4 = c4[h4], k4 != null))
          switch (h4) {
            case "children":
              l4 = k4;
              break;
            case "value":
              e5 = k4;
              break;
            case "defaultValue":
              g4 = k4;
              break;
            case "dangerouslySetInnerHTML":
              throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              w8(a4, d4, h4, k4);
          }
      e5 === null && g4 !== null && (e5 = g4);
      a4.push(">");
      if (l4 != null) {
        if (e5 != null)
          throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (ra(l4) && 1 < l4.length)
          throw Error("<textarea> can only have at most one child.");
        e5 = "" + l4;
      }
      typeof e5 === "string" && e5[0] === "\n" && a4.push("\n");
      e5 !== null && a4.push(u9("" + e5));
      return null;
    case "input":
      a4.push(z7("input"));
      k4 = l4 = h4 = e5 = null;
      for (g4 in c4)
        if (n7.call(c4, g4) && (m4 = c4[g4], m4 != null))
          switch (g4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              k4 = m4;
              break;
            case "defaultValue":
              h4 = m4;
              break;
            case "checked":
              l4 = m4;
              break;
            case "value":
              e5 = m4;
              break;
            default:
              w8(a4, d4, g4, m4);
          }
      l4 !== null ? w8(a4, d4, "checked", l4) : k4 !== null && w8(a4, d4, "checked", k4);
      e5 !== null ? w8(a4, d4, "value", e5) : h4 !== null && w8(a4, d4, "value", h4);
      a4.push("/>");
      return null;
    case "menuitem":
      a4.push(z7("menuitem"));
      for (var B5 in c4)
        if (n7.call(c4, B5) && (e5 = c4[B5], e5 != null))
          switch (B5) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              w8(a4, d4, B5, e5);
          }
      a4.push(">");
      return null;
    case "title":
      a4.push(z7("title"));
      e5 = null;
      for (p4 in c4)
        if (n7.call(c4, p4) && (g4 = c4[p4], g4 != null))
          switch (p4) {
            case "children":
              e5 = g4;
              break;
            case "dangerouslySetInnerHTML":
              throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              w8(a4, d4, p4, g4);
          }
      a4.push(">");
      return e5;
    case "listing":
    case "pre":
      a4.push(z7(b4));
      g4 = e5 = null;
      for (k4 in c4)
        if (n7.call(c4, k4) && (h4 = c4[k4], h4 != null))
          switch (k4) {
            case "children":
              e5 = h4;
              break;
            case "dangerouslySetInnerHTML":
              g4 = h4;
              break;
            default:
              w8(a4, d4, k4, h4);
          }
      a4.push(">");
      if (g4 != null) {
        if (e5 != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof g4 !== "object" || !("__html" in g4))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        c4 = g4.__html;
        c4 !== null && c4 !== undefined && (typeof c4 === "string" && 0 < c4.length && c4[0] === "\n" ? a4.push("\n", c4) : a4.push("" + c4));
      }
      typeof e5 === "string" && e5[0] === "\n" && a4.push("\n");
      return e5;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a4.push(z7(b4));
      for (var C4 in c4)
        if (n7.call(c4, C4) && (e5 = c4[C4], e5 != null))
          switch (C4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(b4 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              w8(a4, d4, C4, e5);
          }
      a4.push("/>");
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return wa(a4, c4, b4, d4);
    case "html":
      return f4.insertionMode === 0 && a4.push("<!DOCTYPE html>"), wa(a4, c4, b4, d4);
    default:
      if (b4.indexOf("-") === -1 && typeof c4.is !== "string")
        return wa(a4, c4, b4, d4);
      a4.push(z7(b4));
      g4 = e5 = null;
      for (m4 in c4)
        if (n7.call(c4, m4) && (h4 = c4[m4], h4 != null))
          switch (m4) {
            case "children":
              e5 = h4;
              break;
            case "dangerouslySetInnerHTML":
              g4 = h4;
              break;
            case "style":
              ua(a4, d4, h4);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ka(m4) && typeof h4 !== "function" && typeof h4 !== "symbol" && a4.push(" ", m4, '="', u9(h4), '"');
          }
      a4.push(">");
      x9(a4, g4, e5);
      return e5;
  }
}
function Aa(a4, b4, c4) {
  a4.push('<!--$?--><template id="');
  if (c4 === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  a4.push(c4);
  return a4.push('"></template>');
}
function Ba(a4, b4, c4, d4) {
  switch (c4.insertionMode) {
    case 0:
    case 1:
      return a4.push('<div hidden id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 2:
      return a4.push('<svg aria-hidden="true" style="display:none" id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 3:
      return a4.push('<math aria-hidden="true" style="display:none" id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 4:
      return a4.push('<table hidden id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 5:
      return a4.push('<table hidden><tbody id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 6:
      return a4.push('<table hidden><tr id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    case 7:
      return a4.push('<table hidden><colgroup id="'), a4.push(b4.segmentPrefix), b4 = d4.toString(16), a4.push(b4), a4.push('">');
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function Ca(a4, b4) {
  switch (b4.insertionMode) {
    case 0:
    case 1:
      return a4.push("</div>");
    case 2:
      return a4.push("</svg>");
    case 3:
      return a4.push("</math>");
    case 4:
      return a4.push("</table>");
    case 5:
      return a4.push("</tbody></table>");
    case 6:
      return a4.push("</tr></table>");
    case 7:
      return a4.push("</colgroup></table>");
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function Ea(a4) {
  return JSON.stringify(a4).replace(Da, function(a7) {
    switch (a7) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function Fa(a4, b4) {
  b4 = b4 === undefined ? "" : b4;
  return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b4 + "P:", segmentPrefix: b4 + "S:", boundaryPrefix: b4 + "B:", idPrefix: b4, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a4 };
}
function Ga() {
  return { insertionMode: 1, selectedValue: null };
}
function Ha(a4, b4, c4, d4) {
  if (c4.generateStaticMarkup)
    return a4.push(u9(b4)), false;
  b4 === "" ? a4 = d4 : (d4 && a4.push("<!-- -->"), a4.push(u9(b4)), a4 = true);
  return a4;
}
function Za(a4) {
  if (a4 == null)
    return null;
  if (typeof a4 === "function")
    return a4.displayName || a4.name || null;
  if (typeof a4 === "string")
    return a4;
  switch (a4) {
    case Ka:
      return "Fragment";
    case Ja:
      return "Portal";
    case Ma:
      return "Profiler";
    case La:
      return "StrictMode";
    case Qa:
      return "Suspense";
    case Ra:
      return "SuspenseList";
  }
  if (typeof a4 === "object")
    switch (a4.$$typeof) {
      case Oa:
        return (a4.displayName || "Context") + ".Consumer";
      case Na:
        return (a4._context.displayName || "Context") + ".Provider";
      case Pa:
        var b4 = a4.render;
        a4 = a4.displayName;
        a4 || (a4 = b4.displayName || b4.name || "", a4 = a4 !== "" ? "ForwardRef(" + a4 + ")" : "ForwardRef");
        return a4;
      case Sa:
        return b4 = a4.displayName || null, b4 !== null ? b4 : Za(a4.type) || "Memo";
      case Ta:
        b4 = a4._payload;
        a4 = a4._init;
        try {
          return Za(a4(b4));
        } catch (c4) {
        }
    }
  return null;
}
function ab(a4, b4) {
  a4 = a4.contextTypes;
  if (!a4)
    return $a;
  var c4 = {}, d4;
  for (d4 in a4)
    c4[d4] = b4[d4];
  return c4;
}
function E7(a4, b4) {
  if (a4 !== b4) {
    a4.context._currentValue2 = a4.parentValue;
    a4 = a4.parent;
    var c4 = b4.parent;
    if (a4 === null) {
      if (c4 !== null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
    } else {
      if (c4 === null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      E7(a4, c4);
    }
    b4.context._currentValue2 = b4.value;
  }
}
function bb(a4) {
  a4.context._currentValue2 = a4.parentValue;
  a4 = a4.parent;
  a4 !== null && bb(a4);
}
function cb(a4) {
  var b4 = a4.parent;
  b4 !== null && cb(b4);
  a4.context._currentValue2 = a4.value;
}
function db2(a4, b4) {
  a4.context._currentValue2 = a4.parentValue;
  a4 = a4.parent;
  if (a4 === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  a4.depth === b4.depth ? E7(a4, b4) : db2(a4, b4);
}
function eb(a4, b4) {
  var c4 = b4.parent;
  if (c4 === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  a4.depth === c4.depth ? E7(a4, c4) : eb(a4, c4);
  b4.context._currentValue2 = b4.value;
}
function F6(a4) {
  var b4 = D7;
  b4 !== a4 && (b4 === null ? cb(a4) : a4 === null ? bb(b4) : b4.depth === a4.depth ? E7(b4, a4) : b4.depth > a4.depth ? db2(b4, a4) : eb(b4, a4), D7 = a4);
}
function gb(a4, b4, c4, d4) {
  var f4 = a4.state !== undefined ? a4.state : null;
  a4.updater = fb;
  a4.props = c4;
  a4.state = f4;
  var e5 = { queue: [], replace: false };
  a4._reactInternals = e5;
  var g4 = b4.contextType;
  a4.context = typeof g4 === "object" && g4 !== null ? g4._currentValue2 : d4;
  g4 = b4.getDerivedStateFromProps;
  typeof g4 === "function" && (g4 = g4(c4, f4), f4 = g4 === null || g4 === undefined ? f4 : A7({}, f4, g4), a4.state = f4);
  if (typeof b4.getDerivedStateFromProps !== "function" && typeof a4.getSnapshotBeforeUpdate !== "function" && (typeof a4.UNSAFE_componentWillMount === "function" || typeof a4.componentWillMount === "function"))
    if (b4 = a4.state, typeof a4.componentWillMount === "function" && a4.componentWillMount(), typeof a4.UNSAFE_componentWillMount === "function" && a4.UNSAFE_componentWillMount(), b4 !== a4.state && fb.enqueueReplaceState(a4, a4.state, null), e5.queue !== null && 0 < e5.queue.length)
      if (b4 = e5.queue, g4 = e5.replace, e5.queue = null, e5.replace = false, g4 && b4.length === 1)
        a4.state = b4[0];
      else {
        e5 = g4 ? b4[0] : a4.state;
        f4 = true;
        for (g4 = g4 ? 1 : 0;g4 < b4.length; g4++) {
          var h4 = b4[g4];
          h4 = typeof h4 === "function" ? h4.call(a4, e5, c4, d4) : h4;
          h4 != null && (f4 ? (f4 = false, e5 = A7({}, e5, h4)) : A7(e5, h4));
        }
        a4.state = e5;
      }
    else
      e5.queue = null;
}
function ib(a4, b4, c4) {
  var d4 = a4.id;
  a4 = a4.overflow;
  var f4 = 32 - G7(d4) - 1;
  d4 &= ~(1 << f4);
  c4 += 1;
  var e5 = 32 - G7(b4) + f4;
  if (30 < e5) {
    var g4 = f4 - f4 % 5;
    e5 = (d4 & (1 << g4) - 1).toString(32);
    d4 >>= g4;
    f4 -= g4;
    return { id: 1 << 32 - G7(b4) + f4 | c4 << f4 | d4, overflow: e5 + a4 };
  }
  return { id: 1 << e5 | c4 << f4 | d4, overflow: a4 };
}
function jb(a4) {
  a4 >>>= 0;
  return a4 === 0 ? 32 : 31 - (kb(a4) / lb | 0) | 0;
}
function mb(a4, b4) {
  return a4 === b4 && (a4 !== 0 || 1 / a4 === 1 / b4) || a4 !== a4 && b4 !== b4;
}
function P6() {
  if (H5 === null)
    throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
  return H5;
}
function rb4() {
  if (0 < O6)
    throw Error("Rendered more hooks than during the previous render");
  return { memoizedState: null, queue: null, next: null };
}
function sb() {
  J7 === null ? I7 === null ? (K2 = false, I7 = J7 = rb4()) : (K2 = true, J7 = I7) : J7.next === null ? (K2 = false, J7 = J7.next = rb4()) : (K2 = true, J7 = J7.next);
  return J7;
}
function tb() {
  ob = H5 = null;
  L5 = false;
  I7 = null;
  O6 = 0;
  J7 = N4 = null;
}
function ub(a4, b4) {
  return typeof b4 === "function" ? b4(a4) : b4;
}
function vb(a4, b4, c4) {
  H5 = P6();
  J7 = sb();
  if (K2) {
    var d4 = J7.queue;
    b4 = d4.dispatch;
    if (N4 !== null && (c4 = N4.get(d4), c4 !== undefined)) {
      N4.delete(d4);
      d4 = J7.memoizedState;
      do
        d4 = a4(d4, c4.action), c4 = c4.next;
      while (c4 !== null);
      J7.memoizedState = d4;
      return [d4, b4];
    }
    return [J7.memoizedState, b4];
  }
  a4 = a4 === ub ? typeof b4 === "function" ? b4() : b4 : c4 !== undefined ? c4(b4) : b4;
  J7.memoizedState = a4;
  a4 = J7.queue = { last: null, dispatch: null };
  a4 = a4.dispatch = wb.bind(null, H5, a4);
  return [J7.memoizedState, a4];
}
function xb(a4, b4) {
  H5 = P6();
  J7 = sb();
  b4 = b4 === undefined ? null : b4;
  if (J7 !== null) {
    var c4 = J7.memoizedState;
    if (c4 !== null && b4 !== null) {
      var d4 = c4[1];
      a:
        if (d4 === null)
          d4 = false;
        else {
          for (var f4 = 0;f4 < d4.length && f4 < b4.length; f4++)
            if (!nb(b4[f4], d4[f4])) {
              d4 = false;
              break a;
            }
          d4 = true;
        }
      if (d4)
        return c4[0];
    }
  }
  a4 = a4();
  J7.memoizedState = [a4, b4];
  return a4;
}
function wb(a4, b4, c4) {
  if (25 <= O6)
    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
  if (a4 === H5)
    if (L5 = true, a4 = { action: c4, next: null }, N4 === null && (N4 = new Map), c4 = N4.get(b4), c4 === undefined)
      N4.set(b4, a4);
    else {
      for (b4 = c4;b4.next !== null; )
        b4 = b4.next;
      b4.next = a4;
    }
}
function yb() {
  throw Error("startTransition cannot be called during server rendering.");
}
function Q4() {
}
function Bb(a4) {
  console.error(a4);
  return null;
}
function S5() {
}
function Cb(a4, b4, c4, d4, f4, e5, g4, h4, k4) {
  var m4 = [], l4 = new Set;
  b4 = { destination: null, responseState: b4, progressiveChunkSize: d4 === undefined ? 12800 : d4, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l4, pingedTasks: m4, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: f4 === undefined ? Bb : f4, onAllReady: e5 === undefined ? S5 : e5, onShellReady: g4 === undefined ? S5 : g4, onShellError: h4 === undefined ? S5 : h4, onFatalError: k4 === undefined ? S5 : k4 };
  c4 = T6(b4, 0, null, c4, false, false);
  c4.parentFlushed = true;
  a4 = Db(b4, a4, null, c4, l4, $a, null, hb);
  m4.push(a4);
  return b4;
}
function Db(a4, b4, c4, d4, f4, e5, g4, h4) {
  a4.allPendingTasks++;
  c4 === null ? a4.pendingRootTasks++ : c4.pendingTasks++;
  var k4 = { node: b4, ping: function() {
    var b9 = a4.pingedTasks;
    b9.push(k4);
    b9.length === 1 && Eb(a4);
  }, blockedBoundary: c4, blockedSegment: d4, abortSet: f4, legacyContext: e5, context: g4, treeContext: h4 };
  f4.add(k4);
  return k4;
}
function T6(a4, b4, c4, d4, f4, e5) {
  return { status: 0, id: -1, index: b4, parentFlushed: false, chunks: [], children: [], formatContext: d4, boundary: c4, lastPushedText: f4, textEmbedded: e5 };
}
function U4(a4, b4) {
  a4 = a4.onError(b4);
  if (a4 != null && typeof a4 !== "string")
    throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a4 + '" instead');
  return a4;
}
function V7(a4, b4) {
  var c4 = a4.onShellError;
  c4(b4);
  c4 = a4.onFatalError;
  c4(b4);
  a4.destination !== null ? (a4.status = 2, a4.destination.destroy(b4)) : (a4.status = 1, a4.fatalError = b4);
}
function Fb(a4, b4, c4, d4, f4) {
  H5 = {};
  ob = b4;
  M4 = 0;
  for (a4 = c4(d4, f4);L5; )
    L5 = false, M4 = 0, O6 += 1, J7 = null, a4 = c4(d4, f4);
  tb();
  return a4;
}
function Gb(a4, b4, c4, d4) {
  var f4 = c4.render(), e5 = d4.childContextTypes;
  if (e5 !== null && e5 !== undefined) {
    var g4 = b4.legacyContext;
    if (typeof c4.getChildContext !== "function")
      d4 = g4;
    else {
      c4 = c4.getChildContext();
      for (var h4 in c4)
        if (!(h4 in e5))
          throw Error((Za(d4) || "Unknown") + '.getChildContext(): key "' + h4 + '" is not defined in childContextTypes.');
      d4 = A7({}, g4, c4);
    }
    b4.legacyContext = d4;
    W4(a4, b4, f4);
    b4.legacyContext = g4;
  } else
    W4(a4, b4, f4);
}
function Hb(a4, b4) {
  if (a4 && a4.defaultProps) {
    b4 = A7({}, b4);
    a4 = a4.defaultProps;
    for (var c4 in a4)
      b4[c4] === undefined && (b4[c4] = a4[c4]);
    return b4;
  }
  return b4;
}
function Ib(a4, b4, c4, d4, f4) {
  if (typeof c4 === "function")
    if (c4.prototype && c4.prototype.isReactComponent) {
      f4 = ab(c4, b4.legacyContext);
      var e5 = c4.contextType;
      e5 = new c4(d4, typeof e5 === "object" && e5 !== null ? e5._currentValue2 : f4);
      gb(e5, c4, d4, f4);
      Gb(a4, b4, e5, c4);
    } else {
      e5 = ab(c4, b4.legacyContext);
      f4 = Fb(a4, b4, c4, d4, e5);
      var g4 = M4 !== 0;
      if (typeof f4 === "object" && f4 !== null && typeof f4.render === "function" && f4.$$typeof === undefined)
        gb(f4, c4, d4, e5), Gb(a4, b4, f4, c4);
      else if (g4) {
        d4 = b4.treeContext;
        b4.treeContext = ib(d4, 1, 0);
        try {
          W4(a4, b4, f4);
        } finally {
          b4.treeContext = d4;
        }
      } else
        W4(a4, b4, f4);
    }
  else if (typeof c4 === "string") {
    f4 = b4.blockedSegment;
    e5 = za(f4.chunks, c4, d4, a4.responseState, f4.formatContext);
    f4.lastPushedText = false;
    g4 = f4.formatContext;
    f4.formatContext = sa(g4, c4, d4);
    Jb(a4, b4, e5);
    f4.formatContext = g4;
    switch (c4) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f4.chunks.push("</", c4, ">");
    }
    f4.lastPushedText = false;
  } else {
    switch (c4) {
      case Wa:
      case Va:
      case La:
      case Ma:
      case Ka:
        W4(a4, b4, d4.children);
        return;
      case Ra:
        W4(a4, b4, d4.children);
        return;
      case Ua:
        throw Error("ReactDOMServer does not yet support scope components.");
      case Qa:
        a: {
          c4 = b4.blockedBoundary;
          f4 = b4.blockedSegment;
          e5 = d4.fallback;
          d4 = d4.children;
          g4 = new Set;
          var h4 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g4, errorDigest: null }, k4 = T6(a4, f4.chunks.length, h4, f4.formatContext, false, false);
          f4.children.push(k4);
          f4.lastPushedText = false;
          var m4 = T6(a4, 0, null, f4.formatContext, false, false);
          m4.parentFlushed = true;
          b4.blockedBoundary = h4;
          b4.blockedSegment = m4;
          try {
            if (Jb(a4, b4, d4), a4.responseState.generateStaticMarkup || m4.lastPushedText && m4.textEmbedded && m4.chunks.push("<!-- -->"), m4.status = 1, X6(h4, m4), h4.pendingTasks === 0)
              break a;
          } catch (l4) {
            m4.status = 4, h4.forceClientRender = true, h4.errorDigest = U4(a4, l4);
          } finally {
            b4.blockedBoundary = c4, b4.blockedSegment = f4;
          }
          b4 = Db(a4, e5, c4, k4, g4, b4.legacyContext, b4.context, b4.treeContext);
          a4.pingedTasks.push(b4);
        }
        return;
    }
    if (typeof c4 === "object" && c4 !== null)
      switch (c4.$$typeof) {
        case Pa:
          d4 = Fb(a4, b4, c4.render, d4, f4);
          if (M4 !== 0) {
            c4 = b4.treeContext;
            b4.treeContext = ib(c4, 1, 0);
            try {
              W4(a4, b4, d4);
            } finally {
              b4.treeContext = c4;
            }
          } else
            W4(a4, b4, d4);
          return;
        case Sa:
          c4 = c4.type;
          d4 = Hb(c4, d4);
          Ib(a4, b4, c4, d4, f4);
          return;
        case Na:
          f4 = d4.children;
          c4 = c4._context;
          d4 = d4.value;
          e5 = c4._currentValue2;
          c4._currentValue2 = d4;
          g4 = D7;
          D7 = d4 = { parent: g4, depth: g4 === null ? 0 : g4.depth + 1, context: c4, parentValue: e5, value: d4 };
          b4.context = d4;
          W4(a4, b4, f4);
          a4 = D7;
          if (a4 === null)
            throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          d4 = a4.parentValue;
          a4.context._currentValue2 = d4 === Xa ? a4.context._defaultValue : d4;
          a4 = D7 = a4.parent;
          b4.context = a4;
          return;
        case Oa:
          d4 = d4.children;
          d4 = d4(c4._currentValue2);
          W4(a4, b4, d4);
          return;
        case Ta:
          f4 = c4._init;
          c4 = f4(c4._payload);
          d4 = Hb(c4, d4);
          Ib(a4, b4, c4, d4, undefined);
          return;
      }
    throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c4 == null ? c4 : typeof c4) + "."));
  }
}
function W4(a4, b4, c4) {
  b4.node = c4;
  if (typeof c4 === "object" && c4 !== null) {
    switch (c4.$$typeof) {
      case Ia:
        Ib(a4, b4, c4.type, c4.props, c4.ref);
        return;
      case Ja:
        throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
      case Ta:
        var d4 = c4._init;
        c4 = d4(c4._payload);
        W4(a4, b4, c4);
        return;
    }
    if (ra(c4)) {
      Kb(a4, b4, c4);
      return;
    }
    c4 === null || typeof c4 !== "object" ? d4 = null : (d4 = Ya && c4[Ya] || c4["@@iterator"], d4 = typeof d4 === "function" ? d4 : null);
    if (d4 && (d4 = d4.call(c4))) {
      c4 = d4.next();
      if (!c4.done) {
        var f4 = [];
        do
          f4.push(c4.value), c4 = d4.next();
        while (!c4.done);
        Kb(a4, b4, f4);
      }
      return;
    }
    a4 = Object.prototype.toString.call(c4);
    throw Error("Objects are not valid as a React child (found: " + (a4 === "[object Object]" ? "object with keys {" + Object.keys(c4).join(", ") + "}" : a4) + "). If you meant to render a collection of children, use an array instead.");
  }
  typeof c4 === "string" ? (d4 = b4.blockedSegment, d4.lastPushedText = Ha(b4.blockedSegment.chunks, c4, a4.responseState, d4.lastPushedText)) : typeof c4 === "number" && (d4 = b4.blockedSegment, d4.lastPushedText = Ha(b4.blockedSegment.chunks, "" + c4, a4.responseState, d4.lastPushedText));
}
function Kb(a4, b4, c4) {
  for (var d4 = c4.length, f4 = 0;f4 < d4; f4++) {
    var e5 = b4.treeContext;
    b4.treeContext = ib(e5, d4, f4);
    try {
      Jb(a4, b4, c4[f4]);
    } finally {
      b4.treeContext = e5;
    }
  }
}
function Jb(a4, b4, c4) {
  var d4 = b4.blockedSegment.formatContext, f4 = b4.legacyContext, e5 = b4.context;
  try {
    return W4(a4, b4, c4);
  } catch (k4) {
    if (tb(), typeof k4 === "object" && k4 !== null && typeof k4.then === "function") {
      c4 = k4;
      var g4 = b4.blockedSegment, h4 = T6(a4, g4.chunks.length, null, g4.formatContext, g4.lastPushedText, true);
      g4.children.push(h4);
      g4.lastPushedText = false;
      a4 = Db(a4, b4.node, b4.blockedBoundary, h4, b4.abortSet, b4.legacyContext, b4.context, b4.treeContext).ping;
      c4.then(a4, a4);
      b4.blockedSegment.formatContext = d4;
      b4.legacyContext = f4;
      b4.context = e5;
      F6(e5);
    } else
      throw b4.blockedSegment.formatContext = d4, b4.legacyContext = f4, b4.context = e5, F6(e5), k4;
  }
}
function Lb(a4) {
  var b4 = a4.blockedBoundary;
  a4 = a4.blockedSegment;
  a4.status = 3;
  Mb(this, b4, a4);
}
function Nb(a4, b4, c4) {
  var d4 = a4.blockedBoundary;
  a4.blockedSegment.status = 3;
  d4 === null ? (b4.allPendingTasks--, b4.status !== 2 && (b4.status = 2, b4.destination !== null && b4.destination.push(null))) : (d4.pendingTasks--, d4.forceClientRender || (d4.forceClientRender = true, d4.errorDigest = b4.onError(c4 === undefined ? Error("The render was aborted by the server without a reason.") : c4), d4.parentFlushed && b4.clientRenderedBoundaries.push(d4)), d4.fallbackAbortableTasks.forEach(function(a7) {
    return Nb(a7, b4, c4);
  }), d4.fallbackAbortableTasks.clear(), b4.allPendingTasks--, b4.allPendingTasks === 0 && (a4 = b4.onAllReady, a4()));
}
function X6(a4, b4) {
  if (b4.chunks.length === 0 && b4.children.length === 1 && b4.children[0].boundary === null) {
    var c4 = b4.children[0];
    c4.id = b4.id;
    c4.parentFlushed = true;
    c4.status === 1 && X6(a4, c4);
  } else
    a4.completedSegments.push(b4);
}
function Mb(a4, b4, c4) {
  if (b4 === null) {
    if (c4.parentFlushed) {
      if (a4.completedRootSegment !== null)
        throw Error("There can only be one root segment. This is a bug in React.");
      a4.completedRootSegment = c4;
    }
    a4.pendingRootTasks--;
    a4.pendingRootTasks === 0 && (a4.onShellError = S5, b4 = a4.onShellReady, b4());
  } else
    b4.pendingTasks--, b4.forceClientRender || (b4.pendingTasks === 0 ? (c4.parentFlushed && c4.status === 1 && X6(b4, c4), b4.parentFlushed && a4.completedBoundaries.push(b4), b4.fallbackAbortableTasks.forEach(Lb, a4), b4.fallbackAbortableTasks.clear()) : c4.parentFlushed && c4.status === 1 && (X6(b4, c4), b4.completedSegments.length === 1 && b4.parentFlushed && a4.partialBoundaries.push(b4)));
  a4.allPendingTasks--;
  a4.allPendingTasks === 0 && (a4 = a4.onAllReady, a4());
}
function Eb(a4) {
  if (a4.status !== 2) {
    var b4 = D7, c4 = Ab.current;
    Ab.current = zb;
    var d4 = R3;
    R3 = a4.responseState;
    try {
      var f4 = a4.pingedTasks, e5;
      for (e5 = 0;e5 < f4.length; e5++) {
        var g4 = f4[e5];
        var h4 = a4, k4 = g4.blockedSegment;
        if (k4.status === 0) {
          F6(g4.context);
          try {
            W4(h4, g4, g4.node), h4.responseState.generateStaticMarkup || k4.lastPushedText && k4.textEmbedded && k4.chunks.push("<!-- -->"), g4.abortSet.delete(g4), k4.status = 1, Mb(h4, g4.blockedBoundary, k4);
          } catch (y4) {
            if (tb(), typeof y4 === "object" && y4 !== null && typeof y4.then === "function") {
              var m4 = g4.ping;
              y4.then(m4, m4);
            } else {
              g4.abortSet.delete(g4);
              k4.status = 4;
              var l4 = g4.blockedBoundary, p4 = y4, B5 = U4(h4, p4);
              l4 === null ? V7(h4, p4) : (l4.pendingTasks--, l4.forceClientRender || (l4.forceClientRender = true, l4.errorDigest = B5, l4.parentFlushed && h4.clientRenderedBoundaries.push(l4)));
              h4.allPendingTasks--;
              if (h4.allPendingTasks === 0) {
                var C4 = h4.onAllReady;
                C4();
              }
            }
          } finally {
          }
        }
      }
      f4.splice(0, e5);
      a4.destination !== null && Ob(a4, a4.destination);
    } catch (y4) {
      U4(a4, y4), V7(a4, y4);
    } finally {
      R3 = d4, Ab.current = c4, c4 === zb && F6(b4);
    }
  }
}
function Y(a4, b4, c4) {
  c4.parentFlushed = true;
  switch (c4.status) {
    case 0:
      var d4 = c4.id = a4.nextSegmentId++;
      c4.lastPushedText = false;
      c4.textEmbedded = false;
      a4 = a4.responseState;
      b4.push('<template id="');
      b4.push(a4.placeholderPrefix);
      a4 = d4.toString(16);
      b4.push(a4);
      return b4.push('"></template>');
    case 1:
      c4.status = 2;
      var f4 = true;
      d4 = c4.chunks;
      var e5 = 0;
      c4 = c4.children;
      for (var g4 = 0;g4 < c4.length; g4++) {
        for (f4 = c4[g4];e5 < f4.index; e5++)
          b4.push(d4[e5]);
        f4 = Z(a4, b4, f4);
      }
      for (;e5 < d4.length - 1; e5++)
        b4.push(d4[e5]);
      e5 < d4.length && (f4 = b4.push(d4[e5]));
      return f4;
    default:
      throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
  }
}
function Z(a4, b4, c4) {
  var d4 = c4.boundary;
  if (d4 === null)
    return Y(a4, b4, c4);
  d4.parentFlushed = true;
  if (d4.forceClientRender)
    return a4.responseState.generateStaticMarkup || (d4 = d4.errorDigest, b4.push("<!--$!-->"), b4.push("<template"), d4 && (b4.push(' data-dgst="'), d4 = u9(d4), b4.push(d4), b4.push('"')), b4.push("></template>")), Y(a4, b4, c4), a4 = a4.responseState.generateStaticMarkup ? true : b4.push("<!--/$-->"), a4;
  if (0 < d4.pendingTasks) {
    d4.rootSegmentID = a4.nextSegmentId++;
    0 < d4.completedSegments.length && a4.partialBoundaries.push(d4);
    var f4 = a4.responseState;
    var e5 = f4.nextSuspenseID++;
    f4 = f4.boundaryPrefix + e5.toString(16);
    d4 = d4.id = f4;
    Aa(b4, a4.responseState, d4);
    Y(a4, b4, c4);
    return b4.push("<!--/$-->");
  }
  if (d4.byteSize > a4.progressiveChunkSize)
    return d4.rootSegmentID = a4.nextSegmentId++, a4.completedBoundaries.push(d4), Aa(b4, a4.responseState, d4.id), Y(a4, b4, c4), b4.push("<!--/$-->");
  a4.responseState.generateStaticMarkup || b4.push("<!--$-->");
  c4 = d4.completedSegments;
  if (c4.length !== 1)
    throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
  Z(a4, b4, c4[0]);
  a4 = a4.responseState.generateStaticMarkup ? true : b4.push("<!--/$-->");
  return a4;
}
function Pb(a4, b4, c4) {
  Ba(b4, a4.responseState, c4.formatContext, c4.id);
  Z(a4, b4, c4);
  return Ca(b4, c4.formatContext);
}
function Qb(a4, b4, c4) {
  for (var d4 = c4.completedSegments, f4 = 0;f4 < d4.length; f4++)
    Rb(a4, b4, c4, d4[f4]);
  d4.length = 0;
  a4 = a4.responseState;
  d4 = c4.id;
  c4 = c4.rootSegmentID;
  b4.push(a4.startInlineScript);
  a4.sentCompleteBoundaryFunction ? b4.push('$RC("') : (a4.sentCompleteBoundaryFunction = true, b4.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
  if (d4 === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  c4 = c4.toString(16);
  b4.push(d4);
  b4.push('","');
  b4.push(a4.segmentPrefix);
  b4.push(c4);
  return b4.push('")</script>');
}
function Rb(a4, b4, c4, d4) {
  if (d4.status === 2)
    return true;
  var f4 = d4.id;
  if (f4 === -1) {
    if ((d4.id = c4.rootSegmentID) === -1)
      throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
    return Pb(a4, b4, d4);
  }
  Pb(a4, b4, d4);
  a4 = a4.responseState;
  b4.push(a4.startInlineScript);
  a4.sentCompleteSegmentFunction ? b4.push('$RS("') : (a4.sentCompleteSegmentFunction = true, b4.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
  b4.push(a4.segmentPrefix);
  f4 = f4.toString(16);
  b4.push(f4);
  b4.push('","');
  b4.push(a4.placeholderPrefix);
  b4.push(f4);
  return b4.push('")</script>');
}
function Ob(a4, b4) {
  try {
    var c4 = a4.completedRootSegment;
    if (c4 !== null && a4.pendingRootTasks === 0) {
      Z(a4, b4, c4);
      a4.completedRootSegment = null;
      var d4 = a4.responseState.bootstrapChunks;
      for (c4 = 0;c4 < d4.length - 1; c4++)
        b4.push(d4[c4]);
      c4 < d4.length && b4.push(d4[c4]);
    }
    var f4 = a4.clientRenderedBoundaries, e5;
    for (e5 = 0;e5 < f4.length; e5++) {
      var g4 = f4[e5];
      d4 = b4;
      var h4 = a4.responseState, k4 = g4.id, m4 = g4.errorDigest, l4 = g4.errorMessage, p4 = g4.errorComponentStack;
      d4.push(h4.startInlineScript);
      h4.sentClientRenderFunction ? d4.push('$RX("') : (h4.sentClientRenderFunction = true, d4.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
      if (k4 === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      d4.push(k4);
      d4.push('"');
      if (m4 || l4 || p4) {
        d4.push(",");
        var B5 = Ea(m4 || "");
        d4.push(B5);
      }
      if (l4 || p4) {
        d4.push(",");
        var C4 = Ea(l4 || "");
        d4.push(C4);
      }
      if (p4) {
        d4.push(",");
        var y4 = Ea(p4);
        d4.push(y4);
      }
      if (!d4.push(")</script>")) {
        a4.destination = null;
        e5++;
        f4.splice(0, e5);
        return;
      }
    }
    f4.splice(0, e5);
    var aa = a4.completedBoundaries;
    for (e5 = 0;e5 < aa.length; e5++)
      if (!Qb(a4, b4, aa[e5])) {
        a4.destination = null;
        e5++;
        aa.splice(0, e5);
        return;
      }
    aa.splice(0, e5);
    var ba = a4.partialBoundaries;
    for (e5 = 0;e5 < ba.length; e5++) {
      var pb = ba[e5];
      a: {
        f4 = a4;
        g4 = b4;
        var ca = pb.completedSegments;
        for (h4 = 0;h4 < ca.length; h4++)
          if (!Rb(f4, g4, pb, ca[h4])) {
            h4++;
            ca.splice(0, h4);
            var qb = false;
            break a;
          }
        ca.splice(0, h4);
        qb = true;
      }
      if (!qb) {
        a4.destination = null;
        e5++;
        ba.splice(0, e5);
        return;
      }
    }
    ba.splice(0, e5);
    var da = a4.completedBoundaries;
    for (e5 = 0;e5 < da.length; e5++)
      if (!Qb(a4, b4, da[e5])) {
        a4.destination = null;
        e5++;
        da.splice(0, e5);
        return;
      }
    da.splice(0, e5);
  } finally {
    a4.allPendingTasks === 0 && a4.pingedTasks.length === 0 && a4.clientRenderedBoundaries.length === 0 && a4.completedBoundaries.length === 0 && b4.push(null);
  }
}
function Sb(a4, b4) {
  if (a4.status === 1)
    a4.status = 2, b4.destroy(a4.fatalError);
  else if (a4.status !== 2 && a4.destination === null) {
    a4.destination = b4;
    try {
      Ob(a4, b4);
    } catch (c4) {
      U4(a4, c4), V7(a4, c4);
    }
  }
}
function Tb(a4, b4) {
  try {
    var c4 = a4.abortableTasks;
    c4.forEach(function(c8) {
      return Nb(c8, a4, b4);
    });
    c4.clear();
    a4.destination !== null && Ob(a4, a4.destination);
  } catch (d4) {
    U4(a4, d4), V7(a4, d4);
  }
}
function Ub() {
}
function Vb(a4, b4, c4, d4) {
  var f4 = false, e5 = null, g4 = "", h4 = false;
  a4 = Cb(a4, Fa(c4, b4 ? b4.identifierPrefix : undefined), Ga(), Infinity, Ub, undefined, function() {
    h4 = true;
  }, undefined, undefined);
  Eb(a4);
  Tb(a4, d4);
  Sb(a4, { push: function(a7) {
    a7 !== null && (g4 += a7);
    return true;
  }, destroy: function(a7) {
    f4 = true;
    e5 = a7;
  } });
  if (f4)
    throw e5;
  if (!h4)
    throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
  return g4;
}
function Wb(a4, b4) {
  a4.prototype = Object.create(b4.prototype);
  a4.prototype.constructor = a4;
  a4.__proto__ = b4;
}
function Yb() {
}
function Zb(a4, b4) {
  var c4 = new Xb, d4 = Cb(a4, Fa(false, b4 ? b4.identifierPrefix : undefined), Ga(), Infinity, Yb, function() {
    c4.startedFlowing = true;
    Sb(d4, c4);
  }, undefined, undefined);
  c4.request = d4;
  Eb(d4);
  return c4;
}
var ea, n7, ha, ia, ja, r8, la, t9, na, oa, pa, qa, ra, ta, xa, ya, Da, A7, Ia, Ja, Ka, La, Ma, Na, Oa, Pa, Qa, Ra, Sa, Ta, Ua, Va, Wa, Xa, Ya, $a, D7 = null, fb, hb, G7, kb, lb, nb, H5 = null, ob = null, I7 = null, J7 = null, K2 = false, L5 = false, M4 = 0, N4 = null, O6 = 0, zb, R3 = null, Ab, Xb, $renderToNodeStream = function(a4, b4) {
  return Zb(a4, b4);
}, $renderToStaticMarkup = function(a4, b4) {
  return Vb(a4, b4, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
}, $renderToStaticNodeStream = function(a4, b4) {
  return Zb(a4, b4);
}, $renderToString = function(a4, b4) {
  return Vb(a4, b4, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
}, $version2 = "18.3.1";
var init_react_dom_server_legacy_node_production_min = __esm(() => {
  ea = __toESM(require_react(), 1);
  n7 = Object.prototype.hasOwnProperty;
  ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
  ia = {};
  ja = {};
  r8 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
    r8[a4] = new q11(a4, 0, false, a4, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
    var b4 = a4[0];
    r8[b4] = new q11(b4, 1, false, a4[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
    r8[a4] = new q11(a4, 2, false, a4.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
    r8[a4] = new q11(a4, 2, false, a4, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
    r8[a4] = new q11(a4, 3, false, a4.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a4) {
    r8[a4] = new q11(a4, 3, true, a4, null, false, false);
  });
  ["capture", "download"].forEach(function(a4) {
    r8[a4] = new q11(a4, 4, false, a4, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a4) {
    r8[a4] = new q11(a4, 6, false, a4, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a4) {
    r8[a4] = new q11(a4, 5, false, a4.toLowerCase(), null, false, false);
  });
  la = /[\-:]([a-z])/g;
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
    var b4 = a4.replace(la, ma);
    r8[b4] = new q11(b4, 1, false, a4, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
    var b4 = a4.replace(la, ma);
    r8[b4] = new q11(b4, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
    var b4 = a4.replace(la, ma);
    r8[b4] = new q11(b4, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a4) {
    r8[a4] = new q11(a4, 1, false, a4.toLowerCase(), null, false, false);
  });
  r8.xlinkHref = new q11("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a4) {
    r8[a4] = new q11(a4, 1, false, a4.toLowerCase(), null, true, true);
  });
  t9 = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  na = ["Webkit", "ms", "Moz", "O"];
  Object.keys(t9).forEach(function(a4) {
    na.forEach(function(b4) {
      b4 = b4 + a4.charAt(0).toUpperCase() + a4.substring(1);
      t9[b4] = t9[a4];
    });
  });
  oa = /["'&<>]/;
  pa = /([A-Z])/g;
  qa = /^ms-/;
  ra = Array.isArray;
  ta = new Map;
  xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
  ya = new Map;
  Da = /[<\u2028\u2029]/g;
  A7 = Object.assign;
  Ia = Symbol.for("react.element");
  Ja = Symbol.for("react.portal");
  Ka = Symbol.for("react.fragment");
  La = Symbol.for("react.strict_mode");
  Ma = Symbol.for("react.profiler");
  Na = Symbol.for("react.provider");
  Oa = Symbol.for("react.context");
  Pa = Symbol.for("react.forward_ref");
  Qa = Symbol.for("react.suspense");
  Ra = Symbol.for("react.suspense_list");
  Sa = Symbol.for("react.memo");
  Ta = Symbol.for("react.lazy");
  Ua = Symbol.for("react.scope");
  Va = Symbol.for("react.debug_trace_mode");
  Wa = Symbol.for("react.legacy_hidden");
  Xa = Symbol.for("react.default_value");
  Ya = Symbol.iterator;
  $a = {};
  fb = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a4, b4) {
    a4 = a4._reactInternals;
    a4.queue !== null && a4.queue.push(b4);
  }, enqueueReplaceState: function(a4, b4) {
    a4 = a4._reactInternals;
    a4.replace = true;
    a4.queue = [b4];
  }, enqueueForceUpdate: function() {
  } };
  hb = { id: 1, overflow: "" };
  G7 = Math.clz32 ? Math.clz32 : jb;
  kb = Math.log;
  lb = Math.LN2;
  nb = typeof Object.is === "function" ? Object.is : mb;
  zb = { readContext: function(a4) {
    return a4._currentValue2;
  }, useContext: function(a4) {
    P6();
    return a4._currentValue2;
  }, useMemo: xb, useReducer: vb, useRef: function(a4) {
    H5 = P6();
    J7 = sb();
    var b4 = J7.memoizedState;
    return b4 === null ? (a4 = { current: a4 }, J7.memoizedState = a4) : b4;
  }, useState: function(a4) {
    return vb(ub, a4);
  }, useInsertionEffect: Q4, useLayoutEffect: function() {
  }, useCallback: function(a4, b4) {
    return xb(function() {
      return a4;
    }, b4);
  }, useImperativeHandle: Q4, useEffect: Q4, useDebugValue: Q4, useDeferredValue: function(a4) {
    P6();
    return a4;
  }, useTransition: function() {
    P6();
    return [false, yb];
  }, useId: function() {
    var a4 = ob.treeContext;
    var b4 = a4.overflow;
    a4 = a4.id;
    a4 = (a4 & ~(1 << 32 - G7(a4) - 1)).toString(32) + b4;
    var c4 = R3;
    if (c4 === null)
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
    b4 = M4++;
    a4 = ":" + c4.idPrefix + "R" + a4;
    0 < b4 && (a4 += "H" + b4.toString(32));
    return a4 + ":";
  }, useMutableSource: function(a4, b4) {
    P6();
    return b4(a4._source);
  }, useSyncExternalStore: function(a4, b4, c4) {
    if (c4 === undefined)
      throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
    return c4();
  } };
  Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  Xb = function(a4) {
    function b4() {
      var b9 = a4.call(this, {}) || this;
      b9.request = null;
      b9.startedFlowing = false;
      return b9;
    }
    Wb(b4, a4);
    var c4 = b4.prototype;
    c4._destroy = function(a7, b9) {
      Tb(this.request);
      b9(a7);
    };
    c4._read = function() {
      this.startedFlowing && Sb(this.request, this);
    };
    return b4;
  }(fa.Readable);
});

// ../node_modules/react-dom/cjs/react-dom-server.node.production.min.js
var exports_react_dom_server_node_production_min = {};
__export(exports_react_dom_server_node_production_min, {
  version: () => $version3,
  renderToPipeableStream: () => $renderToPipeableStream
});
import * as aa from "util";
function r9(a4, b4) {
  if (typeof b4 === "string") {
    if (b4.length !== 0)
      if (2048 < 3 * b4.length)
        0 < l8 && (t10(a4, k9.subarray(0, l8)), k9 = new Uint8Array(2048), l8 = 0), t10(a4, u10.encode(b4));
      else {
        var c4 = k9;
        0 < l8 && (c4 = k9.subarray(l8));
        c4 = u10.encodeInto(b4, c4);
        var d4 = c4.read;
        l8 += c4.written;
        d4 < b4.length && (t10(a4, k9), k9 = new Uint8Array(2048), l8 = u10.encodeInto(b4.slice(d4), k9).written);
        l8 === 2048 && (t10(a4, k9), k9 = new Uint8Array(2048), l8 = 0);
      }
  } else
    b4.byteLength !== 0 && (2048 < b4.byteLength ? (0 < l8 && (t10(a4, k9.subarray(0, l8)), k9 = new Uint8Array(2048), l8 = 0), t10(a4, b4)) : (c4 = k9.length - l8, c4 < b4.byteLength && (c4 === 0 ? t10(a4, k9) : (k9.set(b4.subarray(0, c4), l8), l8 += c4, t10(a4, k9), b4 = b4.subarray(c4)), k9 = new Uint8Array(2048), l8 = 0), k9.set(b4, l8), l8 += b4.byteLength, l8 === 2048 && (t10(a4, k9), k9 = new Uint8Array(2048), l8 = 0)));
}
function t10(a4, b4) {
  a4 = a4.write(b4);
  q12 = q12 && a4;
}
function w9(a4, b4) {
  r9(a4, b4);
  return q12;
}
function ca(a4) {
  k9 && 0 < l8 && a4.write(k9.subarray(0, l8));
  k9 = null;
  l8 = 0;
  q12 = true;
}
function x10(a4) {
  return u10.encode(a4);
}
function ha2(a4) {
  if (y6.call(fa2, a4))
    return true;
  if (y6.call(ea2, a4))
    return false;
  if (da.test(a4))
    return fa2[a4] = true;
  ea2[a4] = true;
  return false;
}
function z8(a4, b4, c4, d4, f4, e5, g4) {
  this.acceptsBooleans = b4 === 2 || b4 === 3 || b4 === 4;
  this.attributeName = d4;
  this.attributeNamespace = f4;
  this.mustUseProperty = c4;
  this.propertyName = a4;
  this.type = b4;
  this.sanitizeURL = e5;
  this.removeEmptyString = g4;
}
function ja2(a4) {
  return a4[1].toUpperCase();
}
function F7(a4) {
  if (typeof a4 === "boolean" || typeof a4 === "number")
    return "" + a4;
  a4 = "" + a4;
  var b4 = la2.exec(a4);
  if (b4) {
    var c4 = "", d4, f4 = 0;
    for (d4 = b4.index;d4 < a4.length; d4++) {
      switch (a4.charCodeAt(d4)) {
        case 34:
          b4 = "&quot;";
          break;
        case 38:
          b4 = "&amp;";
          break;
        case 39:
          b4 = "&#x27;";
          break;
        case 60:
          b4 = "&lt;";
          break;
        case 62:
          b4 = "&gt;";
          break;
        default:
          continue;
      }
      f4 !== d4 && (c4 += a4.substring(f4, d4));
      f4 = d4 + 1;
      c4 += b4;
    }
    a4 = f4 !== d4 ? c4 + a4.substring(f4, d4) : c4;
  }
  return a4;
}
function xa2(a4, b4, c4, d4) {
  return "" + b4 + (c4 === "s" ? "\\u0073" : "\\u0053") + d4;
}
function G8(a4, b4) {
  return { insertionMode: a4, selectedValue: b4 };
}
function ya2(a4, b4, c4) {
  switch (b4) {
    case "select":
      return G8(1, c4.value != null ? c4.value : c4.defaultValue);
    case "svg":
      return G8(2, null);
    case "math":
      return G8(3, null);
    case "foreignObject":
      return G8(1, null);
    case "table":
      return G8(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return G8(5, null);
    case "colgroup":
      return G8(7, null);
    case "tr":
      return G8(6, null);
  }
  return 4 <= a4.insertionMode || a4.insertionMode === 0 ? G8(1, null) : a4;
}
function Aa2(a4, b4, c4, d4) {
  if (b4 === "")
    return d4;
  d4 && a4.push(za2);
  a4.push(F7(b4));
  return true;
}
function Fa2(a4, b4, c4) {
  if (typeof c4 !== "object")
    throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
  b4 = true;
  for (var d4 in c4)
    if (y6.call(c4, d4)) {
      var f4 = c4[d4];
      if (f4 != null && typeof f4 !== "boolean" && f4 !== "") {
        if (d4.indexOf("--") === 0) {
          var e5 = F7(d4);
          f4 = F7(("" + f4).trim());
        } else {
          e5 = d4;
          var g4 = Ba2.get(e5);
          g4 !== undefined ? e5 = g4 : (g4 = x10(F7(e5.replace(ma2, "-$1").toLowerCase().replace(pa2, "-ms-"))), Ba2.set(e5, g4), e5 = g4);
          f4 = typeof f4 === "number" ? f4 === 0 || y6.call(B6, d4) ? "" + f4 : f4 + "px" : F7(("" + f4).trim());
        }
        b4 ? (b4 = false, a4.push(Ca2, e5, Da2, f4)) : a4.push(Ea2, e5, Da2, f4);
      }
    }
  b4 || a4.push(H6);
}
function K4(a4, b4, c4, d4) {
  switch (c4) {
    case "style":
      Fa2(a4, b4, d4);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c4.length) || c4[0] !== "o" && c4[0] !== "O" || c4[1] !== "n" && c4[1] !== "N") {
    if (b4 = A8.hasOwnProperty(c4) ? A8[c4] : null, b4 !== null) {
      switch (typeof d4) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b4.acceptsBooleans)
            return;
      }
      c4 = b4.attributeName;
      switch (b4.type) {
        case 3:
          d4 && a4.push(I8, c4, Ga2);
          break;
        case 4:
          d4 === true ? a4.push(I8, c4, Ga2) : d4 !== false && a4.push(I8, c4, J8, F7(d4), H6);
          break;
        case 5:
          isNaN(d4) || a4.push(I8, c4, J8, F7(d4), H6);
          break;
        case 6:
          !isNaN(d4) && 1 <= d4 && a4.push(I8, c4, J8, F7(d4), H6);
          break;
        default:
          b4.sanitizeURL && (d4 = "" + d4), a4.push(I8, c4, J8, F7(d4), H6);
      }
    } else if (ha2(c4)) {
      switch (typeof d4) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b4 = c4.toLowerCase().slice(0, 5), b4 !== "data-" && b4 !== "aria-")
            return;
      }
      a4.push(I8, c4, J8, F7(d4), H6);
    }
  }
}
function M6(a4, b4, c4) {
  if (b4 != null) {
    if (c4 != null)
      throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
    if (typeof b4 !== "object" || !("__html" in b4))
      throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
    b4 = b4.__html;
    b4 !== null && b4 !== undefined && a4.push("" + b4);
  }
}
function Ia2(a4) {
  var b4 = "";
  ba.Children.forEach(a4, function(a7) {
    a7 != null && (b4 += a7);
  });
  return b4;
}
function Ka2(a4, b4, c4, d4) {
  a4.push(N6(c4));
  var f4 = c4 = null, e5;
  for (e5 in b4)
    if (y6.call(b4, e5)) {
      var g4 = b4[e5];
      if (g4 != null)
        switch (e5) {
          case "children":
            c4 = g4;
            break;
          case "dangerouslySetInnerHTML":
            f4 = g4;
            break;
          default:
            K4(a4, d4, e5, g4);
        }
    }
  a4.push(L6);
  M6(a4, f4, c4);
  return typeof c4 === "string" ? (a4.push(F7(c4)), null) : c4;
}
function N6(a4) {
  var b4 = Na2.get(a4);
  if (b4 === undefined) {
    if (!Ma2.test(a4))
      throw Error("Invalid tag: " + a4);
    b4 = x10("<" + a4);
    Na2.set(a4, b4);
  }
  return b4;
}
function Pa2(a4, b4, c4, d4, f4) {
  switch (b4) {
    case "select":
      a4.push(N6("select"));
      var e5 = null, g4 = null;
      for (p4 in c4)
        if (y6.call(c4, p4)) {
          var h4 = c4[p4];
          if (h4 != null)
            switch (p4) {
              case "children":
                e5 = h4;
                break;
              case "dangerouslySetInnerHTML":
                g4 = h4;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                K4(a4, d4, p4, h4);
            }
        }
      a4.push(L6);
      M6(a4, g4, e5);
      return e5;
    case "option":
      g4 = f4.selectedValue;
      a4.push(N6("option"));
      var m4 = h4 = null, n9 = null;
      var p4 = null;
      for (e5 in c4)
        if (y6.call(c4, e5)) {
          var v7 = c4[e5];
          if (v7 != null)
            switch (e5) {
              case "children":
                h4 = v7;
                break;
              case "selected":
                n9 = v7;
                break;
              case "dangerouslySetInnerHTML":
                p4 = v7;
                break;
              case "value":
                m4 = v7;
              default:
                K4(a4, d4, e5, v7);
            }
        }
      if (g4 != null)
        if (c4 = m4 !== null ? "" + m4 : Ia2(h4), qa2(g4))
          for (d4 = 0;d4 < g4.length; d4++) {
            if ("" + g4[d4] === c4) {
              a4.push(Ja2);
              break;
            }
          }
        else
          "" + g4 === c4 && a4.push(Ja2);
      else
        n9 && a4.push(Ja2);
      a4.push(L6);
      M6(a4, p4, h4);
      return h4;
    case "textarea":
      a4.push(N6("textarea"));
      p4 = g4 = e5 = null;
      for (h4 in c4)
        if (y6.call(c4, h4) && (m4 = c4[h4], m4 != null))
          switch (h4) {
            case "children":
              p4 = m4;
              break;
            case "value":
              e5 = m4;
              break;
            case "defaultValue":
              g4 = m4;
              break;
            case "dangerouslySetInnerHTML":
              throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              K4(a4, d4, h4, m4);
          }
      e5 === null && g4 !== null && (e5 = g4);
      a4.push(L6);
      if (p4 != null) {
        if (e5 != null)
          throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (qa2(p4) && 1 < p4.length)
          throw Error("<textarea> can only have at most one child.");
        e5 = "" + p4;
      }
      typeof e5 === "string" && e5[0] === "\n" && a4.push(La2);
      e5 !== null && a4.push(F7("" + e5));
      return null;
    case "input":
      a4.push(N6("input"));
      m4 = p4 = h4 = e5 = null;
      for (g4 in c4)
        if (y6.call(c4, g4) && (n9 = c4[g4], n9 != null))
          switch (g4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              m4 = n9;
              break;
            case "defaultValue":
              h4 = n9;
              break;
            case "checked":
              p4 = n9;
              break;
            case "value":
              e5 = n9;
              break;
            default:
              K4(a4, d4, g4, n9);
          }
      p4 !== null ? K4(a4, d4, "checked", p4) : m4 !== null && K4(a4, d4, "checked", m4);
      e5 !== null ? K4(a4, d4, "value", e5) : h4 !== null && K4(a4, d4, "value", h4);
      a4.push(Ha2);
      return null;
    case "menuitem":
      a4.push(N6("menuitem"));
      for (var C4 in c4)
        if (y6.call(c4, C4) && (e5 = c4[C4], e5 != null))
          switch (C4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              K4(a4, d4, C4, e5);
          }
      a4.push(L6);
      return null;
    case "title":
      a4.push(N6("title"));
      e5 = null;
      for (v7 in c4)
        if (y6.call(c4, v7) && (g4 = c4[v7], g4 != null))
          switch (v7) {
            case "children":
              e5 = g4;
              break;
            case "dangerouslySetInnerHTML":
              throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              K4(a4, d4, v7, g4);
          }
      a4.push(L6);
      return e5;
    case "listing":
    case "pre":
      a4.push(N6(b4));
      g4 = e5 = null;
      for (m4 in c4)
        if (y6.call(c4, m4) && (h4 = c4[m4], h4 != null))
          switch (m4) {
            case "children":
              e5 = h4;
              break;
            case "dangerouslySetInnerHTML":
              g4 = h4;
              break;
            default:
              K4(a4, d4, m4, h4);
          }
      a4.push(L6);
      if (g4 != null) {
        if (e5 != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof g4 !== "object" || !("__html" in g4))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        c4 = g4.__html;
        c4 !== null && c4 !== undefined && (typeof c4 === "string" && 0 < c4.length && c4[0] === "\n" ? a4.push(La2, c4) : a4.push("" + c4));
      }
      typeof e5 === "string" && e5[0] === "\n" && a4.push(La2);
      return e5;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a4.push(N6(b4));
      for (var D5 in c4)
        if (y6.call(c4, D5) && (e5 = c4[D5], e5 != null))
          switch (D5) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(b4 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              K4(a4, d4, D5, e5);
          }
      a4.push(Ha2);
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return Ka2(a4, c4, b4, d4);
    case "html":
      return f4.insertionMode === 0 && a4.push(Oa2), Ka2(a4, c4, b4, d4);
    default:
      if (b4.indexOf("-") === -1 && typeof c4.is !== "string")
        return Ka2(a4, c4, b4, d4);
      a4.push(N6(b4));
      g4 = e5 = null;
      for (n9 in c4)
        if (y6.call(c4, n9) && (h4 = c4[n9], h4 != null))
          switch (n9) {
            case "children":
              e5 = h4;
              break;
            case "dangerouslySetInnerHTML":
              g4 = h4;
              break;
            case "style":
              Fa2(a4, d4, h4);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ha2(n9) && typeof h4 !== "function" && typeof h4 !== "symbol" && a4.push(I8, n9, J8, F7(h4), H6);
          }
      a4.push(L6);
      M6(a4, g4, e5);
      return e5;
  }
}
function cb2(a4, b4, c4) {
  r9(a4, Va2);
  if (c4 === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  r9(a4, c4);
  return w9(a4, Wa2);
}
function yb2(a4, b4, c4, d4) {
  switch (c4.insertionMode) {
    case 0:
    case 1:
      return r9(a4, db3), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, eb2);
    case 2:
      return r9(a4, gb2), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, hb2);
    case 3:
      return r9(a4, jb2), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, kb2);
    case 4:
      return r9(a4, mb2), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, nb2);
    case 5:
      return r9(a4, pb), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, qb);
    case 6:
      return r9(a4, sb2), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, tb2);
    case 7:
      return r9(a4, vb2), r9(a4, b4.segmentPrefix), r9(a4, d4.toString(16)), w9(a4, wb2);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function zb2(a4, b4) {
  switch (b4.insertionMode) {
    case 0:
    case 1:
      return w9(a4, fb2);
    case 2:
      return w9(a4, ib2);
    case 3:
      return w9(a4, lb2);
    case 4:
      return w9(a4, ob2);
    case 5:
      return w9(a4, rb5);
    case 6:
      return w9(a4, ub2);
    case 7:
      return w9(a4, xb2);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function Pb2(a4) {
  return JSON.stringify(a4).replace(Ob2, function(a7) {
    switch (a7) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function gc(a4) {
  if (a4 == null)
    return null;
  if (typeof a4 === "function")
    return a4.displayName || a4.name || null;
  if (typeof a4 === "string")
    return a4;
  switch (a4) {
    case Sb2:
      return "Fragment";
    case Rb2:
      return "Portal";
    case Ub2:
      return "Profiler";
    case Tb2:
      return "StrictMode";
    case Yb2:
      return "Suspense";
    case Zb2:
      return "SuspenseList";
  }
  if (typeof a4 === "object")
    switch (a4.$$typeof) {
      case Wb2:
        return (a4.displayName || "Context") + ".Consumer";
      case Vb2:
        return (a4._context.displayName || "Context") + ".Provider";
      case Xb2:
        var b4 = a4.render;
        a4 = a4.displayName;
        a4 || (a4 = b4.displayName || b4.name || "", a4 = a4 !== "" ? "ForwardRef(" + a4 + ")" : "ForwardRef");
        return a4;
      case $b:
        return b4 = a4.displayName || null, b4 !== null ? b4 : gc(a4.type) || "Memo";
      case ac:
        b4 = a4._payload;
        a4 = a4._init;
        try {
          return gc(a4(b4));
        } catch (c4) {
        }
    }
  return null;
}
function ic(a4, b4) {
  a4 = a4.contextTypes;
  if (!a4)
    return hc;
  var c4 = {}, d4;
  for (d4 in a4)
    c4[d4] = b4[d4];
  return c4;
}
function Q6(a4, b4) {
  if (a4 !== b4) {
    a4.context._currentValue = a4.parentValue;
    a4 = a4.parent;
    var c4 = b4.parent;
    if (a4 === null) {
      if (c4 !== null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
    } else {
      if (c4 === null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      Q6(a4, c4);
    }
    b4.context._currentValue = b4.value;
  }
}
function jc(a4) {
  a4.context._currentValue = a4.parentValue;
  a4 = a4.parent;
  a4 !== null && jc(a4);
}
function kc(a4) {
  var b4 = a4.parent;
  b4 !== null && kc(b4);
  a4.context._currentValue = a4.value;
}
function lc(a4, b4) {
  a4.context._currentValue = a4.parentValue;
  a4 = a4.parent;
  if (a4 === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  a4.depth === b4.depth ? Q6(a4, b4) : lc(a4, b4);
}
function mc(a4, b4) {
  var c4 = b4.parent;
  if (c4 === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  a4.depth === c4.depth ? Q6(a4, c4) : mc(a4, c4);
  b4.context._currentValue = b4.value;
}
function nc(a4) {
  var b4 = P7;
  b4 !== a4 && (b4 === null ? kc(a4) : a4 === null ? jc(b4) : b4.depth === a4.depth ? Q6(b4, a4) : b4.depth > a4.depth ? lc(b4, a4) : mc(b4, a4), P7 = a4);
}
function pc(a4, b4, c4, d4) {
  var f4 = a4.state !== undefined ? a4.state : null;
  a4.updater = oc;
  a4.props = c4;
  a4.state = f4;
  var e5 = { queue: [], replace: false };
  a4._reactInternals = e5;
  var g4 = b4.contextType;
  a4.context = typeof g4 === "object" && g4 !== null ? g4._currentValue : d4;
  g4 = b4.getDerivedStateFromProps;
  typeof g4 === "function" && (g4 = g4(c4, f4), f4 = g4 === null || g4 === undefined ? f4 : O7({}, f4, g4), a4.state = f4);
  if (typeof b4.getDerivedStateFromProps !== "function" && typeof a4.getSnapshotBeforeUpdate !== "function" && (typeof a4.UNSAFE_componentWillMount === "function" || typeof a4.componentWillMount === "function"))
    if (b4 = a4.state, typeof a4.componentWillMount === "function" && a4.componentWillMount(), typeof a4.UNSAFE_componentWillMount === "function" && a4.UNSAFE_componentWillMount(), b4 !== a4.state && oc.enqueueReplaceState(a4, a4.state, null), e5.queue !== null && 0 < e5.queue.length)
      if (b4 = e5.queue, g4 = e5.replace, e5.queue = null, e5.replace = false, g4 && b4.length === 1)
        a4.state = b4[0];
      else {
        e5 = g4 ? b4[0] : a4.state;
        f4 = true;
        for (g4 = g4 ? 1 : 0;g4 < b4.length; g4++) {
          var h4 = b4[g4];
          h4 = typeof h4 === "function" ? h4.call(a4, e5, c4, d4) : h4;
          h4 != null && (f4 ? (f4 = false, e5 = O7({}, e5, h4)) : O7(e5, h4));
        }
        a4.state = e5;
      }
    else
      e5.queue = null;
}
function rc(a4, b4, c4) {
  var d4 = a4.id;
  a4 = a4.overflow;
  var f4 = 32 - sc(d4) - 1;
  d4 &= ~(1 << f4);
  c4 += 1;
  var e5 = 32 - sc(b4) + f4;
  if (30 < e5) {
    var g4 = f4 - f4 % 5;
    e5 = (d4 & (1 << g4) - 1).toString(32);
    d4 >>= g4;
    f4 -= g4;
    return { id: 1 << 32 - sc(b4) + f4 | c4 << f4 | d4, overflow: e5 + a4 };
  }
  return { id: 1 << e5 | c4 << f4 | d4, overflow: a4 };
}
function tc(a4) {
  a4 >>>= 0;
  return a4 === 0 ? 32 : 31 - (uc(a4) / vc | 0) | 0;
}
function wc(a4, b4) {
  return a4 === b4 && (a4 !== 0 || 1 / a4 === 1 / b4) || a4 !== a4 && b4 !== b4;
}
function W6() {
  if (R5 === null)
    throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
  return R5;
}
function Cc() {
  if (0 < Bc)
    throw Error("Rendered more hooks than during the previous render");
  return { memoizedState: null, queue: null, next: null };
}
function Dc() {
  S6 === null ? zc === null ? (T7 = false, zc = S6 = Cc()) : (T7 = true, S6 = zc) : S6.next === null ? (T7 = false, S6 = S6.next = Cc()) : (T7 = true, S6 = S6.next);
  return S6;
}
function Ec() {
  yc = R5 = null;
  Ac = false;
  zc = null;
  Bc = 0;
  S6 = V8 = null;
}
function Fc(a4, b4) {
  return typeof b4 === "function" ? b4(a4) : b4;
}
function Gc(a4, b4, c4) {
  R5 = W6();
  S6 = Dc();
  if (T7) {
    var d4 = S6.queue;
    b4 = d4.dispatch;
    if (V8 !== null && (c4 = V8.get(d4), c4 !== undefined)) {
      V8.delete(d4);
      d4 = S6.memoizedState;
      do
        d4 = a4(d4, c4.action), c4 = c4.next;
      while (c4 !== null);
      S6.memoizedState = d4;
      return [d4, b4];
    }
    return [S6.memoizedState, b4];
  }
  a4 = a4 === Fc ? typeof b4 === "function" ? b4() : b4 : c4 !== undefined ? c4(b4) : b4;
  S6.memoizedState = a4;
  a4 = S6.queue = { last: null, dispatch: null };
  a4 = a4.dispatch = Hc.bind(null, R5, a4);
  return [S6.memoizedState, a4];
}
function Ic(a4, b4) {
  R5 = W6();
  S6 = Dc();
  b4 = b4 === undefined ? null : b4;
  if (S6 !== null) {
    var c4 = S6.memoizedState;
    if (c4 !== null && b4 !== null) {
      var d4 = c4[1];
      a:
        if (d4 === null)
          d4 = false;
        else {
          for (var f4 = 0;f4 < d4.length && f4 < b4.length; f4++)
            if (!xc(b4[f4], d4[f4])) {
              d4 = false;
              break a;
            }
          d4 = true;
        }
      if (d4)
        return c4[0];
    }
  }
  a4 = a4();
  S6.memoizedState = [a4, b4];
  return a4;
}
function Hc(a4, b4, c4) {
  if (25 <= Bc)
    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
  if (a4 === R5)
    if (Ac = true, a4 = { action: c4, next: null }, V8 === null && (V8 = new Map), c4 = V8.get(b4), c4 === undefined)
      V8.set(b4, a4);
    else {
      for (b4 = c4;b4.next !== null; )
        b4 = b4.next;
      b4.next = a4;
    }
}
function Jc() {
  throw Error("startTransition cannot be called during server rendering.");
}
function Kc() {
}
function Oc(a4) {
  console.error(a4);
  return null;
}
function X7() {
}
function Pc(a4, b4) {
  var c4 = a4.pingedTasks;
  c4.push(b4);
  c4.length === 1 && setImmediate(function() {
    return Qc(a4);
  });
}
function Rc(a4, b4, c4, d4, f4, e5, g4, h4) {
  a4.allPendingTasks++;
  c4 === null ? a4.pendingRootTasks++ : c4.pendingTasks++;
  var m4 = { node: b4, ping: function() {
    return Pc(a4, m4);
  }, blockedBoundary: c4, blockedSegment: d4, abortSet: f4, legacyContext: e5, context: g4, treeContext: h4 };
  f4.add(m4);
  return m4;
}
function Sc(a4, b4, c4, d4, f4, e5) {
  return { status: 0, id: -1, index: b4, parentFlushed: false, chunks: [], children: [], formatContext: d4, boundary: c4, lastPushedText: f4, textEmbedded: e5 };
}
function Y4(a4, b4) {
  a4 = a4.onError(b4);
  if (a4 != null && typeof a4 !== "string")
    throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a4 + '" instead');
  return a4;
}
function Tc(a4, b4) {
  var c4 = a4.onShellError;
  c4(b4);
  c4 = a4.onFatalError;
  c4(b4);
  a4.destination !== null ? (a4.status = 2, a4.destination.destroy(b4)) : (a4.status = 1, a4.fatalError = b4);
}
function Uc(a4, b4, c4, d4, f4) {
  R5 = {};
  yc = b4;
  U6 = 0;
  for (a4 = c4(d4, f4);Ac; )
    Ac = false, U6 = 0, Bc += 1, S6 = null, a4 = c4(d4, f4);
  Ec();
  return a4;
}
function Vc(a4, b4, c4, d4) {
  var f4 = c4.render(), e5 = d4.childContextTypes;
  if (e5 !== null && e5 !== undefined) {
    var g4 = b4.legacyContext;
    if (typeof c4.getChildContext !== "function")
      d4 = g4;
    else {
      c4 = c4.getChildContext();
      for (var h4 in c4)
        if (!(h4 in e5))
          throw Error((gc(d4) || "Unknown") + '.getChildContext(): key "' + h4 + '" is not defined in childContextTypes.');
      d4 = O7({}, g4, c4);
    }
    b4.legacyContext = d4;
    Z4(a4, b4, f4);
    b4.legacyContext = g4;
  } else
    Z4(a4, b4, f4);
}
function Wc(a4, b4) {
  if (a4 && a4.defaultProps) {
    b4 = O7({}, b4);
    a4 = a4.defaultProps;
    for (var c4 in a4)
      b4[c4] === undefined && (b4[c4] = a4[c4]);
    return b4;
  }
  return b4;
}
function Xc(a4, b4, c4, d4, f4) {
  if (typeof c4 === "function")
    if (c4.prototype && c4.prototype.isReactComponent) {
      f4 = ic(c4, b4.legacyContext);
      var e5 = c4.contextType;
      e5 = new c4(d4, typeof e5 === "object" && e5 !== null ? e5._currentValue : f4);
      pc(e5, c4, d4, f4);
      Vc(a4, b4, e5, c4);
    } else {
      e5 = ic(c4, b4.legacyContext);
      f4 = Uc(a4, b4, c4, d4, e5);
      var g4 = U6 !== 0;
      if (typeof f4 === "object" && f4 !== null && typeof f4.render === "function" && f4.$$typeof === undefined)
        pc(f4, c4, d4, e5), Vc(a4, b4, f4, c4);
      else if (g4) {
        d4 = b4.treeContext;
        b4.treeContext = rc(d4, 1, 0);
        try {
          Z4(a4, b4, f4);
        } finally {
          b4.treeContext = d4;
        }
      } else
        Z4(a4, b4, f4);
    }
  else if (typeof c4 === "string") {
    f4 = b4.blockedSegment;
    e5 = Pa2(f4.chunks, c4, d4, a4.responseState, f4.formatContext);
    f4.lastPushedText = false;
    g4 = f4.formatContext;
    f4.formatContext = ya2(g4, c4, d4);
    Yc(a4, b4, e5);
    f4.formatContext = g4;
    switch (c4) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f4.chunks.push(Qa2, c4, Ra2);
    }
    f4.lastPushedText = false;
  } else {
    switch (c4) {
      case dc:
      case cc:
      case Tb2:
      case Ub2:
      case Sb2:
        Z4(a4, b4, d4.children);
        return;
      case Zb2:
        Z4(a4, b4, d4.children);
        return;
      case bc:
        throw Error("ReactDOMServer does not yet support scope components.");
      case Yb2:
        a: {
          c4 = b4.blockedBoundary;
          f4 = b4.blockedSegment;
          e5 = d4.fallback;
          d4 = d4.children;
          g4 = new Set;
          var h4 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g4, errorDigest: null }, m4 = Sc(a4, f4.chunks.length, h4, f4.formatContext, false, false);
          f4.children.push(m4);
          f4.lastPushedText = false;
          var n9 = Sc(a4, 0, null, f4.formatContext, false, false);
          n9.parentFlushed = true;
          b4.blockedBoundary = h4;
          b4.blockedSegment = n9;
          try {
            if (Yc(a4, b4, d4), n9.lastPushedText && n9.textEmbedded && n9.chunks.push(za2), n9.status = 1, Zc(h4, n9), h4.pendingTasks === 0)
              break a;
          } catch (p4) {
            n9.status = 4, h4.forceClientRender = true, h4.errorDigest = Y4(a4, p4);
          } finally {
            b4.blockedBoundary = c4, b4.blockedSegment = f4;
          }
          b4 = Rc(a4, e5, c4, m4, g4, b4.legacyContext, b4.context, b4.treeContext);
          a4.pingedTasks.push(b4);
        }
        return;
    }
    if (typeof c4 === "object" && c4 !== null)
      switch (c4.$$typeof) {
        case Xb2:
          d4 = Uc(a4, b4, c4.render, d4, f4);
          if (U6 !== 0) {
            c4 = b4.treeContext;
            b4.treeContext = rc(c4, 1, 0);
            try {
              Z4(a4, b4, d4);
            } finally {
              b4.treeContext = c4;
            }
          } else
            Z4(a4, b4, d4);
          return;
        case $b:
          c4 = c4.type;
          d4 = Wc(c4, d4);
          Xc(a4, b4, c4, d4, f4);
          return;
        case Vb2:
          f4 = d4.children;
          c4 = c4._context;
          d4 = d4.value;
          e5 = c4._currentValue;
          c4._currentValue = d4;
          g4 = P7;
          P7 = d4 = { parent: g4, depth: g4 === null ? 0 : g4.depth + 1, context: c4, parentValue: e5, value: d4 };
          b4.context = d4;
          Z4(a4, b4, f4);
          a4 = P7;
          if (a4 === null)
            throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          d4 = a4.parentValue;
          a4.context._currentValue = d4 === ec ? a4.context._defaultValue : d4;
          a4 = P7 = a4.parent;
          b4.context = a4;
          return;
        case Wb2:
          d4 = d4.children;
          d4 = d4(c4._currentValue);
          Z4(a4, b4, d4);
          return;
        case ac:
          f4 = c4._init;
          c4 = f4(c4._payload);
          d4 = Wc(c4, d4);
          Xc(a4, b4, c4, d4, undefined);
          return;
      }
    throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c4 == null ? c4 : typeof c4) + "."));
  }
}
function Z4(a4, b4, c4) {
  b4.node = c4;
  if (typeof c4 === "object" && c4 !== null) {
    switch (c4.$$typeof) {
      case Qb2:
        Xc(a4, b4, c4.type, c4.props, c4.ref);
        return;
      case Rb2:
        throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
      case ac:
        var d4 = c4._init;
        c4 = d4(c4._payload);
        Z4(a4, b4, c4);
        return;
    }
    if (qa2(c4)) {
      $c(a4, b4, c4);
      return;
    }
    c4 === null || typeof c4 !== "object" ? d4 = null : (d4 = fc && c4[fc] || c4["@@iterator"], d4 = typeof d4 === "function" ? d4 : null);
    if (d4 && (d4 = d4.call(c4))) {
      c4 = d4.next();
      if (!c4.done) {
        var f4 = [];
        do
          f4.push(c4.value), c4 = d4.next();
        while (!c4.done);
        $c(a4, b4, f4);
      }
      return;
    }
    a4 = Object.prototype.toString.call(c4);
    throw Error("Objects are not valid as a React child (found: " + (a4 === "[object Object]" ? "object with keys {" + Object.keys(c4).join(", ") + "}" : a4) + "). If you meant to render a collection of children, use an array instead.");
  }
  typeof c4 === "string" ? (d4 = b4.blockedSegment, d4.lastPushedText = Aa2(b4.blockedSegment.chunks, c4, a4.responseState, d4.lastPushedText)) : typeof c4 === "number" && (d4 = b4.blockedSegment, d4.lastPushedText = Aa2(b4.blockedSegment.chunks, "" + c4, a4.responseState, d4.lastPushedText));
}
function $c(a4, b4, c4) {
  for (var d4 = c4.length, f4 = 0;f4 < d4; f4++) {
    var e5 = b4.treeContext;
    b4.treeContext = rc(e5, d4, f4);
    try {
      Yc(a4, b4, c4[f4]);
    } finally {
      b4.treeContext = e5;
    }
  }
}
function Yc(a4, b4, c4) {
  var d4 = b4.blockedSegment.formatContext, f4 = b4.legacyContext, e5 = b4.context;
  try {
    return Z4(a4, b4, c4);
  } catch (m4) {
    if (Ec(), typeof m4 === "object" && m4 !== null && typeof m4.then === "function") {
      c4 = m4;
      var g4 = b4.blockedSegment, h4 = Sc(a4, g4.chunks.length, null, g4.formatContext, g4.lastPushedText, true);
      g4.children.push(h4);
      g4.lastPushedText = false;
      a4 = Rc(a4, b4.node, b4.blockedBoundary, h4, b4.abortSet, b4.legacyContext, b4.context, b4.treeContext).ping;
      c4.then(a4, a4);
      b4.blockedSegment.formatContext = d4;
      b4.legacyContext = f4;
      b4.context = e5;
      nc(e5);
    } else
      throw b4.blockedSegment.formatContext = d4, b4.legacyContext = f4, b4.context = e5, nc(e5), m4;
  }
}
function ad(a4) {
  var b4 = a4.blockedBoundary;
  a4 = a4.blockedSegment;
  a4.status = 3;
  bd(this, b4, a4);
}
function cd(a4, b4, c4) {
  var d4 = a4.blockedBoundary;
  a4.blockedSegment.status = 3;
  d4 === null ? (b4.allPendingTasks--, b4.status !== 2 && (b4.status = 2, b4.destination !== null && b4.destination.end())) : (d4.pendingTasks--, d4.forceClientRender || (d4.forceClientRender = true, d4.errorDigest = b4.onError(c4 === undefined ? Error("The render was aborted by the server without a reason.") : c4), d4.parentFlushed && b4.clientRenderedBoundaries.push(d4)), d4.fallbackAbortableTasks.forEach(function(a7) {
    return cd(a7, b4, c4);
  }), d4.fallbackAbortableTasks.clear(), b4.allPendingTasks--, b4.allPendingTasks === 0 && (a4 = b4.onAllReady, a4()));
}
function Zc(a4, b4) {
  if (b4.chunks.length === 0 && b4.children.length === 1 && b4.children[0].boundary === null) {
    var c4 = b4.children[0];
    c4.id = b4.id;
    c4.parentFlushed = true;
    c4.status === 1 && Zc(a4, c4);
  } else
    a4.completedSegments.push(b4);
}
function bd(a4, b4, c4) {
  if (b4 === null) {
    if (c4.parentFlushed) {
      if (a4.completedRootSegment !== null)
        throw Error("There can only be one root segment. This is a bug in React.");
      a4.completedRootSegment = c4;
    }
    a4.pendingRootTasks--;
    a4.pendingRootTasks === 0 && (a4.onShellError = X7, b4 = a4.onShellReady, b4());
  } else
    b4.pendingTasks--, b4.forceClientRender || (b4.pendingTasks === 0 ? (c4.parentFlushed && c4.status === 1 && Zc(b4, c4), b4.parentFlushed && a4.completedBoundaries.push(b4), b4.fallbackAbortableTasks.forEach(ad, a4), b4.fallbackAbortableTasks.clear()) : c4.parentFlushed && c4.status === 1 && (Zc(b4, c4), b4.completedSegments.length === 1 && b4.parentFlushed && a4.partialBoundaries.push(b4)));
  a4.allPendingTasks--;
  a4.allPendingTasks === 0 && (a4 = a4.onAllReady, a4());
}
function Qc(a4) {
  if (a4.status !== 2) {
    var b4 = P7, c4 = Nc.current;
    Nc.current = Mc;
    var d4 = Lc;
    Lc = a4.responseState;
    try {
      var f4 = a4.pingedTasks, e5;
      for (e5 = 0;e5 < f4.length; e5++) {
        var g4 = f4[e5];
        var h4 = a4, m4 = g4.blockedSegment;
        if (m4.status === 0) {
          nc(g4.context);
          try {
            Z4(h4, g4, g4.node), m4.lastPushedText && m4.textEmbedded && m4.chunks.push(za2), g4.abortSet.delete(g4), m4.status = 1, bd(h4, g4.blockedBoundary, m4);
          } catch (E5) {
            if (Ec(), typeof E5 === "object" && E5 !== null && typeof E5.then === "function") {
              var n9 = g4.ping;
              E5.then(n9, n9);
            } else {
              g4.abortSet.delete(g4);
              m4.status = 4;
              var p4 = g4.blockedBoundary, v7 = E5, C4 = Y4(h4, v7);
              p4 === null ? Tc(h4, v7) : (p4.pendingTasks--, p4.forceClientRender || (p4.forceClientRender = true, p4.errorDigest = C4, p4.parentFlushed && h4.clientRenderedBoundaries.push(p4)));
              h4.allPendingTasks--;
              if (h4.allPendingTasks === 0) {
                var D5 = h4.onAllReady;
                D5();
              }
            }
          } finally {
          }
        }
      }
      f4.splice(0, e5);
      a4.destination !== null && dd(a4, a4.destination);
    } catch (E5) {
      Y4(a4, E5), Tc(a4, E5);
    } finally {
      Lc = d4, Nc.current = c4, c4 === Mc && nc(b4);
    }
  }
}
function ed(a4, b4, c4) {
  c4.parentFlushed = true;
  switch (c4.status) {
    case 0:
      var d4 = c4.id = a4.nextSegmentId++;
      c4.lastPushedText = false;
      c4.textEmbedded = false;
      a4 = a4.responseState;
      r9(b4, Sa2);
      r9(b4, a4.placeholderPrefix);
      a4 = d4.toString(16);
      r9(b4, a4);
      return w9(b4, Ta2);
    case 1:
      c4.status = 2;
      var f4 = true;
      d4 = c4.chunks;
      var e5 = 0;
      c4 = c4.children;
      for (var g4 = 0;g4 < c4.length; g4++) {
        for (f4 = c4[g4];e5 < f4.index; e5++)
          r9(b4, d4[e5]);
        f4 = fd(a4, b4, f4);
      }
      for (;e5 < d4.length - 1; e5++)
        r9(b4, d4[e5]);
      e5 < d4.length && (f4 = w9(b4, d4[e5]));
      return f4;
    default:
      throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
  }
}
function fd(a4, b4, c4) {
  var d4 = c4.boundary;
  if (d4 === null)
    return ed(a4, b4, c4);
  d4.parentFlushed = true;
  if (d4.forceClientRender)
    d4 = d4.errorDigest, w9(b4, Xa2), r9(b4, Za2), d4 && (r9(b4, ab2), r9(b4, F7(d4)), r9(b4, $a2)), w9(b4, bb2), ed(a4, b4, c4);
  else if (0 < d4.pendingTasks) {
    d4.rootSegmentID = a4.nextSegmentId++;
    0 < d4.completedSegments.length && a4.partialBoundaries.push(d4);
    var f4 = a4.responseState;
    var e5 = f4.nextSuspenseID++;
    f4 = x10(f4.boundaryPrefix + e5.toString(16));
    d4 = d4.id = f4;
    cb2(b4, a4.responseState, d4);
    ed(a4, b4, c4);
  } else if (d4.byteSize > a4.progressiveChunkSize)
    d4.rootSegmentID = a4.nextSegmentId++, a4.completedBoundaries.push(d4), cb2(b4, a4.responseState, d4.id), ed(a4, b4, c4);
  else {
    w9(b4, Ua2);
    c4 = d4.completedSegments;
    if (c4.length !== 1)
      throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
    fd(a4, b4, c4[0]);
  }
  return w9(b4, Ya2);
}
function gd(a4, b4, c4) {
  yb2(b4, a4.responseState, c4.formatContext, c4.id);
  fd(a4, b4, c4);
  return zb2(b4, c4.formatContext);
}
function hd(a4, b4, c4) {
  for (var d4 = c4.completedSegments, f4 = 0;f4 < d4.length; f4++)
    id(a4, b4, c4, d4[f4]);
  d4.length = 0;
  a4 = a4.responseState;
  d4 = c4.id;
  c4 = c4.rootSegmentID;
  r9(b4, a4.startInlineScript);
  a4.sentCompleteBoundaryFunction ? r9(b4, Gb2) : (a4.sentCompleteBoundaryFunction = true, r9(b4, Fb2));
  if (d4 === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  c4 = c4.toString(16);
  r9(b4, d4);
  r9(b4, Hb2);
  r9(b4, a4.segmentPrefix);
  r9(b4, c4);
  return w9(b4, Ib2);
}
function id(a4, b4, c4, d4) {
  if (d4.status === 2)
    return true;
  var f4 = d4.id;
  if (f4 === -1) {
    if ((d4.id = c4.rootSegmentID) === -1)
      throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
    return gd(a4, b4, d4);
  }
  gd(a4, b4, d4);
  a4 = a4.responseState;
  r9(b4, a4.startInlineScript);
  a4.sentCompleteSegmentFunction ? r9(b4, Bb2) : (a4.sentCompleteSegmentFunction = true, r9(b4, Ab2));
  r9(b4, a4.segmentPrefix);
  f4 = f4.toString(16);
  r9(b4, f4);
  r9(b4, Cb2);
  r9(b4, a4.placeholderPrefix);
  r9(b4, f4);
  return w9(b4, Db2);
}
function dd(a4, b4) {
  k9 = new Uint8Array(2048);
  l8 = 0;
  q12 = true;
  try {
    var c4 = a4.completedRootSegment;
    if (c4 !== null && a4.pendingRootTasks === 0) {
      fd(a4, b4, c4);
      a4.completedRootSegment = null;
      var d4 = a4.responseState.bootstrapChunks;
      for (c4 = 0;c4 < d4.length - 1; c4++)
        r9(b4, d4[c4]);
      c4 < d4.length && w9(b4, d4[c4]);
    }
    var f4 = a4.clientRenderedBoundaries, e5;
    for (e5 = 0;e5 < f4.length; e5++) {
      var g4 = f4[e5];
      d4 = b4;
      var h4 = a4.responseState, m4 = g4.id, n9 = g4.errorDigest, p4 = g4.errorMessage, v7 = g4.errorComponentStack;
      r9(d4, h4.startInlineScript);
      h4.sentClientRenderFunction ? r9(d4, Kb2) : (h4.sentClientRenderFunction = true, r9(d4, Jb2));
      if (m4 === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      r9(d4, m4);
      r9(d4, Lb2);
      if (n9 || p4 || v7)
        r9(d4, Nb2), r9(d4, Pb2(n9 || ""));
      if (p4 || v7)
        r9(d4, Nb2), r9(d4, Pb2(p4 || ""));
      v7 && (r9(d4, Nb2), r9(d4, Pb2(v7)));
      if (!w9(d4, Mb2)) {
        a4.destination = null;
        e5++;
        f4.splice(0, e5);
        return;
      }
    }
    f4.splice(0, e5);
    var C4 = a4.completedBoundaries;
    for (e5 = 0;e5 < C4.length; e5++)
      if (!hd(a4, b4, C4[e5])) {
        a4.destination = null;
        e5++;
        C4.splice(0, e5);
        return;
      }
    C4.splice(0, e5);
    ca(b4);
    k9 = new Uint8Array(2048);
    l8 = 0;
    q12 = true;
    var D5 = a4.partialBoundaries;
    for (e5 = 0;e5 < D5.length; e5++) {
      var E5 = D5[e5];
      a: {
        f4 = a4;
        g4 = b4;
        var na2 = E5.completedSegments;
        for (h4 = 0;h4 < na2.length; h4++)
          if (!id(f4, g4, E5, na2[h4])) {
            h4++;
            na2.splice(0, h4);
            var Eb2 = false;
            break a;
          }
        na2.splice(0, h4);
        Eb2 = true;
      }
      if (!Eb2) {
        a4.destination = null;
        e5++;
        D5.splice(0, e5);
        return;
      }
    }
    D5.splice(0, e5);
    var oa2 = a4.completedBoundaries;
    for (e5 = 0;e5 < oa2.length; e5++)
      if (!hd(a4, b4, oa2[e5])) {
        a4.destination = null;
        e5++;
        oa2.splice(0, e5);
        return;
      }
    oa2.splice(0, e5);
  } finally {
    ca(b4), typeof b4.flush === "function" && b4.flush(), a4.allPendingTasks === 0 && a4.pingedTasks.length === 0 && a4.clientRenderedBoundaries.length === 0 && a4.completedBoundaries.length === 0 && b4.end();
  }
}
function jd(a4) {
  setImmediate(function() {
    return Qc(a4);
  });
}
function kd(a4, b4) {
  if (a4.status === 1)
    a4.status = 2, b4.destroy(a4.fatalError);
  else if (a4.status !== 2 && a4.destination === null) {
    a4.destination = b4;
    try {
      dd(a4, b4);
    } catch (c4) {
      Y4(a4, c4), Tc(a4, c4);
    }
  }
}
function ld(a4, b4) {
  try {
    var c4 = a4.abortableTasks;
    c4.forEach(function(c8) {
      return cd(c8, a4, b4);
    });
    c4.clear();
    a4.destination !== null && dd(a4, a4.destination);
  } catch (d4) {
    Y4(a4, d4), Tc(a4, d4);
  }
}
function md(a4, b4) {
  return function() {
    return kd(b4, a4);
  };
}
function nd(a4, b4) {
  return function() {
    return ld(a4, b4);
  };
}
function od(a4, b4) {
  var c4 = b4 ? b4.identifierPrefix : undefined, d4 = b4 ? b4.nonce : undefined, f4 = b4 ? b4.bootstrapScriptContent : undefined, e5 = b4 ? b4.bootstrapScripts : undefined;
  var g4 = b4 ? b4.bootstrapModules : undefined;
  c4 = c4 === undefined ? "" : c4;
  d4 = d4 === undefined ? ra2 : x10('<script nonce="' + F7(d4) + '">');
  var h4 = [];
  f4 !== undefined && h4.push(d4, ("" + f4).replace(wa2, xa2), sa2);
  if (e5 !== undefined)
    for (f4 = 0;f4 < e5.length; f4++)
      h4.push(ta2, F7(e5[f4]), va2);
  if (g4 !== undefined)
    for (e5 = 0;e5 < g4.length; e5++)
      h4.push(ua2, F7(g4[e5]), va2);
  g4 = {
    bootstrapChunks: h4,
    startInlineScript: d4,
    placeholderPrefix: x10(c4 + "P:"),
    segmentPrefix: x10(c4 + "S:"),
    boundaryPrefix: c4 + "B:",
    idPrefix: c4,
    nextSuspenseID: 0,
    sentCompleteSegmentFunction: false,
    sentCompleteBoundaryFunction: false,
    sentClientRenderFunction: false
  };
  e5 = b4 ? b4.namespaceURI : undefined;
  e5 = G8(e5 === "http://www.w3.org/2000/svg" ? 2 : e5 === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  f4 = b4 ? b4.progressiveChunkSize : undefined;
  d4 = b4 ? b4.onError : undefined;
  h4 = b4 ? b4.onAllReady : undefined;
  var m4 = b4 ? b4.onShellReady : undefined, n9 = b4 ? b4.onShellError : undefined;
  b4 = [];
  c4 = new Set;
  g4 = {
    destination: null,
    responseState: g4,
    progressiveChunkSize: f4 === undefined ? 12800 : f4,
    status: 0,
    fatalError: null,
    nextSegmentId: 0,
    allPendingTasks: 0,
    pendingRootTasks: 0,
    completedRootSegment: null,
    abortableTasks: c4,
    pingedTasks: b4,
    clientRenderedBoundaries: [],
    completedBoundaries: [],
    partialBoundaries: [],
    onError: d4 === undefined ? Oc : d4,
    onAllReady: h4 === undefined ? X7 : h4,
    onShellReady: m4 === undefined ? X7 : m4,
    onShellError: n9 === undefined ? X7 : n9,
    onFatalError: X7
  };
  e5 = Sc(g4, 0, null, e5, false, false);
  e5.parentFlushed = true;
  a4 = Rc(g4, a4, null, e5, c4, hc, null, qc);
  b4.push(a4);
  return g4;
}
var ba, k9 = null, l8 = 0, q12 = true, u10, y6, da, ea2, fa2, A8, ia2, B6, ka2, la2, ma2, pa2, qa2, ra2, sa2, ta2, ua2, va2, wa2, za2, Ba2, Ca2, Da2, Ea2, I8, J8, H6, Ga2, L6, Ha2, Ja2, La2, Ma2, Na2, Oa2, Qa2, Ra2, Sa2, Ta2, Ua2, Va2, Wa2, Xa2, Ya2, Za2, $a2, ab2, bb2, db3, eb2, fb2, gb2, hb2, ib2, jb2, kb2, lb2, mb2, nb2, ob2, pb, qb, rb5, sb2, tb2, ub2, vb2, wb2, xb2, Ab2, Bb2, Cb2, Db2, Fb2, Gb2, Hb2, Ib2, Jb2, Kb2, Lb2, Mb2, Nb2, Ob2, O7, Qb2, Rb2, Sb2, Tb2, Ub2, Vb2, Wb2, Xb2, Yb2, Zb2, $b, ac, bc, cc, dc, ec, fc, hc, P7 = null, oc, qc, sc, uc, vc, xc, R5 = null, yc = null, zc = null, S6 = null, T7 = false, Ac = false, U6 = 0, V8 = null, Bc = 0, Mc, Lc = null, Nc, $renderToPipeableStream = function(a4, b4) {
  var c4 = od(a4, b4), d4 = false;
  jd(c4);
  return { pipe: function(a7) {
    if (d4)
      throw Error("React currently only supports piping to one writable stream.");
    d4 = true;
    kd(c4, a7);
    a7.on("drain", md(a7, c4));
    a7.on("error", nd(c4, Error("The destination stream errored while writing data.")));
    a7.on("close", nd(c4, Error("The destination stream closed early.")));
    return a7;
  }, abort: function(a7) {
    ld(c4, a7);
  } };
}, $version3 = "18.3.1";
var init_react_dom_server_node_production_min = __esm(() => {
  ba = __toESM(require_react(), 1);
  u10 = new aa.TextEncoder;
  y6 = Object.prototype.hasOwnProperty;
  da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
  ea2 = {};
  fa2 = {};
  A8 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
    A8[a4] = new z8(a4, 0, false, a4, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
    var b4 = a4[0];
    A8[b4] = new z8(b4, 1, false, a4[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
    A8[a4] = new z8(a4, 2, false, a4.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
    A8[a4] = new z8(a4, 2, false, a4, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
    A8[a4] = new z8(a4, 3, false, a4.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a4) {
    A8[a4] = new z8(a4, 3, true, a4, null, false, false);
  });
  ["capture", "download"].forEach(function(a4) {
    A8[a4] = new z8(a4, 4, false, a4, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a4) {
    A8[a4] = new z8(a4, 6, false, a4, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a4) {
    A8[a4] = new z8(a4, 5, false, a4.toLowerCase(), null, false, false);
  });
  ia2 = /[\-:]([a-z])/g;
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
    var b4 = a4.replace(ia2, ja2);
    A8[b4] = new z8(b4, 1, false, a4, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
    var b4 = a4.replace(ia2, ja2);
    A8[b4] = new z8(b4, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
    var b4 = a4.replace(ia2, ja2);
    A8[b4] = new z8(b4, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a4) {
    A8[a4] = new z8(a4, 1, false, a4.toLowerCase(), null, false, false);
  });
  A8.xlinkHref = new z8("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a4) {
    A8[a4] = new z8(a4, 1, false, a4.toLowerCase(), null, true, true);
  });
  B6 = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  ka2 = ["Webkit", "ms", "Moz", "O"];
  Object.keys(B6).forEach(function(a4) {
    ka2.forEach(function(b4) {
      b4 = b4 + a4.charAt(0).toUpperCase() + a4.substring(1);
      B6[b4] = B6[a4];
    });
  });
  la2 = /["'&<>]/;
  ma2 = /([A-Z])/g;
  pa2 = /^ms-/;
  qa2 = Array.isArray;
  ra2 = x10("<script>");
  sa2 = x10("</script>");
  ta2 = x10('<script src="');
  ua2 = x10('<script type="module" src="');
  va2 = x10('" async=""></script>');
  wa2 = /(<\/|<)(s)(cript)/gi;
  za2 = x10("<!-- -->");
  Ba2 = new Map;
  Ca2 = x10(' style="');
  Da2 = x10(":");
  Ea2 = x10(";");
  I8 = x10(" ");
  J8 = x10('="');
  H6 = x10('"');
  Ga2 = x10('=""');
  L6 = x10(">");
  Ha2 = x10("/>");
  Ja2 = x10(' selected=""');
  La2 = x10("\n");
  Ma2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
  Na2 = new Map;
  Oa2 = x10("<!DOCTYPE html>");
  Qa2 = x10("</");
  Ra2 = x10(">");
  Sa2 = x10('<template id="');
  Ta2 = x10('"></template>');
  Ua2 = x10("<!--$-->");
  Va2 = x10('<!--$?--><template id="');
  Wa2 = x10('"></template>');
  Xa2 = x10("<!--$!-->");
  Ya2 = x10("<!--/$-->");
  Za2 = x10("<template");
  $a2 = x10('"');
  ab2 = x10(' data-dgst="');
  x10(' data-msg="');
  x10(' data-stck="');
  bb2 = x10("></template>");
  db3 = x10('<div hidden id="');
  eb2 = x10('">');
  fb2 = x10("</div>");
  gb2 = x10('<svg aria-hidden="true" style="display:none" id="');
  hb2 = x10('">');
  ib2 = x10("</svg>");
  jb2 = x10('<math aria-hidden="true" style="display:none" id="');
  kb2 = x10('">');
  lb2 = x10("</math>");
  mb2 = x10('<table hidden id="');
  nb2 = x10('">');
  ob2 = x10("</table>");
  pb = x10('<table hidden><tbody id="');
  qb = x10('">');
  rb5 = x10("</tbody></table>");
  sb2 = x10('<table hidden><tr id="');
  tb2 = x10('">');
  ub2 = x10("</tr></table>");
  vb2 = x10('<table hidden><colgroup id="');
  wb2 = x10('">');
  xb2 = x10("</colgroup></table>");
  Ab2 = x10('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("');
  Bb2 = x10('$RS("');
  Cb2 = x10('","');
  Db2 = x10('")</script>');
  Fb2 = x10('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("');
  Gb2 = x10('$RC("');
  Hb2 = x10('","');
  Ib2 = x10('")</script>');
  Jb2 = x10('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("');
  Kb2 = x10('$RX("');
  Lb2 = x10('"');
  Mb2 = x10(")</script>");
  Nb2 = x10(",");
  Ob2 = /[<\u2028\u2029]/g;
  O7 = Object.assign;
  Qb2 = Symbol.for("react.element");
  Rb2 = Symbol.for("react.portal");
  Sb2 = Symbol.for("react.fragment");
  Tb2 = Symbol.for("react.strict_mode");
  Ub2 = Symbol.for("react.profiler");
  Vb2 = Symbol.for("react.provider");
  Wb2 = Symbol.for("react.context");
  Xb2 = Symbol.for("react.forward_ref");
  Yb2 = Symbol.for("react.suspense");
  Zb2 = Symbol.for("react.suspense_list");
  $b = Symbol.for("react.memo");
  ac = Symbol.for("react.lazy");
  bc = Symbol.for("react.scope");
  cc = Symbol.for("react.debug_trace_mode");
  dc = Symbol.for("react.legacy_hidden");
  ec = Symbol.for("react.default_value");
  fc = Symbol.iterator;
  hc = {};
  oc = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a4, b4) {
    a4 = a4._reactInternals;
    a4.queue !== null && a4.queue.push(b4);
  }, enqueueReplaceState: function(a4, b4) {
    a4 = a4._reactInternals;
    a4.replace = true;
    a4.queue = [b4];
  }, enqueueForceUpdate: function() {
  } };
  qc = { id: 1, overflow: "" };
  sc = Math.clz32 ? Math.clz32 : tc;
  uc = Math.log;
  vc = Math.LN2;
  xc = typeof Object.is === "function" ? Object.is : wc;
  Mc = { readContext: function(a4) {
    return a4._currentValue;
  }, useContext: function(a4) {
    W6();
    return a4._currentValue;
  }, useMemo: Ic, useReducer: Gc, useRef: function(a4) {
    R5 = W6();
    S6 = Dc();
    var b4 = S6.memoizedState;
    return b4 === null ? (a4 = { current: a4 }, S6.memoizedState = a4) : b4;
  }, useState: function(a4) {
    return Gc(Fc, a4);
  }, useInsertionEffect: Kc, useLayoutEffect: function() {
  }, useCallback: function(a4, b4) {
    return Ic(function() {
      return a4;
    }, b4);
  }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a4) {
    W6();
    return a4;
  }, useTransition: function() {
    W6();
    return [false, Jc];
  }, useId: function() {
    var a4 = yc.treeContext;
    var b4 = a4.overflow;
    a4 = a4.id;
    a4 = (a4 & ~(1 << 32 - sc(a4) - 1)).toString(32) + b4;
    var c4 = Lc;
    if (c4 === null)
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
    b4 = U6++;
    a4 = ":" + c4.idPrefix + "R" + a4;
    0 < b4 && (a4 += "H" + b4.toString(32));
    return a4 + ":";
  }, useMutableSource: function(a4, b4) {
    W6();
    return b4(a4._source);
  }, useSyncExternalStore: function(a4, b4, c4) {
    if (c4 === undefined)
      throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
    return c4();
  } };
  Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
});

// ../node_modules/react-dom/server.node.js
var exports_server_node = {};
__export(exports_server_node, {
  version: () => $version4,
  renderToString: () => $renderToString2,
  renderToStaticNodeStream: () => $renderToStaticNodeStream2,
  renderToStaticMarkup: () => $renderToStaticMarkup2,
  renderToPipeableStream: () => $renderToPipeableStream2,
  renderToNodeStream: () => $renderToNodeStream2
});
var l9, s8, $version4, $renderToString2, $renderToStaticMarkup2, $renderToNodeStream2, $renderToStaticNodeStream2, $renderToPipeableStream2;
var init_server_node = __esm(() => {
  init_react_dom_server_legacy_node_production_min();
  init_react_dom_server_node_production_min();
  if (true) {
    l9 = exports_react_dom_server_legacy_node_production_min;
    s8 = exports_react_dom_server_node_production_min;
  } else {
  }
  $version4 = l9.version;
  $renderToString2 = l9.renderToString;
  $renderToStaticMarkup2 = l9.renderToStaticMarkup;
  $renderToNodeStream2 = l9.renderToNodeStream;
  $renderToStaticNodeStream2 = l9.renderToStaticNodeStream;
  $renderToPipeableStream2 = s8.renderToPipeableStream;
});

// ../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isMergeableObject = function isMergeableObject(value3) {
    return isNonNullObject(value3) && !isSpecial(value3);
  };
  function isNonNullObject(value3) {
    return !!value3 && typeof value3 === "object";
  }
  function isSpecial(value3) {
    var stringValue = Object.prototype.toString.call(value3);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value3);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value3) {
    return value3.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val2) {
    return Array.isArray(val2) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value3, options) {
    return options.clone !== false && options.isMergeableObject(value3) ? deepmerge(emptyTarget(value3), value3, options) : value3;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol5) {
      return Object.propertyIsEnumerable.call(target, symbol5);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object5, property) {
    try {
      return property in object5;
    } catch (_4) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array5, options) {
    if (!Array.isArray(array5)) {
      throw new Error("first argument should be an array");
    }
    return array5.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// ../node_modules/js-beautify/js/src/core/output.js
var require_output = __commonJS((exports, module) => {
  function OutputLine(parent) {
    this.__parent = parent;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  }
  OutputLine.prototype.clone_empty = function() {
    var line2 = new OutputLine(this.__parent);
    line2.set_indent(this.__indent_count, this.__alignment_count);
    return line2;
  };
  OutputLine.prototype.item = function(index2) {
    if (index2 < 0) {
      return this.__items[this.__items.length + index2];
    } else {
      return this.__items[index2];
    }
  };
  OutputLine.prototype.has_match = function(pattern3) {
    for (var lastCheckedOutput = this.__items.length - 1;lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern3)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next = this.__parent.current_line;
      next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next.__items[0] === " ") {
        next.__items.splice(0, 1);
        next.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf("\n");
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result += this.__items.join("");
    }
    return result;
  };
  function IndentStringCache(options, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options.indent_size;
    this.__indent_string = options.indent_char;
    if (!options.indent_with_tabs) {
      this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options.indent_level > 0) {
      baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  }
  IndentStringCache.prototype.get_indent_size = function(indent, column) {
    var result = this.__base_string_length;
    column = column || 0;
    if (indent < 0) {
      result = 0;
    }
    result += indent * this.__indent_size;
    result += column;
    return result;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
    var result = this.__base_string;
    column = column || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result = "";
    }
    column += indent_level * this.__indent_size;
    this.__ensure_cache(column);
    result += this.__cache[column];
    return result;
  };
  IndentStringCache.prototype.__ensure_cache = function(column) {
    while (column >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column = this.__cache.length;
    var indent = 0;
    var result = "";
    if (this.__indent_size && column >= this.__indent_size) {
      indent = Math.floor(column / this.__indent_size);
      column -= indent * this.__indent_size;
      result = new Array(indent + 1).join(this.__indent_string);
    }
    if (column) {
      result += new Array(column + 1).join(" ");
    }
    this.__cache.push(result);
  };
  function Output(options, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options, baseIndentString);
    this.raw = false;
    this._end_with_newline = options.end_with_newline;
    this.indent_size = options.indent_size;
    this.wrap_line_length = options.wrap_line_length;
    this.indent_empty_lines = options.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  }
  Output.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output.prototype.get_indent_string = function(indent, column) {
    return this.__indent_cache.get_indent_string(indent, column);
  };
  Output.prototype.get_indent_size = function(indent, column) {
    return this.__indent_cache.get_indent_size(indent, column);
  };
  Output.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === "\n") {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join("\n");
    if (eol !== "\n") {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output.prototype.add_raw_token = function(token2) {
    for (var x4 = 0;x4 < token2.newlines; x4++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token2.whitespace_before);
    this.current_line.push(token2.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output.prototype.remove_indent = function(index2) {
    var output_length = this.__lines.length;
    while (index2 < output_length) {
      this.__lines[index2]._remove_indent();
      index2++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index2 = this.__lines.length - 2;
    while (index2 >= 0) {
      var potentialEmptyLine = this.__lines[index2];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index2 + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index2--;
    }
  };
  exports.Output = Output;
});

// ../node_modules/js-beautify/js/src/core/token.js
var require_token = __commonJS((exports, module) => {
  function Token(type5, text4, newlines, whitespace_before) {
    this.type = type5;
    this.text = text4;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  }
  exports.Token = Token;
});

// ../node_modules/js-beautify/js/src/javascript/acorn.js
var require_acorn = __commonJS((exports) => {
  var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
  var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
  var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
  var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
  var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
  var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
  var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
  exports.identifier = new RegExp(identifierStart + identifierChars, "g");
  exports.identifierStart = new RegExp(identifierStart);
  exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
  exports.newline = /[\n\r\u2028\u2029]/;
  exports.lineBreak = new RegExp("\r\n|" + exports.newline.source);
  exports.allLineBreaks = new RegExp(exports.lineBreak.source, "g");
});

// ../node_modules/js-beautify/js/src/core/options.js
var require_options = __commonJS((exports, module) => {
  function Options(options, merge_child_field) {
    this.raw_options = _mergeOpts(options, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "\t");
    if (this.indent_with_tabs) {
      this.indent_char = "\t";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "angular", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  }
  Options.prototype._get_array = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result;
  };
  Options.prototype._get_boolean = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = option_value === undefined ? !!default_value : !!option_value;
    return result;
  };
  Options.prototype._get_characters = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = default_value || "";
    if (typeof option_value === "string") {
      result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "\t");
    }
    return result;
  };
  Options.prototype._get_number = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result = parseInt(option_value, 10);
    if (isNaN(result)) {
      result = default_value;
    }
    return result;
  };
  Options.prototype._get_selection = function(name2, selection_list, default_value) {
    var result = this._get_selection_list(name2, selection_list, default_value);
    if (result.length !== 1) {
      throw new Error("Invalid Option Value: The option '" + name2 + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name2] + "'");
    }
    return result[0];
  };
  Options.prototype._get_selection_list = function(name2, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result = this._get_array(name2, default_value);
    if (!this._is_valid_selection(result, selection_list)) {
      throw new Error("Invalid Option Value: The option '" + name2 + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name2] + "'");
    }
    return result;
  };
  Options.prototype._is_valid_selection = function(result, selection_list) {
    return result.length && selection_list.length && !result.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  function _mergeOpts(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name2;
    for (name2 in allOptions) {
      if (name2 !== childFieldName) {
        finalOpts[name2] = allOptions[name2];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name2 in allOptions[childFieldName]) {
        finalOpts[name2] = allOptions[childFieldName][name2];
      }
    }
    return finalOpts;
  }
  function _normalizeOpts(options) {
    var convertedOpts = {};
    var key;
    for (key in options) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options[key];
    }
    return convertedOpts;
  }
  exports.Options = Options;
  exports.normalizeOpts = _normalizeOpts;
  exports.mergeOpts = _mergeOpts;
});

// ../node_modules/js-beautify/js/src/javascript/options.js
var require_options2 = __commonJS((exports, module) => {
  var BaseOptions = require_options().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  function Options(options) {
    BaseOptions.call(this, options, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== undefined) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  }
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../node_modules/js-beautify/js/src/core/inputscanner.js
var require_inputscanner = __commonJS((exports, module) => {
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  function InputScanner(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  }
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val2 = null;
    if (this.hasNext()) {
      val2 = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val2;
  };
  InputScanner.prototype.peek = function(index2) {
    var val2 = null;
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__input_length) {
      val2 = this.__input.charAt(index2);
    }
    return val2;
  };
  InputScanner.prototype.__match = function(pattern3, index2) {
    pattern3.lastIndex = index2;
    var pattern_match = pattern3.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern3.sticky)) {
      if (pattern_match.index !== index2) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern3, index2) {
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__input_length) {
      return !!this.__match(pattern3, index2);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern3, index2) {
    var val2 = this.peek(index2);
    pattern3.lastIndex = 0;
    return val2 !== null && pattern3.test(val2);
  };
  InputScanner.prototype.match = function(pattern3) {
    var pattern_match = this.__match(pattern3, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val2 = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val2 += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val2 += this.readUntil(until_pattern, until_after);
    }
    return val2;
  };
  InputScanner.prototype.readUntil = function(pattern3, until_after) {
    var val2 = "";
    var match_index = this.__position;
    pattern3.lastIndex = this.__position;
    var pattern_match = pattern3.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val2 = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val2;
  };
  InputScanner.prototype.readUntilAfter = function(pattern3) {
    return this.readUntil(pattern3, true);
  };
  InputScanner.prototype.get_regexp = function(pattern3, match_from) {
    var result = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern3 === "string" && pattern3 !== "") {
      result = new RegExp(pattern3, flags);
    } else if (pattern3) {
      result = new RegExp(pattern3.source, flags);
    }
    return result;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern3) {
    var start = this.__position;
    var val2 = this.readUntilAfter(pattern3);
    this.__position = start;
    return val2;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  exports.InputScanner = InputScanner;
});

// ../node_modules/js-beautify/js/src/core/tokenstream.js
var require_tokenstream = __commonJS((exports, module) => {
  function TokenStream(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  }
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val2 = null;
    if (this.hasNext()) {
      val2 = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val2;
  };
  TokenStream.prototype.peek = function(index2) {
    var val2 = null;
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__tokens_length) {
      val2 = this.__tokens[index2];
    }
    return val2;
  };
  TokenStream.prototype.add = function(token2) {
    if (this.__parent_token) {
      token2.parent = this.__parent_token;
    }
    this.__tokens.push(token2);
    this.__tokens_length += 1;
  };
  exports.TokenStream = TokenStream;
});

// ../node_modules/js-beautify/js/src/core/pattern.js
var require_pattern = __commonJS((exports, module) => {
  function Pattern(input_scanner, parent) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent) {
      this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent._until_pattern);
      this._until_after = parent._until_after;
    }
  }
  Pattern.prototype.read = function() {
    var result = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result) {
      result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern3) {
    var result = this._create();
    result._until_after = true;
    result._until_pattern = this._input.get_regexp(pattern3);
    result._update();
    return result;
  };
  Pattern.prototype.until = function(pattern3) {
    var result = this._create();
    result._until_after = false;
    result._until_pattern = this._input.get_regexp(pattern3);
    result._update();
    return result;
  };
  Pattern.prototype.starting_with = function(pattern3) {
    var result = this._create();
    result._starting_pattern = this._input.get_regexp(pattern3, true);
    result._update();
    return result;
  };
  Pattern.prototype.matching = function(pattern3) {
    var result = this._create();
    result._match_pattern = this._input.get_regexp(pattern3, true);
    result._update();
    return result;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {
  };
  exports.Pattern = Pattern;
});

// ../node_modules/js-beautify/js/src/core/whitespacepattern.js
var require_whitespacepattern = __commonJS((exports, module) => {
  var Pattern = require_pattern().Pattern;
  function WhitespacePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    if (parent) {
      this._line_regexp = this._input.get_regexp(parent._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  }
  WhitespacePattern.prototype = new Pattern;
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result = this._create();
    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result._update();
    return result;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp5, input_string) {
    regexp5.lastIndex = 0;
    var start_index = 0;
    var result = [];
    var next_match = regexp5.exec(input_string);
    while (next_match) {
      result.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp5.exec(input_string);
    }
    if (start_index < input_string.length) {
      result.push(input_string.substring(start_index, input_string.length));
    } else {
      result.push("");
    }
    return result;
  };
  exports.WhitespacePattern = WhitespacePattern;
});

// ../node_modules/js-beautify/js/src/core/tokenizer.js
var require_tokenizer = __commonJS((exports, module) => {
  var InputScanner = require_inputscanner().InputScanner;
  var Token = require_token().Token;
  var TokenStream = require_tokenstream().TokenStream;
  var WhitespacePattern = require_whitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer2 = function(input_string, options) {
    this._input = new InputScanner(input_string);
    this._options = options || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer2.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream;
    this._reset();
    var current;
    var previous = new Token(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream;
    while (previous.type !== TOKEN.EOF) {
      current = this._get_next_token(previous, open_token);
      while (this._is_comment(current)) {
        comments.add(current);
        current = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current.comments_before = comments;
        comments = new TokenStream;
      }
      current.parent = open_token;
      if (this._is_opening(current)) {
        open_stack.push(open_token);
        open_token = current;
      } else if (open_token && this._is_closing(current, open_token)) {
        current.opened = open_token;
        open_token.closed = current;
        open_token = open_stack.pop();
        current.parent = open_token;
      }
      current.previous = previous;
      previous.next = current;
      this.__tokens.add(current);
      previous = current;
    }
    return this.__tokens;
  };
  Tokenizer2.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer2.prototype._reset = function() {
  };
  Tokenizer2.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer2.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer2.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer2.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer2.prototype._create_token = function(type5, text4) {
    var token2 = new Token(type5, text4, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
    return token2;
  };
  Tokenizer2.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  exports.Tokenizer = Tokenizer2;
  exports.TOKEN = TOKEN;
});

// ../node_modules/js-beautify/js/src/core/directives.js
var require_directives = __commonJS((exports, module) => {
  function Directives(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  }
  Directives.prototype.get_directives = function(text4) {
    if (!text4.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text4);
    while (directive_match) {
      directives[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text4);
    }
    return directives;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  exports.Directives = Directives;
});

// ../node_modules/js-beautify/js/src/core/templatablepattern.js
var require_templatablepattern = __commonJS((exports, module) => {
  var Pattern = require_pattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false,
    angular: false
  };
  function TemplatablePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent) {
      this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent._excluded);
      this._disabled = Object.assign(this._disabled, parent._disabled);
    }
    var pattern3 = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern3.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern3.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern3.starting_with(/{{/).until_after(/}}/),
      php: pattern3.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern3.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      django: pattern3.starting_with(/{%/).until_after(/%}/),
      django_value: pattern3.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern3.starting_with(/{#/).until_after(/#}/),
      smarty: pattern3.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern3.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern3.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  }
  TemplatablePattern.prototype = new Pattern;
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result = this._create();
    result._disabled[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read_options = function(options) {
    var result = this._create();
    for (var language in template_names) {
      result._disabled[language] = options.templating.indexOf(language) === -1;
    }
    result._update();
    return result;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result = this._create();
    result._excluded[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read = function() {
    var result = "";
    if (this._match_pattern) {
      result = this._input.read(this._starting_pattern);
    } else {
      result = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next = this._read_template();
    while (next) {
      if (this._match_pattern) {
        next += this._input.read(this._match_pattern);
      } else {
        next += this._input.readUntil(this.__template_pattern);
      }
      result += next;
      next = this._read_template();
    }
    if (this._until_after) {
      result += this._input.readUntilAfter(this._until_pattern);
    }
    return result;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c4 = this._input.peek();
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c4 === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  exports.TemplatablePattern = TemplatablePattern;
});

// ../node_modules/js-beautify/js/src/javascript/tokenizer.js
var require_tokenizer2 = __commonJS((exports, module) => {
  var InputScanner = require_inputscanner().InputScanner;
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var acorn = require_acorn();
  var Pattern = require_pattern().Pattern;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = (">>> === !== &&= ??= ||= " + "<< && >= ** != == <= >> || ?? |> " + "< / - + > : & % ? ^ | *").split(" ");
  var punct = ">>>= " + "... >>= <<= === >>> !== **= &&= ??= ||= " + "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " + "= ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer2 = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer2.prototype = new BaseTokenizer;
  Tokenizer2.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer2.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer2.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer2.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer2.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c4 = this._input.peek();
    if (c4 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_non_javascript(c4);
    token2 = token2 || this._read_string(c4);
    token2 = token2 || this._read_pair(c4, this._input.peek(1));
    token2 = token2 || this._read_word(previous_token);
    token2 = token2 || this._read_singles(c4);
    token2 = token2 || this._read_comment(c4);
    token2 = token2 || this._read_regexp(c4, previous_token);
    token2 = token2 || this._read_xml(c4, previous_token);
    token2 = token2 || this._read_punctuation();
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer2.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer2.prototype._read_singles = function(c4) {
    var token2 = null;
    if (c4 === "(" || c4 === "[") {
      token2 = this._create_token(TOKEN.START_EXPR, c4);
    } else if (c4 === ")" || c4 === "]") {
      token2 = this._create_token(TOKEN.END_EXPR, c4);
    } else if (c4 === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c4);
    } else if (c4 === "}") {
      token2 = this._create_token(TOKEN.END_BLOCK, c4);
    } else if (c4 === ";") {
      token2 = this._create_token(TOKEN.SEMICOLON, c4);
    } else if (c4 === "." && dot_pattern.test(this._input.peek(1))) {
      token2 = this._create_token(TOKEN.DOT, c4);
    } else if (c4 === ",") {
      token2 = this._create_token(TOKEN.COMMA, c4);
    }
    if (token2) {
      this._input.next();
    }
    return token2;
  };
  Tokenizer2.prototype._read_pair = function(c4, d4) {
    var token2 = null;
    if (c4 === "#" && d4 === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c4 + d4);
    }
    if (token2) {
      this._input.next();
      this._input.next();
    }
    return token2;
  };
  Tokenizer2.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer2.prototype._read_non_javascript = function(c4) {
    var resulting_string = "";
    if (c4 === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
      }
      c4 = this._input.next();
      var sharp = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c4 = this._input.next();
          sharp += c4;
        } while (this._input.hasNext() && c4 !== "#" && c4 !== "=");
        if (c4 === "#") {
        } else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp);
      }
      this._input.back();
    } else if (c4 === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c4 === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer2.prototype._read_comment = function(c4) {
    var token2 = null;
    if (c4 === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn.allLineBreaks, "\n");
        token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token2.directives = directives;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token2 = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_string = function(c4) {
    if (c4 === "`" || c4 === "'" || c4 === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c4 === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c4);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c4) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer2.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer2.prototype._read_regexp = function(c4, previous_token) {
    if (c4 === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c4) && !this._input.testChar(acorn.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c4) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer2.prototype._read_xml = function(c4, previous_token) {
    if (this._options.e4x && c4 === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  function unescape_string(s5) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s5);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          if (!matched) {
            matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
          }
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s5;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s5;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
        } else if (escaped > 1114111) {
          out += "\\" + matched[0];
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  }
  Tokenizer2.prototype._read_string_recursive = function(delimiter2, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern3;
    if (delimiter2 === "\'") {
      pattern3 = this.__patterns.single_quote;
    } else if (delimiter2 === '"') {
      pattern3 = this.__patterns.double_quote;
    } else if (delimiter2 === "`") {
      pattern3 = this.__patterns.template_text;
    } else if (delimiter2 === "}") {
      pattern3 = this.__patterns.template_expression;
    }
    var resulting_string = pattern3.read();
    var next = "";
    while (this._input.hasNext()) {
      next = this._input.next();
      if (next === delimiter2 || !allow_unescaped_newlines && acorn.newline.test(next)) {
        this._input.back();
        break;
      } else if (next === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === "\n") {
          this._input.next();
        }
        next += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
          next += this._input.next();
        }
        if (start_sub === next) {
          if (delimiter2 === "`") {
            next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next += this._input.next();
          }
        }
      }
      next += pattern3.read();
      resulting_string += next;
    }
    return resulting_string;
  };
  exports.Tokenizer = Tokenizer2;
  exports.TOKEN = TOKEN;
  exports.positionable_operators = positionable_operators.slice();
  exports.line_starters = line_starters.slice();
});

// ../node_modules/js-beautify/js/src/javascript/beautifier.js
var require_beautifier = __commonJS((exports, module) => {
  var Output = require_output().Output;
  var Token = require_token().Token;
  var acorn = require_acorn();
  var Options = require_options2().Options;
  var Tokenizer2 = require_tokenizer2().Tokenizer;
  var line_starters = require_tokenizer2().line_starters;
  var positionable_operators = require_tokenizer2().positionable_operators;
  var TOKEN = require_tokenizer2().TOKEN;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function ltrim(s5) {
    return s5.replace(/^\s+/g, "");
  }
  function generateMapFromStrings(list) {
    var result = {};
    for (var x4 = 0;x4 < list.length; x4++) {
      result[list[x4].replace(/-/g, "_")] = list[x4];
    }
    return result;
  }
  function reserved_word(token2, word) {
    return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
  }
  function reserved_array(token2, words) {
    return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
  }
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    Statement: "Statement",
    ObjectLiteral: "ObjectLiteral",
    ArrayLiteral: "ArrayLiteral",
    ForInitializer: "ForInitializer",
    Conditional: "Conditional",
    Expression: "Expression"
  };
  function remove_redundant_indentation(output, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output.remove_indent(frame.start_line_index);
  }
  function split_linebreaks(s5) {
    s5 = s5.replace(acorn.allLineBreaks, "\n");
    var out = [], idx = s5.indexOf("\n");
    while (idx !== -1) {
      out.push(s5.substring(0, idx));
      s5 = s5.substring(idx + 1);
      idx = s5.indexOf("\n");
    }
    if (s5.length) {
      out.push(s5);
    }
    return out;
  }
  function is_array(mode) {
    return mode === MODE.ArrayLiteral;
  }
  function is_expression(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  }
  function all_lines_start_with(lines, c4) {
    for (var i4 = 0;i4 < lines.length; i4++) {
      var line2 = lines[i4].trim();
      if (line2.charAt(0) !== c4) {
        return false;
      }
    }
    return true;
  }
  function each_line_matches_indent(lines, indent) {
    var i4 = 0, len = lines.length, line2;
    for (;i4 < len; i4++) {
      line2 = lines[i4];
      if (line2 && line2.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  }
  function Beautifier(source_text, options) {
    options = options || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options);
  }
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
      last_word: flags_base ? flags_base.last_word : "",
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      in_case: false,
      case_body: false,
      case_block: false,
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer = new Tokenizer2(source_text, this._options);
    this._tokens = tokenizer.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && acorn.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i4 = 0;i4 < newlines; i4 += 1) {
        this.print_newline(i4 > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j5 = 1;j5 < newlines; j5 += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === undefined ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index2 = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index2 += 1;
        check_token = this._tokens.peek(index2 - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property() && !(in_array(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
      } else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix = "NEWLINE";
        } else {
          prefix = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line2 = this._output.current_line;
        if (line2.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) {
    } else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token)) {
    } else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (in_array(current_token.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j5;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j5 = 0;j5 < lines.length; j5++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j5]));
        } else if (starless && lines[j5]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j5].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j5]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === "\n") {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  exports.Beautifier = Beautifier;
});

// ../node_modules/js-beautify/js/src/javascript/index.js
var require_javascript = __commonJS((exports, module) => {
  var Beautifier = require_beautifier().Beautifier;
  var Options = require_options2().Options;
  function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
  }
  module.exports = js_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../node_modules/js-beautify/js/src/css/options.js
var require_options3 = __commonJS((exports, module) => {
  var BaseOptions = require_options().Options;
  function Options(options) {
    BaseOptions.call(this, options, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
  }
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../node_modules/js-beautify/js/src/css/beautifier.js
var require_beautifier2 = __commonJS((exports, module) => {
  var Options = require_options3().Options;
  var Output = require_output().Output;
  var InputScanner = require_inputscanner().InputScanner;
  var Directives = require_directives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  function Beautifier(source_text, options) {
    this._source_text = source_text || "";
    this._options = new Options(options);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      page: true,
      "font-face": true,
      keyframes: true,
      media: true,
      supports: true,
      document: true
    };
    this.CONDITIONAL_GROUP_RULE = {
      media: true,
      supports: true,
      document: true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  }
  Beautifier.prototype.eatString = function(endChars) {
    var result = "";
    this._ch = this._input.next();
    while (this._ch) {
      result += this._ch;
      if (this._ch === "\\") {
        result += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
        break;
      }
      this._ch = this._input.next();
    }
    return result;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === "\n") {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i4 = 1;
    var ch = this._input.peek(i4);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i4++;
      ch = this._input.peek(i4);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text || "")) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideNonNestedAtRule = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        if (variable.match(/[ :]$/)) {
          variable = this.eatString(": ").replace(/\s+$/, "");
          this.print_string(variable);
          this._output.space_before_token = true;
        }
        if (parenLevel === 0 && variable.indexOf(":") !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      } else if (this._ch === "@") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s+$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          } else if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (parenLevel === 0 && !insidePropertyValue) {
            insideNonNestedAtRule = true;
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        insideNonNestedAtRule = false;
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i4 = 0;i4 < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i4++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i4])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "\'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideNonNestedAtRule = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "\'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  exports.Beautifier = Beautifier;
});

// ../node_modules/js-beautify/js/src/css/index.js
var require_css = __commonJS((exports, module) => {
  var Beautifier = require_beautifier2().Beautifier;
  var Options = require_options3().Options;
  function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
  }
  module.exports = css_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../node_modules/js-beautify/js/src/html/options.js
var require_options4 = __commonJS((exports, module) => {
  var BaseOptions = require_options().Options;
  function Options(options) {
    BaseOptions.call(this, options, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
    this.void_elements = this._get_array("void_elements", [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      "!doctype",
      "?xml",
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  }
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../node_modules/js-beautify/js/src/html/tokenizer.js
var require_tokenizer3 = __commonJS((exports, module) => {
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  var Pattern = require_pattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    CONTROL_FLOW_OPEN: "TK_CONTROL_FLOW_OPEN",
    CONTROL_FLOW_CLOSE: "TK_CONTROL_FLOW_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer2 = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      word_control_flow_close_excluded: templatable_reader.until(/[\n\r\t <}]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      angular_control_flow_start: pattern_reader.matching(/\@[a-zA-Z]+[^({]*[({]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
      this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer2.prototype = new BaseTokenizer;
  Tokenizer2.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer2.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;
  };
  Tokenizer2.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{")) || current_token.type === TOKEN.CONTROL_FLOW_CLOSE && (current_token.text === "}" && open_token.text.endsWith("{"));
  };
  Tokenizer2.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer2.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c4 = this._input.peek();
    if (c4 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_open_handlebars(c4, open_token);
    token2 = token2 || this._read_attribute(c4, previous_token, open_token);
    token2 = token2 || this._read_close(c4, open_token);
    token2 = token2 || this._read_control_flows(c4, open_token);
    token2 = token2 || this._read_raw_content(c4, previous_token, open_token);
    token2 = token2 || this._read_content_word(c4, open_token);
    token2 = token2 || this._read_comment_or_cdata(c4);
    token2 = token2 || this._read_processing(c4);
    token2 = token2 || this._read_open(c4, open_token);
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer2.prototype._read_comment_or_cdata = function(c4) {
    var token2 = null;
    var resulting_string = null;
    var directives = null;
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives = directives_core.get_directives(resulting_string);
          if (directives && directives.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives;
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_processing = function(c4) {
    var token2 = null;
    var resulting_string = null;
    var directives = null;
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives;
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_open = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      if (c4 === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_open_handlebars = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      if (this._options.indent_handlebars && c4 === "{" && this._input.peek(1) === "{") {
        if (this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_control_flows = function(c4, open_token) {
    var resulting_string = "";
    var token2 = null;
    if (!this._options.templating.includes("angular") || !this._options.indent_handlebars) {
      return token2;
    }
    if (c4 === "@") {
      resulting_string = this.__patterns.angular_control_flow_start.read();
      if (resulting_string === "") {
        return token2;
      }
      var opening_parentheses_count = resulting_string.endsWith("(") ? 1 : 0;
      var closing_parentheses_count = 0;
      while (!(resulting_string.endsWith("{") && opening_parentheses_count === closing_parentheses_count)) {
        var next_char = this._input.next();
        if (next_char === null) {
          break;
        } else if (next_char === "(") {
          opening_parentheses_count++;
        } else if (next_char === ")") {
          closing_parentheses_count++;
        }
        resulting_string += next_char;
      }
      token2 = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);
    } else if (c4 === "}" && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      resulting_string = this._input.next();
      token2 = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);
    }
    return token2;
  };
  Tokenizer2.prototype._read_close = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (open_token && open_token.type === TOKEN.TAG_OPEN) {
      if (open_token.text[0] === "<" && (c4 === ">" || c4 === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c4 === "/") {
          resulting_string += this._input.next();
        }
        token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c4 === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token2;
  };
  Tokenizer2.prototype._read_attribute = function(c4, previous_token, open_token) {
    var token2 = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c4 === "=") {
        token2 = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c4 === '"' || c4 === "'") {
        var content = this._input.next();
        if (c4 === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token2 = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token2 = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token2;
  };
  Tokenizer2.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer2.prototype._read_raw_content = function(c4, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token2 = this._read_comment_or_cdata(c4);
        if (token2) {
          token2.type = TOKEN.TEXT;
          return token2;
        }
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      } else if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer2.prototype._read_content_word = function(c4, open_token) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c4 === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
  };
  exports.Tokenizer = Tokenizer2;
  exports.TOKEN = TOKEN;
});

// ../node_modules/js-beautify/js/src/html/beautifier.js
var require_beautifier3 = __commonJS((exports, module) => {
  var Options = require_options4().Options;
  var Output = require_output().Output;
  var Tokenizer2 = require_tokenizer3().Tokenizer;
  var TOKEN = require_tokenizer3().TOKEN;
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options.max_preserve_newlines;
    this.preserve_newlines = options.preserve_newlines;
    this._output = new Output(options, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern3) {
    return this._output.current_line.has_match(pattern3);
  };
  Printer.prototype.set_space_before_token = function(value3, non_breaking) {
    this._output.space_before_token = value3;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token2) {
    this._output.add_raw_token(token2);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n10 = 0;n10 < newlines; n10++) {
      this.print_newline(n10 > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token2) {
    if (token2.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token2.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.deindent = function() {
    if (this.indent_level > 0) {
      this.indent_level--;
      this._output.set_indent(this.indent_level, this.alignment_size);
    }
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result = "null";
    }
    return result;
  };
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function TagFrame(parent, parser_token, indent_level) {
    this.parent = parent || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  }
  function TagStack(printer) {
    this._printer = printer;
    this._current_frame = null;
  }
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  function Beautifier(source_text, options, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options = options || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  }
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text)) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken;
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer2(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {
        parser_token = this._handle_control_flow_open(printer, raw_token);
      } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {
        parser_token = this._handle_control_flow_close(printer, raw_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (raw_token.newlines) {
      printer.print_preserved_newlines(raw_token);
    } else {
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    }
    printer.print_token(raw_token);
    printer.indent();
    return parser_token;
  };
  Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.deindent();
    if (raw_token.newlines) {
      printer.print_preserved_newlines(raw_token);
    } else {
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    }
    printer.print_token(raw_token);
    return parser_token;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline)) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text4 = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options) {
          var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
          return beautifier.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text4 = text4.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text4[0] === "<" && text4.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text4);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre = indentation + matched[1] + "\n";
        text4 = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text4 = text4.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf("\n") !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text4) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = "\n";
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options;
          text4 = _beautifier(indentation + text4, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text4 = text4.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
          }
          text4 = indentation + text4.replace(/\n/g, "\n" + indentation);
        }
      }
      if (pre) {
        if (!text4) {
          text4 = pre + post;
        } else {
          text4 = pre + text4 + "\n" + post;
        }
      }
      printer.print_newline(false);
      if (text4) {
        raw_token.text = text4;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
      var peek_index = 0;
      var peek_token;
      do {
        peek_token = tokens.peek(peek_index);
        if (peek_token.type === TOKEN.ATTRIBUTE) {
          parser_token.attr_count += 1;
        }
        peek_index += 1;
      } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(parent, raw_token) {
    this.parent = parent || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
      } else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result = result || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result = result || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result = result || this._tag_stack.try_pop("dt", ["dl"]);
      result = result || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result = result || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result = result || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("thead", ["table"]);
      result = result || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result;
  };
  exports.Beautifier = Beautifier;
});

// ../node_modules/js-beautify/js/src/html/index.js
var require_html = __commonJS((exports, module) => {
  var Beautifier = require_beautifier3().Beautifier;
  var Options = require_options4().Options;
  function style_html(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
  }
  module.exports = style_html;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../node_modules/js-beautify/js/src/index.js
var require_src30 = __commonJS((exports, module) => {
  var js_beautify = require_javascript();
  var css_beautify = require_css();
  var html_beautify = require_html();
  function style_html(html_source, options, js, css) {
    js = js || js_beautify;
    css = css || css_beautify;
    return html_beautify(html_source, options, js, css);
  }
  style_html.defaultOptions = html_beautify.defaultOptions;
  exports.js = js_beautify;
  exports.css = css_beautify;
  exports.html = style_html;
});

// ../node_modules/js-beautify/js/index.js
var require_js = __commonJS((exports, module) => {
  function get_beautify(js_beautify, css_beautify, html_beautify) {
    var beautify = function(src, config6) {
      return js_beautify.js_beautify(src, config6);
    };
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
  }
  if (typeof define === "function" && define.amd) {
    define([
      "./lib/beautify",
      "./lib/beautify-css",
      "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
      return get_beautify(js_beautify, css_beautify, html_beautify);
    });
  } else {
    (function(mod) {
      var beautifier = require_src30();
      beautifier.js_beautify = beautifier.js;
      beautifier.css_beautify = beautifier.css;
      beautifier.html_beautify = beautifier.html;
      mod.exports = get_beautify(beautifier, beautifier, beautifier);
    })(module);
  }
});

// ../node_modules/@sentry/utils/build/esm/is.js
var objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}

// ../node_modules/@sentry/utils/build/esm/string.js
function truncate(str, max = 0) {
  if (typeof str !== "string" || max === 0) {
    return str;
  }
  return str.length <= max ? str : `${str.slice(0, max)}...`;
}
function snipLine(line, colno) {
  let newLine = line;
  const lineLength = newLine.length;
  if (lineLength <= 150) {
    return newLine;
  }
  if (colno > lineLength) {
    colno = lineLength;
  }
  let start = Math.max(colno - 60, 0);
  if (start < 5) {
    start = 0;
  }
  let end = Math.min(start + 140, lineLength);
  if (end > lineLength - 5) {
    end = lineLength;
  }
  if (end === lineLength) {
    start = Math.max(end - 140, 0);
  }
  newLine = newLine.slice(start, end);
  if (start > 0) {
    newLine = `'{snip} ${newLine}`;
  }
  if (end < lineLength) {
    newLine += " {snip}";
  }
  return newLine;
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}

// ../node_modules/@sentry/utils/build/esm/aggregate-errors.js
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : undefined;
  if (originalException) {
    event.exception.values = truncateAggregateExceptions(aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, hint.originalException, key, event.exception.values, originalException, 0), maxValueLimit);
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser, error[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error[key], key, [newException, ...newExceptions], newException, newExceptionId);
  }
  if (Array.isArray(error.errors)) {
    error.errors.forEach((childError, i) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, childError, key, [newException, ...newExceptions], newException, newExceptionId);
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}
function truncateAggregateExceptions(exceptions, maxValueLength) {
  return exceptions.map((exception) => {
    if (exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    return exception;
  });
}
// ../node_modules/@sentry/utils/build/esm/array.js
function flatten(input) {
  const result = [];
  const flattenHelper = (input2) => {
    input2.forEach((el) => {
      if (Array.isArray(el)) {
        flattenHelper(el);
      } else {
        result.push(el);
      }
    });
  };
  flattenHelper(input);
  return result;
}
// ../node_modules/@sentry/utils/build/esm/breadcrumb-log-level.js
function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
  if (statusCode === undefined) {
    return;
  } else if (statusCode >= 400 && statusCode < 500) {
    return "warning";
  } else if (statusCode >= 500) {
    return "error";
  } else {
    return;
  }
}
// ../node_modules/@sentry/utils/build/esm/version.js
var SDK_VERSION = "8.32.0";

// ../node_modules/@sentry/utils/build/esm/worldwide.js
var GLOBAL_OBJ = globalThis;
function getGlobalSingleton(name, creator, obj) {
  const gbl = obj || GLOBAL_OBJ;
  const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
  const versionedCarrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return versionedCarrier[name] || (versionedCarrier[name] = creator());
}

// ../node_modules/@sentry/utils/build/esm/browser.js
var WINDOW = GLOBAL_OBJ;
var DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
    const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el, keyAttrs) {
  const elem = el;
  const out = [];
  if (!elem || !elem.tagName) {
    return "";
  }
  if (WINDOW.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset) {
      if (elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
      if (elem.dataset["sentryElement"]) {
        return elem.dataset["sentryElement"];
      }
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    const className = elem.className;
    if (className && isString(className)) {
      const classes = className.split(/\s+/);
      for (const c of classes) {
        out.push(`.${c}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (const k of allowedAttrs) {
    const attr = elem.getAttribute(k);
    if (attr) {
      out.push(`[${k}="${attr}"]`);
    }
  }
  return out.join("");
}

// ../node_modules/@sentry/utils/build/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../node_modules/@sentry/utils/build/esm/logger.js
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
var originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD) {
    CONSOLE_LEVELS.forEach((name) => {
      logger[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger[name] = () => {
        return;
      };
    });
  }
  return logger;
}
var logger = getGlobalSingleton("logger", makeLogger);

// ../node_modules/@sentry/utils/build/esm/dsn.js
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}` + `@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
}
function dsnFromString(str) {
  const match = DSN_REGEX.exec(str);
  if (!match) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return;
  }
  const [protocol, publicKey, pass = "", host = "", port = "", lastPath = ""] = match.slice(1);
  let path = "";
  let projectId = lastPath;
  const split = projectId.split("/");
  if (split.length > 1) {
    path = split.slice(0, -1).join("/");
    projectId = split.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      logger.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function makeDsn(from) {
  const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  if (!components || !validateDsn(components)) {
    return;
  }
  return components;
}
// ../node_modules/@sentry/utils/build/esm/error.js
class SentryError extends Error {
  constructor(message, logLevel = "warn") {
    super(message);
    this.message = message;
    this.name = new.target.prototype.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
    this.logLevel = logLevel;
  }
}
// ../node_modules/@sentry/utils/build/esm/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  source[name] = wrapped;
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch (o_O) {
  }
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function urlEncode(object) {
  return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys = Object.keys(convertToPlainObject(exception));
  keys.sort();
  const firstKey = keys[0];
  if (!firstKey) {
    return "[object has no keys]";
  }
  if (firstKey.length >= maxLength) {
    return truncate(firstKey, maxLength);
  }
  for (let includedKeys = keys.length;includedKeys > 0; includedKeys--) {
    const serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}
function dropUndefinedKeys(inputValue) {
  const memoizationMap = new Map;
  return _dropUndefinedKeys(inputValue, memoizationMap);
}
function _dropUndefinedKeys(inputValue, memoizationMap) {
  if (isPojo(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal;
    }
    const returnValue = {};
    memoizationMap.set(inputValue, returnValue);
    for (const key of Object.keys(inputValue)) {
      if (typeof inputValue[key] !== "undefined") {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }
    return returnValue;
  }
  if (Array.isArray(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal;
    }
    const returnValue = [];
    memoizationMap.set(inputValue, returnValue);
    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });
    return returnValue;
  }
  return inputValue;
}
function isPojo(input) {
  if (!isPlainObject(input)) {
    return false;
  }
  try {
    const name = Object.getPrototypeOf(input).constructor.name;
    return !name || name === "Object";
  } catch (e) {
    return true;
  }
}

// ../node_modules/@sentry/utils/build/esm/stacktrace.js
var STACKTRACE_FRAME_LIMIT = 50;
var UNKNOWN_FUNCTION = "?";
var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
  return (stack, skipFirstLines = 0, framesToPop = 0) => {
    const frames = [];
    const lines = stack.split("\n");
    for (let i = skipFirstLines;i < lines.length; i++) {
      const line = lines[i];
      if (line.length > 1024) {
        continue;
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames.slice(framesToPop));
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || getLastStackFrame(localStack).filename,
    function: frame.function || UNKNOWN_FUNCTION
  }));
}
function getLastStackFrame(arr) {
  return arr[arr.length - 1] || {};
}
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    return defaultFunctionName;
  }
}

// ../node_modules/@sentry/utils/build/esm/instrument/handlers.js
var handlers = {};
var instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumentFn();
    instrumented[type] = true;
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e) {
      DEBUG_BUILD && logger.error(`Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`, e);
    }
  }
}

// ../node_modules/@sentry/utils/build/esm/instrument/console.js
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log = originalConsoleMethods[level];
        log && log.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}
// ../node_modules/@sentry/utils/build/esm/time.js
var ONE_SECOND_IN_MS = 1000;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == undefined ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
var timestampInSeconds = createUnixTimestampInSecondsFunc();
var _browserPerformanceTimeOriginMode;
var browserPerformanceTimeOrigin = (() => {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    _browserPerformanceTimeOriginMode = "none";
    return;
  }
  const threshold = 3600 * 1000;
  const performanceNow = performance2.now();
  const dateNow = Date.now();
  const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;
  const navigationStart = performance2.timing && performance2.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === "number";
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = "timeOrigin";
      return performance2.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = "navigationStart";
      return navigationStart;
    }
  }
  _browserPerformanceTimeOriginMode = "dateNow";
  return dateNow;
})();

// ../node_modules/@sentry/utils/build/esm/instrument/globalError.js
var _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
    const handlerData = {
      column,
      error,
      line,
      msg,
      url
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}
// ../node_modules/@sentry/utils/build/esm/instrument/globalUnhandledRejection.js
var _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e) {
    const handlerData = e;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
// ../node_modules/@sentry/utils/build/esm/memo.js
function memoBuilder() {
  const hasWeakSet = typeof WeakSet === "function";
  const inner = hasWeakSet ? new WeakSet : [];
  function memoize(obj) {
    if (hasWeakSet) {
      if (inner.has(obj)) {
        return true;
      }
      inner.add(obj);
      return false;
    }
    for (let i = 0;i < inner.length; i++) {
      const value = inner[i];
      if (value === obj) {
        return true;
      }
    }
    inner.push(obj);
    return false;
  }
  function unmemoize(obj) {
    if (hasWeakSet) {
      inner.delete(obj);
    } else {
      for (let i = 0;i < inner.length; i++) {
        if (inner[i] === obj) {
          inner.splice(i, 1);
          break;
        }
      }
    }
  }
  return [memoize, unmemoize];
}

// ../node_modules/@sentry/utils/build/esm/misc.js
function uuid4() {
  const gbl = GLOBAL_OBJ;
  const crypto2 = gbl.crypto || gbl.msCrypto;
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto2 && crypto2.randomUUID) {
      return crypto2.randomUUID().replace(/-/g, "");
    }
    if (crypto2 && crypto2.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto2.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_) {
  }
  return ([1e7] + 1000 + 4000 + 8000 + 100000000000).replace(/[018]/g, (c) => (c ^ (getRandomByte() & 15) >> c / 4).toString(16));
}
function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values = exception.values = exception.values || [];
  const firstException = values[0] = values[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function _parseInt(input) {
  return parseInt(input || "", 10);
}
function parseSemver(input) {
  const match = input.match(SEMVER_REGEXP) || [];
  const major = _parseInt(match[1]);
  const minor = _parseInt(match[2]);
  const patch = _parseInt(match[3]);
  return {
    buildmetadata: match[5],
    major: isNaN(major) ? undefined : major,
    minor: isNaN(minor) ? undefined : minor,
    patch: isNaN(patch) ? undefined : patch,
    prerelease: match[4]
  };
}
function checkOrSetAlreadyCaught(exception) {
  if (exception && exception.__sentry_captured__) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}
function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}
// ../node_modules/@sentry/utils/build/esm/normalize.js
function normalize(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize, unmemoize] = memo;
  if (value == null || ["boolean", "string"].includes(typeof value) || typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  const stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch (err) {
    }
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      return `[${value}]`;
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype = Object.getPrototypeOf(value);
  return prototype ? prototype.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
// ../node_modules/@sentry/utils/build/esm/path.js
var splitPathRe = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
function splitPath(filename) {
  const truncated = filename.length > 1024 ? `<truncated>${filename.slice(-1024)}` : filename;
  const parts = splitPathRe.exec(truncated);
  return parts ? parts.slice(1) : [];
}
function dirname(path) {
  const result = splitPath(path);
  const root = result[0] || "";
  let dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.slice(0, dir.length - 1);
  }
  return root + dir;
}
// ../node_modules/@sentry/utils/build/esm/syncpromise.js
var States;
(function(States2) {
  const PENDING = 0;
  States2[States2["PENDING"] = PENDING] = "PENDING";
  const RESOLVED = 1;
  States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
  const REJECTED = 2;
  States2[States2["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve) => {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_, reject) => {
    reject(reason);
  });
}

class SyncPromise {
  constructor(executor) {
    SyncPromise.prototype.__init.call(this);
    SyncPromise.prototype.__init2.call(this);
    SyncPromise.prototype.__init3.call(this);
    SyncPromise.prototype.__init4.call(this);
    this._state = States.PENDING;
    this._handlers = [];
    try {
      executor(this._resolve, this._reject);
    } catch (e) {
      this._reject(e);
    }
  }
  then(onfulfilled, onrejected) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        (result) => {
          if (!onfulfilled) {
            resolve(result);
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  catch(onrejected) {
    return this.then((val2) => val2, onrejected);
  }
  finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val2;
      let isRejected;
      return this.then((value) => {
        isRejected = false;
        val2 = value;
        if (onfinally) {
          onfinally();
        }
      }, (reason) => {
        isRejected = true;
        val2 = reason;
        if (onfinally) {
          onfinally();
        }
      }).then(() => {
        if (isRejected) {
          reject(val2);
          return;
        }
        resolve(val2);
      });
    });
  }
  __init() {
    this._resolve = (value) => {
      this._setResult(States.RESOLVED, value);
    };
  }
  __init2() {
    this._reject = (reason) => {
      this._setResult(States.REJECTED, reason);
    };
  }
  __init3() {
    this._setResult = (state, value) => {
      if (this._state !== States.PENDING) {
        return;
      }
      if (isThenable(value)) {
        value.then(this._resolve, this._reject);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === States.PENDING) {
        return;
      }
      const cachedHandlers = this._handlers.slice();
      this._handlers = [];
      cachedHandlers.forEach((handler) => {
        if (handler[0]) {
          return;
        }
        if (this._state === States.RESOLVED) {
          handler[1](this._value);
        }
        if (this._state === States.REJECTED) {
          handler[2](this._value);
        }
        handler[0] = true;
      });
    };
  }
}

// ../node_modules/@sentry/utils/build/esm/promisebuffer.js
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === undefined || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(undefined);
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    task.then(() => remove(task)).then(null, () => remove(task).then(null, () => {
    }));
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve, reject) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}
// ../node_modules/@sentry/utils/build/esm/cookie.js
function parseCookie(str) {
  const obj = {};
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      let val2 = str.slice(eqIdx + 1, endIdx).trim();
      if (val2.charCodeAt(0) === 34) {
        val2 = val2.slice(1, -1);
      }
      try {
        obj[key] = val2.indexOf("%") !== -1 ? decodeURIComponent(val2) : val2;
      } catch (e) {
        obj[key] = val2;
      }
    }
    index = endIdx + 1;
  }
  return obj;
}

// ../node_modules/@sentry/utils/build/esm/url.js
function parseUrl(url) {
  if (!url) {
    return {};
  }
  const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  const query = match[6] || "";
  const fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    search: query,
    hash: fragment,
    relative: match[5] + query + fragment
  };
}
function stripUrlQueryAndFragment(urlPath) {
  return urlPath.split(/[?#]/, 1)[0];
}
function getSanitizedUrlString(url) {
  const { protocol, host, path } = url;
  const filteredHost = host && host.replace(/^.*@/, "[filtered]:[filtered]@").replace(/(:80)$/, "").replace(/(:443)$/, "") || "";
  return `${protocol ? `${protocol}://` : ""}${filteredHost}${path}`;
}

// ../node_modules/@sentry/utils/build/esm/vendor/getIpAddress.js
var ipHeaderNames = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For"
];
function getClientIPAddress(headers) {
  const headerValues = ipHeaderNames.map((headerName) => {
    const rawValue = headers[headerName];
    const value = Array.isArray(rawValue) ? rawValue.join(";") : rawValue;
    if (headerName === "Forwarded") {
      return parseForwardedHeader(value);
    }
    return value && value.split(",").map((v) => v.trim());
  });
  const flattenedHeaderValues = headerValues.reduce((acc, val2) => {
    if (!val2) {
      return acc;
    }
    return acc.concat(val2);
  }, []);
  const ipAddress = flattenedHeaderValues.find((ip) => ip !== null && isIP(ip));
  return ipAddress || null;
}
function parseForwardedHeader(value) {
  if (!value) {
    return null;
  }
  for (const part of value.split(";")) {
    if (part.startsWith("for=")) {
      return part.slice(4);
    }
  }
  return null;
}
function isIP(str) {
  const regex = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/;
  return regex.test(str);
}

// ../node_modules/@sentry/utils/build/esm/requestdata.js
var DEFAULT_INCLUDES = {
  ip: false,
  request: true,
  transaction: true,
  user: true
};
var DEFAULT_REQUEST_INCLUDES = ["cookies", "data", "headers", "method", "query_string", "url"];
var DEFAULT_USER_INCLUDES = ["id", "username", "email"];
function extractPathForTransaction(req, options = {}) {
  const method = req.method && req.method.toUpperCase();
  let path = "";
  let source = "url";
  if (options.customRoute || req.route) {
    path = options.customRoute || `${req.baseUrl || ""}${req.route && req.route.path}`;
    source = "route";
  } else if (req.originalUrl || req.url) {
    path = stripUrlQueryAndFragment(req.originalUrl || req.url || "");
  }
  let name = "";
  if (options.method && method) {
    name += method;
  }
  if (options.method && options.path) {
    name += " ";
  }
  if (options.path && path) {
    name += path;
  }
  return [name, source];
}
function extractTransaction(req, type) {
  switch (type) {
    case "path": {
      return extractPathForTransaction(req, { path: true })[0];
    }
    case "handler": {
      return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || "<anonymous>";
    }
    case "methodPath":
    default: {
      const customRoute = req._reconstructedRoute ? req._reconstructedRoute : undefined;
      return extractPathForTransaction(req, { path: true, method: true, customRoute })[0];
    }
  }
}
function extractUserData(user, keys) {
  const extractedUser = {};
  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;
  attributes.forEach((key) => {
    if (user && key in user) {
      extractedUser[key] = user[key];
    }
  });
  return extractedUser;
}
function extractRequestData(req, options = {}) {
  const { include = DEFAULT_REQUEST_INCLUDES } = options;
  const requestData = {};
  const headers = req.headers || {};
  const method = req.method;
  const host = headers.host || req.hostname || req.host || "<no host>";
  const protocol = req.protocol === "https" || req.socket && req.socket.encrypted ? "https" : "http";
  const originalUrl = req.originalUrl || req.url || "";
  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;
  include.forEach((key) => {
    switch (key) {
      case "headers": {
        requestData.headers = headers;
        if (!include.includes("cookies")) {
          delete requestData.headers.cookie;
        }
        if (!include.includes("ip")) {
          ipHeaderNames.forEach((ipHeaderName) => {
            delete requestData.headers[ipHeaderName];
          });
        }
        break;
      }
      case "method": {
        requestData.method = method;
        break;
      }
      case "url": {
        requestData.url = absoluteUrl;
        break;
      }
      case "cookies": {
        requestData.cookies = req.cookies || headers.cookie && parseCookie(headers.cookie) || {};
        break;
      }
      case "query_string": {
        requestData.query_string = extractQueryParams(req);
        break;
      }
      case "data": {
        if (method === "GET" || method === "HEAD") {
          break;
        }
        if (req.body !== undefined) {
          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));
        }
        break;
      }
      default: {
        if ({}.hasOwnProperty.call(req, key)) {
          requestData[key] = req[key];
        }
      }
    }
  });
  return requestData;
}
function addRequestDataToEvent(event, req, options) {
  const include = {
    ...DEFAULT_INCLUDES,
    ...options && options.include
  };
  if (include.request) {
    const includeRequest = Array.isArray(include.request) ? [...include.request] : [...DEFAULT_REQUEST_INCLUDES];
    if (include.ip) {
      includeRequest.push("ip");
    }
    const extractedRequestData = extractRequestData(req, { include: includeRequest });
    event.request = {
      ...event.request,
      ...extractedRequestData
    };
  }
  if (include.user) {
    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};
    if (Object.keys(extractedUser).length) {
      event.user = {
        ...event.user,
        ...extractedUser
      };
    }
  }
  if (include.ip) {
    const ip = req.headers && getClientIPAddress(req.headers) || req.ip || req.socket && req.socket.remoteAddress;
    if (ip) {
      event.user = {
        ...event.user,
        ip_address: ip
      };
    }
  }
  if (include.transaction && !event.transaction && event.type === "transaction") {
    event.transaction = extractTransaction(req, include.transaction);
  }
  return event;
}
function extractQueryParams(req) {
  let originalUrl = req.originalUrl || req.url || "";
  if (!originalUrl) {
    return;
  }
  if (originalUrl.startsWith("/")) {
    originalUrl = `http://dogs.are.great${originalUrl}`;
  }
  try {
    const queryParams = req.query || new URL(originalUrl).search.slice(1);
    return queryParams.length ? queryParams : undefined;
  } catch (e2) {
    return;
  }
}
// ../node_modules/@sentry/utils/build/esm/severity.js
var validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
}
// ../node_modules/@sentry/utils/build/esm/node-stack-trace.js
function filenameIsInApp(filename, isNative = false) {
  const isInternal = isNative || filename && !filename.startsWith("/") && !filename.match(/^[A-Z]:/) && !filename.startsWith(".") && !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
  return !isInternal && filename !== undefined && !filename.includes("node_modules/");
}
function node(getModule) {
  const FILENAME_MATCH = /^\s*[-]{4,}$/;
  const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  return (line) => {
    const lineMatch = line.match(FULL_MATCH);
    if (lineMatch) {
      let object;
      let method;
      let functionName;
      let typeName;
      let methodName;
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        let methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] === ".") {
          methodStart--;
        }
        if (methodStart > 0) {
          object = functionName.slice(0, methodStart);
          method = functionName.slice(methodStart + 1);
          const objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.slice(objectEnd + 1);
            object = object.slice(0, objectEnd);
          }
        }
        typeName = undefined;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = undefined;
        functionName = undefined;
      }
      if (functionName === undefined) {
        methodName = methodName || UNKNOWN_FUNCTION;
        functionName = typeName ? `${typeName}.${methodName}` : methodName;
      }
      let filename = lineMatch[2] && lineMatch[2].startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
      const isNative = lineMatch[5] === "native";
      if (filename && filename.match(/\/[A-Z]:/)) {
        filename = filename.slice(1);
      }
      if (!filename && lineMatch[5] && !isNative) {
        filename = lineMatch[5];
      }
      return {
        filename,
        module: getModule ? getModule(filename) : undefined,
        function: functionName,
        lineno: _parseIntOrUndefined(lineMatch[3]),
        colno: _parseIntOrUndefined(lineMatch[4]),
        in_app: filenameIsInApp(filename || "", isNative)
      };
    }
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line
      };
    }
    return;
  };
}
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}
function _parseIntOrUndefined(input) {
  return parseInt(input || "", 10) || undefined;
}
// ../node_modules/@sentry/utils/build/esm/baggage.js
var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
var MAX_BAGGAGE_STRING_LENGTH = 8192;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return;
  }
}
function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
  if (!dynamicSamplingContext) {
    return;
  }
  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce((acc, [dscKey, dscValue]) => {
    if (dscValue) {
      acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
    }
    return acc;
  }, {});
  return objectToBaggageHeader(sentryPrefixedDSC);
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
function objectToBaggageHeader(object) {
  if (Object.keys(object).length === 0) {
    return;
  }
  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
      DEBUG_BUILD && logger.warn(`Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`);
      return baggageHeader;
    } else {
      return newBaggageHeader;
    }
  }, "");
}

// ../node_modules/@sentry/utils/build/esm/tracing.js
var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*" + "([0-9a-f]{32})?" + "-?([0-9a-f]{16})?" + "-?([01])?" + "[ \\t]*$");
function extractTraceparentData(traceparent) {
  if (!traceparent) {
    return;
  }
  const matches = traceparent.match(TRACEPARENT_REGEXP);
  if (!matches) {
    return;
  }
  let parentSampled;
  if (matches[3] === "1") {
    parentSampled = true;
  } else if (matches[3] === "0") {
    parentSampled = false;
  }
  return {
    traceId: matches[1],
    parentSampled,
    parentSpanId: matches[2]
  };
}
function propagationContextFromHeaders(sentryTrace, baggage) {
  const traceparentData = extractTraceparentData(sentryTrace);
  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);
  const { traceId, parentSpanId, parentSampled } = traceparentData || {};
  if (!traceparentData) {
    return {
      traceId: traceId || uuid4(),
      spanId: uuid4().substring(16)
    };
  } else {
    return {
      traceId: traceId || uuid4(),
      parentSpanId: parentSpanId || uuid4().substring(16),
      spanId: uuid4().substring(16),
      sampled: parentSampled,
      dsc: dynamicSamplingContext || {}
    };
  }
}
function generateSentryTraceHeader(traceId = uuid4(), spanId = uuid4().substring(16), sampled) {
  let sampledString = "";
  if (sampled !== undefined) {
    sampledString = sampled ? "-1" : "-0";
  }
  return `${traceId}-${spanId}${sampledString}`;
}
// ../node_modules/@sentry/utils/build/esm/envelope.js
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result = callback(envelopeItem, envelopeItemType);
    if (result) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input) {
  return GLOBAL_OBJ.__SENTRY__ && GLOBAL_OBJ.__SENTRY__.encodePolyfill ? GLOBAL_OBJ.__SENTRY__.encodePolyfill(input) : new TextEncoder().encode(input);
}
function serializeEnvelope(envelope) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`\n${JSON.stringify(itemHeaders)}\n`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e) {
        stringifiedPayload = JSON.stringify(normalize(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }
  return merged;
}
function createSpanEnvelopeItem(spanJson) {
  const spanHeaders = {
    type: "span"
  };
  return [spanHeaders, spanJson];
}
function createAttachmentEnvelopeItem(attachment) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
  return [
    dropUndefinedKeys({
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    }),
    buffer
  ];
}
var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent || !metadataOrEvent.sdk) {
    return;
  }
  const { name, version } = metadataOrEvent.sdk;
  return { name, version };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: new Date().toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dropUndefinedKeys({ ...dynamicSamplingContext })
    }
  };
}
// ../node_modules/@sentry/utils/build/esm/clientreport.js
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}
// ../node_modules/@sentry/utils/build/esm/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1000;
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1000;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now = Date.now()) {
  return disabledUntil(limits, dataCategory) > now;
}
function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
  const retryAfterHeader = headers && headers["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000;
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now + delay;
            }
          } else {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1000;
  }
  return updatedRateLimits;
}
// ../node_modules/@sentry/utils/build/esm/eventbuilder.js
function parseStackFrames(stackParser, error) {
  return stackParser(error.stack || "", 1);
}
function exceptionFromError(stackParser, error) {
  const exception = {
    type: error.name || error.constructor.name,
    value: error.message
  };
  const frames = parseStackFrames(stackParser, error);
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  return exception;
}
function getErrorPropertyFromObject(obj) {
  for (const prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      const value = obj[prop];
      if (value instanceof Error) {
        return value;
      }
    }
  }
  return;
}
function getMessageForObject(exception) {
  if ("name" in exception && typeof exception.name === "string") {
    let message = `'${exception.name}' captured as exception`;
    if ("message" in exception && typeof exception.message === "string") {
      message += ` with message '${exception.message}'`;
    }
    return message;
  } else if ("message" in exception && typeof exception.message === "string") {
    return exception.message;
  }
  const keys = extractExceptionKeysForMessage(exception);
  if (isErrorEvent(exception)) {
    return `Event \`ErrorEvent\` captured as exception with message \`${exception.message}\``;
  }
  const className = getObjectClassName(exception);
  return `${className && className !== "Object" ? `'${className}'` : "Object"} captured as exception with keys: ${keys}`;
}
function getObjectClassName(obj) {
  try {
    const prototype = Object.getPrototypeOf(obj);
    return prototype ? prototype.constructor.name : undefined;
  } catch (e) {
  }
}
function getException(client, mechanism, exception, hint) {
  if (isError(exception)) {
    return [exception, undefined];
  }
  mechanism.synthetic = true;
  if (isPlainObject(exception)) {
    const normalizeDepth = client && client.getOptions().normalizeDepth;
    const extras = { ["__serialized__"]: normalizeToSize(exception, normalizeDepth) };
    const errorFromProp = getErrorPropertyFromObject(exception);
    if (errorFromProp) {
      return [errorFromProp, extras];
    }
    const message = getMessageForObject(exception);
    const ex2 = hint && hint.syntheticException || new Error(message);
    ex2.message = message;
    return [ex2, extras];
  }
  const ex = hint && hint.syntheticException || new Error(exception);
  ex.message = `${exception}`;
  return [ex, undefined];
}
function eventFromUnknownInput(client, stackParser, exception, hint) {
  const providedMechanism = hint && hint.data && hint.data.mechanism;
  const mechanism = providedMechanism || {
    handled: true,
    type: "generic"
  };
  const [ex, extras] = getException(client, mechanism, exception, hint);
  const event = {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
  if (extras) {
    event.extra = extras;
  }
  addExceptionTypeValue(event, undefined, undefined);
  addExceptionMechanism(event, mechanism);
  return {
    ...event,
    event_id: hint && hint.event_id
  };
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const event = {
    event_id: hint && hint.event_id,
    level
  };
  if (attachStacktrace && hint && hint.syntheticException) {
    const frames = parseStackFrames(stackParser, hint.syntheticException);
    if (frames.length) {
      event.exception = {
        values: [
          {
            value: message,
            stacktrace: { frames }
          }
        ]
      };
    }
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}
// ../node_modules/@sentry/utils/build/esm/lru.js
class LRUMap {
  constructor(_maxSize) {
    this._maxSize = _maxSize;
    this._cache = new Map;
  }
  get size() {
    return this._cache.size;
  }
  get(key) {
    const value = this._cache.get(key);
    if (value === undefined) {
      return;
    }
    this._cache.delete(key);
    this._cache.set(key, value);
    return value;
  }
  set(key, value) {
    if (this._cache.size >= this._maxSize) {
      this._cache.delete(this._cache.keys().next().value);
    }
    this._cache.set(key, value);
  }
  remove(key) {
    const value = this._cache.get(key);
    if (value) {
      this._cache.delete(key);
    }
    return value;
  }
  clear() {
    this._cache.clear();
  }
  keys() {
    return Array.from(this._cache.keys());
  }
  values() {
    const values = [];
    this._cache.forEach((value) => values.push(value));
    return values;
  }
}
// ../node_modules/@sentry/utils/build/esm/buildPolyfills/_nullishCoalesce.js
function _nullishCoalesce(lhs, rhsFn) {
  return lhs != null ? lhs : rhsFn();
}
// ../node_modules/@sentry/utils/build/esm/buildPolyfills/_optionalChain.js
function _optionalChain(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
// ../node_modules/@sentry/utils/build/esm/propagationContext.js
function generatePropagationContext() {
  return {
    traceId: uuid4(),
    spanId: uuid4().substring(16)
  };
}
// ../node_modules/@sentry/node/build/esm/integrations/http.js
var import_api22 = __toESM(require_src(), 1);
var import_instrumentation_http = __toESM(require_src7(), 1);

// ../node_modules/@sentry/opentelemetry/build/esm/index.js
var import_semantic_conventions4 = __toESM(require_src2(), 1);
var api2 = __toESM(require_src(), 1);
var import_api20 = __toESM(require_src(), 1);

// ../node_modules/@sentry/core/build/esm/debug-build.js
var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../node_modules/@sentry/core/build/esm/carrier.js
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}

// ../node_modules/@sentry/core/build/esm/session.js
function makeSession(context) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context) {
    updateSession(session, context);
  }
  return session;
}
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }
    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }
  session.timestamp = context.timestamp || timestampInSeconds();
  if (context.abnormal_mechanism) {
    session.abnormal_mechanism = context.abnormal_mechanism;
  }
  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== undefined) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === "number") {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = undefined;
  } else if (typeof context.duration === "number") {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === "number") {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === "ok") {
    context = { status: "exited" };
  }
  updateSession(session, context);
}
function sessionToJSON(session) {
  return dropUndefinedKeys({
    sid: `${session.sid}`,
    init: session.init,
    started: new Date(session.started * 1000).toISOString(),
    timestamp: new Date(session.timestamp * 1000).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : undefined,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  });
}

// ../node_modules/@sentry/core/build/esm/utils/spanOnScope.js
var SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}

// ../node_modules/@sentry/core/build/esm/scope.js
var DEFAULT_MAX_BREADCRUMBS = 100;

class ScopeClass {
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = generatePropagationContext();
  }
  clone() {
    const newScope = new ScopeClass;
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._requestSession = this._requestSession;
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  setClient(client) {
    this._client = client;
  }
  setLastEventId(lastEventId) {
    this._lastEventId = lastEventId;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  setUser(user) {
    this._user = user || {
      email: undefined,
      id: undefined,
      ip_address: undefined,
      username: undefined
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  setContext(key, context) {
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }
    this._notifyScopeListeners();
    return this;
  }
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  getSession() {
    return this._session;
  }
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const [scopeInstance, requestSession] = scopeToMerge instanceof Scope ? [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()] : isPlainObject(scopeToMerge) ? [captureContext, captureContext.requestSession] : [];
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    if (requestSession) {
      this._requestSession = requestSession;
    }
    return this;
  }
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = undefined;
    this._transactionName = undefined;
    this._fingerprint = undefined;
    this._requestSession = undefined;
    this._session = undefined;
    _setSpanForScope(this, undefined);
    this._attachments = [];
    this._propagationContext = generatePropagationContext();
    this._notifyScopeListeners();
    return this;
  }
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb
    };
    const breadcrumbs = this._breadcrumbs;
    breadcrumbs.push(mergedBreadcrumb);
    this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
    this._notifyScopeListeners();
    return this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
    return this;
  }
  setPropagationContext(context) {
    this._propagationContext = context;
    return this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(exception, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(exception, {
      originalException: exception,
      syntheticException,
      ...hint,
      event_id: eventId
    }, this);
    return eventId;
  }
  captureMessage(message, level, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(message, level, {
      originalException: message,
      syntheticException,
      ...hint,
      event_id: eventId
    }, this);
    return eventId;
  }
  captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
}
var Scope = ScopeClass;

// ../node_modules/@sentry/core/build/esm/defaultScopes.js
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope);
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope);
}

// ../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
class AsyncContextStack {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope;
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope;
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e) {
      this._popScope();
      throw e;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then((res) => {
        this._popScope();
        return res;
      }, (e) => {
        this._popScope();
        throw e;
      });
    }
    this._popScope();
    return maybePromiseResult;
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  _popScope() {
    if (this._stack.length <= 1)
      return false;
    return !!this._stack.pop();
  }
}
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}

// ../node_modules/@sentry/core/build/esm/asyncContext/index.js
function setAsyncContextStrategy(strategy) {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  sentry.acs = strategy;
}
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}

// ../node_modules/@sentry/core/build/esm/currentScopes.js
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function getGlobalScope() {
  return getGlobalSingleton("globalScope", () => new Scope);
}
function withScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest[0]);
}
function withIsolationScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [isolationScope, callback] = rest;
    if (!isolationScope) {
      return acs.withIsolationScope(callback);
    }
    return acs.withSetIsolationScope(isolationScope, callback);
  }
  return acs.withIsolationScope(rest[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}

// ../node_modules/@sentry/core/build/esm/metrics/metric-summary.js
var METRICS_SPAN_FIELD = "_sentryMetrics";
function getMetricSummaryJsonForSpan(span) {
  const storage = span[METRICS_SPAN_FIELD];
  if (!storage) {
    return;
  }
  const output = {};
  for (const [, [exportKey, summary]] of storage) {
    const arr = output[exportKey] || (output[exportKey] = []);
    arr.push(dropUndefinedKeys(summary));
  }
  return output;
}

// ../node_modules/@sentry/core/build/esm/semanticAttributes.js
var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = "sentry.measurement_unit";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = "sentry.measurement_value";
var SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id";
var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time";
var SEMANTIC_ATTRIBUTE_CACHE_HIT = "cache.hit";
var SEMANTIC_ATTRIBUTE_CACHE_KEY = "cache.key";
var SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = "cache.item_size";
var SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = "http.request.method";

// ../node_modules/@sentry/core/build/esm/tracing/spanstatus.js
var SPAN_STATUS_UNSET = 0;
var SPAN_STATUS_OK = 1;
var SPAN_STATUS_ERROR = 2;
function getSpanStatusFromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return { code: SPAN_STATUS_OK };
  }
  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return { code: SPAN_STATUS_ERROR, message: "unauthenticated" };
      case 403:
        return { code: SPAN_STATUS_ERROR, message: "permission_denied" };
      case 404:
        return { code: SPAN_STATUS_ERROR, message: "not_found" };
      case 409:
        return { code: SPAN_STATUS_ERROR, message: "already_exists" };
      case 413:
        return { code: SPAN_STATUS_ERROR, message: "failed_precondition" };
      case 429:
        return { code: SPAN_STATUS_ERROR, message: "resource_exhausted" };
      case 499:
        return { code: SPAN_STATUS_ERROR, message: "cancelled" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "invalid_argument" };
    }
  }
  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return { code: SPAN_STATUS_ERROR, message: "unimplemented" };
      case 503:
        return { code: SPAN_STATUS_ERROR, message: "unavailable" };
      case 504:
        return { code: SPAN_STATUS_ERROR, message: "deadline_exceeded" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "internal_error" };
    }
  }
  return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
}
function setHttpStatus(span, httpStatus) {
  span.setAttribute("http.response.status_code", httpStatus);
  const spanStatus = getSpanStatusFromHttpCode(httpStatus);
  if (spanStatus.message !== "unknown_error") {
    span.setStatus(spanStatus);
  }
}

// ../node_modules/@sentry/core/build/esm/utils/spanUtils.js
var TRACE_FLAG_NONE = 0;
var TRACE_FLAG_SAMPLED = 1;
function spanToTransactionTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { data, op, parent_span_id, status, origin } = spanToJSON(span);
  return dropUndefinedKeys({
    parent_span_id,
    span_id,
    trace_id,
    data,
    op,
    status,
    origin
  });
}
function spanToTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { parent_span_id } = spanToJSON(span);
  return dropUndefinedKeys({ parent_span_id, span_id, trace_id });
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1000 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  try {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
      const { attributes, startTime, name, endTime, parentSpanId, status } = span;
      return dropUndefinedKeys({
        span_id,
        trace_id,
        data: attributes,
        description: name,
        parent_span_id: parentSpanId,
        start_timestamp: spanTimeInputToSeconds(startTime),
        timestamp: spanTimeInputToSeconds(endTime) || undefined,
        status: getStatusMessage(status),
        op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
        origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
        _metrics_summary: getMetricSummaryJsonForSpan(span)
      });
    }
    return {
      span_id,
      trace_id
    };
  } catch (e) {
    return {};
  }
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
var CHILD_SPANS_FIELD = "_sentryChildSpans";
var ROOT_SPAN_FIELD = "_sentryRootSpan";
function addChildSpanToSpan(span, childSpan) {
  const rootSpan = span[ROOT_SPAN_FIELD] || span;
  addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);
  if (span[CHILD_SPANS_FIELD]) {
    span[CHILD_SPANS_FIELD].add(childSpan);
  } else {
    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));
  }
}
function getSpanDescendants(span) {
  const resultSet = new Set;
  function addSpanChildren(span2) {
    if (resultSet.has(span2)) {
      return;
    } else if (spanIsSampled(span2)) {
      resultSet.add(span2);
      const childSpans = span2[CHILD_SPANS_FIELD] ? Array.from(span2[CHILD_SPANS_FIELD]) : [];
      for (const childSpan of childSpans) {
        addSpanChildren(childSpan);
      }
    }
  }
  addSpanChildren(span);
  return Array.from(resultSet);
}
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function getActiveSpan() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.getActiveSpan) {
    return acs.getActiveSpan();
  }
  return _getSpanForScope(getCurrentScope());
}

// ../node_modules/@sentry/core/build/esm/tracing/errors.js
var errorsInstrumented = false;
function registerSpanErrorInstrumentation() {
  if (errorsInstrumented) {
    return;
  }
  errorsInstrumented = true;
  addGlobalErrorInstrumentationHandler(errorCallback);
  addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
}
function errorCallback() {
  const activeSpan = getActiveSpan();
  const rootSpan = activeSpan && getRootSpan(activeSpan);
  if (rootSpan) {
    const message = "internal_error";
    DEBUG_BUILD2 && logger.log(`[Tracing] Root span: ${message} -> Global error occured`);
    rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message });
  }
}
errorCallback.tag = "sentry_tracingErrorCallback";

// ../node_modules/@sentry/core/build/esm/tracing/utils.js
var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function setCapturedScopesOnSpan(span, scope, isolationScope) {
  if (span) {
    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
  }
}
function getCapturedScopesOnSpan(span) {
  return {
    scope: span[SCOPE_ON_START_SPAN_FIELD],
    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
  };
}
// ../node_modules/@sentry/core/build/esm/utils/hasTracingEnabled.js
function hasTracingEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const client = getClient();
  const options = maybeOptions || client && client.getOptions();
  return !!options && (options.enableTracing || ("tracesSampleRate" in options) || ("tracesSampler" in options));
}

// ../node_modules/@sentry/core/build/esm/tracing/sentryNonRecordingSpan.js
class SentryNonRecordingSpan {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || uuid4();
    this._spanId = spanContext.spanId || uuid4().substring(16);
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: TRACE_FLAG_NONE
    };
  }
  end(_timestamp) {
  }
  setAttribute(_key, _value) {
    return this;
  }
  setAttributes(_values) {
    return this;
  }
  setStatus(_status) {
    return this;
  }
  updateName(_name) {
    return this;
  }
  isRecording() {
    return false;
  }
  addEvent(_name, _attributesOrStartTime, _startTime) {
    return this;
  }
  addLink(_link) {
    return this;
  }
  addLinks(_links) {
    return this;
  }
  recordException(_exception, _time) {
  }
}

// ../node_modules/@sentry/core/build/esm/utils/handleCallbackErrors.js
function handleCallbackErrors(fn, onError, onFinally = () => {
}) {
  let maybePromiseResult;
  try {
    maybePromiseResult = fn();
  } catch (e) {
    onError(e);
    onFinally();
    throw e;
  }
  return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
}
function maybeHandlePromiseRejection(value, onError, onFinally) {
  if (isThenable(value)) {
    return value.then((res) => {
      onFinally();
      return res;
    }, (e) => {
      onError(e);
      onFinally();
      throw e;
    });
  }
  onFinally();
  return value;
}

// ../node_modules/@sentry/core/build/esm/constants.js
var DEFAULT_ENVIRONMENT = "production";

// ../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js
var FROZEN_DSC_FIELD = "_frozenDsc";
function freezeDscOnSpan(span, dsc) {
  const spanWithMaybeDsc = span;
  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);
}
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = dropUndefinedKeys({
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    public_key,
    trace_id
  });
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client);
  const rootSpan = getRootSpan(span);
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return frozenDsc;
  }
  const traceState = rootSpan.spanContext().traceState;
  const traceStateDsc = traceState && traceState.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return dscOnTraceState;
  }
  const jsonSpan = spanToJSON(rootSpan);
  const attributes = jsonSpan.data || {};
  const maybeSampleRate = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  if (maybeSampleRate != null) {
    dsc.sample_rate = `${maybeSampleRate}`;
  }
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = jsonSpan.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasTracingEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
  }
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}

// ../node_modules/@sentry/core/build/esm/tracing/logSpans.js
function logSpanStart(span) {
  if (!DEBUG_BUILD2)
    return;
  const { description = "< unknown name >", op = "< unknown op >", parent_span_id: parentSpanId } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const header = `[Tracing] Starting ${sampled ? "sampled" : "unsampled"} ${isRootSpan ? "root " : ""}span`;
  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];
  if (parentSpanId) {
    infoParts.push(`parent ID: ${parentSpanId}`);
  }
  if (!isRootSpan) {
    const { op: op2, description: description2 } = spanToJSON(rootSpan);
    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);
    if (op2) {
      infoParts.push(`root op: ${op2}`);
    }
    if (description2) {
      infoParts.push(`root description: ${description2}`);
    }
  }
  logger.log(`${header}
  ${infoParts.join("\n  ")}`);
}
function logSpanEnd(span) {
  if (!DEBUG_BUILD2)
    return;
  const { description = "< unknown name >", op = "< unknown op >" } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const msg = `[Tracing] Finishing "${op}" ${isRootSpan ? "root " : ""}span "${description}" with ID ${spanId}`;
  logger.log(msg);
}

// ../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    DEBUG_BUILD2 && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(sampleRate)} of type ${JSON.stringify(typeof sampleRate)}.`);
    return;
  }
  return rate;
}

// ../node_modules/@sentry/core/build/esm/tracing/sampling.js
function sampleSpan(options, samplingContext) {
  if (!hasTracingEnabled(options)) {
    return [false];
  }
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler(samplingContext);
  } else if (samplingContext.parentSampled !== undefined) {
    sampleRate = samplingContext.parentSampled;
  } else if (typeof options.tracesSampleRate !== "undefined") {
    sampleRate = options.tracesSampleRate;
  } else {
    sampleRate = 1;
  }
  const parsedSampleRate = parseSampleRate(sampleRate);
  if (parsedSampleRate === undefined) {
    DEBUG_BUILD2 && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
    return [false];
  }
  if (!parsedSampleRate) {
    DEBUG_BUILD2 && logger.log(`[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`);
    return [false, parsedSampleRate];
  }
  const shouldSample = Math.random() < parsedSampleRate;
  if (!shouldSample) {
    DEBUG_BUILD2 && logger.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(sampleRate)})`);
    return [false, parsedSampleRate];
  }
  return [true, parsedSampleRate];
}

// ../node_modules/@sentry/core/build/esm/envelope.js
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
  event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: new Date().toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
function createSpanEnvelope(spans, client) {
  function dscHasRequiredProps(dsc2) {
    return !!dsc2.trace_id && !!dsc2.public_key;
  }
  const dsc = getDynamicSamplingContextFromSpan(spans[0]);
  const dsn = client && client.getDsn();
  const tunnel = client && client.getOptions().tunnel;
  const headers = {
    sent_at: new Date().toISOString(),
    ...dscHasRequiredProps(dsc) && { trace: dsc },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const beforeSendSpan = client && client.getOptions().beforeSendSpan;
  const convertToSpanJSON = beforeSendSpan ? (span) => beforeSendSpan(spanToJSON(span)) : (span) => spanToJSON(span);
  const items = [];
  for (const span of spans) {
    const spanJson = convertToSpanJSON(span);
    if (spanJson) {
      items.push(createSpanEnvelopeItem(spanJson));
    }
  }
  return createEnvelope(headers, items);
}

// ../node_modules/@sentry/core/build/esm/tracing/measurement.js
function timedEventsToMeasurements(events) {
  if (!events || events.length === 0) {
    return;
  }
  const measurements = {};
  events.forEach((event) => {
    const attributes = event.attributes || {};
    const unit = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT];
    const value = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];
    if (typeof unit === "string" && typeof value === "number") {
      measurements[event.name] = { value, unit };
    }
  });
  return measurements;
}

// ../node_modules/@sentry/core/build/esm/tracing/sentrySpan.js
var MAX_SPAN_COUNT = 1000;

class SentrySpan {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || uuid4();
    this._spanId = spanContext.spanId || uuid4().substring(16);
    this._startTime = spanContext.startTimestamp || timestampInSeconds();
    this._attributes = {};
    this.setAttributes({
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "manual",
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
      ...spanContext.attributes
    });
    this._name = spanContext.name;
    if (spanContext.parentSpanId) {
      this._parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this._sampled = spanContext.sampled;
    }
    if (spanContext.endTimestamp) {
      this._endTime = spanContext.endTimestamp;
    }
    this._events = [];
    this._isStandaloneSpan = spanContext.isStandalone;
    if (this._endTime) {
      this._onSpanEnded();
    }
  }
  addLink(_link) {
    return this;
  }
  addLinks(_links) {
    return this;
  }
  recordException(_exception, _time) {
  }
  spanContext() {
    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
    return {
      spanId,
      traceId,
      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
    };
  }
  setAttribute(key, value) {
    if (value === undefined) {
      delete this._attributes[key];
    } else {
      this._attributes[key] = value;
    }
    return this;
  }
  setAttributes(attributes) {
    Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    return this;
  }
  updateStartTime(timeInput) {
    this._startTime = spanTimeInputToSeconds(timeInput);
  }
  setStatus(value) {
    this._status = value;
    return this;
  }
  updateName(name) {
    this._name = name;
    return this;
  }
  end(endTimestamp) {
    if (this._endTime) {
      return;
    }
    this._endTime = spanTimeInputToSeconds(endTimestamp);
    logSpanEnd(this);
    this._onSpanEnded();
  }
  getSpanJSON() {
    return dropUndefinedKeys({
      data: this._attributes,
      description: this._name,
      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: getStatusMessage(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      _metrics_summary: getMetricSummaryJsonForSpan(this),
      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
      measurements: timedEventsToMeasurements(this._events),
      is_segment: this._isStandaloneSpan && getRootSpan(this) === this || undefined,
      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : undefined
    });
  }
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  addEvent(name, attributesOrStartTime, startTime) {
    DEBUG_BUILD2 && logger.log("[Tracing] Adding an event to span:", name);
    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();
    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};
    const event = {
      name,
      time: spanTimeInputToSeconds(time),
      attributes
    };
    this._events.push(event);
    return this;
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  _onSpanEnded() {
    const client = getClient();
    if (client) {
      client.emit("spanEnd", this);
    }
    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);
    if (!isSegmentSpan) {
      return;
    }
    if (this._isStandaloneSpan) {
      if (this._sampled) {
        sendSpanEnvelope(createSpanEnvelope([this], client));
      } else {
        DEBUG_BUILD2 && logger.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "span");
        }
      }
      return;
    }
    const transactionEvent = this._convertSpanToTransaction();
    if (transactionEvent) {
      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();
      scope.captureEvent(transactionEvent);
    }
  }
  _convertSpanToTransaction() {
    if (!isFullFinishedSpan(spanToJSON(this))) {
      return;
    }
    if (!this._name) {
      DEBUG_BUILD2 && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this._name = "<unlabeled transaction>";
    }
    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);
    const scope = capturedSpanScope || getCurrentScope();
    const client = scope.getClient() || getClient();
    if (this._sampled !== true) {
      DEBUG_BUILD2 && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
      if (client) {
        client.recordDroppedEvent("sample_rate", "transaction");
      }
      return;
    }
    const finishedSpans = getSpanDescendants(this).filter((span) => span !== this && !isStandaloneSpan(span));
    const spans = finishedSpans.map((span) => spanToJSON(span)).filter(isFullFinishedSpan);
    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const transaction = {
      contexts: {
        trace: spanToTransactionTraceContext(this)
      },
      spans: spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans,
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope,
        capturedSpanIsolationScope,
        ...dropUndefinedKeys({
          dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
        })
      },
      _metrics_summary: getMetricSummaryJsonForSpan(this),
      ...source && {
        transaction_info: {
          source
        }
      }
    };
    const measurements = timedEventsToMeasurements(this._events);
    const hasMeasurements = measurements && Object.keys(measurements).length;
    if (hasMeasurements) {
      DEBUG_BUILD2 && logger.log("[Measurements] Adding measurements to transaction event", JSON.stringify(measurements, undefined, 2));
      transaction.measurements = measurements;
    }
    return transaction;
  }
}
function isSpanTimeInput(value) {
  return value && typeof value === "number" || value instanceof Date || Array.isArray(value);
}
function isFullFinishedSpan(input) {
  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;
}
function isStandaloneSpan(span) {
  return span instanceof SentrySpan && span.isStandaloneSpan();
}
function sendSpanEnvelope(envelope) {
  const client = getClient();
  if (!client) {
    return;
  }
  const spanItems = envelope[1];
  if (!spanItems || spanItems.length === 0) {
    client.recordDroppedEvent("before_send", "span");
    return;
  }
  const transport = client.getTransport();
  if (transport) {
    transport.send(envelope).then(null, (reason) => {
      DEBUG_BUILD2 && logger.error("Error while sending span:", reason);
    });
  }
}

// ../node_modules/@sentry/core/build/esm/tracing/trace.js
var SUPPRESS_TRACING_KEY = "__SENTRY_SUPPRESS_TRACING__";
function startSpan(options, callback) {
  const acs = getAcs();
  if (acs.startSpan) {
    return acs.startSpan(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan } = options;
  return withScope2(options.scope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      return handleCallbackErrors(() => callback(activeSpan), () => {
        const { status } = spanToJSON(activeSpan);
        if (activeSpan.isRecording() && (!status || status === "ok")) {
          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
        }
      }, () => activeSpan.end());
    });
  });
}
function startSpanManual(options, callback) {
  const acs = getAcs();
  if (acs.startSpanManual) {
    return acs.startSpanManual(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan } = options;
  return withScope2(options.scope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      function finishAndSetSpan() {
        activeSpan.end();
      }
      return handleCallbackErrors(() => callback(activeSpan, finishAndSetSpan), () => {
        const { status } = spanToJSON(activeSpan);
        if (activeSpan.isRecording() && (!status || status === "ok")) {
          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
        }
      });
    });
  });
}
function startInactiveSpan(options) {
  const acs = getAcs();
  if (acs.startInactiveSpan) {
    return acs.startInactiveSpan(options);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan } = options;
  const wrapper = options.scope ? (callback) => withScope2(options.scope, callback) : customParentSpan !== undefined ? (callback) => withActiveSpan(customParentSpan, callback) : (callback) => callback();
  return wrapper(() => {
    const scope = getCurrentScope();
    const parentSpan = getParentSpan(scope);
    const shouldSkipSpan = options.onlyIfParent && !parentSpan;
    if (shouldSkipSpan) {
      return new SentryNonRecordingSpan;
    }
    return createChildOrRootSpan({
      parentSpan,
      spanArguments,
      forceTransaction,
      scope
    });
  });
}
var continueTrace = ({
  sentryTrace,
  baggage
}, callback) => {
  return withScope2((scope) => {
    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
    scope.setPropagationContext(propagationContext);
    return callback();
  });
};
function withActiveSpan(span, callback) {
  const acs = getAcs();
  if (acs.withActiveSpan) {
    return acs.withActiveSpan(span, callback);
  }
  return withScope2((scope) => {
    _setSpanForScope(scope, span || undefined);
    return callback(scope);
  });
}
function suppressTracing(callback) {
  const acs = getAcs();
  if (acs.suppressTracing) {
    return acs.suppressTracing(callback);
  }
  return withScope2((scope) => {
    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });
    return callback();
  });
}
function createChildOrRootSpan({
  parentSpan,
  spanArguments,
  forceTransaction,
  scope
}) {
  if (!hasTracingEnabled()) {
    return new SentryNonRecordingSpan;
  }
  const isolationScope = getIsolationScope();
  let span;
  if (parentSpan && !forceTransaction) {
    span = _startChildSpan(parentSpan, scope, spanArguments);
    addChildSpanToSpan(parentSpan, span);
  } else if (parentSpan) {
    const dsc = getDynamicSamplingContextFromSpan(parentSpan);
    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
    const parentSampled = spanIsSampled(parentSpan);
    span = _startRootSpan({
      traceId,
      parentSpanId,
      ...spanArguments
    }, scope, parentSampled);
    freezeDscOnSpan(span, dsc);
  } else {
    const {
      traceId,
      dsc,
      parentSpanId,
      sampled: parentSampled
    } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    span = _startRootSpan({
      traceId,
      parentSpanId,
      ...spanArguments
    }, scope, parentSampled);
    if (dsc) {
      freezeDscOnSpan(span, dsc);
    }
  }
  logSpanStart(span);
  setCapturedScopesOnSpan(span, scope, isolationScope);
  return span;
}
function parseSentrySpanArguments(options) {
  const exp = options.experimental || {};
  const initialCtx = {
    isStandalone: exp.standalone,
    ...options
  };
  if (options.startTime) {
    const ctx = { ...initialCtx };
    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);
    delete ctx.startTime;
    return ctx;
  }
  return initialCtx;
}
function getAcs() {
  const carrier = getMainCarrier();
  return getAsyncContextStrategy(carrier);
}
function _startRootSpan(spanArguments, scope, parentSampled) {
  const client = getClient();
  const options = client && client.getOptions() || {};
  const { name = "", attributes } = spanArguments;
  const [sampled, sampleRate] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(options, {
    name,
    parentSampled,
    attributes,
    transactionContext: {
      name,
      parentSampled
    }
  });
  const rootSpan = new SentrySpan({
    ...spanArguments,
    attributes: {
      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "custom",
      ...spanArguments.attributes
    },
    sampled
  });
  if (sampleRate !== undefined) {
    rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
  }
  if (client) {
    client.emit("spanStart", rootSpan);
  }
  return rootSpan;
}
function _startChildSpan(parentSpan, scope, spanArguments) {
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);
  const childSpan = sampled ? new SentrySpan({
    ...spanArguments,
    parentSpanId: spanId,
    traceId,
    sampled
  }) : new SentryNonRecordingSpan({ traceId });
  addChildSpanToSpan(parentSpan, childSpan);
  const client = getClient();
  if (client) {
    client.emit("spanStart", childSpan);
    if (spanArguments.endTimestamp) {
      client.emit("spanEnd", childSpan);
    }
  }
  return childSpan;
}
function getParentSpan(scope) {
  const span = _getSpanForScope(scope);
  if (!span) {
    return;
  }
  const client = getClient();
  const options = client ? client.getOptions() : {};
  if (options.parentSpanIsAlwaysRootSpan) {
    return getRootSpan(span);
  }
  return span;
}
function getActiveSpanWrapper(parentSpan) {
  return parentSpan !== undefined ? (callback) => {
    return withActiveSpan(parentSpan, callback);
  } : (callback) => callback();
}
// ../node_modules/@sentry/core/build/esm/eventProcessors.js
function notifyEventProcessors(processors, event, hint, index = 0) {
  return new SyncPromise((resolve2, reject) => {
    const processor = processors[index];
    if (event === null || typeof processor !== "function") {
      resolve2(event);
    } else {
      const result = processor({ ...event }, hint);
      DEBUG_BUILD2 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
      if (isThenable(result)) {
        result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve2)).then(null, reject);
      } else {
        notifyEventProcessors(processors, result, hint, index + 1).then(resolve2).then(null, reject);
      }
    }
  });
}

// ../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  if (mergeVal && Object.keys(mergeVal).length) {
    data[prop] = { ...data[prop] };
    for (const key in mergeVal) {
      if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
        data[prop][key] = mergeVal[key];
      }
    }
  }
}
function applyDataToEvent(event, data) {
  const { extra, tags, user, contexts, level, transactionName } = data;
  const cleanedExtra = dropUndefinedKeys(extra);
  if (cleanedExtra && Object.keys(cleanedExtra).length) {
    event.extra = { ...cleanedExtra, ...event.extra };
  }
  const cleanedTags = dropUndefinedKeys(tags);
  if (cleanedTags && Object.keys(cleanedTags).length) {
    event.tags = { ...cleanedTags, ...event.tags };
  }
  const cleanedUser = dropUndefinedKeys(user);
  if (cleanedUser && Object.keys(cleanedUser).length) {
    event.user = { ...cleanedUser, ...event.user };
  }
  const cleanedContexts = dropUndefinedKeys(contexts);
  if (cleanedContexts && Object.keys(cleanedContexts).length) {
    event.contexts = { ...cleanedContexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName && event.type !== "transaction") {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = {
    trace: spanToTraceContext(span),
    ...event.contexts
  };
  event.sdkProcessingMetadata = {
    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
    ...event.sdkProcessingMetadata
  };
  const rootSpan = getRootSpan(span);
  const transactionName = spanToJSON(rootSpan).description;
  if (transactionName && !event.transaction && event.type === "transaction") {
    event.transaction = transactionName;
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (event.fingerprint && !event.fingerprint.length) {
    delete event.fingerprint;
  }
}

// ../node_modules/@sentry/core/build/esm/utils/prepareEvent.js
function prepareEvent(options, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options.integrations.map((i) => i.name);
  applyClientOptions(prepared, options);
  applyIntegrationsMetadata(prepared, integrations);
  if (client) {
    client.emit("applyFrameMetadata", event);
  }
  if (event.type === undefined) {
    applyDebugIds(prepared, options.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    ...data.eventProcessors
  ];
  const result = notifyEventProcessors(eventProcessors, prepared, hint);
  return result.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options) {
  const { environment, release, dist, maxValueLength = 250 } = options;
  if (!("environment" in event)) {
    event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
  }
  if (event.release === undefined && release !== undefined) {
    event.release = release;
  }
  if (event.dist === undefined && dist !== undefined) {
    event.dist = dist;
  }
  if (event.message) {
    event.message = truncate(event.message, maxValueLength);
  }
  const exception = event.exception && event.exception.values && event.exception.values[0];
  if (exception && exception.value) {
    exception.value = truncate(exception.value, maxValueLength);
  }
  const request = event.request;
  if (request && request.url) {
    request.url = truncate(request.url, maxValueLength);
  }
}
var debugIdStackParserCache = new WeakMap;
function applyDebugIds(event, stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return;
  }
  let debugIdStackFramesCache;
  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
  if (cachedDebugIdStackFrameCache) {
    debugIdStackFramesCache = cachedDebugIdStackFrameCache;
  } else {
    debugIdStackFramesCache = new Map;
    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
  }
  const filenameDebugIdMap = Object.entries(debugIdMap).reduce((acc, [debugIdStackTrace, debugIdValue]) => {
    let parsedStack;
    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
    if (cachedParsedStack) {
      parsedStack = cachedParsedStack;
    } else {
      parsedStack = stackParser(debugIdStackTrace);
      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
    }
    for (let i = parsedStack.length - 1;i >= 0; i--) {
      const stackFrame = parsedStack[i];
      if (stackFrame.filename) {
        acc[stackFrame.filename] = debugIdValue;
        break;
      }
    }
    return acc;
  }, {});
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (frame.filename) {
          frame.debug_id = filenameDebugIdMap[frame.filename];
        }
      });
    });
  } catch (e) {
  }
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (frame.debug_id) {
          if (frame.abs_path) {
            filenameDebugIdMap[frame.abs_path] = frame.debug_id;
          } else if (frame.filename) {
            filenameDebugIdMap[frame.filename] = frame.debug_id;
          }
          delete frame.debug_id;
        }
      });
    });
  } catch (e) {
  }
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b) => ({
        ...b,
        ...b.data && {
          data: normalize(b.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts && event.contexts.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      return {
        ...span,
        ...span.data && {
          data: normalize(span.data, depth, maxBreadth)
        }
      };
    });
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope;
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
var captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}

// ../node_modules/@sentry/core/build/esm/exports.js
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureEvent(event, hint) {
  return getCurrentScope().captureEvent(event, hint);
}
function startSession(context) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    release,
    environment,
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context
  });
  const currentSession = isolationScope.getSession();
  if (currentSession && currentSession.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  currentScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
  currentScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const client = getClient();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session && client) {
    client.captureSession(session);
  }
}
// ../node_modules/@sentry/core/build/esm/sessionflusher.js
class SessionFlusher {
  constructor(client, attrs) {
    this._client = client;
    this.flushTimeout = 60;
    this._pendingAggregates = new Map;
    this._isEnabled = true;
    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);
    if (this._intervalId.unref) {
      this._intervalId.unref();
    }
    this._sessionAttrs = attrs;
  }
  flush() {
    const sessionAggregates = this.getSessionAggregates();
    if (sessionAggregates.aggregates.length === 0) {
      return;
    }
    this._pendingAggregates = new Map;
    this._client.sendSession(sessionAggregates);
  }
  getSessionAggregates() {
    const aggregates = Array.from(this._pendingAggregates.values());
    const sessionAggregates = {
      attrs: this._sessionAttrs,
      aggregates
    };
    return dropUndefinedKeys(sessionAggregates);
  }
  close() {
    clearInterval(this._intervalId);
    this._isEnabled = false;
    this.flush();
  }
  incrementSessionStatusCount() {
    if (!this._isEnabled) {
      return;
    }
    const isolationScope = getIsolationScope();
    const requestSession = isolationScope.getRequestSession();
    if (requestSession && requestSession.status) {
      this._incrementSessionStatusCount(requestSession.status, new Date);
      isolationScope.setRequestSession(undefined);
    }
  }
  _incrementSessionStatusCount(status, date) {
    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);
    let aggregationCounts = this._pendingAggregates.get(sessionStartedTrunc);
    if (!aggregationCounts) {
      aggregationCounts = { started: new Date(sessionStartedTrunc).toISOString() };
      this._pendingAggregates.set(sessionStartedTrunc, aggregationCounts);
    }
    switch (status) {
      case "errored":
        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
        return aggregationCounts.errored;
      case "ok":
        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
        return aggregationCounts.exited;
      default:
        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
        return aggregationCounts.crashed;
    }
  }
}

// ../node_modules/@sentry/core/build/esm/api.js
var SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  return urlEncode({
    sentry_key: dsn.publicKey,
    sentry_version: SENTRY_API_VERSION,
    ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
  });
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}

// ../node_modules/@sentry/core/build/esm/integration.js
var installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.values(integrationsByName);
}
function getIntegrationsToSetup(options) {
  const defaultIntegrations = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;
  defaultIntegrations.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    integrations = arrayify(userIntegrations(defaultIntegrations));
  } else {
    integrations = defaultIntegrations;
  }
  const finalIntegrations = filterDuplicates(integrations);
  const debugIndex = finalIntegrations.findIndex((integration) => integration.name === "Debug");
  if (debugIndex > -1) {
    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
    finalIntegrations.push(debugInstance);
  }
  return finalIntegrations;
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration && integration.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD2 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
    integration.setupOnce();
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD2 && logger.log(`Integration installed: ${integration.name}`);
}
function defineIntegration(fn) {
  return fn;
}

// ../node_modules/@sentry/core/build/esm/baseclient.js
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";

class BaseClient {
  constructor(options) {
    this._options = options;
    this._integrations = {};
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    } else {
      DEBUG_BUILD2 && logger.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options.tunnel, options._metadata ? options._metadata.sdk : undefined);
      this._transport = options.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url
      });
    }
  }
  captureException(exception, hint, scope) {
    const eventId = uuid4();
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    this._process(this.eventFromException(exception, hintWithEventId).then((event) => this._captureEvent(event, hintWithEventId, scope)));
    return hintWithEventId.event_id;
  }
  captureMessage(message, level, hint, currentScope) {
    const hintWithEventId = {
      event_id: uuid4(),
      ...hint
    };
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);
    this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));
    return hintWithEventId.event_id;
  }
  captureEvent(event, hint, currentScope) {
    const eventId = uuid4();
    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope));
    return hintWithEventId.event_id;
  }
  captureSession(session) {
    if (!(typeof session.release === "string")) {
      DEBUG_BUILD2 && logger.warn("Discarded session because of missing or non-string release");
    } else {
      this.sendSession(session);
      updateSession(session, { init: false });
    }
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      this.emit("flush");
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  close(timeout) {
    return this.flush(timeout).then((result) => {
      this.getOptions().enabled = false;
      this.emit("close");
      return result;
    });
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  init() {
    if (this._isEnabled() || this._options.integrations.some(({ name }) => name.startsWith("Spotlight"))) {
      this._setupIntegrations();
    }
  }
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
    }
    const promise = this.sendEnvelope(env);
    if (promise) {
      promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
    }
  }
  sendSession(session) {
    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(env);
  }
  recordDroppedEvent(reason, category, eventOrCount) {
    if (this._options.sendClientReports) {
      const count = typeof eventOrCount === "number" ? eventOrCount : 1;
      const key = `${reason}:${category}`;
      DEBUG_BUILD2 && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count;
    }
  }
  on(hook, callback) {
    const hooks = this._hooks[hook] = this._hooks[hook] || [];
    hooks.push(callback);
    return () => {
      const cbIndex = hooks.indexOf(callback);
      if (cbIndex > -1) {
        hooks.splice(cbIndex, 1);
      }
    };
  }
  emit(hook, ...rest) {
    const callbacks = this._hooks[hook];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...rest));
    }
  }
  sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD2 && logger.error("Error while sending event:", reason);
        return reason;
      });
    }
    DEBUG_BUILD2 && logger.error("Transport disabled");
    return resolvedSyncPromise({});
  }
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
  }
  _updateSessionFromEvent(session, event) {
    let crashed = false;
    let errored = false;
    const exceptions = event.exception && event.exception.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism && mechanism.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve2) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve2(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve2(false);
          }
        }
      }, tick);
    });
  }
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== undefined;
  }
  _prepareEvent(event, hint, currentScope, isolationScope = getIsolationScope()) {
    const options = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations.length > 0) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    if (!event.type) {
      isolationScope.setLastEventId(event.event_id || hint.event_id);
    }
    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      const propagationContext = {
        ...isolationScope.getPropagationContext(),
        ...currentScope ? currentScope.getPropagationContext() : undefined
      };
      const trace = evt.contexts && evt.contexts.trace;
      if (!trace && propagationContext) {
        const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
        evt.contexts = {
          trace: dropUndefinedKeys({
            trace_id,
            span_id: spanId,
            parent_span_id: parentSpanId
          }),
          ...evt.contexts
        };
        const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this);
        evt.sdkProcessingMetadata = {
          dynamicSamplingContext,
          ...evt.sdkProcessingMetadata
        };
      }
      return evt;
    });
  }
  _captureEvent(event, hint = {}, scope) {
    return this._processEvent(event, hint, scope).then((finalEvent) => {
      return finalEvent.event_id;
    }, (reason) => {
      if (DEBUG_BUILD2) {
        const sentryError = reason;
        if (sentryError.logLevel === "log") {
          logger.log(sentryError.message);
        } else {
          logger.warn(sentryError);
        }
      }
      return;
    });
  }
  _processEvent(event, hint, currentScope) {
    const options = this.getOptions();
    const { sampleRate } = options;
    const isTransaction = isTransactionEvent(event);
    const isError2 = isErrorEvent2(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    const parsedSampleRate = typeof sampleRate === "undefined" ? undefined : parseSampleRate(sampleRate);
    if (isError2 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
      this.recordDroppedEvent("sample_rate", "error", event);
      return rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`, "log"));
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    return this._prepareEvent(event, hint, currentScope, capturedSpanIsolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory, event);
        throw new SentryError("An event processor returned `null`, will not send event.", "log");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result = processBeforeSend(this, options, prepared, hint);
      return _validateBeforeSendResult(result, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory, event);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
      }
      const session = currentScope && currentScope.getSession();
      if (!isTransaction && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (reason instanceof SentryError) {
        throw reason;
      }
      this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`);
    });
  }
  _process(promise) {
    this._numProcessing++;
    promise.then((value) => {
      this._numProcessing--;
      return value;
    }, (reason) => {
      this._numProcessing--;
      return reason;
    });
  }
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.entries(outcomes).map(([key, quantity]) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity
      };
    });
  }
  _flushOutcomes() {
    DEBUG_BUILD2 && logger.log("Flushing outcomes...");
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD2 && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD2 && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD2 && logger.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this.sendEnvelope(envelope);
  }
}
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then((event) => {
      if (!isPlainObject(event) && event !== null) {
        throw new SentryError(invalidValueError);
      }
      return event;
    }, (e) => {
      throw new SentryError(`${beforeSendLabel} rejected with ${e}`);
    });
  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
    throw new SentryError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(client, options, event, hint) {
  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;
  if (isErrorEvent2(event) && beforeSend) {
    return beforeSend(event, hint);
  }
  if (isTransactionEvent(event)) {
    if (event.spans && beforeSendSpan) {
      const processedSpans = [];
      for (const span of event.spans) {
        const processedSpan = beforeSendSpan(span);
        if (processedSpan) {
          processedSpans.push(processedSpan);
        } else {
          client.recordDroppedEvent("before_send", "span");
        }
      }
      event.spans = processedSpans;
    }
    if (beforeSendTransaction) {
      if (event.spans) {
        const spanCountBefore = event.spans.length;
        event.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(event, hint);
    }
  }
  return event;
}
function isErrorEvent2(event) {
  return event.type === undefined;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}

// ../node_modules/@sentry/core/build/esm/checkin.js
function createCheckInEnvelope(checkIn, dynamicSamplingContext, metadata, tunnel, dsn) {
  const headers = {
    sent_at: new Date().toISOString()
  };
  if (metadata && metadata.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  if (dynamicSamplingContext) {
    headers.trace = dropUndefinedKeys(dynamicSamplingContext);
  }
  const item = createCheckInEnvelopeItem(checkIn);
  return createEnvelope(headers, [item]);
}
function createCheckInEnvelopeItem(checkIn) {
  const checkInHeaders = {
    type: "check_in"
  };
  return [checkInHeaders, checkIn];
}

// ../node_modules/@sentry/core/build/esm/server-runtime-client.js
class ServerRuntimeClient extends BaseClient {
  constructor(options) {
    registerSpanErrorInstrumentation();
    super(options);
  }
  eventFromException(exception, hint) {
    return resolvedSyncPromise(eventFromUnknownInput(this, this._options.stackParser, exception, hint));
  }
  eventFromMessage(message, level = "info", hint) {
    return resolvedSyncPromise(eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace));
  }
  captureException(exception, hint, scope) {
    if (this._options.autoSessionTracking && this._sessionFlusher) {
      const requestSession = getIsolationScope().getRequestSession();
      if (requestSession && requestSession.status === "ok") {
        requestSession.status = "errored";
      }
    }
    return super.captureException(exception, hint, scope);
  }
  captureEvent(event, hint, scope) {
    if (this._options.autoSessionTracking && this._sessionFlusher) {
      const eventType = event.type || "exception";
      const isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
      if (isException) {
        const requestSession = getIsolationScope().getRequestSession();
        if (requestSession && requestSession.status === "ok") {
          requestSession.status = "errored";
        }
      }
    }
    return super.captureEvent(event, hint, scope);
  }
  close(timeout) {
    if (this._sessionFlusher) {
      this._sessionFlusher.close();
    }
    return super.close(timeout);
  }
  initSessionFlusher() {
    const { release, environment } = this._options;
    if (!release) {
      DEBUG_BUILD2 && logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
    } else {
      this._sessionFlusher = new SessionFlusher(this, {
        release,
        environment
      });
    }
  }
  captureCheckIn(checkIn, monitorConfig, scope) {
    const id = "checkInId" in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();
    if (!this._isEnabled()) {
      DEBUG_BUILD2 && logger.warn("SDK not enabled, will not capture checkin.");
      return id;
    }
    const options = this.getOptions();
    const { release, environment, tunnel } = options;
    const serializedCheckIn = {
      check_in_id: id,
      monitor_slug: checkIn.monitorSlug,
      status: checkIn.status,
      release,
      environment
    };
    if ("duration" in checkIn) {
      serializedCheckIn.duration = checkIn.duration;
    }
    if (monitorConfig) {
      serializedCheckIn.monitor_config = {
        schedule: monitorConfig.schedule,
        checkin_margin: monitorConfig.checkinMargin,
        max_runtime: monitorConfig.maxRuntime,
        timezone: monitorConfig.timezone,
        failure_issue_threshold: monitorConfig.failureIssueThreshold,
        recovery_threshold: monitorConfig.recoveryThreshold
      };
    }
    const [dynamicSamplingContext, traceContext] = this._getTraceInfoFromScope(scope);
    if (traceContext) {
      serializedCheckIn.contexts = {
        trace: traceContext
      };
    }
    const envelope = createCheckInEnvelope(serializedCheckIn, dynamicSamplingContext, this.getSdkMetadata(), tunnel, this.getDsn());
    DEBUG_BUILD2 && logger.info("Sending checkin:", checkIn.monitorSlug, checkIn.status);
    this.sendEnvelope(envelope);
    return id;
  }
  _captureRequestSession() {
    if (!this._sessionFlusher) {
      DEBUG_BUILD2 && logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
    } else {
      this._sessionFlusher.incrementSessionStatusCount();
    }
  }
  _prepareEvent(event, hint, scope, isolationScope) {
    if (this._options.platform) {
      event.platform = event.platform || this._options.platform;
    }
    if (this._options.runtime) {
      event.contexts = {
        ...event.contexts,
        runtime: (event.contexts || {}).runtime || this._options.runtime
      };
    }
    if (this._options.serverName) {
      event.server_name = event.server_name || this._options.serverName;
    }
    return super._prepareEvent(event, hint, scope, isolationScope);
  }
  _getTraceInfoFromScope(scope) {
    if (!scope) {
      return [undefined, undefined];
    }
    const span = _getSpanForScope(scope);
    if (span) {
      const rootSpan = getRootSpan(span);
      const samplingContext = getDynamicSamplingContextFromSpan(rootSpan);
      return [samplingContext, spanToTraceContext(rootSpan)];
    }
    const { traceId, spanId, parentSpanId, dsc } = scope.getPropagationContext();
    const traceContext = {
      trace_id: traceId,
      span_id: spanId,
      parent_span_id: parentSpanId
    };
    if (dsc) {
      return [dsc, traceContext];
    }
    return [getDynamicSamplingContextFromClient(traceId, this), traceContext];
  }
}
// ../node_modules/@sentry/core/build/esm/transports/base.js
var DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(options, makeRequest, buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
  let rateLimits = {};
  const flush = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise({});
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then((response) => {
      if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
        DEBUG_BUILD2 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
      }
      rateLimits = updateRateLimits(rateLimits, response);
      return response;
    }, (error) => {
      recordEnvelopeLoss("network_error");
      throw error;
    });
    return buffer.add(requestTask).then((result) => result, (error) => {
      if (error instanceof SentryError) {
        DEBUG_BUILD2 && logger.error("Skipped sending event because buffer is full.");
        recordEnvelopeLoss("queue_overflow");
        return resolvedSyncPromise({});
      } else {
        throw error;
      }
    });
  }
  return {
    send,
    flush
  };
}
function getEventForEnvelopeItem(item, type) {
  if (type !== "event" && type !== "transaction") {
    return;
  }
  return Array.isArray(item) ? item[1] : undefined;
}
// ../node_modules/@sentry/core/build/esm/utils/sdkMetadata.js
function applySdkMetadata(options, name, names = [name], source = "npm") {
  const metadata = options._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options._metadata = metadata;
}
// ../node_modules/@sentry/core/build/esm/breadcrumbs.js
var DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(breadcrumb, hint) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  if (!client)
    return;
  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();
  if (maxBreadcrumbs <= 0)
    return;
  const timestamp = dateTimestampInSeconds();
  const mergedBreadcrumb = { timestamp, ...breadcrumb };
  const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
  if (finalBreadcrumb === null)
    return;
  if (client.emit) {
    client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
  }
  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
}
// ../node_modules/@sentry/core/build/esm/integrations/functiontostring.js
var originalFunctionToString;
var INTEGRATION_NAME = "FunctionToString";
var SETUP_CLIENTS = new WeakMap;
var _functionToStringIntegration = () => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== undefined ? originalFunction : this;
          return originalFunctionToString.apply(context, args);
        };
      } catch (e) {
      }
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
};
var functionToStringIntegration = defineIntegration(_functionToStringIntegration);
// ../node_modules/@sentry/core/build/esm/integrations/inboundfilters.js
var DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/,
  "undefined is not an object (evaluating 'a.L')",
  'can\'t redefine non-configurable property "solana"',
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  "Can't find variable: _AutofillCallbackHandler"
];
var INTEGRATION_NAME2 = "InboundFilters";
var _inboundFiltersIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME2,
    processEvent(event, _hint, client) {
      const clientOptions = client.getOptions();
      const mergedOptions = _mergeOptions(options, clientOptions);
      return _shouldDropEvent(event, mergedOptions) ? null : event;
    }
  };
};
var inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []],
    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true
  };
}
function _shouldDropEvent(event, options) {
  if (options.ignoreInternal && _isSentryError(event)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(event)}`);
    return true;
  }
  if (_isIgnoredError(event, options.ignoreErrors)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(event)}`);
    return true;
  }
  if (_isUselessError(event)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${getEventDescription(event)}`);
    return true;
  }
  if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${getEventDescription(event)}`);
    return true;
  }
  if (_isDeniedUrl(event, options.denyUrls)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`);
    return true;
  }
  if (!_isAllowedUrl(event, options.allowUrls)) {
    DEBUG_BUILD2 && logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`);
    return true;
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (event.type || !ignoreErrors || !ignoreErrors.length) {
    return false;
  }
  return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}
function _getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  let lastException;
  try {
    lastException = event.exception.values[event.exception.values.length - 1];
  } catch (e) {
  }
  if (lastException) {
    if (lastException.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  }
  return possibleMessages;
}
function _isSentryError(event) {
  try {
    return event.exception.values[0].type === "SentryError";
  } catch (e) {
  }
  return false;
}
function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1;i >= 0; i--) {
    const frame = frames[i];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    let frames;
    try {
      frames = event.exception.values[0].stacktrace.frames;
    } catch (e) {
    }
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    DEBUG_BUILD2 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
function _isUselessError(event) {
  if (event.type) {
    return false;
  }
  if (!event.exception || !event.exception.values || event.exception.values.length === 0) {
    return false;
  }
  return !event.message && !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== "Error" || value.value);
}
// ../node_modules/@sentry/core/build/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var INTEGRATION_NAME3 = "LinkedErrors";
var _linkedErrorsIntegration = (options = {}) => {
  const limit = options.limit || DEFAULT_LIMIT;
  const key = options.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME3,
    preprocessEvent(event, hint, client) {
      const options2 = client.getOptions();
      applyAggregateErrorsToEvent(exceptionFromError, options2.stackParser, options2.maxValueLength, key, limit, event, hint);
    }
  };
};
var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
// ../node_modules/@sentry/core/build/esm/integrations/requestdata.js
var DEFAULT_OPTIONS = {
  include: {
    cookies: true,
    data: true,
    headers: true,
    ip: false,
    query_string: true,
    url: true,
    user: {
      id: true,
      username: true,
      email: true
    }
  },
  transactionNamingScheme: "methodPath"
};
var INTEGRATION_NAME4 = "RequestData";
var _requestDataIntegration = (options = {}) => {
  const _options = {
    ...DEFAULT_OPTIONS,
    ...options,
    include: {
      ...DEFAULT_OPTIONS.include,
      ...options.include,
      user: options.include && typeof options.include.user === "boolean" ? options.include.user : {
        ...DEFAULT_OPTIONS.include.user,
        ...(options.include || {}).user
      }
    }
  };
  return {
    name: INTEGRATION_NAME4,
    processEvent(event) {
      const { sdkProcessingMetadata = {} } = event;
      const req = sdkProcessingMetadata.request;
      if (!req) {
        return event;
      }
      const addRequestDataOptions = convertReqDataIntegrationOptsToAddReqDataOpts(_options);
      return addRequestDataToEvent(event, req, addRequestDataOptions);
    }
  };
};
var requestDataIntegration = defineIntegration(_requestDataIntegration);
function convertReqDataIntegrationOptsToAddReqDataOpts(integrationOptions) {
  const {
    transactionNamingScheme,
    include: { ip, user, ...requestOptions }
  } = integrationOptions;
  const requestIncludeKeys = ["method"];
  for (const [key, value] of Object.entries(requestOptions)) {
    if (value) {
      requestIncludeKeys.push(key);
    }
  }
  let addReqDataUserOpt;
  if (user === undefined) {
    addReqDataUserOpt = true;
  } else if (typeof user === "boolean") {
    addReqDataUserOpt = user;
  } else {
    const userIncludeKeys = [];
    for (const [key, value] of Object.entries(user)) {
      if (value) {
        userIncludeKeys.push(key);
      }
    }
    addReqDataUserOpt = userIncludeKeys;
  }
  return {
    include: {
      ip,
      user: addReqDataUserOpt,
      request: requestIncludeKeys.length !== 0 ? requestIncludeKeys : undefined,
      transaction: transactionNamingScheme
    }
  };
}
// ../node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
var import_api4 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
var import_api2 = __toESM(require_src(), 1);
var SUPPRESS_TRACING_KEY2 = import_api2.createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function suppressTracing2(context) {
  return context.setValue(SUPPRESS_TRACING_KEY2, true);
}
function isTracingSuppressed(context) {
  return context.getValue(SUPPRESS_TRACING_KEY2) === true;
}

// ../node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR = "=";
var BAGGAGE_PROPERTIES_SEPARATOR = ";";
var BAGGAGE_ITEMS_SEPARATOR = ",";
var BAGGAGE_HEADER = "baggage";
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

// ../node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var import_api3 = __toESM(require_src(), 1);
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function serializeKeyPairs(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
  }, "");
}
function getKeyPairs(baggage) {
  return baggage.getAllEntries().map(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== undefined) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
  if (separatorIndex <= 0)
    return;
  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = import_api3.baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
  }
  return { key, value, metadata };
}

// ../node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
var W3CBaggagePropagator = function() {
  function W3CBaggagePropagator2() {
  }
  W3CBaggagePropagator2.prototype.inject = function(context, carrier, setter) {
    var baggage = import_api4.propagation.getBaggage(context);
    if (!baggage || isTracingSuppressed(context))
      return;
    var keyPairs = getKeyPairs(baggage).filter(function(pair) {
      return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
    }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
    var headerValue = serializeKeyPairs(keyPairs);
    if (headerValue.length > 0) {
      setter.set(carrier, BAGGAGE_HEADER, headerValue);
    }
  };
  W3CBaggagePropagator2.prototype.extract = function(context, carrier, getter) {
    var headerValue = getter.get(carrier, BAGGAGE_HEADER);
    var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
    if (!baggageString)
      return context;
    var baggage = {};
    if (baggageString.length === 0) {
      return context;
    }
    var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
    pairs.forEach(function(entry) {
      var keyPair = parsePairKeyValue(entry);
      if (keyPair) {
        var baggageEntry = { value: keyPair.value };
        if (keyPair.metadata) {
          baggageEntry.metadata = keyPair.metadata;
        }
        baggage[keyPair.key] = baggageEntry;
      }
    });
    if (Object.entries(baggage).length === 0) {
      return context;
    }
    return import_api4.propagation.setBaggage(context, import_api4.propagation.createBaggage(baggage));
  };
  W3CBaggagePropagator2.prototype.fields = function() {
    return [BAGGAGE_HEADER];
  };
  return W3CBaggagePropagator2;
}();
// ../node_modules/@opentelemetry/core/build/esm/common/attributes.js
var import_api5 = __toESM(require_src(), 1);
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function sanitizeAttributes(attributes) {
  var e_1, _a;
  var out = {};
  if (typeof attributes !== "object" || attributes == null) {
    return out;
  }
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next();!_c.done; _c = _b.next()) {
      var _d = __read2(_c.value, 2), key = _d[0], val2 = _d[1];
      if (!isAttributeKey(key)) {
        import_api5.diag.warn("Invalid attribute key: " + key);
        continue;
      }
      if (!isAttributeValue(val2)) {
        import_api5.diag.warn("Invalid attribute value set for key: " + key);
        continue;
      }
      if (Array.isArray(val2)) {
        out[key] = val2.slice();
      } else {
        out[key] = val2;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return out;
}
function isAttributeKey(key) {
  return typeof key === "string" && key.length > 0;
}
function isAttributeValue(val2) {
  if (val2 == null) {
    return true;
  }
  if (Array.isArray(val2)) {
    return isHomogeneousAttributeValueArray(val2);
  }
  return isValidPrimitiveAttributeValue(val2);
}
function isHomogeneousAttributeValueArray(arr) {
  var e_2, _a;
  var type;
  try {
    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next();!arr_1_1.done; arr_1_1 = arr_1.next()) {
      var element = arr_1_1.value;
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return))
        _a.call(arr_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return true;
}
function isValidPrimitiveAttributeValue(val2) {
  switch (typeof val2) {
    case "number":
    case "boolean":
    case "string":
      return true;
  }
  return false;
}
// ../node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
var import_api6 = __toESM(require_src(), 1);
function loggingErrorHandler() {
  return function(ex) {
    import_api6.diag.error(stringifyException(ex));
  };
}
function stringifyException(ex) {
  if (typeof ex === "string") {
    return ex;
  } else {
    return JSON.stringify(flattenException(ex));
  }
}
function flattenException(ex) {
  var result = {};
  var current = ex;
  while (current !== null) {
    Object.getOwnPropertyNames(current).forEach(function(propertyName) {
      if (result[propertyName])
        return;
      var value = current[propertyName];
      if (value) {
        result[propertyName] = String(value);
      }
    });
    current = Object.getPrototypeOf(current);
  }
  return result;
}

// ../node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
var delegateHandler = loggingErrorHandler();
function globalErrorHandler(ex) {
  try {
    delegateHandler(ex);
  } catch (_a) {
  }
}
// ../node_modules/@opentelemetry/core/build/esm/utils/environment.js
var import_api7 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/core/build/esm/utils/sampling.js
var TracesSamplerValues;
(function(TracesSamplerValues2) {
  TracesSamplerValues2["AlwaysOff"] = "always_off";
  TracesSamplerValues2["AlwaysOn"] = "always_on";
  TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
  TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
  TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
  TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

// ../node_modules/@opentelemetry/core/build/esm/utils/environment.js
var DEFAULT_LIST_SEPARATOR = ",";
var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
function isEnvVarABoolean(key) {
  return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT"
];
function isEnvVarANumber(key) {
  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS = [
  "OTEL_NO_PATCH_MODULES",
  "OTEL_PROPAGATORS"
];
function isEnvVarAList(key) {
  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
var DEFAULT_ENVIRONMENT2 = {
  OTEL_SDK_DISABLED: false,
  CONTAINER_NAME: "",
  ECS_CONTAINER_METADATA_URI_V4: "",
  ECS_CONTAINER_METADATA_URI: "",
  HOSTNAME: "",
  KUBERNETES_SERVICE_HOST: "",
  NAMESPACE: "",
  OTEL_BSP_EXPORT_TIMEOUT: 30000,
  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BSP_MAX_QUEUE_SIZE: 2048,
  OTEL_BSP_SCHEDULE_DELAY: 5000,
  OTEL_BLRP_EXPORT_TIMEOUT: 30000,
  OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
  OTEL_BLRP_SCHEDULE_DELAY: 5000,
  OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
  OTEL_EXPORTER_JAEGER_ENDPOINT: "",
  OTEL_EXPORTER_JAEGER_PASSWORD: "",
  OTEL_EXPORTER_JAEGER_USER: "",
  OTEL_EXPORTER_OTLP_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_HEADERS: "",
  OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
  OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
  OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
  OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
  OTEL_LOG_LEVEL: import_api7.DiagLogLevel.INFO,
  OTEL_NO_PATCH_MODULES: [],
  OTEL_PROPAGATORS: ["tracecontext", "baggage"],
  OTEL_RESOURCE_ATTRIBUTES: "",
  OTEL_SERVICE_NAME: "",
  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
  OTEL_SPAN_LINK_COUNT_LIMIT: 128,
  OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
  OTEL_TRACES_EXPORTER: "",
  OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
  OTEL_TRACES_SAMPLER_ARG: "",
  OTEL_LOGS_EXPORTER: "",
  OTEL_EXPORTER_OTLP_INSECURE: "",
  OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
  OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
  OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
  OTEL_EXPORTER_OTLP_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
};
function parseBoolean(key, environment, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment[key] = value.toLowerCase() === "true";
}
function parseNumber(name, environment, values, min, max) {
  if (min === undefined) {
    min = -Infinity;
  }
  if (max === undefined) {
    max = Infinity;
  }
  if (typeof values[name] !== "undefined") {
    var value = Number(values[name]);
    if (!isNaN(value)) {
      if (value < min) {
        environment[name] = min;
      } else if (value > max) {
        environment[name] = max;
      } else {
        environment[name] = value;
      }
    }
  }
}
function parseStringList(name, output, input, separator) {
  if (separator === undefined) {
    separator = DEFAULT_LIST_SEPARATOR;
  }
  var givenValue = input[name];
  if (typeof givenValue === "string") {
    output[name] = givenValue.split(separator).map(function(v) {
      return v.trim();
    });
  }
}
var logLevelMap = {
  ALL: import_api7.DiagLogLevel.ALL,
  VERBOSE: import_api7.DiagLogLevel.VERBOSE,
  DEBUG: import_api7.DiagLogLevel.DEBUG,
  INFO: import_api7.DiagLogLevel.INFO,
  WARN: import_api7.DiagLogLevel.WARN,
  ERROR: import_api7.DiagLogLevel.ERROR,
  NONE: import_api7.DiagLogLevel.NONE
};
function setLogLevelFromEnv(key, environment, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap[value.toUpperCase()];
    if (theLevel != null) {
      environment[key] = theLevel;
    }
  }
}
function parseEnvironment(values) {
  var environment = {};
  for (var env in DEFAULT_ENVIRONMENT2) {
    var key = env;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv(key, environment, values);
        break;
      default:
        if (isEnvVarABoolean(key)) {
          parseBoolean(key, environment, values);
        } else if (isEnvVarANumber(key)) {
          parseNumber(key, environment, values);
        } else if (isEnvVarAList(key)) {
          parseStringList(key, environment, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment[key] = String(value);
          }
        }
    }
  }
  return environment;
}

// ../node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getEnv() {
  var processEnv = parseEnvironment(process.env);
  return Object.assign({}, DEFAULT_ENVIRONMENT2, processEnv);
}
function getEnvWithoutDefaults() {
  return parseEnvironment(process.env);
}
// ../node_modules/@opentelemetry/core/build/esm/platform/node/performance.js
import { performance as performance2 } from "perf_hooks";
var otperformance = performance2;
// ../node_modules/@opentelemetry/core/build/esm/version.js
var VERSION = "1.26.0";

// ../node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js
var import_semantic_conventions = __toESM(require_src2(), 1);
var _a;
var SDK_INFO = (_a = {}, _a[import_semantic_conventions.SEMRESATTRS_TELEMETRY_SDK_NAME] = "opentelemetry", _a[import_semantic_conventions.SEMRESATTRS_PROCESS_RUNTIME_NAME] = "node", _a[import_semantic_conventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = import_semantic_conventions.TELEMETRYSDKLANGUAGEVALUES_NODEJS, _a[import_semantic_conventions.SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION, _a);
// ../node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js
function unrefTimer(timer) {
  timer.unref();
}
// ../node_modules/@opentelemetry/core/build/esm/common/time.js
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
  var epochSeconds = epochMillis / 1000;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
  return [seconds, nanos];
}
function getTimeOrigin() {
  var timeOrigin = otperformance.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime(performanceNow) {
  var timeOrigin = millisToHrTime(getTimeOrigin());
  var now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
  return addHrTimes(timeOrigin, now);
}
function hrTimeDuration(startTime, endTime) {
  var seconds = endTime[0] - startTime[0];
  var nanos = endTime[1] - startTime[1];
  if (nanos < 0) {
    seconds -= 1;
    nanos += SECOND_TO_NANOSECONDS;
  }
  return [seconds, nanos];
}
function isTimeInputHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function isTimeInput(value) {
  return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
}
function addHrTimes(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS) {
    out[1] -= SECOND_TO_NANOSECONDS;
    out[0] += 1;
  }
  return out;
}
// ../node_modules/@opentelemetry/core/build/esm/ExportResult.js
var ExportResultCode;
(function(ExportResultCode2) {
  ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
  ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));
// ../node_modules/@opentelemetry/core/build/esm/propagation/composite.js
var import_api8 = __toESM(require_src(), 1);
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var CompositePropagator = function() {
  function CompositePropagator2(config) {
    if (config === undefined) {
      config = {};
    }
    var _a2;
    this._propagators = (_a2 = config.propagators) !== null && _a2 !== undefined ? _a2 : [];
    this._fields = Array.from(new Set(this._propagators.map(function(p) {
      return typeof p.fields === "function" ? p.fields() : [];
    }).reduce(function(x, y) {
      return x.concat(y);
    }, [])));
  }
  CompositePropagator2.prototype.inject = function(context, carrier, setter) {
    var e_1, _a2;
    try {
      for (var _b = __values2(this._propagators), _c = _b.next();!_c.done; _c = _b.next()) {
        var propagator = _c.value;
        try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          import_api8.diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  CompositePropagator2.prototype.extract = function(context, carrier, getter) {
    return this._propagators.reduce(function(ctx, propagator) {
      try {
        return propagator.extract(ctx, carrier, getter);
      } catch (err) {
        import_api8.diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
      }
      return ctx;
    }, context);
  };
  CompositePropagator2.prototype.fields = function() {
    return this._fields.slice();
  };
  return CompositePropagator2;
}();
// ../node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
var import_api9 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/core/build/esm/internal/validators.js
var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

// ../node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ",";
var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
var TraceState = function() {
  function TraceState2(rawTraceState) {
    this._internalState = new Map;
    if (rawTraceState)
      this._parse(rawTraceState);
  }
  TraceState2.prototype.set = function(key, value) {
    var traceState = this._clone();
    if (traceState._internalState.has(key)) {
      traceState._internalState.delete(key);
    }
    traceState._internalState.set(key, value);
    return traceState;
  };
  TraceState2.prototype.unset = function(key) {
    var traceState = this._clone();
    traceState._internalState.delete(key);
    return traceState;
  };
  TraceState2.prototype.get = function(key) {
    return this._internalState.get(key);
  };
  TraceState2.prototype.serialize = function() {
    var _this = this;
    return this._keys().reduce(function(agg, key) {
      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
      return agg;
    }, []).join(LIST_MEMBERS_SEPARATOR);
  };
  TraceState2.prototype._parse = function(rawTraceState) {
    if (rawTraceState.length > MAX_TRACE_STATE_LEN)
      return;
    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
      var listMember = part.trim();
      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
      if (i !== -1) {
        var key = listMember.slice(0, i);
        var value = listMember.slice(i + 1, part.length);
        if (validateKey(key) && validateValue(value)) {
          agg.set(key, value);
        } else {
        }
      }
      return agg;
    }, new Map);
    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
      this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
    }
  };
  TraceState2.prototype._keys = function() {
    return Array.from(this._internalState.keys()).reverse();
  };
  TraceState2.prototype._clone = function() {
    var traceState = new TraceState2;
    traceState._internalState = new Map(this._internalState);
    return traceState;
  };
  return TraceState2;
}();

// ../node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
var TRACE_PARENT_HEADER = "traceparent";
var TRACE_STATE_HEADER = "tracestate";
var VERSION2 = "00";
var VERSION_PART = "(?!ff)[\\da-f]{2}";
var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
var FLAGS_PART = "[\\da-f]{2}";
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
  var match = TRACE_PARENT_REGEX.exec(traceParent);
  if (!match)
    return null;
  if (match[1] === "00" && match[5])
    return null;
  return {
    traceId: match[2],
    spanId: match[3],
    traceFlags: parseInt(match[4], 16)
  };
}
var W3CTraceContextPropagator = function() {
  function W3CTraceContextPropagator2() {
  }
  W3CTraceContextPropagator2.prototype.inject = function(context, carrier, setter) {
    var spanContext = import_api9.trace.getSpanContext(context);
    if (!spanContext || isTracingSuppressed(context) || !import_api9.isSpanContextValid(spanContext))
      return;
    var traceParent = VERSION2 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || import_api9.TraceFlags.NONE).toString(16);
    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
    if (spanContext.traceState) {
      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
    }
  };
  W3CTraceContextPropagator2.prototype.extract = function(context, carrier, getter) {
    var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
    if (!traceParentHeader)
      return context;
    var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
    if (typeof traceParent !== "string")
      return context;
    var spanContext = parseTraceParent(traceParent);
    if (!spanContext)
      return context;
    spanContext.isRemote = true;
    var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
    if (traceStateHeader) {
      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
      spanContext.traceState = new TraceState(typeof state === "string" ? state : undefined);
    }
    return import_api9.trace.setSpanContext(context, spanContext);
  };
  W3CTraceContextPropagator2.prototype.fields = function() {
    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
  };
  return W3CTraceContextPropagator2;
}();
// ../node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
var objectTag = "[object Object]";
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var nativeObjectToString = objectProto.toString;
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function isPlainObject2(value) {
  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
}
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  var unmasked = false;
  try {
    value[symToStringTag] = undefined;
    unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function objectToString2(value) {
  return nativeObjectToString.call(value);
}

// ../node_modules/@opentelemetry/core/build/esm/utils/merge.js
var MAX_LEVEL = 20;
function merge() {
  var args = [];
  for (var _i = 0;_i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = args.shift();
  var objects = new WeakMap;
  while (args.length > 0) {
    result = mergeTwoObjects(result, args.shift(), 0, objects);
  }
  return result;
}
function takeValue(value) {
  if (isArray(value)) {
    return value.slice();
  }
  return value;
}
function mergeTwoObjects(one, two, level, objects) {
  if (level === undefined) {
    level = 0;
  }
  var result;
  if (level > MAX_LEVEL) {
    return;
  }
  level++;
  if (isPrimitive2(one) || isPrimitive2(two) || isFunction(two)) {
    result = takeValue(two);
  } else if (isArray(one)) {
    result = one.slice();
    if (isArray(two)) {
      for (var i = 0, j = two.length;i < j; i++) {
        result.push(takeValue(two[i]));
      }
    } else if (isObject(two)) {
      var keys = Object.keys(two);
      for (var i = 0, j = keys.length;i < j; i++) {
        var key = keys[i];
        result[key] = takeValue(two[key]);
      }
    }
  } else if (isObject(one)) {
    if (isObject(two)) {
      if (!shouldMerge(one, two)) {
        return two;
      }
      result = Object.assign({}, one);
      var keys = Object.keys(two);
      for (var i = 0, j = keys.length;i < j; i++) {
        var key = keys[i];
        var twoValue = two[key];
        if (isPrimitive2(twoValue)) {
          if (typeof twoValue === "undefined") {
            delete result[key];
          } else {
            result[key] = twoValue;
          }
        } else {
          var obj1 = result[key];
          var obj2 = twoValue;
          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
            delete result[key];
          } else {
            if (isObject(obj1) && isObject(obj2)) {
              var arr1 = objects.get(obj1) || [];
              var arr2 = objects.get(obj2) || [];
              arr1.push({ obj: one, key });
              arr2.push({ obj: two, key });
              objects.set(obj1, arr1);
              objects.set(obj2, arr2);
            }
            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
          }
        }
      }
    } else {
      result = two;
    }
  }
  return result;
}
function wasObjectReferenced(obj, key, objects) {
  var arr = objects.get(obj[key]) || [];
  for (var i = 0, j = arr.length;i < j; i++) {
    var info = arr[i];
    if (info.key === key && info.obj === obj) {
      return true;
    }
  }
  return false;
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return !isPrimitive2(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
}
function isPrimitive2(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
  if (!isPlainObject2(one) || !isPlainObject2(two)) {
    return false;
  }
  return true;
}
// ../node_modules/@opentelemetry/core/build/esm/utils/wrap.js
function isWrapped(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}
// ../node_modules/@opentelemetry/core/build/esm/utils/promise.js
var Deferred = function() {
  function Deferred2() {
    var _this = this;
    this._promise = new Promise(function(resolve2, reject) {
      _this._resolve = resolve2;
      _this._reject = reject;
    });
  }
  Object.defineProperty(Deferred2.prototype, "promise", {
    get: function() {
      return this._promise;
    },
    enumerable: false,
    configurable: true
  });
  Deferred2.prototype.resolve = function(val2) {
    this._resolve(val2);
  };
  Deferred2.prototype.reject = function(err) {
    this._reject(err);
  };
  return Deferred2;
}();

// ../node_modules/@opentelemetry/core/build/esm/utils/callback.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BindOnceFuture = function() {
  function BindOnceFuture2(_callback, _that) {
    this._callback = _callback;
    this._that = _that;
    this._isCalled = false;
    this._deferred = new Deferred;
  }
  Object.defineProperty(BindOnceFuture2.prototype, "isCalled", {
    get: function() {
      return this._isCalled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BindOnceFuture2.prototype, "promise", {
    get: function() {
      return this._deferred.promise;
    },
    enumerable: false,
    configurable: true
  });
  BindOnceFuture2.prototype.call = function() {
    var _a2;
    var _this = this;
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this._isCalled) {
      this._isCalled = true;
      try {
        Promise.resolve((_a2 = this._callback).call.apply(_a2, __spreadArray([this._that], __read3(args), false))).then(function(val2) {
          return _this._deferred.resolve(val2);
        }, function(err) {
          return _this._deferred.reject(err);
        });
      } catch (err) {
        this._deferred.reject(err);
      }
    }
    return this._deferred.promise;
  };
  return BindOnceFuture2;
}();
// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js
var api = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js
var import_api10 = __toESM(require_src(), 1);
var import_semantic_conventions2 = __toESM(require_src2(), 1);

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js
var ExceptionEventName = "exception";

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js
var __values3 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Span = function() {
  function Span2(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock, attributes) {
    if (links === undefined) {
      links = [];
    }
    this.attributes = {};
    this.links = [];
    this.events = [];
    this._droppedAttributesCount = 0;
    this._droppedEventsCount = 0;
    this._droppedLinksCount = 0;
    this.status = {
      code: import_api10.SpanStatusCode.UNSET
    };
    this.endTime = [0, 0];
    this._ended = false;
    this._duration = [-1, -1];
    this.name = spanName;
    this._spanContext = spanContext;
    this.parentSpanId = parentSpanId;
    this.kind = kind;
    this.links = links;
    var now = Date.now();
    this._performanceStartTime = otperformance.now();
    this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());
    this._startTimeProvided = startTime != null;
    this.startTime = this._getTime(startTime !== null && startTime !== undefined ? startTime : now);
    this.resource = parentTracer.resource;
    this.instrumentationLibrary = parentTracer.instrumentationLibrary;
    this._spanLimits = parentTracer.getSpanLimits();
    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
    if (attributes != null) {
      this.setAttributes(attributes);
    }
    this._spanProcessor = parentTracer.getActiveSpanProcessor();
    this._spanProcessor.onStart(this, context);
  }
  Span2.prototype.spanContext = function() {
    return this._spanContext;
  };
  Span2.prototype.setAttribute = function(key, value) {
    if (value == null || this._isSpanEnded())
      return this;
    if (key.length === 0) {
      import_api10.diag.warn("Invalid attribute key: " + key);
      return this;
    }
    if (!isAttributeValue(value)) {
      import_api10.diag.warn("Invalid attribute value set for key: " + key);
      return this;
    }
    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
      this._droppedAttributesCount++;
      return this;
    }
    this.attributes[key] = this._truncateToSize(value);
    return this;
  };
  Span2.prototype.setAttributes = function(attributes) {
    var e_1, _a2;
    try {
      for (var _b = __values3(Object.entries(attributes)), _c = _b.next();!_c.done; _c = _b.next()) {
        var _d = __read4(_c.value, 2), k = _d[0], v = _d[1];
        this.setAttribute(k, v);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return this;
  };
  Span2.prototype.addEvent = function(name, attributesOrStartTime, timeStamp) {
    if (this._isSpanEnded())
      return this;
    if (this._spanLimits.eventCountLimit === 0) {
      import_api10.diag.warn("No events allowed.");
      this._droppedEventsCount++;
      return this;
    }
    if (this.events.length >= this._spanLimits.eventCountLimit) {
      if (this._droppedEventsCount === 0) {
        import_api10.diag.debug("Dropping extra events.");
      }
      this.events.shift();
      this._droppedEventsCount++;
    }
    if (isTimeInput(attributesOrStartTime)) {
      if (!isTimeInput(timeStamp)) {
        timeStamp = attributesOrStartTime;
      }
      attributesOrStartTime = undefined;
    }
    var attributes = sanitizeAttributes(attributesOrStartTime);
    this.events.push({
      name,
      attributes,
      time: this._getTime(timeStamp),
      droppedAttributesCount: 0
    });
    return this;
  };
  Span2.prototype.addLink = function(link) {
    this.links.push(link);
    return this;
  };
  Span2.prototype.addLinks = function(links) {
    var _a2;
    (_a2 = this.links).push.apply(_a2, __spreadArray2([], __read4(links), false));
    return this;
  };
  Span2.prototype.setStatus = function(status) {
    if (this._isSpanEnded())
      return this;
    this.status = status;
    return this;
  };
  Span2.prototype.updateName = function(name) {
    if (this._isSpanEnded())
      return this;
    this.name = name;
    return this;
  };
  Span2.prototype.end = function(endTime) {
    if (this._isSpanEnded()) {
      import_api10.diag.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
      return;
    }
    this._ended = true;
    this.endTime = this._getTime(endTime);
    this._duration = hrTimeDuration(this.startTime, this.endTime);
    if (this._duration[0] < 0) {
      import_api10.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
      this.endTime = this.startTime.slice();
      this._duration = [0, 0];
    }
    if (this._droppedEventsCount > 0) {
      import_api10.diag.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
    }
    this._spanProcessor.onEnd(this);
  };
  Span2.prototype._getTime = function(inp) {
    if (typeof inp === "number" && inp < otperformance.now()) {
      return hrTime(inp + this._performanceOffset);
    }
    if (typeof inp === "number") {
      return millisToHrTime(inp);
    }
    if (inp instanceof Date) {
      return millisToHrTime(inp.getTime());
    }
    if (isTimeInputHrTime(inp)) {
      return inp;
    }
    if (this._startTimeProvided) {
      return millisToHrTime(Date.now());
    }
    var msDuration = otperformance.now() - this._performanceStartTime;
    return addHrTimes(this.startTime, millisToHrTime(msDuration));
  };
  Span2.prototype.isRecording = function() {
    return this._ended === false;
  };
  Span2.prototype.recordException = function(exception, time) {
    var attributes = {};
    if (typeof exception === "string") {
      attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_MESSAGE] = exception;
    } else if (exception) {
      if (exception.code) {
        attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
      } else if (exception.name) {
        attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_TYPE] = exception.name;
      }
      if (exception.message) {
        attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
      }
      if (exception.stack) {
        attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
      }
    }
    if (attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_TYPE] || attributes[import_semantic_conventions2.SEMATTRS_EXCEPTION_MESSAGE]) {
      this.addEvent(ExceptionEventName, attributes, time);
    } else {
      import_api10.diag.warn("Failed to record an exception " + exception);
    }
  };
  Object.defineProperty(Span2.prototype, "duration", {
    get: function() {
      return this._duration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Span2.prototype, "ended", {
    get: function() {
      return this._ended;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Span2.prototype, "droppedAttributesCount", {
    get: function() {
      return this._droppedAttributesCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Span2.prototype, "droppedEventsCount", {
    get: function() {
      return this._droppedEventsCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Span2.prototype, "droppedLinksCount", {
    get: function() {
      return this._droppedLinksCount;
    },
    enumerable: false,
    configurable: true
  });
  Span2.prototype._isSpanEnded = function() {
    if (this._ended) {
      import_api10.diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
    }
    return this._ended;
  };
  Span2.prototype._truncateToLimitUtil = function(value, limit) {
    if (value.length <= limit) {
      return value;
    }
    return value.substr(0, limit);
  };
  Span2.prototype._truncateToSize = function(value) {
    var _this = this;
    var limit = this._attributeValueLengthLimit;
    if (limit <= 0) {
      import_api10.diag.warn("Attribute value limit must be positive, got " + limit);
      return value;
    }
    if (typeof value === "string") {
      return this._truncateToLimitUtil(value, limit);
    }
    if (Array.isArray(value)) {
      return value.map(function(val2) {
        return typeof val2 === "string" ? _this._truncateToLimitUtil(val2, limit) : val2;
      });
    }
    return value;
  };
  return Span2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js
var import_api13 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js
var SamplingDecision;
(function(SamplingDecision2) {
  SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
  SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js
var AlwaysOffSampler = function() {
  function AlwaysOffSampler2() {
  }
  AlwaysOffSampler2.prototype.shouldSample = function() {
    return {
      decision: SamplingDecision.NOT_RECORD
    };
  };
  AlwaysOffSampler2.prototype.toString = function() {
    return "AlwaysOffSampler";
  };
  return AlwaysOffSampler2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js
var AlwaysOnSampler = function() {
  function AlwaysOnSampler2() {
  }
  AlwaysOnSampler2.prototype.shouldSample = function() {
    return {
      decision: SamplingDecision.RECORD_AND_SAMPLED
    };
  };
  AlwaysOnSampler2.prototype.toString = function() {
    return "AlwaysOnSampler";
  };
  return AlwaysOnSampler2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js
var import_api11 = __toESM(require_src(), 1);
var ParentBasedSampler = function() {
  function ParentBasedSampler2(config) {
    var _a2, _b, _c, _d;
    this._root = config.root;
    if (!this._root) {
      globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
      this._root = new AlwaysOnSampler;
    }
    this._remoteParentSampled = (_a2 = config.remoteParentSampled) !== null && _a2 !== undefined ? _a2 : new AlwaysOnSampler;
    this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== undefined ? _b : new AlwaysOffSampler;
    this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== undefined ? _c : new AlwaysOnSampler;
    this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== undefined ? _d : new AlwaysOffSampler;
  }
  ParentBasedSampler2.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
    var parentContext = import_api11.trace.getSpanContext(context);
    if (!parentContext || !import_api11.isSpanContextValid(parentContext)) {
      return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    if (parentContext.isRemote) {
      if (parentContext.traceFlags & import_api11.TraceFlags.SAMPLED) {
        return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    if (parentContext.traceFlags & import_api11.TraceFlags.SAMPLED) {
      return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
  };
  ParentBasedSampler2.prototype.toString = function() {
    return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
  };
  return ParentBasedSampler2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js
var import_api12 = __toESM(require_src(), 1);
var TraceIdRatioBasedSampler = function() {
  function TraceIdRatioBasedSampler2(_ratio) {
    if (_ratio === undefined) {
      _ratio = 0;
    }
    this._ratio = _ratio;
    this._ratio = this._normalize(_ratio);
    this._upperBound = Math.floor(this._ratio * 4294967295);
  }
  TraceIdRatioBasedSampler2.prototype.shouldSample = function(context, traceId) {
    return {
      decision: import_api12.isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
    };
  };
  TraceIdRatioBasedSampler2.prototype.toString = function() {
    return "TraceIdRatioBased{" + this._ratio + "}";
  };
  TraceIdRatioBasedSampler2.prototype._normalize = function(ratio) {
    if (typeof ratio !== "number" || isNaN(ratio))
      return 0;
    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
  };
  TraceIdRatioBasedSampler2.prototype._accumulate = function(traceId) {
    var accumulation = 0;
    for (var i = 0;i < traceId.length / 8; i++) {
      var pos = i * 8;
      var part = parseInt(traceId.slice(pos, pos + 8), 16);
      accumulation = (accumulation ^ part) >>> 0;
    }
    return accumulation;
  };
  return TraceIdRatioBasedSampler2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js
var env = getEnv();
var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
var DEFAULT_RATIO = 1;
function loadDefaultConfig() {
  var _env = getEnv();
  return {
    sampler: buildSamplerFromEnv(env),
    forceFlushTimeoutMillis: 30000,
    generalLimits: {
      attributeValueLengthLimit: _env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: _env.OTEL_ATTRIBUTE_COUNT_LIMIT
    },
    spanLimits: {
      attributeValueLengthLimit: _env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: _env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: _env.OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: _env.OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
    }
  };
}
function buildSamplerFromEnv(environment) {
  if (environment === undefined) {
    environment = getEnv();
  }
  switch (environment.OTEL_TRACES_SAMPLER) {
    case TracesSamplerValues.AlwaysOn:
      return new AlwaysOnSampler;
    case TracesSamplerValues.AlwaysOff:
      return new AlwaysOffSampler;
    case TracesSamplerValues.ParentBasedAlwaysOn:
      return new ParentBasedSampler({
        root: new AlwaysOnSampler
      });
    case TracesSamplerValues.ParentBasedAlwaysOff:
      return new ParentBasedSampler({
        root: new AlwaysOffSampler
      });
    case TracesSamplerValues.TraceIdRatio:
      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
    case TracesSamplerValues.ParentBasedTraceIdRatio:
      return new ParentBasedSampler({
        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
      });
    default:
      import_api13.diag.error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
      return new AlwaysOnSampler;
  }
}
function getSamplerProbabilityFromEnv(environment) {
  if (environment.OTEL_TRACES_SAMPLER_ARG === undefined || environment.OTEL_TRACES_SAMPLER_ARG === "") {
    import_api13.diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
  if (isNaN(probability)) {
    import_api13.diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  if (probability < 0 || probability > 1) {
    import_api13.diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  return probability;
}

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js
function mergeConfig(userConfig) {
  var perInstanceDefaults = {
    sampler: buildSamplerFromEnv()
  };
  var DEFAULT_CONFIG = loadDefaultConfig();
  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
  return target;
}
function reconfigureLimits(userConfig) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  var spanLimits = Object.assign({}, userConfig.spanLimits);
  var parsedEnvConfig = getEnvWithoutDefaults();
  spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a2 = userConfig.spanLimits) === null || _a2 === undefined ? undefined : _a2.attributeCountLimit) !== null && _b !== undefined ? _b : (_c = userConfig.generalLimits) === null || _c === undefined ? undefined : _c.attributeCountLimit) !== null && _d !== undefined ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== undefined ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== undefined ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === undefined ? undefined : _g.attributeValueLengthLimit) !== null && _h !== undefined ? _h : (_j = userConfig.generalLimits) === null || _j === undefined ? undefined : _j.attributeValueLengthLimit) !== null && _k !== undefined ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== undefined ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== undefined ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
  return Object.assign({}, userConfig, { spanLimits });
}

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js
var import_api14 = __toESM(require_src(), 1);
var BatchSpanProcessorBase = function() {
  function BatchSpanProcessorBase2(_exporter, config) {
    this._exporter = _exporter;
    this._isExporting = false;
    this._finishedSpans = [];
    this._droppedSpansCount = 0;
    var env2 = getEnv();
    this._maxExportBatchSize = typeof (config === null || config === undefined ? undefined : config.maxExportBatchSize) === "number" ? config.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
    this._maxQueueSize = typeof (config === null || config === undefined ? undefined : config.maxQueueSize) === "number" ? config.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
    this._scheduledDelayMillis = typeof (config === null || config === undefined ? undefined : config.scheduledDelayMillis) === "number" ? config.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
    this._exportTimeoutMillis = typeof (config === null || config === undefined ? undefined : config.exportTimeoutMillis) === "number" ? config.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
    if (this._maxExportBatchSize > this._maxQueueSize) {
      import_api14.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
      this._maxExportBatchSize = this._maxQueueSize;
    }
  }
  BatchSpanProcessorBase2.prototype.forceFlush = function() {
    if (this._shutdownOnce.isCalled) {
      return this._shutdownOnce.promise;
    }
    return this._flushAll();
  };
  BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {
  };
  BatchSpanProcessorBase2.prototype.onEnd = function(span) {
    if (this._shutdownOnce.isCalled) {
      return;
    }
    if ((span.spanContext().traceFlags & import_api14.TraceFlags.SAMPLED) === 0) {
      return;
    }
    this._addToBuffer(span);
  };
  BatchSpanProcessorBase2.prototype.shutdown = function() {
    return this._shutdownOnce.call();
  };
  BatchSpanProcessorBase2.prototype._shutdown = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.onShutdown();
    }).then(function() {
      return _this._flushAll();
    }).then(function() {
      return _this._exporter.shutdown();
    });
  };
  BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {
    if (this._finishedSpans.length >= this._maxQueueSize) {
      if (this._droppedSpansCount === 0) {
        import_api14.diag.debug("maxQueueSize reached, dropping spans");
      }
      this._droppedSpansCount++;
      return;
    }
    if (this._droppedSpansCount > 0) {
      import_api14.diag.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
      this._droppedSpansCount = 0;
    }
    this._finishedSpans.push(span);
    this._maybeStartTimer();
  };
  BatchSpanProcessorBase2.prototype._flushAll = function() {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      var promises = [];
      var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
      for (var i = 0, j = count;i < j; i++) {
        promises.push(_this._flushOneBatch());
      }
      Promise.all(promises).then(function() {
        resolve2();
      }).catch(reject);
    });
  };
  BatchSpanProcessorBase2.prototype._flushOneBatch = function() {
    var _this = this;
    this._clearTimer();
    if (this._finishedSpans.length === 0) {
      return Promise.resolve();
    }
    return new Promise(function(resolve2, reject) {
      var timer = setTimeout(function() {
        reject(new Error("Timeout"));
      }, _this._exportTimeoutMillis);
      import_api14.context.with(suppressTracing2(import_api14.context.active()), function() {
        var spans;
        if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
          spans = _this._finishedSpans;
          _this._finishedSpans = [];
        } else {
          spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
        }
        var doExport = function() {
          return _this._exporter.export(spans, function(result) {
            var _a2;
            clearTimeout(timer);
            if (result.code === ExportResultCode.SUCCESS) {
              resolve2();
            } else {
              reject((_a2 = result.error) !== null && _a2 !== undefined ? _a2 : new Error("BatchSpanProcessor: span export failed"));
            }
          });
        };
        var pendingResources = null;
        for (var i = 0, len = spans.length;i < len; i++) {
          var span = spans[i];
          if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
            pendingResources !== null && pendingResources !== undefined || (pendingResources = []);
            pendingResources.push(span.resource.waitForAsyncAttributes());
          }
        }
        if (pendingResources === null) {
          doExport();
        } else {
          Promise.all(pendingResources).then(doExport, function(err) {
            globalErrorHandler(err);
            reject(err);
          });
        }
      });
    });
  };
  BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {
    var _this = this;
    if (this._isExporting)
      return;
    var flush2 = function() {
      _this._isExporting = true;
      _this._flushOneBatch().finally(function() {
        _this._isExporting = false;
        if (_this._finishedSpans.length > 0) {
          _this._clearTimer();
          _this._maybeStartTimer();
        }
      }).catch(function(e) {
        _this._isExporting = false;
        globalErrorHandler(e);
      });
    };
    if (this._finishedSpans.length >= this._maxExportBatchSize) {
      return flush2();
    }
    if (this._timer !== undefined)
      return;
    this._timer = setTimeout(function() {
      return flush2();
    }, this._scheduledDelayMillis);
    unrefTimer(this._timer);
  };
  BatchSpanProcessorBase2.prototype._clearTimer = function() {
    if (this._timer !== undefined) {
      clearTimeout(this._timer);
      this._timer = undefined;
    }
  };
  return BatchSpanProcessorBase2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
  };
}();
var BatchSpanProcessor = function(_super) {
  __extends(BatchSpanProcessor2, _super);
  function BatchSpanProcessor2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BatchSpanProcessor2.prototype.onShutdown = function() {
  };
  return BatchSpanProcessor2;
}(BatchSpanProcessorBase);
// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator2 = function() {
  function RandomIdGenerator3() {
    this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
    this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
  }
  return RandomIdGenerator3;
}();
var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
function getIdGenerator(bytes) {
  return function generateId() {
    for (var i = 0;i < bytes / 4; i++) {
      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);
    }
    for (var i = 0;i < bytes; i++) {
      if (SHARED_BUFFER[i] > 0) {
        break;
      } else if (i === bytes - 1) {
        SHARED_BUFFER[bytes - 1] = 1;
      }
    }
    return SHARED_BUFFER.toString("hex", 0, bytes);
  };
}
// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js
var Tracer = function() {
  function Tracer2(instrumentationLibrary, config, _tracerProvider) {
    this._tracerProvider = _tracerProvider;
    var localConfig = mergeConfig(config);
    this._sampler = localConfig.sampler;
    this._generalLimits = localConfig.generalLimits;
    this._spanLimits = localConfig.spanLimits;
    this._idGenerator = config.idGenerator || new RandomIdGenerator2;
    this.resource = _tracerProvider.resource;
    this.instrumentationLibrary = instrumentationLibrary;
  }
  Tracer2.prototype.startSpan = function(name, options, context3) {
    var _a2, _b, _c;
    if (options === undefined) {
      options = {};
    }
    if (context3 === undefined) {
      context3 = api.context.active();
    }
    if (options.root) {
      context3 = api.trace.deleteSpan(context3);
    }
    var parentSpan = api.trace.getSpan(context3);
    if (isTracingSuppressed(context3)) {
      api.diag.debug("Instrumentation suppressed, returning Noop Span");
      var nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
      return nonRecordingSpan;
    }
    var parentSpanContext = parentSpan === null || parentSpan === undefined ? undefined : parentSpan.spanContext();
    var spanId = this._idGenerator.generateSpanId();
    var traceId;
    var traceState;
    var parentSpanId;
    if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
      traceId = this._idGenerator.generateTraceId();
    } else {
      traceId = parentSpanContext.traceId;
      traceState = parentSpanContext.traceState;
      parentSpanId = parentSpanContext.spanId;
    }
    var spanKind = (_a2 = options.kind) !== null && _a2 !== undefined ? _a2 : api.SpanKind.INTERNAL;
    var links = ((_b = options.links) !== null && _b !== undefined ? _b : []).map(function(link) {
      return {
        context: link.context,
        attributes: sanitizeAttributes(link.attributes)
      };
    });
    var attributes = sanitizeAttributes(options.attributes);
    var samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);
    traceState = (_c = samplingResult.traceState) !== null && _c !== undefined ? _c : traceState;
    var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
    var spanContext = { traceId, spanId, traceFlags, traceState };
    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
      api.diag.debug("Recording is off, propagating context in a non-recording span");
      var nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
      return nonRecordingSpan;
    }
    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
    var span = new Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
    return span;
  };
  Tracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
    var opts;
    var ctx;
    var fn;
    if (arguments.length < 2) {
      return;
    } else if (arguments.length === 2) {
      fn = arg2;
    } else if (arguments.length === 3) {
      opts = arg2;
      fn = arg3;
    } else {
      opts = arg2;
      ctx = arg3;
      fn = arg4;
    }
    var parentContext = ctx !== null && ctx !== undefined ? ctx : api.context.active();
    var span = this.startSpan(name, opts, parentContext);
    var contextWithSpanSet = api.trace.setSpan(parentContext, span);
    return api.context.with(contextWithSpanSet, fn, undefined, span);
  };
  Tracer2.prototype.getGeneralLimits = function() {
    return this._generalLimits;
  };
  Tracer2.prototype.getSpanLimits = function() {
    return this._spanLimits;
  };
  Tracer2.prototype.getActiveSpanProcessor = function() {
    return this._tracerProvider.getActiveSpanProcessor();
  };
  return Tracer2;
}();
// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js
var import_api16 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/resources/build/esm/Resource.js
var import_api15 = __toESM(require_src(), 1);
var import_semantic_conventions3 = __toESM(require_src2(), 1);

// ../node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js
function defaultServiceName() {
  return "unknown_service:" + process.argv0;
}
// ../node_modules/@opentelemetry/resources/build/esm/Resource.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
};
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var Resource = function() {
  function Resource2(attributes, asyncAttributesPromise) {
    var _this = this;
    var _a2;
    this._attributes = attributes;
    this.asyncAttributesPending = asyncAttributesPromise != null;
    this._syncAttributes = (_a2 = this._attributes) !== null && _a2 !== undefined ? _a2 : {};
    this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === undefined ? undefined : asyncAttributesPromise.then(function(asyncAttributes) {
      _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
      _this.asyncAttributesPending = false;
      return asyncAttributes;
    }, function(err) {
      import_api15.diag.debug("a resource's async attributes promise rejected: %s", err);
      _this.asyncAttributesPending = false;
      return {};
    });
  }
  Resource2.empty = function() {
    return Resource2.EMPTY;
  };
  Resource2.default = function() {
    var _a2;
    return new Resource2((_a2 = {}, _a2[import_semantic_conventions3.SEMRESATTRS_SERVICE_NAME] = defaultServiceName(), _a2[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = SDK_INFO[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE], _a2[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_NAME] = SDK_INFO[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_NAME], _a2[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_VERSION] = SDK_INFO[import_semantic_conventions3.SEMRESATTRS_TELEMETRY_SDK_VERSION], _a2));
  };
  Object.defineProperty(Resource2.prototype, "attributes", {
    get: function() {
      var _a2;
      if (this.asyncAttributesPending) {
        import_api15.diag.error("Accessing resource attributes before async attributes settled");
      }
      return (_a2 = this._attributes) !== null && _a2 !== undefined ? _a2 : {};
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.waitForAsyncAttributes = function() {
    return __awaiter(this, undefined, undefined, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this.asyncAttributesPending)
              return [3, 2];
            return [4, this._asyncAttributesPromise];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  Resource2.prototype.merge = function(other) {
    var _this = this;
    var _a2;
    if (!other)
      return this;
    var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== undefined ? _a2 : other.attributes);
    if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
      return new Resource2(mergedSyncAttributes);
    }
    var mergedAttributesPromise = Promise.all([
      this._asyncAttributesPromise,
      other._asyncAttributesPromise
    ]).then(function(_a3) {
      var _b;
      var _c = __read5(_a3, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
      return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== undefined ? _b : other.attributes), otherAsyncAttributes);
    });
    return new Resource2(mergedSyncAttributes, mergedAttributesPromise);
  };
  Resource2.EMPTY = new Resource2({});
  return Resource2;
}();
// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js
var __values4 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiSpanProcessor = function() {
  function MultiSpanProcessor2(_spanProcessors) {
    this._spanProcessors = _spanProcessors;
  }
  MultiSpanProcessor2.prototype.forceFlush = function() {
    var e_1, _a2;
    var promises = [];
    try {
      for (var _b = __values4(this._spanProcessors), _c = _b.next();!_c.done; _c = _b.next()) {
        var spanProcessor = _c.value;
        promises.push(spanProcessor.forceFlush());
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return new Promise(function(resolve2) {
      Promise.all(promises).then(function() {
        resolve2();
      }).catch(function(error) {
        globalErrorHandler(error || new Error("MultiSpanProcessor: forceFlush failed"));
        resolve2();
      });
    });
  };
  MultiSpanProcessor2.prototype.onStart = function(span, context3) {
    var e_2, _a2;
    try {
      for (var _b = __values4(this._spanProcessors), _c = _b.next();!_c.done; _c = _b.next()) {
        var spanProcessor = _c.value;
        spanProcessor.onStart(span, context3);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  MultiSpanProcessor2.prototype.onEnd = function(span) {
    var e_3, _a2;
    try {
      for (var _b = __values4(this._spanProcessors), _c = _b.next();!_c.done; _c = _b.next()) {
        var spanProcessor = _c.value;
        spanProcessor.onEnd(span);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  MultiSpanProcessor2.prototype.shutdown = function() {
    var e_4, _a2;
    var promises = [];
    try {
      for (var _b = __values4(this._spanProcessors), _c = _b.next();!_c.done; _c = _b.next()) {
        var spanProcessor = _c.value;
        promises.push(spanProcessor.shutdown());
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    return new Promise(function(resolve2, reject) {
      Promise.all(promises).then(function() {
        resolve2();
      }, reject);
    });
  };
  return MultiSpanProcessor2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js
var NoopSpanProcessor = function() {
  function NoopSpanProcessor2() {
  }
  NoopSpanProcessor2.prototype.onStart = function(_span, _context) {
  };
  NoopSpanProcessor2.prototype.onEnd = function(_span) {
  };
  NoopSpanProcessor2.prototype.shutdown = function() {
    return Promise.resolve();
  };
  NoopSpanProcessor2.prototype.forceFlush = function() {
    return Promise.resolve();
  };
  return NoopSpanProcessor2;
}();

// ../node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js
var ForceFlushState;
(function(ForceFlushState2) {
  ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
  ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
  ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
  ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
var BasicTracerProvider = function() {
  function BasicTracerProvider2(config) {
    if (config === undefined) {
      config = {};
    }
    var _a2;
    this._registeredSpanProcessors = [];
    this._tracers = new Map;
    var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
    this.resource = (_a2 = mergedConfig.resource) !== null && _a2 !== undefined ? _a2 : Resource.empty();
    this.resource = Resource.default().merge(this.resource);
    this._config = Object.assign({}, mergedConfig, {
      resource: this.resource
    });
    var defaultExporter = this._buildExporterFromEnv();
    if (defaultExporter !== undefined) {
      var batchProcessor = new BatchSpanProcessor(defaultExporter);
      this.activeSpanProcessor = batchProcessor;
    } else {
      this.activeSpanProcessor = new NoopSpanProcessor;
    }
  }
  BasicTracerProvider2.prototype.getTracer = function(name, version, options) {
    var key = name + "@" + (version || "") + ":" + ((options === null || options === undefined ? undefined : options.schemaUrl) || "");
    if (!this._tracers.has(key)) {
      this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === undefined ? undefined : options.schemaUrl }, this._config, this));
    }
    return this._tracers.get(key);
  };
  BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {
    if (this._registeredSpanProcessors.length === 0) {
      this.activeSpanProcessor.shutdown().catch(function(err) {
        return import_api16.diag.error("Error while trying to shutdown current span processor", err);
      });
    }
    this._registeredSpanProcessors.push(spanProcessor);
    this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
  };
  BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {
    return this.activeSpanProcessor;
  };
  BasicTracerProvider2.prototype.register = function(config) {
    if (config === undefined) {
      config = {};
    }
    import_api16.trace.setGlobalTracerProvider(this);
    if (config.propagator === undefined) {
      config.propagator = this._buildPropagatorFromEnv();
    }
    if (config.contextManager) {
      import_api16.context.setGlobalContextManager(config.contextManager);
    }
    if (config.propagator) {
      import_api16.propagation.setGlobalPropagator(config.propagator);
    }
  };
  BasicTracerProvider2.prototype.forceFlush = function() {
    var timeout = this._config.forceFlushTimeoutMillis;
    var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
      return new Promise(function(resolve2) {
        var state;
        var timeoutInterval = setTimeout(function() {
          resolve2(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
          state = ForceFlushState.timeout;
        }, timeout);
        spanProcessor.forceFlush().then(function() {
          clearTimeout(timeoutInterval);
          if (state !== ForceFlushState.timeout) {
            state = ForceFlushState.resolved;
            resolve2(state);
          }
        }).catch(function(error) {
          clearTimeout(timeoutInterval);
          state = ForceFlushState.error;
          resolve2(error);
        });
      });
    });
    return new Promise(function(resolve2, reject) {
      Promise.all(promises).then(function(results) {
        var errors = results.filter(function(result) {
          return result !== ForceFlushState.resolved;
        });
        if (errors.length > 0) {
          reject(errors);
        } else {
          resolve2();
        }
      }).catch(function(error) {
        return reject([error]);
      });
    });
  };
  BasicTracerProvider2.prototype.shutdown = function() {
    return this.activeSpanProcessor.shutdown();
  };
  BasicTracerProvider2.prototype._getPropagator = function(name) {
    var _a2;
    return (_a2 = this.constructor._registeredPropagators.get(name)) === null || _a2 === undefined ? undefined : _a2();
  };
  BasicTracerProvider2.prototype._getSpanExporter = function(name) {
    var _a2;
    return (_a2 = this.constructor._registeredExporters.get(name)) === null || _a2 === undefined ? undefined : _a2();
  };
  BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {
    var _this = this;
    var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
    var propagators = uniquePropagatorNames.map(function(name) {
      var propagator = _this._getPropagator(name);
      if (!propagator) {
        import_api16.diag.warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
      }
      return propagator;
    });
    var validPropagators = propagators.reduce(function(list, item) {
      if (item) {
        list.push(item);
      }
      return list;
    }, []);
    if (validPropagators.length === 0) {
      return;
    } else if (uniquePropagatorNames.length === 1) {
      return validPropagators[0];
    } else {
      return new CompositePropagator({
        propagators: validPropagators
      });
    }
  };
  BasicTracerProvider2.prototype._buildExporterFromEnv = function() {
    var exporterName = getEnv().OTEL_TRACES_EXPORTER;
    if (exporterName === "none" || exporterName === "")
      return;
    var exporter = this._getSpanExporter(exporterName);
    if (!exporter) {
      import_api16.diag.error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
    }
    return exporter;
  };
  BasicTracerProvider2._registeredPropagators = new Map([
    ["tracecontext", function() {
      return new W3CTraceContextPropagator;
    }],
    ["baggage", function() {
      return new W3CBaggagePropagator;
    }]
  ]);
  BasicTracerProvider2._registeredExporters = new Map;
  return BasicTracerProvider2;
}();
// ../node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
var import_api17 = __toESM(require_src(), 1);

// ../node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js
var NoopLogger = function() {
  function NoopLogger2() {
  }
  NoopLogger2.prototype.emit = function(_logRecord) {
  };
  return NoopLogger2;
}();
var NOOP_LOGGER = new NoopLogger;

// ../node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js
var NoopLoggerProvider = function() {
  function NoopLoggerProvider2() {
  }
  NoopLoggerProvider2.prototype.getLogger = function(_name, _version, _options) {
    return new NoopLogger;
  };
  return NoopLoggerProvider2;
}();
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;

// ../node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js
var _globalThis2 = typeof globalThis === "object" ? globalThis : global;
// ../node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js
var GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
var _global = _globalThis2;
function makeGetter(requiredVersion, instance, fallback) {
  return function(version) {
    return version === requiredVersion ? instance : fallback;
  };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

// ../node_modules/@opentelemetry/api-logs/build/esm/api/logs.js
var LogsAPI = function() {
  function LogsAPI2() {
  }
  LogsAPI2.getInstance = function() {
    if (!this._instance) {
      this._instance = new LogsAPI2;
    }
    return this._instance;
  };
  LogsAPI2.prototype.setGlobalLoggerProvider = function(provider) {
    if (_global[GLOBAL_LOGS_API_KEY]) {
      return this.getLoggerProvider();
    }
    _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
    return provider;
  };
  LogsAPI2.prototype.getLoggerProvider = function() {
    var _a2, _b;
    return (_b = (_a2 = _global[GLOBAL_LOGS_API_KEY]) === null || _a2 === undefined ? undefined : _a2.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== undefined ? _b : NOOP_LOGGER_PROVIDER;
  };
  LogsAPI2.prototype.getLogger = function(name, version, options) {
    return this.getLoggerProvider().getLogger(name, version, options);
  };
  LogsAPI2.prototype.disable = function() {
    delete _global[GLOBAL_LOGS_API_KEY];
  };
  return LogsAPI2;
}();

// ../node_modules/@opentelemetry/api-logs/build/esm/index.js
var logs = LogsAPI.getInstance();

// ../node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
  for (var i = 0, j = instrumentations.length;i < j; i++) {
    var instrumentation = instrumentations[i];
    if (tracerProvider) {
      instrumentation.setTracerProvider(tracerProvider);
    }
    if (meterProvider) {
      instrumentation.setMeterProvider(meterProvider);
    }
    if (loggerProvider && instrumentation.setLoggerProvider) {
      instrumentation.setLoggerProvider(loggerProvider);
    }
    if (!instrumentation.getConfig().enabled) {
      instrumentation.enable();
    }
  }
}
function disableInstrumentations(instrumentations) {
  instrumentations.forEach(function(instrumentation) {
    return instrumentation.disable();
  });
}

// ../node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
function registerInstrumentations(options) {
  var _a2, _b;
  var tracerProvider = options.tracerProvider || import_api17.trace.getTracerProvider();
  var meterProvider = options.meterProvider || import_api17.metrics.getMeterProvider();
  var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
  var instrumentations = (_b = (_a2 = options.instrumentations) === null || _a2 === undefined ? undefined : _a2.flat()) !== null && _b !== undefined ? _b : [];
  enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
  return function() {
    disableInstrumentations(instrumentations);
  };
}
// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var import_semver = __toESM(require_semver3(), 1);
var import_shimmer = __toESM(require_shimmer(), 1);
import * as path2 from "path";
import { types as utilTypes } from "util";

// ../node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js
var import_api18 = __toESM(require_src(), 1);
var shimmer = __toESM(require_shimmer(), 1);
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var InstrumentationAbstract = function() {
  function InstrumentationAbstract2(instrumentationName, instrumentationVersion, config) {
    this.instrumentationName = instrumentationName;
    this.instrumentationVersion = instrumentationVersion;
    this._config = {};
    this._wrap = shimmer.wrap;
    this._unwrap = shimmer.unwrap;
    this._massWrap = shimmer.massWrap;
    this._massUnwrap = shimmer.massUnwrap;
    this.setConfig(config);
    this._diag = import_api18.diag.createComponentLogger({
      namespace: instrumentationName
    });
    this._tracer = import_api18.trace.getTracer(instrumentationName, instrumentationVersion);
    this._meter = import_api18.metrics.getMeter(instrumentationName, instrumentationVersion);
    this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
    this._updateMetricInstruments();
  }
  Object.defineProperty(InstrumentationAbstract2.prototype, "meter", {
    get: function() {
      return this._meter;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype.setMeterProvider = function(meterProvider) {
    this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
    this._updateMetricInstruments();
  };
  Object.defineProperty(InstrumentationAbstract2.prototype, "logger", {
    get: function() {
      return this._logger;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype.setLoggerProvider = function(loggerProvider) {
    this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
  };
  InstrumentationAbstract2.prototype.getModuleDefinitions = function() {
    var _a2;
    var initResult = (_a2 = this.init()) !== null && _a2 !== undefined ? _a2 : [];
    if (!Array.isArray(initResult)) {
      return [initResult];
    }
    return initResult;
  };
  InstrumentationAbstract2.prototype._updateMetricInstruments = function() {
    return;
  };
  InstrumentationAbstract2.prototype.getConfig = function() {
    return this._config;
  };
  InstrumentationAbstract2.prototype.setConfig = function(config) {
    this._config = __assign2({ enabled: true }, config);
  };
  InstrumentationAbstract2.prototype.setTracerProvider = function(tracerProvider) {
    this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
  };
  Object.defineProperty(InstrumentationAbstract2.prototype, "tracer", {
    get: function() {
      return this._tracer;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
    if (!hookHandler) {
      return;
    }
    try {
      hookHandler(span, info);
    } catch (e) {
      this._diag.error("Error running span customization hook due to exception in handler", { triggerName }, e);
    }
  };
  return InstrumentationAbstract2;
}();

// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js
var import_require_in_the_middle = __toESM(require_require_in_the_middle(), 1);
import * as path from "path";

// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ModuleNameTrie.js
var __values5 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === undefined || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var ModuleNameSeparator = "/";
var ModuleNameTrieNode = function() {
  function ModuleNameTrieNode2() {
    this.hooks = [];
    this.children = new Map;
  }
  return ModuleNameTrieNode2;
}();
var ModuleNameTrie = function() {
  function ModuleNameTrie2() {
    this._trie = new ModuleNameTrieNode;
    this._counter = 0;
  }
  ModuleNameTrie2.prototype.insert = function(hook) {
    var e_1, _a2;
    var trieNode = this._trie;
    try {
      for (var _b = __values5(hook.moduleName.split(ModuleNameSeparator)), _c = _b.next();!_c.done; _c = _b.next()) {
        var moduleNamePart = _c.value;
        var nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    trieNode.hooks.push({ hook, insertedId: this._counter++ });
  };
  ModuleNameTrie2.prototype.search = function(moduleName, _a2) {
    var e_2, _b;
    var _c = _a2 === undefined ? {} : _a2, maintainInsertionOrder = _c.maintainInsertionOrder, fullOnly = _c.fullOnly;
    var trieNode = this._trie;
    var results = [];
    var foundFull = true;
    try {
      for (var _d = __values5(moduleName.split(ModuleNameSeparator)), _e = _d.next();!_e.done; _e = _d.next()) {
        var moduleNamePart = _e.value;
        var nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push.apply(results, __spreadArray3([], __read6(nextNode.hooks), false));
        }
        trieNode = nextNode;
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_e && !_e.done && (_b = _d.return))
          _b.call(_d);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    if (fullOnly && foundFull) {
      results.push.apply(results, __spreadArray3([], __read6(trieNode.hooks), false));
    }
    if (results.length === 0) {
      return [];
    }
    if (results.length === 1) {
      return [results[0].hook];
    }
    if (maintainInsertionOrder) {
      results.sort(function(a, b) {
        return a.insertedId - b.insertedId;
      });
    }
    return results.map(function(_a3) {
      var hook = _a3.hook;
      return hook;
    });
  };
  return ModuleNameTrie2;
}();

// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js
var __values6 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var isMocha = [
  "afterEach",
  "after",
  "beforeEach",
  "before",
  "describe",
  "it"
].every(function(fn) {
  return typeof global[fn] === "function";
});
var RequireInTheMiddleSingleton = function() {
  function RequireInTheMiddleSingleton2() {
    this._moduleNameTrie = new ModuleNameTrie;
    this._initialize();
  }
  RequireInTheMiddleSingleton2.prototype._initialize = function() {
    var _this = this;
    new import_require_in_the_middle.Hook(null, { internals: true }, function(exports, name, basedir) {
      var e_1, _a2;
      var normalizedModuleName = normalizePathSeparators(name);
      var matches = _this._moduleNameTrie.search(normalizedModuleName, {
        maintainInsertionOrder: true,
        fullOnly: basedir === undefined
      });
      try {
        for (var matches_1 = __values6(matches), matches_1_1 = matches_1.next();!matches_1_1.done; matches_1_1 = matches_1.next()) {
          var onRequire = matches_1_1.value.onRequire;
          exports = onRequire(exports, name, basedir);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (matches_1_1 && !matches_1_1.done && (_a2 = matches_1.return))
            _a2.call(matches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return exports;
    });
  };
  RequireInTheMiddleSingleton2.prototype.register = function(moduleName, onRequire) {
    var hooked = { moduleName, onRequire };
    this._moduleNameTrie.insert(hooked);
    return hooked;
  };
  RequireInTheMiddleSingleton2.getInstance = function() {
    var _a2;
    if (isMocha)
      return new RequireInTheMiddleSingleton2;
    return this._instance = (_a2 = this._instance) !== null && _a2 !== undefined ? _a2 : new RequireInTheMiddleSingleton2;
  };
  return RequireInTheMiddleSingleton2;
}();
function normalizePathSeparators(moduleNameOrPath) {
  return path.sep !== ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameSeparator) : moduleNameOrPath;
}

// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var import_import_in_the_middle = __toESM(require_import_in_the_middle(), 1);
var import_api19 = __toESM(require_src(), 1);
var import_require_in_the_middle2 = __toESM(require_require_in_the_middle(), 1);
import { readFileSync } from "fs";

// ../node_modules/@opentelemetry/instrumentation/build/esm/utils.js
function isWrapped2(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}

// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
  };
}();
var __values7 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var InstrumentationBase = function(_super) {
  __extends2(InstrumentationBase2, _super);
  function InstrumentationBase2(instrumentationName, instrumentationVersion, config) {
    var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
    _this._hooks = [];
    _this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton.getInstance();
    _this._enabled = false;
    _this._wrap = function(moduleExports, name, wrapper) {
      if (isWrapped2(moduleExports[name])) {
        _this._unwrap(moduleExports, name);
      }
      if (!utilTypes.isProxy(moduleExports)) {
        return import_shimmer.wrap(moduleExports, name, wrapper);
      } else {
        var wrapped = import_shimmer.wrap(Object.assign({}, moduleExports), name, wrapper);
        Object.defineProperty(moduleExports, name, {
          value: wrapped
        });
        return wrapped;
      }
    };
    _this._unwrap = function(moduleExports, name) {
      if (!utilTypes.isProxy(moduleExports)) {
        return import_shimmer.unwrap(moduleExports, name);
      } else {
        return Object.defineProperty(moduleExports, name, {
          value: moduleExports[name]
        });
      }
    };
    _this._massWrap = function(moduleExportsArray, names, wrapper) {
      if (!moduleExportsArray) {
        import_api19.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        import_api19.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach(function(moduleExports) {
        names.forEach(function(name) {
          _this._wrap(moduleExports, name, wrapper);
        });
      });
    };
    _this._massUnwrap = function(moduleExportsArray, names) {
      if (!moduleExportsArray) {
        import_api19.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        import_api19.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach(function(moduleExports) {
        names.forEach(function(name) {
          _this._unwrap(moduleExports, name);
        });
      });
    };
    var modules = _this.init();
    if (modules && !Array.isArray(modules)) {
      modules = [modules];
    }
    _this._modules = modules || [];
    if (_this._config.enabled) {
      _this.enable();
    }
    return _this;
  }
  InstrumentationBase2.prototype._warnOnPreloadedModules = function() {
    var _this = this;
    this._modules.forEach(function(module) {
      var name = module.name;
      try {
        var resolvedModule = import.meta.require.resolve(name);
        if (import.meta.require.cache[resolvedModule]) {
          _this._diag.warn("Module " + name + " has been loaded before " + _this.instrumentationName + " so it might not work, please initialize it before requiring " + name);
        }
      } catch (_a2) {
      }
    });
  };
  InstrumentationBase2.prototype._extractPackageVersion = function(baseDir) {
    try {
      var json = readFileSync(path2.join(baseDir, "package.json"), {
        encoding: "utf8"
      });
      var version = JSON.parse(json).version;
      return typeof version === "string" ? version : undefined;
    } catch (error) {
      import_api19.diag.warn("Failed extracting version", baseDir);
    }
    return;
  };
  InstrumentationBase2.prototype._onRequire = function(module, exports, name, baseDir) {
    var _this = this;
    var _a2;
    if (!baseDir) {
      if (typeof module.patch === "function") {
        module.moduleExports = exports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
            module: module.name
          });
          return module.patch(exports);
        }
      }
      return exports;
    }
    var version = this._extractPackageVersion(baseDir);
    module.moduleVersion = version;
    if (module.name === name) {
      if (isSupported(module.supportedVersions, version, module.includePrerelease)) {
        if (typeof module.patch === "function") {
          module.moduleExports = exports;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for module on require hook", {
              module: module.name,
              version: module.moduleVersion,
              baseDir
            });
            return module.patch(exports, module.moduleVersion);
          }
        }
      }
      return exports;
    }
    var files = (_a2 = module.files) !== null && _a2 !== undefined ? _a2 : [];
    var normalizedName = path2.normalize(name);
    var supportedFileInstrumentations = files.filter(function(f) {
      return f.name === normalizedName;
    }).filter(function(f) {
      return isSupported(f.supportedVersions, version, module.includePrerelease);
    });
    return supportedFileInstrumentations.reduce(function(patchedExports, file) {
      file.moduleExports = patchedExports;
      if (_this._enabled) {
        _this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
          module: module.name,
          version: module.moduleVersion,
          fileName: file.name,
          baseDir
        });
        return file.patch(patchedExports, module.moduleVersion);
      }
      return patchedExports;
    }, exports);
  };
  InstrumentationBase2.prototype.enable = function() {
    var e_1, _a2, e_2, _b, e_3, _c;
    var _this = this;
    if (this._enabled) {
      return;
    }
    this._enabled = true;
    if (this._hooks.length > 0) {
      try {
        for (var _d = __values7(this._modules), _e = _d.next();!_e.done; _e = _d.next()) {
          var module_1 = _e.value;
          if (typeof module_1.patch === "function" && module_1.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module_1.name,
              version: module_1.moduleVersion
            });
            module_1.patch(module_1.moduleExports, module_1.moduleVersion);
          }
          try {
            for (var _f = (e_2 = undefined, __values7(module_1.files)), _g = _f.next();!_g.done; _g = _f.next()) {
              var file = _g.value;
              if (file.moduleExports) {
                this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                  module: module_1.name,
                  version: module_1.moduleVersion,
                  fileName: file.name
                });
                file.patch(file.moduleExports, module_1.moduleVersion);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_g && !_g.done && (_b = _f.return))
                _b.call(_f);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a2 = _d.return))
            _a2.call(_d);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return;
    }
    this._warnOnPreloadedModules();
    var _loop_1 = function(module_22) {
      var hookFn = function(exports, name, baseDir) {
        return _this._onRequire(module_22, exports, name, baseDir);
      };
      var onRequire = function(exports, name, baseDir) {
        return _this._onRequire(module_22, exports, name, baseDir);
      };
      var hook = path2.isAbsolute(module_22.name) ? new import_require_in_the_middle2.Hook([module_22.name], { internals: true }, onRequire) : this_1._requireInTheMiddleSingleton.register(module_22.name, onRequire);
      this_1._hooks.push(hook);
      var esmHook = new import_import_in_the_middle.Hook([module_22.name], { internals: false }, hookFn);
      this_1._hooks.push(esmHook);
    };
    var this_1 = this;
    try {
      for (var _h = __values7(this._modules), _j = _h.next();!_j.done; _j = _h.next()) {
        var module_2 = _j.value;
        _loop_1(module_2);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_j && !_j.done && (_c = _h.return))
          _c.call(_h);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  InstrumentationBase2.prototype.disable = function() {
    var e_4, _a2, e_5, _b;
    if (!this._enabled) {
      return;
    }
    this._enabled = false;
    try {
      for (var _c = __values7(this._modules), _d = _c.next();!_d.done; _d = _c.next()) {
        var module_3 = _d.value;
        if (typeof module_3.unpatch === "function" && module_3.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module_3.name,
            version: module_3.moduleVersion
          });
          module_3.unpatch(module_3.moduleExports, module_3.moduleVersion);
        }
        try {
          for (var _e = (e_5 = undefined, __values7(module_3.files)), _f = _e.next();!_f.done; _f = _e.next()) {
            var file = _f.value;
            if (file.moduleExports) {
              this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
                module: module_3.name,
                version: module_3.moduleVersion,
                fileName: file.name
              });
              file.unpatch(file.moduleExports, module_3.moduleVersion);
            }
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return))
              _b.call(_e);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a2 = _c.return))
          _a2.call(_c);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  InstrumentationBase2.prototype.isEnabled = function() {
    return this._enabled;
  };
  return InstrumentationBase2;
}(InstrumentationAbstract);
function isSupported(supportedVersions, version, includePrerelease) {
  if (typeof version === "undefined") {
    return supportedVersions.includes("*");
  }
  return supportedVersions.some(function(supportedVersion) {
    return import_semver.satisfies(version, supportedVersion, { includePrerelease });
  });
}
// ../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/normalize.js
import { normalize as normalize3 } from "path";
// ../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleDefinition.js
var InstrumentationNodeModuleDefinition = function() {
  function InstrumentationNodeModuleDefinition2(name, supportedVersions, patch, unpatch, files) {
    this.name = name;
    this.supportedVersions = supportedVersions;
    this.patch = patch;
    this.unpatch = unpatch;
    this.files = files || [];
  }
  return InstrumentationNodeModuleDefinition2;
}();
// ../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleFile.js
var InstrumentationNodeModuleFile = function() {
  function InstrumentationNodeModuleFile2(name, supportedVersions, patch, unpatch) {
    this.supportedVersions = supportedVersions;
    this.patch = patch;
    this.unpatch = unpatch;
    this.name = normalize3(name);
  }
  return InstrumentationNodeModuleFile2;
}();
// ../node_modules/@sentry/opentelemetry/build/esm/index.js
var SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = "sentry.parentIsRemote";
var SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = "sentry.graphql.operation";
function spanHasAttributes(span) {
  const castSpan = span;
  return !!castSpan.attributes && typeof castSpan.attributes === "object";
}
function spanHasKind(span) {
  const castSpan = span;
  return typeof castSpan.kind === "number";
}
function spanHasStatus(span) {
  const castSpan = span;
  return !!castSpan.status;
}
function spanHasName(span) {
  const castSpan = span;
  return !!castSpan.name;
}
function spanHasParentId(span) {
  const castSpan = span;
  return !!castSpan.parentSpanId;
}
function getRequestSpanData(span) {
  if (!spanHasAttributes(span)) {
    return {};
  }
  const maybeUrlAttribute = span.attributes[import_semantic_conventions4.ATTR_URL_FULL] || span.attributes[import_semantic_conventions4.SEMATTRS_HTTP_URL];
  const data = {
    url: maybeUrlAttribute,
    "http.method": span.attributes[import_semantic_conventions4.ATTR_HTTP_REQUEST_METHOD] || span.attributes[import_semantic_conventions4.SEMATTRS_HTTP_METHOD]
  };
  if (!data["http.method"] && data.url) {
    data["http.method"] = "GET";
  }
  try {
    if (typeof maybeUrlAttribute === "string") {
      const url = parseUrl(maybeUrlAttribute);
      data.url = getSanitizedUrlString(url);
      if (url.search) {
        data["http.query"] = url.search;
      }
      if (url.hash) {
        data["http.fragment"] = url.hash;
      }
    }
  } catch (e) {
  }
  return data;
}
function getSpanKind(span) {
  if (spanHasKind(span)) {
    return span.kind;
  }
  return import_api20.SpanKind.INTERNAL;
}
var SENTRY_TRACE_HEADER = "sentry-trace";
var SENTRY_BAGGAGE_HEADER = "baggage";
var SENTRY_TRACE_STATE_DSC = "sentry.dsc";
var SENTRY_TRACE_STATE_PARENT_SPAN_ID = "sentry.parent_span_id";
var SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = "sentry.sampled_not_recording";
var SENTRY_TRACE_STATE_URL = "sentry.url";
var SENTRY_SCOPES_CONTEXT_KEY = import_api20.createContextKey("sentry_scopes");
var SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = import_api20.createContextKey("sentry_fork_isolation_scope");
var SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = import_api20.createContextKey("sentry_fork_set_scope");
var SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = import_api20.createContextKey("sentry_fork_set_isolation_scope");
var SCOPE_CONTEXT_FIELD = "_scopeContext";
function getScopesFromContext(context6) {
  return context6.getValue(SENTRY_SCOPES_CONTEXT_KEY);
}
function setScopesOnContext(context6, scopes) {
  return context6.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);
}
function setContextOnScope(scope, context6) {
  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context6);
}
function getContextFromScope(scope) {
  return scope[SCOPE_CONTEXT_FIELD];
}
function inferSpanData(name, attributes, kind) {
  if (attributes["sentry.skip_span_data_inference"]) {
    return {
      op: undefined,
      description: name,
      source: "custom",
      data: {
        "sentry.skip_span_data_inference": undefined
      }
    };
  }
  const httpMethod = attributes[import_semantic_conventions4.ATTR_HTTP_REQUEST_METHOD] || attributes[import_semantic_conventions4.SEMATTRS_HTTP_METHOD];
  if (httpMethod) {
    return descriptionForHttpMethod({ attributes, name, kind }, httpMethod);
  }
  const dbSystem = attributes[import_semantic_conventions4.SEMATTRS_DB_SYSTEM];
  const opIsCache = typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === "string" && attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith("cache.");
  if (dbSystem && !opIsCache) {
    return descriptionForDbSystem({ attributes, name });
  }
  const rpcService = attributes[import_semantic_conventions4.SEMATTRS_RPC_SERVICE];
  if (rpcService) {
    return {
      op: "rpc",
      description: name,
      source: "route"
    };
  }
  const messagingSystem = attributes[import_semantic_conventions4.SEMATTRS_MESSAGING_SYSTEM];
  if (messagingSystem) {
    return {
      op: "message",
      description: name,
      source: "route"
    };
  }
  const faasTrigger = attributes[import_semantic_conventions4.SEMATTRS_FAAS_TRIGGER];
  if (faasTrigger) {
    return { op: faasTrigger.toString(), description: name, source: "route" };
  }
  return { op: undefined, description: name, source: "custom" };
}
function parseSpanDescription(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const name = spanHasName(span) ? span.name : "<unknown>";
  const kind = getSpanKind(span);
  return inferSpanData(name, attributes, kind);
}
function descriptionForDbSystem({ attributes, name }) {
  const statement = attributes[import_semantic_conventions4.SEMATTRS_DB_STATEMENT];
  const description = statement ? statement.toString() : name;
  return { op: "db", description, source: "task" };
}
function descriptionForHttpMethod({ name, kind, attributes }, httpMethod) {
  const opParts = ["http"];
  switch (kind) {
    case import_api20.SpanKind.CLIENT:
      opParts.push("client");
      break;
    case import_api20.SpanKind.SERVER:
      opParts.push("server");
      break;
  }
  if (attributes["sentry.http.prefetch"]) {
    opParts.push("prefetch");
  }
  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);
  if (!urlPath) {
    return { op: opParts.join("."), description: name, source: "custom" };
  }
  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];
  const baseDescription = `${httpMethod} ${urlPath}`;
  const description = graphqlOperationsAttribute ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})` : baseDescription;
  const source = hasRoute || urlPath === "/" ? "route" : "url";
  const data = {};
  if (url) {
    data.url = url;
  }
  if (query) {
    data["http.query"] = query;
  }
  if (fragment) {
    data["http.fragment"] = fragment;
  }
  const isClientOrServerKind = kind === import_api20.SpanKind.CLIENT || kind === import_api20.SpanKind.SERVER;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || "manual";
  const isManualSpan = !`${origin}`.startsWith("auto");
  const useInferredDescription = isClientOrServerKind || !isManualSpan;
  return {
    op: opParts.join("."),
    description: useInferredDescription ? description : name,
    source: useInferredDescription ? source : "custom",
    data
  };
}
function getGraphqlOperationNamesFromAttribute(attr) {
  if (Array.isArray(attr)) {
    const sorted = attr.slice().sort();
    if (sorted.length <= 5) {
      return sorted.join(", ");
    } else {
      return `${sorted.slice(0, 5).join(", ")}, +${sorted.length - 5}`;
    }
  }
  return `${attr}`;
}
function getSanitizedUrl(attributes, kind) {
  const httpTarget = attributes[import_semantic_conventions4.SEMATTRS_HTTP_TARGET];
  const httpUrl = attributes[import_semantic_conventions4.SEMATTRS_HTTP_URL] || attributes[import_semantic_conventions4.ATTR_URL_FULL];
  const httpRoute = attributes[import_semantic_conventions4.ATTR_HTTP_ROUTE];
  const parsedUrl = typeof httpUrl === "string" ? parseUrl(httpUrl) : undefined;
  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;
  const query = parsedUrl && parsedUrl.search ? parsedUrl.search : undefined;
  const fragment = parsedUrl && parsedUrl.hash ? parsedUrl.hash : undefined;
  if (typeof httpRoute === "string") {
    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };
  }
  if (kind === import_api20.SpanKind.SERVER && typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };
  }
  if (parsedUrl) {
    return { urlPath: url, url, query, fragment, hasRoute: false };
  }
  if (typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };
  }
  return { urlPath: undefined, url, query, fragment, hasRoute: false };
}
function enhanceDscWithOpenTelemetryRootSpanName(client) {
  client.on("createDsc", (dsc, rootSpan) => {
    if (rootSpan) {
      const jsonSpan = spanToJSON(rootSpan);
      const attributes = jsonSpan.data || {};
      const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };
      if (source !== "url" && description) {
        dsc.transaction = description;
      }
    }
  });
}
function makeTraceState({
  parentSpanId,
  dsc,
  sampled
}) {
  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;
  const traceStateBase = new TraceState().set(SENTRY_TRACE_STATE_PARENT_SPAN_ID, parentSpanId || "");
  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;
  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") : traceStateWithDsc;
}
function generateSpanContextForPropagationContext(propagationContext) {
  const traceState = makeTraceState({
    parentSpanId: propagationContext.parentSpanId,
    dsc: propagationContext.dsc,
    sampled: propagationContext.sampled
  });
  const spanContext = {
    traceId: propagationContext.traceId,
    spanId: propagationContext.parentSpanId || "",
    isRemote: true,
    traceFlags: propagationContext.sampled ? import_api20.TraceFlags.SAMPLED : import_api20.TraceFlags.NONE,
    traceState
  };
  return spanContext;
}
function getActiveSpan2() {
  return import_api20.trace.getActiveSpan();
}
var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
function _optionalChain$7(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function getSamplingDecision(spanContext) {
  const { traceFlags, traceState } = spanContext;
  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === "1" : false;
  if (traceFlags === import_api20.TraceFlags.SAMPLED) {
    return true;
  }
  if (sampledNotRecording) {
    return false;
  }
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;
  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;
  if (_optionalChain$7([dsc, "optionalAccess", (_) => _.sampled]) === "true") {
    return true;
  }
  if (_optionalChain$7([dsc, "optionalAccess", (_2) => _2.sampled]) === "false") {
    return false;
  }
  return;
}
var setupElements = new Set;
function openTelemetrySetupCheck() {
  return Array.from(setupElements);
}
function setIsSetup(element) {
  setupElements.add(element);
}
function _optionalChain$6(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function getPropagationContextFromSpan(span) {
  const spanContext = span.spanContext();
  const { traceId, spanId, traceState } = spanContext;
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;
  const traceStateDsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;
  const parentSpanId = traceState ? traceState.get(SENTRY_TRACE_STATE_PARENT_SPAN_ID) || undefined : undefined;
  const sampled = getSamplingDecision(spanContext);
  const dsc = traceStateDsc || getDynamicSamplingContextFromSpan(getRootSpan(span));
  return {
    traceId,
    spanId,
    sampled,
    parentSpanId,
    dsc
  };
}

class SentryPropagator extends W3CBaggagePropagator {
  constructor() {
    super();
    setIsSetup("SentryPropagator");
    this._urlMatchesTargetsMap = new LRUMap(100);
  }
  inject(context6, carrier, setter) {
    if (isTracingSuppressed(context6)) {
      DEBUG_BUILD3 && logger.log("[Tracing] Not injecting trace data for url because tracing is suppressed.");
      return;
    }
    const activeSpan = import_api20.trace.getSpan(context6);
    const url = activeSpan && getCurrentURL(activeSpan);
    const tracePropagationTargets = _optionalChain$6([getClient, "call", (_) => _(), "optionalAccess", (_2) => _2.getOptions, "call", (_3) => _3(), "optionalAccess", (_4) => _4.tracePropagationTargets]);
    if (typeof url === "string" && tracePropagationTargets && !this._shouldInjectTraceData(tracePropagationTargets, url)) {
      DEBUG_BUILD3 && logger.log("[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:", url);
      return;
    }
    const existingBaggageHeader = getExistingBaggage(carrier);
    let baggage = import_api20.propagation.getBaggage(context6) || import_api20.propagation.createBaggage({});
    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context6);
    if (existingBaggageHeader) {
      const baggageEntries = parseBaggageHeader(existingBaggageHeader);
      if (baggageEntries) {
        Object.entries(baggageEntries).forEach(([key, value]) => {
          baggage = baggage.setEntry(key, { value });
        });
      }
    }
    if (dynamicSamplingContext) {
      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {
        if (dscValue) {
          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });
        }
        return b;
      }, baggage);
    }
    if (traceId && traceId !== import_api20.INVALID_TRACEID) {
      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));
    }
    super.inject(import_api20.propagation.setBaggage(context6, baggage), carrier, setter);
  }
  extract(context6, carrier, getter) {
    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);
    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);
    const sentryTrace = maybeSentryTraceHeader ? Array.isArray(maybeSentryTraceHeader) ? maybeSentryTraceHeader[0] : maybeSentryTraceHeader : undefined;
    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
    const ctxWithSpanContext = getContextWithRemoteActiveSpan(context6, { sentryTrace, baggage });
    const scopes = getScopesFromContext(ctxWithSpanContext);
    const newScopes = {
      scope: scopes ? scopes.scope.clone() : getCurrentScope().clone(),
      isolationScope: scopes ? scopes.isolationScope : getIsolationScope()
    };
    newScopes.scope.setPropagationContext(propagationContext);
    return setScopesOnContext(ctxWithSpanContext, newScopes);
  }
  fields() {
    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];
  }
  _shouldInjectTraceData(tracePropagationTargets, url) {
    if (tracePropagationTargets === undefined) {
      return true;
    }
    const cachedDecision = this._urlMatchesTargetsMap.get(url);
    if (cachedDecision !== undefined) {
      return cachedDecision;
    }
    const decision = stringMatchesSomePattern(url, tracePropagationTargets);
    this._urlMatchesTargetsMap.set(url, decision);
    return decision;
  }
}
function getInjectionData(context6) {
  const span = import_api20.trace.getSpan(context6);
  const spanIsRemote = _optionalChain$6([span, "optionalAccess", (_5) => _5.spanContext, "call", (_6) => _6(), "access", (_7) => _7.isRemote]);
  if (span && !spanIsRemote) {
    const spanContext = span.spanContext();
    const propagationContext2 = getPropagationContextFromSpan(span);
    const dynamicSamplingContext2 = getDynamicSamplingContext(propagationContext2, spanContext.traceId);
    return {
      dynamicSamplingContext: dynamicSamplingContext2,
      traceId: spanContext.traceId,
      spanId: spanContext.spanId,
      sampled: getSamplingDecision(spanContext)
    };
  }
  const scope = _optionalChain$6([getScopesFromContext, "call", (_8) => _8(context6), "optionalAccess", (_9) => _9.scope]) || getCurrentScope();
  const propagationContext = scope.getPropagationContext();
  const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, propagationContext.traceId);
  return {
    dynamicSamplingContext,
    traceId: propagationContext.traceId,
    spanId: propagationContext.spanId,
    sampled: propagationContext.sampled
  };
}
function getDynamicSamplingContext(propagationContext, traceId) {
  if (_optionalChain$6([propagationContext, "optionalAccess", (_10) => _10.dsc])) {
    return propagationContext.dsc;
  }
  const client = getClient();
  if (client) {
    return getDynamicSamplingContextFromClient(traceId || propagationContext.traceId, client);
  }
  return;
}
function getContextWithRemoteActiveSpan(ctx, { sentryTrace, baggage }) {
  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
  const spanContext = generateSpanContextForPropagationContext(propagationContext);
  return import_api20.trace.setSpanContext(ctx, spanContext);
}
function getExistingBaggage(carrier) {
  try {
    const baggage = carrier[SENTRY_BAGGAGE_HEADER];
    return Array.isArray(baggage) ? baggage.join(",") : baggage;
  } catch (e) {
    return;
  }
}
function getCurrentURL(span) {
  const spanData = spanToJSON(span).data;
  const urlAttribute = _optionalChain$6([spanData, "optionalAccess", (_11) => _11[import_semantic_conventions4.SEMATTRS_HTTP_URL]]) || _optionalChain$6([spanData, "optionalAccess", (_12) => _12[import_semantic_conventions4.ATTR_URL_FULL]]);
  if (urlAttribute) {
    return urlAttribute;
  }
  const urlTraceState = _optionalChain$6([span, "access", (_13) => _13.spanContext, "call", (_14) => _14(), "access", (_15) => _15.traceState, "optionalAccess", (_16) => _16.get, "call", (_17) => _17(SENTRY_TRACE_STATE_URL)]);
  if (urlTraceState) {
    return urlTraceState;
  }
  return;
}
function _optionalChain$5(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function startSpan2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api20.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? suppressTracing2(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(() => callback(span), () => {
        if (spanToJSON(span).status === undefined) {
          span.setStatus({ code: import_api20.SpanStatusCode.ERROR });
        }
      }, () => span.end());
    });
  });
}
function startSpanManual2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api20.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? suppressTracing2(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(() => callback(span, () => span.end()), () => {
        if (spanToJSON(span).status === undefined) {
          span.setStatus({ code: import_api20.SpanStatusCode.ERROR });
        }
      });
    });
  });
}
function startInactiveSpan2(options) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api20.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? suppressTracing2(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    const span = tracer.startSpan(name, spanOptions, ctx);
    return span;
  });
}
function withActiveSpan2(span, callback) {
  const newContextWithActiveSpan = span ? import_api20.trace.setSpan(import_api20.context.active(), span) : import_api20.trace.deleteSpan(import_api20.context.active());
  return import_api20.context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));
}
function getTracer() {
  const client = getClient();
  return client && client.tracer || import_api20.trace.getTracer("@sentry/opentelemetry", SDK_VERSION);
}
function getSpanOptions(options) {
  const { startTime, attributes, kind, op } = options;
  const fixedStartTime = typeof startTime === "number" ? ensureTimestampInMilliseconds(startTime) : startTime;
  return {
    attributes: op ? {
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
      ...attributes
    } : attributes,
    kind,
    startTime: fixedStartTime
  };
}
function ensureTimestampInMilliseconds(timestamp) {
  const isMs = timestamp < 9999999999;
  return isMs ? timestamp * 1000 : timestamp;
}
function getContext(scope, forceTransaction) {
  const ctx = getContextForScope(scope);
  const actualScope = _optionalChain$5([getScopesFromContext, "call", (_) => _(ctx), "optionalAccess", (_2) => _2.scope]);
  const parentSpan = import_api20.trace.getSpan(ctx);
  if (!parentSpan) {
    const client = getClient();
    if (actualScope && client) {
      const propagationContext = actualScope.getPropagationContext();
      const traceState2 = makeTraceState({
        parentSpanId: propagationContext.parentSpanId,
        dsc: undefined,
        sampled: propagationContext.sampled
      });
      const spanOptions2 = {
        traceId: propagationContext.traceId,
        spanId: propagationContext.parentSpanId || propagationContext.spanId,
        isRemote: true,
        traceFlags: propagationContext.sampled ? import_api20.TraceFlags.SAMPLED : import_api20.TraceFlags.NONE,
        traceState: traceState2
      };
      return import_api20.trace.setSpanContext(ctx, spanOptions2);
    }
    return ctx;
  }
  if (!forceTransaction) {
    return ctx;
  }
  const ctxWithoutSpan = import_api20.trace.deleteSpan(ctx);
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = getSamplingDecision(parentSpan.spanContext());
  const rootSpan = getRootSpan(parentSpan);
  const dsc = getDynamicSamplingContextFromSpan(rootSpan);
  const traceState = makeTraceState({
    dsc,
    parentSpanId: spanId !== import_api20.INVALID_SPANID ? spanId : undefined,
    sampled
  });
  const spanOptions = {
    traceId,
    spanId,
    isRemote: true,
    traceFlags: sampled ? import_api20.TraceFlags.SAMPLED : import_api20.TraceFlags.NONE,
    traceState
  };
  const ctxWithSpanContext = import_api20.trace.setSpanContext(ctxWithoutSpan, spanOptions);
  return ctxWithSpanContext;
}
function getContextForScope(scope) {
  if (scope) {
    const ctx = getContextFromScope(scope);
    if (ctx) {
      return ctx;
    }
  }
  return import_api20.context.active();
}
function getActiveSpanWrapper2(parentSpan) {
  return parentSpan !== undefined ? (callback) => {
    return withActiveSpan2(parentSpan, callback);
  } : (callback) => callback();
}
function suppressTracing3(callback) {
  const ctx = suppressTracing2(import_api20.context.active());
  return import_api20.context.with(ctx, callback);
}
function _optionalChain$4(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function setupEventContextTrace(client) {
  client.on("preprocessEvent", (event) => {
    const span = getActiveSpan2();
    if (!span || event.type === "transaction") {
      return;
    }
    const spanContext = span.spanContext();
    const parentSpanIdFromTraceState = _optionalChain$4([spanContext, "access", (_) => _.traceState, "optionalAccess", (_2) => _2.get, "call", (_3) => _3(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);
    const parent_span_id = typeof parentSpanIdFromTraceState === "string" ? parentSpanIdFromTraceState || undefined : spanHasParentId(span) ? span.parentSpanId : undefined;
    event.contexts = {
      trace: dropUndefinedKeys({
        trace_id: spanContext.traceId,
        span_id: spanContext.spanId,
        parent_span_id
      }),
      ...event.contexts
    };
    const rootSpan = getRootSpan(span);
    event.sdkProcessingMetadata = {
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),
      ...event.sdkProcessingMetadata
    };
    return event;
  });
}
function getTraceData() {
  const headersObject = {};
  api2.propagation.inject(api2.context.active(), headersObject);
  if (!headersObject["sentry-trace"]) {
    return {};
  }
  return dropUndefinedKeys({
    "sentry-trace": headersObject["sentry-trace"],
    baggage: headersObject.baggage
  });
}
function setOpenTelemetryContextAsyncContextStrategy() {
  function getScopes() {
    const ctx = api2.context.active();
    const scopes = getScopesFromContext(ctx);
    if (scopes) {
      return scopes;
    }
    return {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  function withScope3(callback) {
    const ctx = api2.context.active();
    return api2.context.with(ctx, () => {
      return callback(getCurrentScope2());
    });
  }
  function withSetScope2(scope, callback) {
    const ctx = api2.context.active();
    return api2.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {
      return callback(scope);
    });
  }
  function withIsolationScope3(callback) {
    const ctx = api2.context.active();
    return api2.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {
      return callback(getIsolationScope2());
    });
  }
  function withSetIsolationScope(isolationScope, callback) {
    const ctx = api2.context.active();
    return api2.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {
      return callback(getIsolationScope2());
    });
  }
  function getCurrentScope2() {
    return getScopes().scope;
  }
  function getIsolationScope2() {
    return getScopes().isolationScope;
  }
  setAsyncContextStrategy({
    withScope: withScope3,
    withSetScope: withSetScope2,
    withSetIsolationScope,
    withIsolationScope: withIsolationScope3,
    getCurrentScope: getCurrentScope2,
    getIsolationScope: getIsolationScope2,
    startSpan: startSpan2,
    startSpanManual: startSpanManual2,
    startInactiveSpan: startInactiveSpan2,
    getActiveSpan: getActiveSpan2,
    suppressTracing: suppressTracing3,
    getTraceData,
    withActiveSpan: withActiveSpan2
  });
}
function _optionalChain$3(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function wrapContextManagerClass(ContextManagerClass) {

  class SentryContextManager extends ContextManagerClass {
    constructor(...args) {
      super(...args);
      setIsSetup("SentryContextManager");
    }
    with(context6, fn, thisArg, ...args) {
      const currentScopes = getScopesFromContext(context6);
      const currentScope = _optionalChain$3([currentScopes, "optionalAccess", (_) => _.scope]) || getCurrentScope();
      const currentIsolationScope = _optionalChain$3([currentScopes, "optionalAccess", (_2) => _2.isolationScope]) || getIsolationScope();
      const shouldForkIsolationScope = context6.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;
      const scope = context6.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY);
      const isolationScope = context6.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      const newCurrentScope = scope || currentScope.clone();
      const newIsolationScope = isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);
      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };
      const ctx1 = setScopesOnContext(context6, scopes);
      const ctx2 = ctx1.deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      setContextOnScope(newCurrentScope, ctx2);
      return super.with(ctx2, fn, thisArg, ...args);
    }
  }
  return SentryContextManager;
}
function groupSpansWithParents(spans) {
  const nodeMap = new Map;
  for (const span of spans) {
    createOrUpdateSpanNodeAndRefs(nodeMap, span);
  }
  return Array.from(nodeMap, function([_id, spanNode]) {
    return spanNode;
  });
}
function getLocalParentId(span) {
  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;
  return !parentIsRemote ? span.parentSpanId : undefined;
}
function createOrUpdateSpanNodeAndRefs(nodeMap, span) {
  const id = span.spanContext().spanId;
  const parentId = getLocalParentId(span);
  if (!parentId) {
    createOrUpdateNode(nodeMap, { id, span, children: [] });
    return;
  }
  const parentNode = createOrGetParentNode(nodeMap, parentId);
  const node2 = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });
  parentNode.children.push(node2);
}
function createOrGetParentNode(nodeMap, id) {
  const existing = nodeMap.get(id);
  if (existing) {
    return existing;
  }
  return createOrUpdateNode(nodeMap, { id, children: [] });
}
function createOrUpdateNode(nodeMap, spanNode) {
  const existing = nodeMap.get(spanNode.id);
  if (existing && existing.span) {
    return existing;
  }
  if (existing && !existing.span) {
    existing.span = spanNode.span;
    existing.parentNode = spanNode.parentNode;
    return existing;
  }
  nodeMap.set(spanNode.id, spanNode);
  return spanNode;
}
var canonicalGrpcErrorCodesMap = {
  "1": "cancelled",
  "2": "unknown_error",
  "3": "invalid_argument",
  "4": "deadline_exceeded",
  "5": "not_found",
  "6": "already_exists",
  "7": "permission_denied",
  "8": "resource_exhausted",
  "9": "failed_precondition",
  "10": "aborted",
  "11": "out_of_range",
  "12": "unimplemented",
  "13": "internal_error",
  "14": "unavailable",
  "15": "data_loss",
  "16": "unauthenticated"
};
var isStatusErrorMessageValid = (message) => {
  return Object.values(canonicalGrpcErrorCodesMap).includes(message);
};
function mapStatus(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const status = spanHasStatus(span) ? span.status : undefined;
  if (status) {
    if (status.code === import_api20.SpanStatusCode.OK) {
      return { code: SPAN_STATUS_OK };
    } else if (status.code === import_api20.SpanStatusCode.ERROR) {
      if (typeof status.message === "undefined") {
        const inferredStatus2 = inferStatusFromAttributes(attributes);
        if (inferredStatus2) {
          return inferredStatus2;
        }
      }
      if (status.message && isStatusErrorMessageValid(status.message)) {
        return { code: SPAN_STATUS_ERROR, message: status.message };
      } else {
        return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
      }
    }
  }
  const inferredStatus = inferStatusFromAttributes(attributes);
  if (inferredStatus) {
    return inferredStatus;
  }
  if (status && status.code === import_api20.SpanStatusCode.UNSET) {
    return { code: SPAN_STATUS_OK };
  } else {
    return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
  }
}
function inferStatusFromAttributes(attributes) {
  const httpCodeAttribute = attributes[import_semantic_conventions4.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[import_semantic_conventions4.SEMATTRS_HTTP_STATUS_CODE];
  const grpcCodeAttribute = attributes[import_semantic_conventions4.SEMATTRS_RPC_GRPC_STATUS_CODE];
  const numberHttpCode = typeof httpCodeAttribute === "number" ? httpCodeAttribute : typeof httpCodeAttribute === "string" ? parseInt(httpCodeAttribute) : undefined;
  if (typeof numberHttpCode === "number") {
    return getSpanStatusFromHttpCode(numberHttpCode);
  }
  if (typeof grpcCodeAttribute === "string") {
    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || "unknown_error" };
  }
  return;
}
function _optionalChain$2(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
var MAX_SPAN_COUNT2 = 1000;
var DEFAULT_TIMEOUT = 300;

class SentrySpanExporter {
  constructor(options) {
    this._finishedSpans = [];
    this._timeout = _optionalChain$2([options, "optionalAccess", (_) => _.timeout]) || DEFAULT_TIMEOUT;
  }
  export(span) {
    this._finishedSpans.push(span);
    if (getLocalParentId(span)) {
      const openSpanCount = this._finishedSpans.length;
      DEBUG_BUILD3 && logger.log(`SpanExporter has ${openSpanCount} unsent spans remaining`);
      this._cleanupOldSpans();
      return;
    }
    this._clearTimeout();
    this._flushTimeout = setTimeout(() => {
      this.flush();
    }, 1);
  }
  flush() {
    this._clearTimeout();
    const openSpanCount = this._finishedSpans.length;
    const remainingSpans = maybeSend(this._finishedSpans);
    const remainingOpenSpanCount = remainingSpans.length;
    const sentSpanCount = openSpanCount - remainingOpenSpanCount;
    DEBUG_BUILD3 && logger.log(`SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} unsent spans remaining`);
    this._cleanupOldSpans(remainingSpans);
  }
  clear() {
    this._finishedSpans = [];
    this._clearTimeout();
  }
  _clearTimeout() {
    if (this._flushTimeout) {
      clearTimeout(this._flushTimeout);
      this._flushTimeout = undefined;
    }
  }
  _cleanupOldSpans(spans = this._finishedSpans) {
    this._finishedSpans = spans.filter((span) => {
      const shouldDrop = shouldCleanupSpan(span, this._timeout);
      DEBUG_BUILD3 && shouldDrop && logger.log(`SpanExporter dropping span ${span.name} (${span.spanContext().spanId}) because it is pending for more than 5 minutes.`);
      return !shouldDrop;
    });
  }
}
function maybeSend(spans) {
  const grouped = groupSpansWithParents(spans);
  const remaining = new Set(grouped);
  const rootNodes = getCompletedRootNodes(grouped);
  rootNodes.forEach((root) => {
    remaining.delete(root);
    const span = root.span;
    const transactionEvent = createTransactionForOtelSpan(span);
    const spans2 = transactionEvent.spans || [];
    root.children.forEach((child) => {
      createAndFinishSpanForOtelSpan(child, spans2, remaining);
    });
    transactionEvent.spans = spans2.length > MAX_SPAN_COUNT2 ? spans2.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT2) : spans2;
    const measurements = timedEventsToMeasurements(span.events);
    if (measurements) {
      transactionEvent.measurements = measurements;
    }
    captureEvent(transactionEvent);
  });
  return Array.from(remaining).map((node2) => node2.span).filter((span) => !!span);
}
function nodeIsCompletedRootNode(node2) {
  return !!node2.span && !node2.parentNode;
}
function getCompletedRootNodes(nodes) {
  return nodes.filter(nodeIsCompletedRootNode);
}
function shouldCleanupSpan(span, maxStartTimeOffsetSeconds) {
  const cutoff = Date.now() / 1000 - maxStartTimeOffsetSeconds;
  return spanTimeInputToSeconds(span.startTime) < cutoff;
}
function parseSpan(span) {
  const attributes = span.attributes;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  return { origin, op, source };
}
function createTransactionForOtelSpan(span) {
  const { op, description, data, origin = "manual", source } = getSpanData(span);
  const capturedSpanScopes = getCapturedScopesOnSpan(span);
  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  const attributes = dropUndefinedKeys({
    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    ...data,
    ...removeSentryAttributes(span.attributes)
  });
  const { traceId: trace_id, spanId: span_id } = span.spanContext();
  const parentSpanIdFromTraceState = _optionalChain$2([span, "access", (_2) => _2.spanContext, "call", (_3) => _3(), "access", (_4) => _4.traceState, "optionalAccess", (_5) => _5.get, "call", (_6) => _6(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);
  const parent_span_id = typeof parentSpanIdFromTraceState === "string" ? parentSpanIdFromTraceState || undefined : span.parentSpanId;
  const status = mapStatus(span);
  const traceContext = dropUndefinedKeys({
    parent_span_id,
    span_id,
    trace_id,
    data: attributes,
    origin,
    op,
    status: getStatusMessage(status)
  });
  const transactionEvent = {
    contexts: {
      trace: traceContext,
      otel: {
        resource: span.resource.attributes
      }
    },
    spans: [],
    start_timestamp: spanTimeInputToSeconds(span.startTime),
    timestamp: spanTimeInputToSeconds(span.endTime),
    transaction: description,
    type: "transaction",
    sdkProcessingMetadata: {
      ...dropUndefinedKeys({
        capturedSpanScope: capturedSpanScopes.scope,
        capturedSpanIsolationScope: capturedSpanScopes.isolationScope,
        sampleRate,
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span)
      })
    },
    ...source && {
      transaction_info: {
        source
      }
    },
    _metrics_summary: getMetricSummaryJsonForSpan(span)
  };
  return transactionEvent;
}
function createAndFinishSpanForOtelSpan(node2, spans, remaining) {
  remaining.delete(node2);
  const span = node2.span;
  const shouldDrop = !span;
  if (shouldDrop) {
    node2.children.forEach((child) => {
      createAndFinishSpanForOtelSpan(child, spans, remaining);
    });
    return;
  }
  const span_id = span.spanContext().spanId;
  const trace_id = span.spanContext().traceId;
  const { attributes, startTime, endTime, parentSpanId } = span;
  const { op, description, data, origin = "manual" } = getSpanData(span);
  const allData = dropUndefinedKeys({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    ...removeSentryAttributes(attributes),
    ...data
  });
  const status = mapStatus(span);
  const spanJSON = dropUndefinedKeys({
    span_id,
    trace_id,
    data: allData,
    description,
    parent_span_id: parentSpanId,
    start_timestamp: spanTimeInputToSeconds(startTime),
    timestamp: spanTimeInputToSeconds(endTime) || undefined,
    status: getStatusMessage(status),
    op,
    origin,
    _metrics_summary: getMetricSummaryJsonForSpan(span),
    measurements: timedEventsToMeasurements(span.events)
  });
  spans.push(spanJSON);
  node2.children.forEach((child) => {
    createAndFinishSpanForOtelSpan(child, spans, remaining);
  });
}
function getSpanData(span) {
  const { op: definedOp, source: definedSource, origin } = parseSpan(span);
  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);
  const op = definedOp || inferredOp;
  const source = definedSource || inferredSource;
  const data = { ...inferredData, ...getData(span) };
  return {
    op,
    description,
    source,
    origin,
    data
  };
}
function removeSentryAttributes(data) {
  const cleanedData = { ...data };
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];
  delete cleanedData["sentry.skip_span_data_inference"];
  return cleanedData;
}
function getData(span) {
  const attributes = span.attributes;
  const data = {};
  if (span.kind !== import_api20.SpanKind.INTERNAL) {
    data["otel.kind"] = import_api20.SpanKind[span.kind];
  }
  const maybeHttpStatusCodeAttribute = attributes[import_semantic_conventions4.SEMATTRS_HTTP_STATUS_CODE];
  if (maybeHttpStatusCodeAttribute) {
    data[import_semantic_conventions4.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute;
  }
  const requestData = getRequestSpanData(span);
  if (requestData.url) {
    data.url = requestData.url;
  }
  if (requestData["http.query"]) {
    data["http.query"] = requestData["http.query"].slice(1);
  }
  if (requestData["http.fragment"]) {
    data["http.fragment"] = requestData["http.fragment"].slice(1);
  }
  return data;
}
function _optionalChain$1(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
function onSpanStart(span, parentContext) {
  const parentSpan = import_api20.trace.getSpan(parentContext);
  let scopes = getScopesFromContext(parentContext);
  if (parentSpan && !parentSpan.spanContext().isRemote) {
    addChildSpanToSpan(parentSpan, span);
  }
  if (parentSpan && parentSpan.spanContext().isRemote) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);
  }
  if (parentContext === import_api20.ROOT_CONTEXT) {
    scopes = {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  if (scopes) {
    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);
  }
  logSpanStart(span);
  const client = getClient();
  _optionalChain$1([client, "optionalAccess", (_) => _.emit, "call", (_2) => _2("spanStart", span)]);
}
function onSpanEnd(span) {
  logSpanEnd(span);
  const client = getClient();
  _optionalChain$1([client, "optionalAccess", (_3) => _3.emit, "call", (_4) => _4("spanEnd", span)]);
}

class SentrySpanProcessor {
  constructor(options) {
    setIsSetup("SentrySpanProcessor");
    this._exporter = new SentrySpanExporter(options);
  }
  async forceFlush() {
    this._exporter.flush();
  }
  async shutdown() {
    this._exporter.clear();
  }
  onStart(span, parentContext) {
    onSpanStart(span, parentContext);
  }
  onEnd(span) {
    onSpanEnd(span);
    this._exporter.export(span);
  }
}

class SentrySampler {
  constructor(client) {
    this._client = client;
    setIsSetup("SentrySampler");
  }
  shouldSample(context6, traceId, spanName, spanKind, spanAttributes, _links) {
    const options = this._client.getOptions();
    const parentSpan = import_api20.trace.getSpan(context6);
    const parentContext = _optionalChain([parentSpan, "optionalAccess", (_) => _.spanContext, "call", (_2) => _2()]);
    if (!hasTracingEnabled(options)) {
      return wrapSamplingDecision({ decision: undefined, context: context6, spanAttributes });
    }
    const maybeSpanHttpMethod = spanAttributes[import_semantic_conventions4.SEMATTRS_HTTP_METHOD] || spanAttributes[import_semantic_conventions4.ATTR_HTTP_REQUEST_METHOD];
    if (spanKind === import_api20.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || _optionalChain([parentContext, "optionalAccess", (_3) => _3.isRemote]))) {
      return wrapSamplingDecision({ decision: undefined, context: context6, spanAttributes });
    }
    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;
    const {
      description: inferredSpanName,
      data: inferredAttributes,
      op
    } = inferSpanData(spanName, spanAttributes, spanKind);
    const mergedAttributes = {
      ...inferredAttributes,
      ...spanAttributes
    };
    if (op) {
      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;
    }
    const mutableSamplingDecision = { decision: true };
    this._client.emit("beforeSampling", {
      spanAttributes: mergedAttributes,
      spanName: inferredSpanName,
      parentSampled,
      parentContext
    }, mutableSamplingDecision);
    if (!mutableSamplingDecision.decision) {
      return wrapSamplingDecision({ decision: undefined, context: context6, spanAttributes });
    }
    const [sampled, sampleRate] = sampleSpan(options, {
      name: inferredSpanName,
      attributes: mergedAttributes,
      transactionContext: {
        name: inferredSpanName,
        parentSampled
      },
      parentSampled
    });
    const attributes = {
      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate
    };
    const method = `${maybeSpanHttpMethod}`.toUpperCase();
    if (method === "OPTIONS" || method === "HEAD") {
      DEBUG_BUILD3 && logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);
      return {
        ...wrapSamplingDecision({ decision: SamplingDecision.NOT_RECORD, context: context6, spanAttributes }),
        attributes
      };
    }
    if (!sampled) {
      return {
        ...wrapSamplingDecision({ decision: SamplingDecision.NOT_RECORD, context: context6, spanAttributes }),
        attributes
      };
    }
    return {
      ...wrapSamplingDecision({ decision: SamplingDecision.RECORD_AND_SAMPLED, context: context6, spanAttributes }),
      attributes
    };
  }
  toString() {
    return "SentrySampler";
  }
}
function getParentRemoteSampled(parentSpan) {
  const traceId = parentSpan.spanContext().traceId;
  const traceparentData = getPropagationContextFromSpan(parentSpan);
  return traceparentData && traceId === traceparentData.traceId ? traceparentData.sampled : undefined;
}
function getParentSampled(parentSpan, traceId, spanName) {
  const parentContext = parentSpan.spanContext();
  if (import_api20.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {
    if (parentContext.isRemote) {
      const parentSampled2 = getParentRemoteSampled(parentSpan);
      DEBUG_BUILD3 && logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled2}`);
      return parentSampled2;
    }
    const parentSampled = getSamplingDecision(parentContext);
    DEBUG_BUILD3 && logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);
    return parentSampled;
  }
  return;
}
function wrapSamplingDecision({
  decision,
  context: context6,
  spanAttributes
}) {
  const traceState = getBaseTraceState(context6, spanAttributes);
  if (decision == undefined) {
    return { decision: SamplingDecision.NOT_RECORD, traceState };
  }
  if (decision === SamplingDecision.NOT_RECORD) {
    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") };
  }
  return { decision, traceState };
}
function getBaseTraceState(context6, spanAttributes) {
  const parentSpan = import_api20.trace.getSpan(context6);
  const parentContext = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.spanContext, "call", (_5) => _5()]);
  let traceState = _optionalChain([parentContext, "optionalAccess", (_6) => _6.traceState]) || new TraceState;
  const url = spanAttributes[import_semantic_conventions4.SEMATTRS_HTTP_URL] || spanAttributes[import_semantic_conventions4.ATTR_URL_FULL];
  if (url && typeof url === "string") {
    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);
  }
  return traceState;
}
function addOpenTelemetryInstrumentation(...instrumentations) {
  registerInstrumentations({
    instrumentations
  });
}

// ../node_modules/@sentry/node/build/esm/sdk/scope.js
var import_api21 = __toESM(require_src(), 1);
function setIsolationScope(isolationScope) {
  const scopes = getScopesFromContext(import_api21.context.active());
  if (scopes) {
    scopes.isolationScope = isolationScope;
  }
}

// ../node_modules/@sentry/node/build/esm/utils/addOriginToSpan.js
function addOriginToSpan(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}

// ../node_modules/@sentry/node/build/esm/utils/getRequestUrl.js
function getRequestUrl(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
  const path3 = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname}${port}${path3}`;
}

// ../node_modules/@sentry/node/build/esm/integrations/http.js
var INTEGRATION_NAME5 = "Http";
var INSTRUMENTATION_NAME = "@opentelemetry_sentry-patched/instrumentation-http";
var _httpOptions = {};
var _httpInstrumentation;
var instrumentHttp = Object.assign(function() {
  if (_httpInstrumentation) {
    return;
  }
  const _InstrumentationClass = _httpOptions._instrumentation || import_instrumentation_http.HttpInstrumentation;
  _httpInstrumentation = new _InstrumentationClass({
    ..._optionalChain([_httpOptions, "access", (_) => _.instrumentation, "optionalAccess", (_2) => _2._experimentalConfig]),
    ignoreOutgoingRequestHook: (request) => {
      const url = getRequestUrl(request);
      if (!url) {
        return false;
      }
      const _ignoreOutgoingRequests = _httpOptions.ignoreOutgoingRequests;
      if (_ignoreOutgoingRequests && _ignoreOutgoingRequests(url, request)) {
        return true;
      }
      return false;
    },
    ignoreIncomingRequestHook: (request) => {
      const urlPath = request.url;
      const method = _optionalChain([request, "access", (_3) => _3.method, "optionalAccess", (_4) => _4.toUpperCase, "call", (_5) => _5()]);
      if (method === "OPTIONS" || method === "HEAD") {
        return true;
      }
      const _ignoreIncomingRequests = _httpOptions.ignoreIncomingRequests;
      if (urlPath && _ignoreIncomingRequests && _ignoreIncomingRequests(urlPath, request)) {
        return true;
      }
      return false;
    },
    requireParentforOutgoingSpans: false,
    requireParentforIncomingSpans: false,
    requestHook: (span, req) => {
      addOriginToSpan(span, "auto.http.otel.http");
      if (_isClientRequest(req)) {
        _optionalChain([_httpOptions, "access", (_6) => _6.instrumentation, "optionalAccess", (_7) => _7.requestHook, "optionalCall", (_8) => _8(span, req)]);
        return;
      }
      const scopes = getCapturedScopesOnSpan(span);
      const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();
      const scope = scopes.scope || getCurrentScope();
      isolationScope.setSDKProcessingMetadata({ request: req });
      const client = getClient();
      if (client && client.getOptions().autoSessionTracking) {
        isolationScope.setRequestSession({ status: "ok" });
      }
      setIsolationScope(isolationScope);
      setCapturedScopesOnSpan(span, scope, isolationScope);
      const httpMethod = (req.method || "GET").toUpperCase();
      const httpTarget = stripUrlQueryAndFragment(req.url || "/");
      const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;
      isolationScope.setTransactionName(bestEffortTransactionName);
      if (isKnownPrefetchRequest(req)) {
        span.setAttribute("sentry.http.prefetch", true);
      }
      _optionalChain([_httpOptions, "access", (_9) => _9.instrumentation, "optionalAccess", (_10) => _10.requestHook, "optionalCall", (_11) => _11(span, req)]);
    },
    responseHook: (span, res) => {
      const client = getClient();
      if (client && client.getOptions().autoSessionTracking) {
        setImmediate(() => {
          client["_captureRequestSession"]();
        });
      }
      _optionalChain([_httpOptions, "access", (_12) => _12.instrumentation, "optionalAccess", (_13) => _13.responseHook, "optionalCall", (_14) => _14(span, res)]);
    },
    applyCustomAttributesOnSpan: (span, request, response) => {
      const _breadcrumbs = typeof _httpOptions.breadcrumbs === "undefined" ? true : _httpOptions.breadcrumbs;
      if (_breadcrumbs) {
        _addRequestBreadcrumb(request, response);
      }
      _optionalChain([_httpOptions, "access", (_15) => _15.instrumentation, "optionalAccess", (_16) => _16.applyCustomAttributesOnSpan, "optionalCall", (_17) => _17(span, request, response)]);
    }
  });
  try {
    _httpInstrumentation["_diag"] = import_api22.diag.createComponentLogger({
      namespace: INSTRUMENTATION_NAME
    });
    _httpInstrumentation.instrumentationName = INSTRUMENTATION_NAME;
  } catch (e) {
  }
  addOpenTelemetryInstrumentation(_httpInstrumentation);
}, {
  id: INTEGRATION_NAME5
});
var _httpIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME5,
    setupOnce() {
      _httpOptions = options;
      instrumentHttp();
    }
  };
};
var httpIntegration = defineIntegration(_httpIntegration);
function _addRequestBreadcrumb(request, response) {
  if (!_isClientRequest(request)) {
    return;
  }
  const data = getBreadcrumbData(request);
  const statusCode = response.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb({
    category: "http",
    data: {
      status_code: statusCode,
      ...data
    },
    type: "http",
    level
  }, {
    event: "response",
    request,
    response
  });
}
function getBreadcrumbData(request) {
  try {
    const host = request.getHeader("host") || request.host;
    const url = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch (e2) {
    return {};
  }
}
function _isClientRequest(req) {
  return "outputData" in req && "outputSize" in req && !("client" in req) && !("statusCode" in req);
}
function isKnownPrefetchRequest(req) {
  return req.headers["next-router-prefetch"] === "1";
}
// ../node_modules/@sentry/node/build/esm/integrations/node-fetch.js
var import_api23 = __toESM(require_src(), 1);
var import_instrumentation_undici = __toESM(require_src8(), 1);
var _nativeNodeFetchIntegration = (options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
  return {
    name: "NodeFetch",
    setupOnce() {
      const instrumentation = new import_instrumentation_undici.UndiciInstrumentation({
        requireParentforSpans: false,
        ignoreRequestHook: (request) => {
          const url = getAbsoluteUrl(request.origin, request.path);
          const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);
          if (shouldIgnore) {
            return true;
          }
          if (!hasTracingEnabled()) {
            const ctx = import_api23.context.active();
            const addedHeaders = {};
            const activeSpan = import_api23.trace.getSpan(ctx);
            const propagationContext = activeSpan ? getPropagationContextFromSpan(activeSpan) : getCurrentScope().getPropagationContext();
            const spanContext = generateSpanContextForPropagationContext(propagationContext);
            spanContext.traceState = _optionalChain([spanContext, "access", (_2) => _2.traceState, "optionalAccess", (_3) => _3.set, "call", (_4) => _4("sentry.url", url)]);
            const ctxWithUrlTraceState = import_api23.trace.setSpanContext(ctx, spanContext);
            import_api23.propagation.inject(ctxWithUrlTraceState, addedHeaders);
            const requestHeaders = request.headers;
            if (Array.isArray(requestHeaders)) {
              Object.entries(addedHeaders).forEach((headers) => requestHeaders.push(...headers));
            } else {
              request.headers += Object.entries(addedHeaders).map(([k, v]) => `${k}: ${v}\r\n`).join("");
            }
            return true;
          }
          return false;
        },
        startSpanHook: () => {
          return {
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.node_fetch"
          };
        },
        responseHook: (_, { request, response }) => {
          if (_breadcrumbs) {
            addRequestBreadcrumb(request, response);
          }
        }
      });
      addOpenTelemetryInstrumentation(instrumentation);
    }
  };
};
var nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);
function addRequestBreadcrumb(request, response) {
  const data = getBreadcrumbData2(request);
  const statusCode = response.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb({
    category: "http",
    data: {
      status_code: statusCode,
      ...data
    },
    type: "http",
    level
  }, {
    event: "response",
    request,
    response
  });
}
function getBreadcrumbData2(request) {
  try {
    const url = new URL(request.path, request.origin);
    const parsedUrl = parseUrl(url.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch (e) {
    return {};
  }
}
function getAbsoluteUrl(origin, path3 = "/") {
  const url = `${origin}`;
  if (url.endsWith("/") && path3.startsWith("/")) {
    return `${url}${path3.slice(1)}`;
  }
  if (!url.endsWith("/") && !path3.startsWith("/")) {
    return `${url}/${path3.slice(1)}`;
  }
  return `${url}${path3}`;
}
// ../node_modules/@sentry/node/build/esm/otel/instrument.js
var INSTRUMENTED = {};
function generateInstrumentOnce(name, creator) {
  return Object.assign((options) => {
    const instrumented2 = INSTRUMENTED[name];
    if (instrumented2) {
      if (options) {
        instrumented2.setConfig(options);
      }
      return;
    }
    const instrumentation = creator(options);
    INSTRUMENTED[name] = instrumentation;
    addOpenTelemetryInstrumentation(instrumentation);
  }, { id: name });
}

// ../node_modules/@sentry/node/build/esm/integrations/console.js
import * as util from "util";
var INTEGRATION_NAME6 = "Console";
var _consoleIntegration = () => {
  return {
    name: INTEGRATION_NAME6,
    setup(client) {
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient() !== client) {
          return;
        }
        addBreadcrumb({
          category: "console",
          level: severityLevelFromString(level),
          message: util.format.apply(undefined, args)
        }, {
          input: [...args],
          level
        });
      });
    }
  };
};
var consoleIntegration = defineIntegration(_consoleIntegration);
// ../node_modules/@sentry/node/build/esm/integrations/context.js
import { execFile } from "child_process";
import { readFile, readdir } from "fs";
import * as os from "os";
import { join as join3 } from "path";
import { promisify } from "util";
var readFileAsync = promisify(readFile);
var readDirAsync = promisify(readdir);
var INTEGRATION_NAME7 = "Context";
var _nodeContextIntegration = (options = {}) => {
  let cachedContext;
  const _options = {
    app: true,
    os: true,
    device: true,
    culture: true,
    cloudResource: true,
    ...options
  };
  async function addContext(event) {
    if (cachedContext === undefined) {
      cachedContext = _getContexts();
    }
    const updatedContext = _updateContext(await cachedContext);
    event.contexts = {
      ...event.contexts,
      app: { ...updatedContext.app, ..._optionalChain([event, "access", (_) => _.contexts, "optionalAccess", (_2) => _2.app]) },
      os: { ...updatedContext.os, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_4) => _4.os]) },
      device: { ...updatedContext.device, ..._optionalChain([event, "access", (_5) => _5.contexts, "optionalAccess", (_6) => _6.device]) },
      culture: { ...updatedContext.culture, ..._optionalChain([event, "access", (_7) => _7.contexts, "optionalAccess", (_8) => _8.culture]) },
      cloud_resource: { ...updatedContext.cloud_resource, ..._optionalChain([event, "access", (_9) => _9.contexts, "optionalAccess", (_10) => _10.cloud_resource]) }
    };
    return event;
  }
  async function _getContexts() {
    const contexts = {};
    if (_options.os) {
      contexts.os = await getOsContext();
    }
    if (_options.app) {
      contexts.app = getAppContext();
    }
    if (_options.device) {
      contexts.device = getDeviceContext(_options.device);
    }
    if (_options.culture) {
      const culture = getCultureContext();
      if (culture) {
        contexts.culture = culture;
      }
    }
    if (_options.cloudResource) {
      contexts.cloud_resource = getCloudResourceContext();
    }
    return contexts;
  }
  return {
    name: INTEGRATION_NAME7,
    processEvent(event) {
      return addContext(event);
    }
  };
};
var nodeContextIntegration = defineIntegration(_nodeContextIntegration);
function _updateContext(contexts) {
  if (_optionalChain([contexts, "optionalAccess", (_11) => _11.app, "optionalAccess", (_12) => _12.app_memory])) {
    contexts.app.app_memory = process.memoryUsage().rss;
  }
  if (_optionalChain([contexts, "optionalAccess", (_13) => _13.app, "optionalAccess", (_14) => _14.free_memory]) && typeof process.availableMemory === "function") {
    const freeMemory = _optionalChain([process, "access", (_15) => _15.availableMemory, "optionalCall", (_16) => _16()]);
    if (freeMemory != null) {
      contexts.app.free_memory = freeMemory;
    }
  }
  if (_optionalChain([contexts, "optionalAccess", (_17) => _17.device, "optionalAccess", (_18) => _18.free_memory])) {
    contexts.device.free_memory = os.freemem();
  }
  return contexts;
}
async function getOsContext() {
  const platformId = os.platform();
  switch (platformId) {
    case "darwin":
      return getDarwinInfo();
    case "linux":
      return getLinuxInfo();
    default:
      return {
        name: PLATFORM_NAMES[platformId] || platformId,
        version: os.release()
      };
  }
}
function getCultureContext() {
  try {
    if (typeof process.versions.icu !== "string") {
      return;
    }
    const january = new Date(900000000);
    const spanish = new Intl.DateTimeFormat("es", { month: "long" });
    if (spanish.format(january) === "enero") {
      const options = Intl.DateTimeFormat().resolvedOptions();
      return {
        locale: options.locale,
        timezone: options.timeZone
      };
    }
  } catch (err) {
  }
  return;
}
function getAppContext() {
  const app_memory = process.memoryUsage().rss;
  const app_start_time = new Date(Date.now() - process.uptime() * 1000).toISOString();
  const appContext = { app_start_time, app_memory };
  if (typeof process.availableMemory === "function") {
    const freeMemory = _optionalChain([process, "access", (_19) => _19.availableMemory, "optionalCall", (_20) => _20()]);
    if (freeMemory != null) {
      appContext.free_memory = freeMemory;
    }
  }
  return appContext;
}
function getDeviceContext(deviceOpt) {
  const device = {};
  let uptime2;
  try {
    uptime2 = os.uptime && os.uptime();
  } catch (e) {
  }
  if (typeof uptime2 === "number") {
    device.boot_time = new Date(Date.now() - uptime2 * 1000).toISOString();
  }
  device.arch = os.arch();
  if (deviceOpt === true || deviceOpt.memory) {
    device.memory_size = os.totalmem();
    device.free_memory = os.freemem();
  }
  if (deviceOpt === true || deviceOpt.cpu) {
    const cpuInfo = os.cpus();
    const firstCpu = cpuInfo && cpuInfo[0];
    if (firstCpu) {
      device.processor_count = cpuInfo.length;
      device.cpu_description = firstCpu.model;
      device.processor_frequency = firstCpu.speed;
    }
  }
  return device;
}
var PLATFORM_NAMES = {
  aix: "IBM AIX",
  freebsd: "FreeBSD",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
var LINUX_DISTROS = [
  { name: "fedora-release", distros: ["Fedora"] },
  { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
  { name: "redhat_version", distros: ["Red Hat Linux"] },
  { name: "SuSE-release", distros: ["SUSE Linux"] },
  { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
  { name: "debian_version", distros: ["Debian"] },
  { name: "debian_release", distros: ["Debian"] },
  { name: "arch-release", distros: ["Arch Linux"] },
  { name: "gentoo-release", distros: ["Gentoo Linux"] },
  { name: "novell-release", distros: ["SUSE Linux"] },
  { name: "alpine-release", distros: ["Alpine Linux"] }
];
var LINUX_VERSIONS = {
  alpine: (content) => content,
  arch: (content) => matchFirst(/distrib_release=(.*)/, content),
  centos: (content) => matchFirst(/release ([^ ]+)/, content),
  debian: (content) => content,
  fedora: (content) => matchFirst(/release (..)/, content),
  mint: (content) => matchFirst(/distrib_release=(.*)/, content),
  red: (content) => matchFirst(/release ([^ ]+)/, content),
  suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
  ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
};
function matchFirst(regex, text) {
  const match = regex.exec(text);
  return match ? match[1] : undefined;
}
async function getDarwinInfo() {
  const darwinInfo = {
    kernel_version: os.release(),
    name: "Mac OS X",
    version: `10.${Number(os.release().split(".")[0]) - 4}`
  };
  try {
    const output = await new Promise((resolve2, reject) => {
      execFile("/usr/bin/sw_vers", (error, stdout) => {
        if (error) {
          reject(error);
          return;
        }
        resolve2(stdout);
      });
    });
    darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
    darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
    darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
  } catch (e) {
  }
  return darwinInfo;
}
function getLinuxDistroId(name) {
  return name.split(" ")[0].toLowerCase();
}
async function getLinuxInfo() {
  const linuxInfo = {
    kernel_version: os.release(),
    name: "Linux"
  };
  try {
    const etcFiles = await readDirAsync("/etc");
    const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
    if (!distroFile) {
      return linuxInfo;
    }
    const distroPath = join3("/etc", distroFile.name);
    const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
    const { distros } = distroFile;
    linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
    const id = getLinuxDistroId(linuxInfo.name);
    linuxInfo.version = _optionalChain([LINUX_VERSIONS, "access", (_21) => _21[id], "optionalCall", (_22) => _22(contents)]);
  } catch (e) {
  }
  return linuxInfo;
}
function getCloudResourceContext() {
  if (process.env.VERCEL) {
    return {
      "cloud.provider": "vercel",
      "cloud.region": process.env.VERCEL_REGION
    };
  } else if (process.env.AWS_REGION) {
    return {
      "cloud.provider": "aws",
      "cloud.region": process.env.AWS_REGION,
      "cloud.platform": process.env.AWS_EXECUTION_ENV
    };
  } else if (process.env.GCP_PROJECT) {
    return {
      "cloud.provider": "gcp"
    };
  } else if (process.env.ALIYUN_REGION_ID) {
    return {
      "cloud.provider": "alibaba_cloud",
      "cloud.region": process.env.ALIYUN_REGION_ID
    };
  } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
    return {
      "cloud.provider": "azure",
      "cloud.region": process.env.REGION_NAME
    };
  } else if (process.env.IBM_CLOUD_REGION) {
    return {
      "cloud.provider": "ibm_cloud",
      "cloud.region": process.env.IBM_CLOUD_REGION
    };
  } else if (process.env.TENCENTCLOUD_REGION) {
    return {
      "cloud.provider": "tencent_cloud",
      "cloud.region": process.env.TENCENTCLOUD_REGION,
      "cloud.account.id": process.env.TENCENTCLOUD_APPID,
      "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
    };
  } else if (process.env.NETLIFY) {
    return {
      "cloud.provider": "netlify"
    };
  } else if (process.env.FLY_REGION) {
    return {
      "cloud.provider": "fly.io",
      "cloud.region": process.env.FLY_REGION
    };
  } else if (process.env.DYNO) {
    return {
      "cloud.provider": "heroku"
    };
  } else {
    return;
  }
}
// ../node_modules/@sentry/node/build/esm/integrations/contextlines.js
import { createReadStream } from "fs";
import { createInterface } from "readline";

// ../node_modules/@sentry/node/build/esm/debug-build.js
var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../node_modules/@sentry/node/build/esm/integrations/contextlines.js
var LRU_FILE_CONTENTS_CACHE = new LRUMap(10);
var LRU_FILE_CONTENTS_FS_READ_FAILED = new LRUMap(20);
var DEFAULT_LINES_OF_CONTEXT = 7;
var INTEGRATION_NAME8 = "ContextLines";
var MAX_CONTEXTLINES_COLNO = 1000;
var MAX_CONTEXTLINES_LINENO = 1e4;
function emplace(map, key, contents) {
  const value = map.get(key);
  if (value === undefined) {
    map.set(key, contents);
    return contents;
  }
  return value;
}
function shouldSkipContextLinesForFile(path3) {
  if (path3.startsWith("node:"))
    return true;
  if (path3.endsWith(".min.js"))
    return true;
  if (path3.endsWith(".min.cjs"))
    return true;
  if (path3.endsWith(".min.mjs"))
    return true;
  if (path3.startsWith("data:"))
    return true;
  return false;
}
function shouldSkipContextLinesForFrame(frame) {
  if (frame.lineno !== undefined && frame.lineno > MAX_CONTEXTLINES_LINENO)
    return true;
  if (frame.colno !== undefined && frame.colno > MAX_CONTEXTLINES_COLNO)
    return true;
  return false;
}
function rangeExistsInContentCache(file, range) {
  const contents = LRU_FILE_CONTENTS_CACHE.get(file);
  if (contents === undefined)
    return false;
  for (let i = range[0];i <= range[1]; i++) {
    if (contents[i] === undefined) {
      return false;
    }
  }
  return true;
}
function makeLineReaderRanges(lines, linecontext) {
  if (!lines.length) {
    return [];
  }
  let i = 0;
  const line = lines[0];
  if (typeof line !== "number") {
    return [];
  }
  let current = makeContextRange(line, linecontext);
  const out = [];
  while (true) {
    if (i === lines.length - 1) {
      out.push(current);
      break;
    }
    const next = lines[i + 1];
    if (typeof next !== "number") {
      break;
    }
    if (next <= current[1]) {
      current[1] = next + linecontext;
    } else {
      out.push(current);
      current = makeContextRange(next, linecontext);
    }
    i++;
  }
  return out;
}
function getContextLinesFromFile(path3, ranges, output) {
  return new Promise((resolve2, _reject) => {
    const stream = createReadStream(path3);
    const lineReaded = createInterface({
      input: stream
    });
    let lineNumber = 0;
    let currentRangeIndex = 0;
    const range = ranges[currentRangeIndex];
    if (range === undefined) {
      resolve2();
      return;
    }
    let rangeStart = range[0];
    let rangeEnd = range[1];
    function onStreamError(e) {
      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path3, 1);
      DEBUG_BUILD4 && logger.error(`Failed to read file: ${path3}. Error: ${e}`);
      lineReaded.close();
      lineReaded.removeAllListeners();
      resolve2();
    }
    stream.on("error", onStreamError);
    lineReaded.on("error", onStreamError);
    lineReaded.on("close", resolve2);
    lineReaded.on("line", (line) => {
      lineNumber++;
      if (lineNumber < rangeStart)
        return;
      output[lineNumber] = snipLine(line, 0);
      if (lineNumber >= rangeEnd) {
        if (currentRangeIndex === ranges.length - 1) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        currentRangeIndex++;
        const range2 = ranges[currentRangeIndex];
        if (range2 === undefined) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        rangeStart = range2[0];
        rangeEnd = range2[1];
      }
    });
  });
}
async function addSourceContext(event, contextLines) {
  const filesToLines = {};
  if (contextLines > 0 && _optionalChain([event, "access", (_) => _.exception, "optionalAccess", (_2) => _2.values])) {
    for (const exception of event.exception.values) {
      if (!_optionalChain([exception, "access", (_3) => _3.stacktrace, "optionalAccess", (_4) => _4.frames, "optionalAccess", (_5) => _5.length])) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1;i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        const filename = _optionalChain([frame, "optionalAccess", (_6) => _6.filename]);
        if (!frame || typeof filename !== "string" || typeof frame.lineno !== "number" || shouldSkipContextLinesForFile(filename) || shouldSkipContextLinesForFrame(frame)) {
          continue;
        }
        const filesToLinesOutput = filesToLines[filename];
        if (!filesToLinesOutput)
          filesToLines[filename] = [];
        filesToLines[filename].push(frame.lineno);
      }
    }
  }
  const files = Object.keys(filesToLines);
  if (files.length == 0) {
    return event;
  }
  const readlinePromises = [];
  for (const file of files) {
    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {
      continue;
    }
    const filesToLineRanges = filesToLines[file];
    if (!filesToLineRanges) {
      continue;
    }
    filesToLineRanges.sort((a, b) => a - b);
    const ranges = makeLineReaderRanges(filesToLineRanges, contextLines);
    if (ranges.every((r) => rangeExistsInContentCache(file, r))) {
      continue;
    }
    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});
    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));
  }
  await Promise.all(readlinePromises).catch(() => {
    DEBUG_BUILD4 && logger.log("Failed to read one or more source files and resolve context lines");
  });
  if (contextLines > 0 && _optionalChain([event, "access", (_7) => _7.exception, "optionalAccess", (_8) => _8.values])) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace && exception.stacktrace.frames && exception.stacktrace.frames.length > 0) {
        addSourceContextToFrames(exception.stacktrace.frames, contextLines, LRU_FILE_CONTENTS_CACHE);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines, cache) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === undefined && typeof frame.lineno === "number") {
      const contents = cache.get(frame.filename);
      if (contents === undefined) {
        continue;
      }
      addContextToFrame2(frame.lineno, frame, contextLines, contents);
    }
  }
}
function clearLineContext(frame) {
  delete frame.pre_context;
  delete frame.context_line;
  delete frame.post_context;
}
function addContextToFrame2(lineno, frame, contextLines, contents) {
  if (frame.lineno === undefined || contents === undefined) {
    DEBUG_BUILD4 && logger.error("Cannot resolve context for frame with no lineno or file contents");
    return;
  }
  frame.pre_context = [];
  for (let i = makeRangeStart(lineno, contextLines);i < lineno; i++) {
    const line = contents[i];
    if (line === undefined) {
      clearLineContext(frame);
      DEBUG_BUILD4 && logger.error(`Could not find line ${i} in file ${frame.filename}`);
      return;
    }
    frame.pre_context.push(line);
  }
  if (contents[lineno] === undefined) {
    clearLineContext(frame);
    DEBUG_BUILD4 && logger.error(`Could not find line ${lineno} in file ${frame.filename}`);
    return;
  }
  frame.context_line = contents[lineno];
  const end = makeRangeEnd(lineno, contextLines);
  frame.post_context = [];
  for (let i = lineno + 1;i <= end; i++) {
    const line = contents[i];
    if (line === undefined) {
      break;
    }
    frame.post_context.push(line);
  }
}
function makeRangeStart(line, linecontext) {
  return Math.max(1, line - linecontext);
}
function makeRangeEnd(line, linecontext) {
  return line + linecontext;
}
function makeContextRange(line, linecontext) {
  return [makeRangeStart(line, linecontext), makeRangeEnd(line, linecontext)];
}
var _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME8,
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
var contextLinesIntegration = defineIntegration(_contextLinesIntegration);
// ../node_modules/@sentry/node/build/esm/nodeVersion.js
var NODE_VERSION = parseSemver(process.versions.node);
var NODE_MAJOR = NODE_VERSION.major;

// ../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
import { Worker } from "worker_threads";

// ../node_modules/@sentry/node/build/esm/integrations/local-variables/common.js
var LOCAL_VARIABLES_KEY = "__SENTRY_ERROR_LOCAL_VARIABLES__";
function createRateLimiter(maxPerSecond, enable, disable) {
  let count = 0;
  let retrySeconds = 5;
  let disabledTimeout = 0;
  setInterval(() => {
    if (disabledTimeout === 0) {
      if (count > maxPerSecond) {
        retrySeconds *= 2;
        disable(retrySeconds);
        if (retrySeconds > 86400) {
          retrySeconds = 86400;
        }
        disabledTimeout = retrySeconds;
      }
    } else {
      disabledTimeout -= 1;
      if (disabledTimeout === 0) {
        enable();
      }
    }
    count = 0;
  }, 1000).unref();
  return () => {
    count += 1;
  };
}
function isAnonymous(name) {
  return name !== undefined && (name.length === 0 || name === "?" || name === "<anonymous>");
}
function functionNamesMatch(a, b) {
  return a === b || isAnonymous(a) && isAnonymous(b);
}

// ../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
var base64WorkerScript = "LyohIEBzZW50cnkvbm9kZSA4LjMyLjAgKGYxYThiZWEpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPSI4LjMyLjAiLG89Z2xvYmFsVGhpcztjb25zdCBpPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXyxhPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxzPXt9O2Z1bmN0aW9uIHIoZSl7aWYoISgiY29uc29sZSJpbiBvKSlyZXR1cm4gZSgpO2NvbnN0IHQ9by5jb25zb2xlLG49e30saT1PYmplY3Qua2V5cyhzKTtpLmZvckVhY2goKGU9Pntjb25zdCBvPXNbZV07bltlXT10W2VdLHRbZV09b30pKTt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e2kuZm9yRWFjaCgoZT0+e3RbZV09bltlXX0pKX19IWZ1bmN0aW9uKGUsdCxpKXtjb25zdCBhPWl8fG8scz1hLl9fU0VOVFJZX189YS5fX1NFTlRSWV9ffHx7fSxyPXNbbl09c1tuXXx8e307cltlXXx8KHJbZV09dCgpKX0oImxvZ2dlciIsKGZ1bmN0aW9uKCl7bGV0IGU9ITE7Y29uc3QgdD17ZW5hYmxlOigpPT57ZT0hMH0sZGlzYWJsZTooKT0+e2U9ITF9LGlzRW5hYmxlZDooKT0+ZX07cmV0dXJuIGk/YS5mb3JFYWNoKChuPT57dFtuXT0oLi4udCk9PntlJiZyKCgoKT0+e28uY29uc29sZVtuXShgU2VudHJ5IExvZ2dlciBbJHtufV06YCwuLi50KX0pKX19KSk6YS5mb3JFYWNoKChlPT57dFtlXT0oKT0+e319KSksdH0pKTtjb25zdCBjPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgdT10O2Z1bmN0aW9uIGwoLi4uZSl7dS5kZWJ1ZyYmcigoKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpKX1hc3luYyBmdW5jdGlvbiBmKGUsdCxuLG8pe2NvbnN0IGk9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtvW25dPWkucmVzdWx0LmZpbHRlcigoZT0+Imxlbmd0aCIhPT1lLm5hbWUmJiFpc05hTihwYXJzZUludChlLm5hbWUsMTApKSkpLnNvcnQoKChlLHQpPT5wYXJzZUludChlLm5hbWUsMTApLXBhcnNlSW50KHQubmFtZSwxMCkpKS5tYXAoKGU9PmUudmFsdWU/LnZhbHVlKSl9YXN5bmMgZnVuY3Rpb24gZyhlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5tYXAoKGU9PltlLm5hbWUsZS52YWx1ZT8udmFsdWVdKSkucmVkdWNlKCgoZSxbdCxuXSk9PihlW3RdPW4sZSkpLHt9KX1mdW5jdGlvbiBkKGUsdCl7ZS52YWx1ZSYmKCJ2YWx1ZSJpbiBlLnZhbHVlP3ZvaWQgMD09PWUudmFsdWUudmFsdWV8fG51bGw9PT1lLnZhbHVlLnZhbHVlP3RbZS5uYW1lXT1gPCR7ZS52YWx1ZS52YWx1ZX0+YDp0W2UubmFtZV09ZS52YWx1ZS52YWx1ZToiZGVzY3JpcHRpb24iaW4gZS52YWx1ZSYmImZ1bmN0aW9uIiE9PWUudmFsdWUudHlwZT90W2UubmFtZV09YDwke2UudmFsdWUuZGVzY3JpcHRpb259PmA6InVuZGVmaW5lZCI9PT1lLnZhbHVlLnR5cGUmJih0W2UubmFtZV09Ijx1bmRlZmluZWQ+IikpfWFzeW5jIGZ1bmN0aW9uIGIoZSx0KXtjb25zdCBuPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSksbz17fTtmb3IoY29uc3QgdCBvZiBuLnJlc3VsdClpZih0Py52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10Py52YWx1ZS5jbGFzc05hbWUpe2NvbnN0IG49dC52YWx1ZS5vYmplY3RJZDthd2FpdCBmKGUsbix0Lm5hbWUsbyl9ZWxzZSBpZih0Py52YWx1ZT8ub2JqZWN0SWQmJiJPYmplY3QiPT09dD8udmFsdWU/LmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGcoZSxuLHQubmFtZSxvKX1lbHNlIHQ/LnZhbHVlJiZkKHQsbyk7cmV0dXJuIG99bGV0IHA7KGFzeW5jIGZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgZTt0LmNvbm5lY3RUb01haW5UaHJlYWQoKSxsKCJDb25uZWN0ZWQgdG8gbWFpbiB0aHJlYWQiKTtsZXQgbj0hMTt0Lm9uKCJEZWJ1Z2dlci5yZXN1bWVkIiwoKCk9PntuPSExfSkpLHQub24oIkRlYnVnZ2VyLnBhdXNlZCIsKGU9PntuPSEwLGFzeW5jIGZ1bmN0aW9uKGUse3JlYXNvbjp0LGRhdGE6e29iamVjdElkOm59LGNhbGxGcmFtZXM6b30pe2lmKCJleGNlcHRpb24iIT09dCYmInByb21pc2VSZWplY3Rpb24iIT09dClyZXR1cm47aWYocD8uKCksbnVsbD09bilyZXR1cm47Y29uc3QgaT1bXTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyl7Y29uc3R7c2NvcGVDaGFpbjpuLGZ1bmN0aW9uTmFtZTphLHRoaXM6c309b1t0XSxyPW4uZmluZCgoZT0+ImxvY2FsIj09PWUudHlwZSkpLGM9Imdsb2JhbCIhPT1zLmNsYXNzTmFtZSYmcy5jbGFzc05hbWU/YCR7cy5jbGFzc05hbWV9LiR7YX1gOmE7aWYodm9pZCAwPT09cj8ub2JqZWN0Lm9iamVjdElkKWlbdF09e2Z1bmN0aW9uOmN9O2Vsc2V7Y29uc3Qgbj1hd2FpdCBiKGUsci5vYmplY3Qub2JqZWN0SWQpO2lbdF09e2Z1bmN0aW9uOmMsdmFyczpufX19cmV0dXJuIGF3YWl0IGUucG9zdCgiUnVudGltZS5jYWxsRnVuY3Rpb25PbiIse2Z1bmN0aW9uRGVjbGFyYXRpb246YGZ1bmN0aW9uKCkgeyB0aGlzLiR7Y30gPSB0aGlzLiR7Y30gfHwgJHtKU09OLnN0cmluZ2lmeShpKX07IH1gLHNpbGVudDohMCxvYmplY3RJZDpufSksbn0odCxlLnBhcmFtcykudGhlbigoYXN5bmMgZT0+e24mJmF3YWl0IHQucG9zdCgiRGVidWdnZXIucmVzdW1lIiksZSYmc2V0VGltZW91dCgoYXN5bmMoKT0+e2F3YWl0IHQucG9zdCgiUnVudGltZS5yZWxlYXNlT2JqZWN0Iix7b2JqZWN0SWQ6ZX0pfSksMWUzKX0pLChhc3luYyBlPT57biYmYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKX0pKX0pKSxhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLmVuYWJsZSIpO2NvbnN0IG89ITEhPT11LmNhcHR1cmVBbGxFeGNlcHRpb25zO2lmKGF3YWl0IHQucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZTpvPyJhbGwiOiJ1bmNhdWdodCJ9KSxvKXtjb25zdCBlPXUubWF4RXhjZXB0aW9uc1BlclNlY29uZHx8NTA7cD1mdW5jdGlvbihlLHQsbil7bGV0IG89MCxpPTUsYT0wO3JldHVybiBzZXRJbnRlcnZhbCgoKCk9PnswPT09YT9vPmUmJihpKj0yLG4oaSksaT44NjQwMCYmKGk9ODY0MDApLGE9aSk6KGEtPTEsMD09PWEmJnQoKSksbz0wfSksMWUzKS51bnJlZigpLCgpPT57bys9MX19KGUsKGFzeW5jKCk9PntsKCJSYXRlLWxpbWl0IGxpZnRlZC4iKSxhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6ImFsbCJ9KX0pLChhc3luYyBlPT57bChgUmF0ZS1saW1pdCBleGNlZWRlZC4gRGlzYWJsaW5nIGNhcHR1cmluZyBvZiBjYXVnaHQgZXhjZXB0aW9ucyBmb3IgJHtlfSBzZWNvbmRzLmApLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToidW5jYXVnaHQifSl9KSl9fSkoKS5jYXRjaCgoZT0+e2woIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSksc2V0SW50ZXJ2YWwoKCgpPT57fSksMWU0KTs=";
function log(...args) {
  logger.log("[LocalVariables]", ...args);
}
var localVariablesAsyncIntegration = defineIntegration((integrationOptions = {}) => {
  function addLocalVariablesToException(exception, localVariables) {
    const frames = (_optionalChain([exception, "access", (_) => _.stacktrace, "optionalAccess", (_2) => _2.frames]) || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0;i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const frameLocalVariables = localVariables[i];
      const frame = frames[frameIndex];
      if (!frame || !frameLocalVariables) {
        break;
      }
      if (frameLocalVariables.vars === undefined || frame.in_app === false || !functionNamesMatch(frame.function, frameLocalVariables.function)) {
        continue;
      }
      frame.vars = frameLocalVariables.vars;
    }
  }
  function addLocalVariablesToEvent(event, hint) {
    if (hint.originalException && typeof hint.originalException === "object" && LOCAL_VARIABLES_KEY in hint.originalException && Array.isArray(hint.originalException[LOCAL_VARIABLES_KEY])) {
      for (const exception of _optionalChain([event, "access", (_3) => _3.exception, "optionalAccess", (_4) => _4.values]) || []) {
        addLocalVariablesToException(exception, hint.originalException[LOCAL_VARIABLES_KEY]);
      }
      hint.originalException[LOCAL_VARIABLES_KEY] = undefined;
    }
    return event;
  }
  async function startInspector() {
    const inspector = await import("inspector");
    if (!inspector.url()) {
      inspector.open(0);
    }
  }
  function startWorker(options) {
    const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
      workerData: options,
      execArgv: []
    });
    process.on("exit", () => {
      worker.terminate();
    });
    worker.once("error", (err) => {
      log("Worker error", err);
    });
    worker.once("exit", (code) => {
      log("Worker exit", code);
    });
    worker.unref();
  }
  return {
    name: "LocalVariablesAsync",
    setup(client) {
      const clientOptions = client.getOptions();
      if (!clientOptions.includeLocalVariables) {
        return;
      }
      const options = {
        ...integrationOptions,
        debug: logger.isEnabled()
      };
      startInspector().then(() => {
        try {
          startWorker(options);
        } catch (e) {
          logger.error("Failed to start worker", e);
        }
      }, (e) => {
        logger.error("Failed to start inspector", e);
      });
    },
    processEvent(event, hint) {
      return addLocalVariablesToEvent(event, hint);
    }
  };
});

// ../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-sync.js
function hashFrames(frames) {
  if (frames === undefined) {
    return;
  }
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
}
function hashFromStack(stackParser, stack) {
  if (stack === undefined) {
    return;
  }
  return hashFrames(stackParser(stack, 1));
}
function createCallbackList(complete) {
  let callbacks = [];
  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }
  callbacks.push(checkedComplete);
  function add(fn) {
    callbacks.push(fn);
  }
  function next(result) {
    const popped = callbacks.pop() || checkedComplete;
    try {
      popped(result);
    } catch (_) {
      checkedComplete(result);
    }
  }
  return { add, next };
}

class AsyncSession {
  constructor(_session) {
    this._session = _session;
  }
  static async create(orDefault) {
    if (orDefault) {
      return orDefault;
    }
    const inspector = await import("inspector");
    return new AsyncSession(new inspector.Session);
  }
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", (event) => {
      onPause(event, () => {
        this._session.post("Debugger.resume");
      });
    });
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  setPauseOnExceptions(captureAll) {
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  getLocalVariables(objectId, complete) {
    this._getProperties(objectId, (props) => {
      const { add, next } = createCallbackList(complete);
      for (const prop of props) {
        if (_optionalChain([prop, "optionalAccess", (_2) => _2.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
          const id = prop.value.objectId;
          add((vars) => this._unrollArray(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
          const id = prop.value.objectId;
          add((vars) => this._unrollObject(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value])) {
          add((vars) => this._unrollOther(prop, vars, next));
        }
      }
      next({});
    });
  }
  _getProperties(objectId, next) {
    this._session.post("Runtime.getProperties", {
      objectId,
      ownProperties: true
    }, (err, params) => {
      if (err) {
        next([]);
      } else {
        next(params.result);
      }
    });
  }
  _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_11) => _11.value, "optionalAccess", (_12) => _12.value]));
      next(vars);
    });
  }
  _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_13) => _13.value, "optionalAccess", (_14) => _14.value])]).reduce((obj, [key, val2]) => {
        obj[key] = val2;
        return obj;
      }, {});
      next(vars);
    });
  }
  _unrollOther(prop, vars, next) {
    if (prop.value) {
      if ("value" in prop.value) {
        if (prop.value.value === undefined || prop.value.value === null) {
          vars[prop.name] = `<${prop.value.value}>`;
        } else {
          vars[prop.name] = prop.value.value;
        }
      } else if ("description" in prop.value && prop.value.type !== "function") {
        vars[prop.name] = `<${prop.value.description}>`;
      } else if (prop.value.type === "undefined") {
        vars[prop.name] = "<undefined>";
      }
    }
    next(vars);
  }
}
var INTEGRATION_NAME9 = "LocalVariables";
var _localVariablesSyncIntegration = (options = {}, sessionOverride) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_15) => _15.stacktrace, "optionalAccess", (_16) => _16.frames]));
    if (hash === undefined) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === undefined) {
      return;
    }
    const frames = (_optionalChain([exception, "access", (_17) => _17.stacktrace, "optionalAccess", (_18) => _18.frames]) || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0;i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const cachedFrameVariable = cachedFrame[i];
      const frameVariable = frames[frameIndex];
      if (!frameVariable || !cachedFrameVariable) {
        break;
      }
      if (cachedFrameVariable.vars === undefined || frameVariable.in_app === false || !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)) {
        continue;
      }
      frameVariable.vars = cachedFrameVariable.vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain([event, "optionalAccess", (_19) => _19.exception, "optionalAccess", (_20) => _20.values]) || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  return {
    name: INTEGRATION_NAME9,
    setupOnce() {
      const client = getClient();
      const clientOptions = _optionalChain([client, "optionalAccess", (_21) => _21.getOptions, "call", (_22) => _22()]);
      if (!_optionalChain([clientOptions, "optionalAccess", (_23) => _23.includeLocalVariables])) {
        return;
      }
      const unsupportedNodeVersion = NODE_MAJOR < 18;
      if (unsupportedNodeVersion) {
        logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
        return;
      }
      AsyncSession.create(sessionOverride).then((session) => {
        function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
          if (reason !== "exception" && reason !== "promiseRejection") {
            complete();
            return;
          }
          _optionalChain([rateLimiter, "optionalCall", (_24) => _24()]);
          const exceptionHash = hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_25) => _25.description]));
          if (exceptionHash == undefined) {
            complete();
            return;
          }
          const { add, next } = createCallbackList((frames) => {
            cachedFrames.set(exceptionHash, frames);
            complete();
          });
          for (let i = 0;i < Math.min(callFrames.length, 5); i++) {
            const { scopeChain, functionName, this: obj } = callFrames[i];
            const localScope = scopeChain.find((scope) => scope.type === "local");
            const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
            if (_optionalChain([localScope, "optionalAccess", (_26) => _26.object, "access", (_27) => _27.objectId]) === undefined) {
              add((frames) => {
                frames[i] = { function: fn };
                next(frames);
              });
            } else {
              const id = localScope.object.objectId;
              add((frames) => _optionalChain([session, "optionalAccess", (_28) => _28.getLocalVariables, "call", (_29) => _29(id, (vars) => {
                frames[i] = { function: fn, vars };
                next(frames);
              })]));
            }
          }
          next([]);
        }
        const captureAll = options.captureAllExceptions !== false;
        session.configureAndConnect((ev, complete) => handlePaused(clientOptions.stackParser, ev, complete), captureAll);
        if (captureAll) {
          const max = options.maxExceptionsPerSecond || 50;
          rateLimiter = createRateLimiter(max, () => {
            logger.log("Local variables rate-limit lifted.");
            _optionalChain([session, "optionalAccess", (_30) => _30.setPauseOnExceptions, "call", (_31) => _31(true)]);
          }, (seconds) => {
            logger.log(`Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`);
            _optionalChain([session, "optionalAccess", (_32) => _32.setPauseOnExceptions, "call", (_33) => _33(false)]);
          });
        }
        shouldProcessEvent = true;
      }, (error) => {
        logger.log("The `LocalVariables` integration failed to start.", error);
      });
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }
      return event;
    },
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    }
  };
};
var localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/local-variables/index.js
var localVariablesIntegration = (options = {}) => {
  return NODE_VERSION.major < 19 ? localVariablesSyncIntegration(options) : localVariablesAsyncIntegration(options);
};

// ../node_modules/@sentry/node/build/esm/integrations/modules.js
import { existsSync, readFileSync as readFileSync2 } from "fs";
import { dirname as dirname2, join as join4 } from "path";
var moduleCache;
var INTEGRATION_NAME10 = "Modules";
var _modulesIntegration = () => {
  return {
    name: INTEGRATION_NAME10,
    processEvent(event) {
      event.modules = {
        ...event.modules,
        ..._getModules()
      };
      return event;
    }
  };
};
var modulesIntegration = defineIntegration(_modulesIntegration);
function getPaths() {
  try {
    return import.meta.require.cache ? Object.keys(import.meta.require.cache) : [];
  } catch (e) {
    return [];
  }
}
function collectModules() {
  const mainPaths = import.meta.require.main && import.meta.require.main.paths || [];
  const paths = getPaths();
  const infos = {};
  const seen = {};
  paths.forEach((path3) => {
    let dir = path3;
    const updir = () => {
      const orig = dir;
      dir = dirname2(orig);
      if (!dir || orig === dir || seen[orig]) {
        return;
      }
      if (mainPaths.indexOf(dir) < 0) {
        return updir();
      }
      const pkgfile = join4(orig, "package.json");
      seen[orig] = true;
      if (!existsSync(pkgfile)) {
        return updir();
      }
      try {
        const info = JSON.parse(readFileSync2(pkgfile, "utf8"));
        infos[info.name] = info.version;
      } catch (_oO) {
      }
    };
    updir();
  });
  return infos;
}
function _getModules() {
  if (!moduleCache) {
    moduleCache = collectModules();
  }
  return moduleCache;
}
// ../node_modules/@sentry/node/build/esm/utils/errorhandling.js
var DEFAULT_SHUTDOWN_TIMEOUT = 2000;
function logAndExitProcess(error) {
  consoleSandbox(() => {
    console.error(error);
  });
  const client = getClient();
  if (client === undefined) {
    DEBUG_BUILD4 && logger.warn("No NodeClient was defined, we are exiting the process now.");
    global.process.exit(1);
    return;
  }
  const options = client.getOptions();
  const timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
  client.close(timeout).then((result) => {
    if (!result) {
      DEBUG_BUILD4 && logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
    }
    global.process.exit(1);
  }, (error2) => {
    DEBUG_BUILD4 && logger.error(error2);
  });
}

// ../node_modules/@sentry/node/build/esm/integrations/onuncaughtexception.js
var INTEGRATION_NAME11 = "OnUncaughtException";
var onUncaughtExceptionIntegration = defineIntegration((options = {}) => {
  const optionsWithDefaults = {
    exitEvenIfOtherHandlersAreRegistered: false,
    ...options
  };
  return {
    name: INTEGRATION_NAME11,
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, optionsWithDefaults));
    }
  };
});
function makeErrorHandler(client, options) {
  const timeout = 2000;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign((error) => {
    let onFatalError = logAndExitProcess;
    if (options.onFatalError) {
      onFatalError = options.onFatalError;
    } else if (clientOptions.onFatalError) {
      onFatalError = clientOptions.onFatalError;
    }
    const userProvidedListenersCount = global.process.listeners("uncaughtException").filter((listener) => {
      return listener.name !== "domainUncaughtExceptionClear" && listener.tag !== "sentry_tracingErrorCallback" && listener._errorHandler !== true;
    }).length;
    const processWouldExit = userProvidedListenersCount === 0;
    const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
    if (!caughtFirstError) {
      firstError = error;
      caughtFirstError = true;
      if (getClient() === client) {
        captureException(error, {
          originalException: error,
          captureContext: {
            level: "fatal"
          },
          mechanism: {
            handled: false,
            type: "onuncaughtexception"
          }
        });
      }
      if (!calledFatalError && shouldApplyFatalHandlingLogic) {
        calledFatalError = true;
        onFatalError(error);
      }
    } else {
      if (shouldApplyFatalHandlingLogic) {
        if (calledFatalError) {
          DEBUG_BUILD4 && logger.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
          logAndExitProcess(error);
        } else if (!caughtSecondError) {
          caughtSecondError = true;
          setTimeout(() => {
            if (!calledFatalError) {
              calledFatalError = true;
              onFatalError(firstError, error);
            }
          }, timeout);
        }
      }
    }
  }, { _errorHandler: true });
}
// ../node_modules/@sentry/node/build/esm/integrations/onunhandledrejection.js
var INTEGRATION_NAME12 = "OnUnhandledRejection";
var _onUnhandledRejectionIntegration = (options = {}) => {
  const mode = options.mode || "warn";
  return {
    name: INTEGRATION_NAME12,
    setup(client) {
      global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, { mode }));
    }
  };
};
var onUnhandledRejectionIntegration = defineIntegration(_onUnhandledRejectionIntegration);
function makeUnhandledPromiseHandler(client, options) {
  return function sendUnhandledPromise(reason, promise) {
    if (getClient() !== client) {
      return;
    }
    captureException(reason, {
      originalException: promise,
      captureContext: {
        extra: { unhandledPromiseRejection: true }
      },
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
    handleRejection(reason, options);
  };
}
function handleRejection(reason, options) {
  const rejectionWarning = "This error originated either by " + "throwing inside of an async function without a catch block, " + "or by rejecting a promise which was not handled with .catch()." + " The promise rejected with the reason:";
  if (options.mode === "warn") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
      console.error(reason && reason.stack ? reason.stack : reason);
    });
  } else if (options.mode === "strict") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    logAndExitProcess(reason);
  }
}
// ../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var import_instrumentation_express = __toESM(require_src9(), 1);

// ../node_modules/@sentry/node/build/esm/utils/commonjs.js
function isCjs() {
  return true;
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var INTEGRATION_NAME13 = "Express";
var instrumentExpress = generateInstrumentOnce(INTEGRATION_NAME13, () => new import_instrumentation_express.ExpressInstrumentation({
  requestHook(span) {
    addOriginToSpan(span, "auto.http.otel.express");
    const attributes = spanToJSON(span).data || {};
    const type = attributes["express.type"];
    if (type) {
      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.express`);
    }
    const name = attributes["express.name"];
    if (typeof name === "string") {
      span.updateName(name);
    }
  },
  spanNameHook(info, defaultName) {
    if (getIsolationScope() === getDefaultIsolationScope()) {
      DEBUG_BUILD4 && logger.warn("Isolation scope is still default isolation scope - skipping setting transactionName");
      return defaultName;
    }
    if (info.layerType === "request_handler") {
      const req = info.request;
      const method = req.method ? req.method.toUpperCase() : "GET";
      getIsolationScope().setTransactionName(`${method} ${info.route}`);
    }
    return defaultName;
  }
}));
var _expressIntegration = () => {
  return {
    name: INTEGRATION_NAME13,
    setupOnce() {
      instrumentExpress();
    }
  };
};
var expressIntegration = defineIntegration(_expressIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/fastify.js
var import_instrumentation_fastify = __toESM(require_src10(), 1);
var INTEGRATION_NAME14 = "Fastify";
var instrumentFastify = generateInstrumentOnce(INTEGRATION_NAME14, () => new import_instrumentation_fastify.FastifyInstrumentation({
  requestHook(span) {
    addFastifySpanAttributes(span);
  }
}));
var _fastifyIntegration = () => {
  return {
    name: INTEGRATION_NAME14,
    setupOnce() {
      instrumentFastify();
    }
  };
};
var fastifyIntegration = defineIntegration(_fastifyIntegration);
function addFastifySpanAttributes(span) {
  const attributes = spanToJSON(span).data || {};
  const type = attributes["fastify.type"];
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {
    return;
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.fastify",
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.fastify`
  });
  const name = attributes["fastify.name"] || attributes["plugin.name"] || attributes["hook.name"];
  if (typeof name === "string") {
    span.updateName(name.replace(/^fastify -> /, ""));
  }
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/graphql.js
var import_instrumentation_graphql = __toESM(require_src11(), 1);
var INTEGRATION_NAME15 = "Graphql";
var instrumentGraphql = generateInstrumentOnce(INTEGRATION_NAME15, (_options = {}) => {
  const options = {
    ignoreResolveSpans: true,
    ignoreTrivialResolveSpans: true,
    useOperationNameForRootSpan: true,
    ..._options
  };
  return new import_instrumentation_graphql.GraphQLInstrumentation({
    ...options,
    responseHook(span) {
      addOriginToSpan(span, "auto.graphql.otel.graphql");
      const attributes = spanToJSON(span).data || {};
      const operationType = attributes["graphql.operation.type"];
      const operationName = attributes["graphql.operation.name"];
      if (options.useOperationNameForRootSpan && operationType) {
        const rootSpan = getRootSpan(span);
        const rootSpanAttributes = spanToJSON(rootSpan).data || {};
        const existingOperations = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION] || [];
        const newOperation = operationName ? `${operationType} ${operationName}` : `${operationType}`;
        if (Array.isArray(existingOperations)) {
          existingOperations.push(newOperation);
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, existingOperations);
        } else if (existingOperations) {
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, [existingOperations, newOperation]);
        } else {
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, newOperation);
        }
      }
    }
  });
});
var _graphqlIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME15,
    setupOnce() {
      instrumentGraphql(options);
    }
  };
};
var graphqlIntegration = defineIntegration(_graphqlIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/kafka.js
var import_instrumentation_kafkajs = __toESM(require_src12(), 1);
var INTEGRATION_NAME16 = "Kafka";
var instrumentKafka = generateInstrumentOnce(INTEGRATION_NAME16, () => new import_instrumentation_kafkajs.KafkaJsInstrumentation({
  consumerHook(span) {
    addOriginToSpan(span, "auto.kafkajs.otel.consumer");
  },
  producerHook(span) {
    addOriginToSpan(span, "auto.kafkajs.otel.producer");
  }
}));
var _kafkaIntegration = () => {
  return {
    name: INTEGRATION_NAME16,
    setupOnce() {
      instrumentKafka();
    }
  };
};
var kafkaIntegration = defineIntegration(_kafkaIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/mongo.js
var import_instrumentation_mongodb = __toESM(require_src13(), 1);
var INTEGRATION_NAME17 = "Mongo";
var instrumentMongo = generateInstrumentOnce(INTEGRATION_NAME17, () => new import_instrumentation_mongodb.MongoDBInstrumentation({
  responseHook(span) {
    addOriginToSpan(span, "auto.db.otel.mongo");
  }
}));
var _mongoIntegration = () => {
  return {
    name: INTEGRATION_NAME17,
    setupOnce() {
      instrumentMongo();
    }
  };
};
var mongoIntegration = defineIntegration(_mongoIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/mongoose.js
var import_instrumentation_mongoose = __toESM(require_src14(), 1);
var INTEGRATION_NAME18 = "Mongoose";
var instrumentMongoose = generateInstrumentOnce(INTEGRATION_NAME18, () => new import_instrumentation_mongoose.MongooseInstrumentation({
  responseHook(span) {
    addOriginToSpan(span, "auto.db.otel.mongoose");
  }
}));
var _mongooseIntegration = () => {
  return {
    name: INTEGRATION_NAME18,
    setupOnce() {
      instrumentMongoose();
    }
  };
};
var mongooseIntegration = defineIntegration(_mongooseIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/mysql.js
var import_instrumentation_mysql = __toESM(require_src15(), 1);
var INTEGRATION_NAME19 = "Mysql";
var instrumentMysql = generateInstrumentOnce(INTEGRATION_NAME19, () => new import_instrumentation_mysql.MySQLInstrumentation({}));
var _mysqlIntegration = () => {
  return {
    name: INTEGRATION_NAME19,
    setupOnce() {
      instrumentMysql();
    }
  };
};
var mysqlIntegration = defineIntegration(_mysqlIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/mysql2.js
var import_instrumentation_mysql2 = __toESM(require_src17(), 1);
var INTEGRATION_NAME20 = "Mysql2";
var instrumentMysql2 = generateInstrumentOnce(INTEGRATION_NAME20, () => new import_instrumentation_mysql2.MySQL2Instrumentation({
  responseHook(span) {
    addOriginToSpan(span, "auto.db.otel.mysql2");
  }
}));
var _mysql2Integration = () => {
  return {
    name: INTEGRATION_NAME20,
    setupOnce() {
      instrumentMysql2();
    }
  };
};
var mysql2Integration = defineIntegration(_mysql2Integration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var import_instrumentation_ioredis = __toESM(require_src19(), 1);
var import_instrumentation_redis_4 = __toESM(require_src20(), 1);

// ../node_modules/@sentry/node/build/esm/utils/redisCache.js
var SINGLE_ARG_COMMANDS = ["get", "set", "setex"];
var GET_COMMANDS = ["get", "mget"];
var SET_COMMANDS = ["set", "setex"];
function isInCommands(redisCommands, command) {
  return redisCommands.includes(command.toLowerCase());
}
function getCacheOperation(command) {
  if (isInCommands(GET_COMMANDS, command)) {
    return "cache.get";
  } else if (isInCommands(SET_COMMANDS, command)) {
    return "cache.put";
  } else {
    return;
  }
}
function keyHasPrefix(key, prefixes) {
  return prefixes.some((prefix) => key.startsWith(prefix));
}
function getCacheKeySafely(redisCommand, cmdArgs) {
  try {
    if (cmdArgs.length === 0) {
      return;
    }
    const processArg = (arg) => {
      if (typeof arg === "string" || typeof arg === "number" || Buffer.isBuffer(arg)) {
        return [arg.toString()];
      } else if (Array.isArray(arg)) {
        return flatten(arg.map((arg2) => processArg(arg2)));
      } else {
        return ["<unknown>"];
      }
    };
    const firstArg = cmdArgs[0];
    if (isInCommands(SINGLE_ARG_COMMANDS, redisCommand) && firstArg != null) {
      return processArg(firstArg);
    }
    return flatten(cmdArgs.map((arg) => processArg(arg)));
  } catch (e) {
    return;
  }
}
function shouldConsiderForCache(redisCommand, keys, prefixes) {
  if (!getCacheOperation(redisCommand)) {
    return false;
  }
  for (const key of keys) {
    if (keyHasPrefix(key, prefixes)) {
      return true;
    }
  }
  return false;
}
function calculateCacheItemSize(response) {
  const getSize = (value) => {
    try {
      if (Buffer.isBuffer(value))
        return value.byteLength;
      else if (typeof value === "string")
        return value.length;
      else if (typeof value === "number")
        return value.toString().length;
      else if (value === null || value === undefined)
        return 0;
      return JSON.stringify(value).length;
    } catch (e) {
      return;
    }
  };
  return Array.isArray(response) ? response.reduce((acc, curr) => {
    const size = getSize(curr);
    return typeof size === "number" ? acc !== undefined ? acc + size : size : acc;
  }, 0) : getSize(response);
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var INTEGRATION_NAME21 = "Redis";
var _redisOptions = {};
var cacheResponseHook = (span, redisCommand, cmdArgs, response) => {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.redis");
  const safeKey = getCacheKeySafely(redisCommand, cmdArgs);
  const cacheOperation = getCacheOperation(redisCommand);
  if (!safeKey || !cacheOperation || !_optionalChain([_redisOptions, "optionalAccess", (_) => _.cachePrefixes]) || !shouldConsiderForCache(redisCommand, safeKey, _redisOptions.cachePrefixes)) {
    return;
  }
  const networkPeerAddress = _optionalChain([spanToJSON, "call", (_2) => _2(span), "access", (_3) => _3.data, "optionalAccess", (_4) => _4["net.peer.name"]]);
  const networkPeerPort = _optionalChain([spanToJSON, "call", (_5) => _5(span), "access", (_6) => _6.data, "optionalAccess", (_7) => _7["net.peer.port"]]);
  if (networkPeerPort && networkPeerAddress) {
    span.setAttributes({ "network.peer.address": networkPeerAddress, "network.peer.port": networkPeerPort });
  }
  const cacheItemSize = calculateCacheItemSize(response);
  if (cacheItemSize) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);
  }
  if (isInCommands(GET_COMMANDS, redisCommand) && cacheItemSize !== undefined) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: cacheOperation,
    [SEMANTIC_ATTRIBUTE_CACHE_KEY]: safeKey
  });
  const spanDescription = safeKey.join(", ");
  span.updateName(truncate(spanDescription, 1024));
};
var instrumentIORedis = generateInstrumentOnce("IORedis", () => {
  return new import_instrumentation_ioredis.IORedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis4 = generateInstrumentOnce("Redis-4", () => {
  return new import_instrumentation_redis_4.RedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis = Object.assign(() => {
  instrumentIORedis();
  instrumentRedis4();
}, { id: INTEGRATION_NAME21 });
var _redisIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME21,
    setupOnce() {
      _redisOptions = options;
      instrumentRedis();
    }
  };
};
var redisIntegration = defineIntegration(_redisIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/nest/nest.js
var import_instrumentation_nestjs_core = __toESM(require_src21(), 1);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/nest/helpers.js
var sentryPatched = "sentryPatched";
function isPatched(target) {
  if (target.sentryPatched) {
    return true;
  }
  addNonEnumerableProperty(target, sentryPatched, true);
  return false;
}
function getMiddlewareSpanOptions(target, name = undefined) {
  const span_name = _nullishCoalesce(name, () => target.name);
  return {
    name: span_name,
    attributes: {
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "middleware.nestjs",
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.middleware.nestjs"
    }
  };
}
function instrumentObservable(observable, activeSpan) {
  if (activeSpan) {
    observable.subscribe = new Proxy(observable.subscribe, {
      apply: (originalSubscribe, thisArgSubscribe, argsSubscribe) => {
        return withActiveSpan(activeSpan, () => {
          const subscription = originalSubscribe.apply(thisArgSubscribe, argsSubscribe);
          subscription.add(() => activeSpan.end());
          return subscription;
        });
      }
    });
  }
}
function getNextProxy(next, span, prevSpan) {
  return new Proxy(next, {
    apply: (originalNext, thisArgNext, argsNext) => {
      span.end();
      if (prevSpan) {
        return withActiveSpan(prevSpan, () => {
          return Reflect.apply(originalNext, thisArgNext, argsNext);
        });
      } else {
        return Reflect.apply(originalNext, thisArgNext, argsNext);
      }
    }
  });
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/nest/sentry-nest-instrumentation.js
var supportedVersions = [">=8.0.0 <11"];

class SentryNestInstrumentation extends InstrumentationBase {
  static __initStatic() {
    this.COMPONENT = "@nestjs/common";
  }
  static __initStatic2() {
    this.COMMON_ATTRIBUTES = {
      component: SentryNestInstrumentation.COMPONENT
    };
  }
  constructor(config = {}) {
    super("sentry-nestjs", SDK_VERSION, config);
  }
  init() {
    const moduleDef = new InstrumentationNodeModuleDefinition(SentryNestInstrumentation.COMPONENT, supportedVersions);
    moduleDef.files.push(this._getInjectableFileInstrumentation(supportedVersions), this._getCatchFileInstrumentation(supportedVersions));
    return moduleDef;
  }
  _getInjectableFileInstrumentation(versions) {
    return new InstrumentationNodeModuleFile("@nestjs/common/decorators/core/injectable.decorator.js", versions, (moduleExports) => {
      if (isWrapped(moduleExports.Injectable)) {
        this._unwrap(moduleExports, "Injectable");
      }
      this._wrap(moduleExports, "Injectable", this._createWrapInjectable());
      return moduleExports;
    }, (moduleExports) => {
      this._unwrap(moduleExports, "Injectable");
    });
  }
  _getCatchFileInstrumentation(versions) {
    return new InstrumentationNodeModuleFile("@nestjs/common/decorators/core/catch.decorator.js", versions, (moduleExports) => {
      if (isWrapped(moduleExports.Catch)) {
        this._unwrap(moduleExports, "Catch");
      }
      this._wrap(moduleExports, "Catch", this._createWrapCatch());
      return moduleExports;
    }, (moduleExports) => {
      this._unwrap(moduleExports, "Catch");
    });
  }
  _createWrapInjectable() {
    return function wrapInjectable(original) {
      return function wrappedInjectable(options) {
        return function(target) {
          if (typeof target.prototype.use === "function" && !target.__SENTRY_INTERNAL__) {
            if (isPatched(target)) {
              return original(options)(target);
            }
            target.prototype.use = new Proxy(target.prototype.use, {
              apply: (originalUse, thisArgUse, argsUse) => {
                const [req, res, next, ...args] = argsUse;
                if (!req || !res || !next || typeof next !== "function") {
                  return originalUse.apply(thisArgUse, argsUse);
                }
                const prevSpan = getActiveSpan();
                return startSpanManual(getMiddlewareSpanOptions(target), (span) => {
                  const nextProxy = getNextProxy(next, span, prevSpan);
                  return originalUse.apply(thisArgUse, [req, res, nextProxy, args]);
                });
              }
            });
          }
          if (typeof target.prototype.canActivate === "function" && !target.__SENTRY_INTERNAL__) {
            if (isPatched(target)) {
              return original(options)(target);
            }
            target.prototype.canActivate = new Proxy(target.prototype.canActivate, {
              apply: (originalCanActivate, thisArgCanActivate, argsCanActivate) => {
                const context8 = argsCanActivate[0];
                if (!context8) {
                  return originalCanActivate.apply(thisArgCanActivate, argsCanActivate);
                }
                return startSpan(getMiddlewareSpanOptions(target), () => {
                  return originalCanActivate.apply(thisArgCanActivate, argsCanActivate);
                });
              }
            });
          }
          if (typeof target.prototype.transform === "function" && !target.__SENTRY_INTERNAL__) {
            if (isPatched(target)) {
              return original(options)(target);
            }
            target.prototype.transform = new Proxy(target.prototype.transform, {
              apply: (originalTransform, thisArgTransform, argsTransform) => {
                const value = argsTransform[0];
                const metadata = argsTransform[1];
                if (!value || !metadata) {
                  return originalTransform.apply(thisArgTransform, argsTransform);
                }
                return startSpan(getMiddlewareSpanOptions(target), () => {
                  return originalTransform.apply(thisArgTransform, argsTransform);
                });
              }
            });
          }
          if (typeof target.prototype.intercept === "function" && !target.__SENTRY_INTERNAL__) {
            if (isPatched(target)) {
              return original(options)(target);
            }
            target.prototype.intercept = new Proxy(target.prototype.intercept, {
              apply: (originalIntercept, thisArgIntercept, argsIntercept) => {
                const context8 = argsIntercept[0];
                const next = argsIntercept[1];
                const parentSpan = getActiveSpan();
                let afterSpan;
                if (!context8 || !next || typeof next.handle !== "function") {
                  return originalIntercept.apply(thisArgIntercept, argsIntercept);
                }
                return startSpanManual(getMiddlewareSpanOptions(target), (beforeSpan) => {
                  next.handle = new Proxy(next.handle, {
                    apply: (originalHandle, thisArgHandle, argsHandle) => {
                      beforeSpan.end();
                      if (parentSpan) {
                        return withActiveSpan(parentSpan, () => {
                          const handleReturnObservable = Reflect.apply(originalHandle, thisArgHandle, argsHandle);
                          if (!context8._sentryInterceptorInstrumented) {
                            addNonEnumerableProperty(context8, "_sentryInterceptorInstrumented", true);
                            afterSpan = startInactiveSpan(getMiddlewareSpanOptions(target, "Interceptors - After Route"));
                          }
                          return handleReturnObservable;
                        });
                      } else {
                        const handleReturnObservable = Reflect.apply(originalHandle, thisArgHandle, argsHandle);
                        if (!context8._sentryInterceptorInstrumented) {
                          addNonEnumerableProperty(context8, "_sentryInterceptorInstrumented", true);
                          afterSpan = startInactiveSpan(getMiddlewareSpanOptions(target, "Interceptors - After Route"));
                        }
                        return handleReturnObservable;
                      }
                    }
                  });
                  let returnedObservableInterceptMaybePromise;
                  try {
                    returnedObservableInterceptMaybePromise = originalIntercept.apply(thisArgIntercept, argsIntercept);
                  } catch (e) {
                    _optionalChain([beforeSpan, "optionalAccess", (_) => _.end, "call", (_2) => _2()]);
                    _optionalChain([afterSpan, "optionalAccess", (_3) => _3.end, "call", (_4) => _4()]);
                    throw e;
                  }
                  if (!afterSpan) {
                    return returnedObservableInterceptMaybePromise;
                  }
                  if (isThenable(returnedObservableInterceptMaybePromise)) {
                    return returnedObservableInterceptMaybePromise.then((observable) => {
                      instrumentObservable(observable, _nullishCoalesce(afterSpan, () => parentSpan));
                      return observable;
                    }, (e) => {
                      _optionalChain([beforeSpan, "optionalAccess", (_5) => _5.end, "call", (_6) => _6()]);
                      _optionalChain([afterSpan, "optionalAccess", (_7) => _7.end, "call", (_8) => _8()]);
                      throw e;
                    });
                  }
                  if (typeof returnedObservableInterceptMaybePromise.subscribe === "function") {
                    instrumentObservable(returnedObservableInterceptMaybePromise, _nullishCoalesce(afterSpan, () => parentSpan));
                  }
                  return returnedObservableInterceptMaybePromise;
                });
              }
            });
          }
          return original(options)(target);
        };
      };
    };
  }
  _createWrapCatch() {
    return function wrapCatch(original) {
      return function wrappedCatch(...exceptions) {
        return function(target) {
          if (typeof target.prototype.catch === "function" && !target.__SENTRY_INTERNAL__) {
            if (isPatched(target)) {
              return original(...exceptions)(target);
            }
            target.prototype.catch = new Proxy(target.prototype.catch, {
              apply: (originalCatch, thisArgCatch, argsCatch) => {
                const exception = argsCatch[0];
                const host = argsCatch[1];
                if (!exception || !host) {
                  return originalCatch.apply(thisArgCatch, argsCatch);
                }
                return startSpan(getMiddlewareSpanOptions(target), () => {
                  return originalCatch.apply(thisArgCatch, argsCatch);
                });
              }
            });
          }
          return original(...exceptions)(target);
        };
      };
    };
  }
}
SentryNestInstrumentation.__initStatic();
SentryNestInstrumentation.__initStatic2();

// ../node_modules/@sentry/node/build/esm/integrations/tracing/nest/nest.js
var INTEGRATION_NAME22 = "Nest";
var instrumentNestCore = generateInstrumentOnce("Nest-Core", () => {
  return new import_instrumentation_nestjs_core.NestInstrumentation;
});
var instrumentNestCommon = generateInstrumentOnce("Nest-Common", () => {
  return new SentryNestInstrumentation;
});
var instrumentNest = Object.assign(() => {
  instrumentNestCore();
  instrumentNestCommon();
}, { id: INTEGRATION_NAME22 });
var _nestIntegration = () => {
  return {
    name: INTEGRATION_NAME22,
    setupOnce() {
      instrumentNest();
    }
  };
};
var nestIntegration = defineIntegration(_nestIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/postgres.js
var import_instrumentation_pg = __toESM(require_src22(), 1);
var INTEGRATION_NAME23 = "Postgres";
var instrumentPostgres = generateInstrumentOnce(INTEGRATION_NAME23, () => new import_instrumentation_pg.PgInstrumentation({
  requireParentSpan: true,
  requestHook(span) {
    addOriginToSpan(span, "auto.db.otel.postgres");
  }
}));
var _postgresIntegration = () => {
  return {
    name: INTEGRATION_NAME23,
    setupOnce() {
      instrumentPostgres();
    }
  };
};
var postgresIntegration = defineIntegration(_postgresIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/hapi/index.js
var import_instrumentation_hapi = __toESM(require_src23(), 1);
var INTEGRATION_NAME24 = "Hapi";
var instrumentHapi = generateInstrumentOnce(INTEGRATION_NAME24, () => new import_instrumentation_hapi.HapiInstrumentation);
var _hapiIntegration = () => {
  return {
    name: INTEGRATION_NAME24,
    setupOnce() {
      instrumentHapi();
    }
  };
};
var hapiIntegration = defineIntegration(_hapiIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/koa.js
var import_instrumentation_koa = __toESM(require_src24(), 1);
var import_semantic_conventions5 = __toESM(require_src2(), 1);
var INTEGRATION_NAME25 = "Koa";
var instrumentKoa = generateInstrumentOnce(INTEGRATION_NAME25, () => new import_instrumentation_koa.KoaInstrumentation({
  requestHook(span, info) {
    addKoaSpanAttributes(span);
    if (getIsolationScope() === getDefaultIsolationScope()) {
      DEBUG_BUILD4 && logger.warn("Isolation scope is default isolation scope - skipping setting transactionName");
      return;
    }
    const attributes = spanToJSON(span).data;
    const route = attributes && attributes[import_semantic_conventions5.ATTR_HTTP_ROUTE];
    const method = _optionalChain([info, "optionalAccess", (_) => _.context, "optionalAccess", (_2) => _2.request, "optionalAccess", (_3) => _3.method, "optionalAccess", (_4) => _4.toUpperCase, "call", (_5) => _5()]) || "GET";
    if (route) {
      getIsolationScope().setTransactionName(`${method} ${route}`);
    }
  }
}));
var _koaIntegration = () => {
  return {
    name: INTEGRATION_NAME25,
    setupOnce() {
      instrumentKoa();
    }
  };
};
var koaIntegration = defineIntegration(_koaIntegration);
function addKoaSpanAttributes(span) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.http.otel.koa");
  const attributes = spanToJSON(span).data || {};
  const type = attributes["koa.type"];
  if (type) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.koa`);
  }
  const name = attributes["koa.name"];
  if (typeof name === "string") {
    span.updateName(name || "< unknown >");
  }
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/connect.js
var import_instrumentation_connect = __toESM(require_src25(), 1);
var INTEGRATION_NAME26 = "Connect";
var instrumentConnect = generateInstrumentOnce(INTEGRATION_NAME26, () => new import_instrumentation_connect.ConnectInstrumentation);
var _connectIntegration = () => {
  return {
    name: INTEGRATION_NAME26,
    setupOnce() {
      instrumentConnect();
    }
  };
};
var connectIntegration = defineIntegration(_connectIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/spotlight.js
import * as http from "http";
var INTEGRATION_NAME27 = "Spotlight";
var _spotlightIntegration = (options = {}) => {
  const _options = {
    sidecarUrl: options.sidecarUrl || "http://localhost:8969/stream"
  };
  return {
    name: INTEGRATION_NAME27,
    setup(client) {
      if (typeof process === "object" && process.env && true) {
        logger.warn("[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?");
      }
      connectToSpotlight(client, _options);
    }
  };
};
var spotlightIntegration = defineIntegration(_spotlightIntegration);
function connectToSpotlight(client, options) {
  const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
  if (!spotlightUrl) {
    return;
  }
  let failedRequests = 0;
  client.on("beforeEnvelope", (envelope) => {
    if (failedRequests > 3) {
      logger.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");
      return;
    }
    const serializedEnvelope = serializeEnvelope(envelope);
    const request = getNativeHttpRequest();
    const req = request({
      method: "POST",
      path: spotlightUrl.pathname,
      hostname: spotlightUrl.hostname,
      port: spotlightUrl.port,
      headers: {
        "Content-Type": "application/x-sentry-envelope"
      }
    }, (res) => {
      if (res.statusCode && res.statusCode >= 200 && res.statusCode < 400) {
        failedRequests = 0;
      }
      res.on("data", () => {
      });
      res.on("end", () => {
      });
      res.setEncoding("utf8");
    });
    req.on("error", () => {
      failedRequests++;
      logger.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
    });
    req.write(serializedEnvelope);
    req.end();
  });
}
function parseSidecarUrl(url) {
  try {
    return new URL(`${url}`);
  } catch (e) {
    logger.warn(`[Spotlight] Invalid sidecar URL: ${url}`);
    return;
  }
}
function getNativeHttpRequest() {
  const { request } = http;
  if (isWrapped3(request)) {
    return request.__sentry_original__;
  }
  return request;
}
function isWrapped3(impl) {
  return "__sentry_original__" in impl;
}

// ../node_modules/@sentry/node/build/esm/integrations/tracing/genericPool.js
var import_instrumentation_generic_pool = __toESM(require_src26(), 1);
var INTEGRATION_NAME28 = "GenericPool";
var instrumentGenericPool = generateInstrumentOnce(INTEGRATION_NAME28, () => new import_instrumentation_generic_pool.GenericPoolInstrumentation({}));
var _genericPoolIntegration = () => {
  return {
    name: INTEGRATION_NAME28,
    setupOnce() {
      instrumentGenericPool();
    },
    setup(client) {
      client.on("spanStart", (span) => {
        const spanJSON = spanToJSON(span);
        const spanDescription = spanJSON.description;
        const isGenericPoolSpan = spanDescription === "generic-pool.aquire" || spanDescription === "generic-pool.acquire";
        if (isGenericPoolSpan) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.generic_pool");
        }
      });
    }
  };
};
var genericPoolIntegration = defineIntegration(_genericPoolIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/dataloader.js
var import_instrumentation_dataloader = __toESM(require_src27(), 1);
var INTEGRATION_NAME29 = "Dataloader";
var instrumentDataloader = generateInstrumentOnce(INTEGRATION_NAME29, () => new import_instrumentation_dataloader.DataloaderInstrumentation({
  requireParentSpan: true
}));
var _dataloaderIntegration = () => {
  return {
    name: INTEGRATION_NAME29,
    setupOnce() {
      instrumentDataloader();
    },
    setup(client) {
      client.on("spanStart", (span) => {
        const spanJSON = spanToJSON(span);
        if (_optionalChain([spanJSON, "access", (_) => _.description, "optionalAccess", (_2) => _2.startsWith, "call", (_3) => _3("dataloader")])) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.dataloader");
        }
        if (spanJSON.description === "dataloader.load" || spanJSON.description === "dataloader.loadMany" || spanJSON.description === "dataloader.batch") {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "cache.get");
        }
      });
    }
  };
};
var dataloaderIntegration = defineIntegration(_dataloaderIntegration);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/amqplib.js
var import_instrumentation_amqplib = __toESM(require_src28(), 1);
var INTEGRATION_NAME30 = "Amqplib";
var config = {
  consumeEndHook: (span) => {
    addOriginToSpan(span, "auto.amqplib.otel.consumer");
  },
  publishHook: (span) => {
    addOriginToSpan(span, "auto.amqplib.otel.publisher");
  }
};
var instrumentAmqplib = generateInstrumentOnce(INTEGRATION_NAME30, () => new import_instrumentation_amqplib.AmqplibInstrumentation(config));
var _amqplibIntegration = () => {
  return {
    name: INTEGRATION_NAME30,
    setupOnce() {
      instrumentAmqplib();
    }
  };
};
var amqplibIntegration = defineIntegration(_amqplibIntegration);

// ../node_modules/@sentry/node/build/esm/otel/contextManager.js
var import_context_async_hooks = __toESM(require_src29(), 1);
var SentryContextManager = wrapContextManagerClass(import_context_async_hooks.AsyncLocalStorageContextManager);

// ../node_modules/@sentry/node/build/esm/integrations/tracing/index.js
function getAutoPerformanceIntegrations() {
  return [
    expressIntegration(),
    fastifyIntegration(),
    graphqlIntegration(),
    mongoIntegration(),
    mongooseIntegration(),
    mysqlIntegration(),
    mysql2Integration(),
    redisIntegration(),
    postgresIntegration(),
    nestIntegration(),
    hapiIntegration(),
    koaIntegration(),
    connectIntegration(),
    genericPoolIntegration(),
    kafkaIntegration(),
    dataloaderIntegration(),
    amqplibIntegration()
  ];
}

// ../node_modules/@sentry/node/build/esm/transports/http.js
import * as http3 from "http";
import * as https from "https";
import { Readable } from "stream";
import { createGzip } from "zlib";

// ../node_modules/@sentry/node/build/esm/proxy/index.js
import * as net from "net";
import * as tls from "tls";

// ../node_modules/@sentry/node/build/esm/proxy/base.js
import * as http2 from "http";
var INTERNAL = Symbol("AgentBaseInternalState");

class Agent2 extends http2.Agent {
  constructor(opts) {
    super(opts);
    this[INTERNAL] = {};
  }
  isSecureEndpoint(options) {
    if (options) {
      if (typeof options.secureEndpoint === "boolean") {
        return options.secureEndpoint;
      }
      if (typeof options.protocol === "string") {
        return options.protocol === "https:";
      }
    }
    const { stack } = new Error;
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  createSocket(req, options, cb) {
    const connectOpts = {
      ...options,
      secureEndpoint: this.isSecureEndpoint(options)
    };
    Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
      if (socket instanceof http2.Agent) {
        return socket.addRequest(req, connectOpts);
      }
      this[INTERNAL].currentSocket = socket;
      super.createSocket(req, options, cb);
    }, cb);
  }
  createConnection() {
    const socket = this[INTERNAL].currentSocket;
    this[INTERNAL].currentSocket = undefined;
    if (!socket) {
      throw new Error("No socket was returned in the `connect()` function");
    }
    return socket;
  }
  get defaultPort() {
    return _nullishCoalesce(this[INTERNAL].defaultPort, () => this.protocol === "https:" ? 443 : 80);
  }
  set defaultPort(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].defaultPort = v;
    }
  }
  get protocol() {
    return _nullishCoalesce(this[INTERNAL].protocol, () => this.isSecureEndpoint() ? "https:" : "http:");
  }
  set protocol(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].protocol = v;
    }
  }
}

// ../node_modules/@sentry/node/build/esm/proxy/parse-proxy-response.js
function debug(...args) {
  logger.log("[https-proxy-agent:parse-proxy-response]", ...args);
}
function parseProxyResponse(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b)
        ondata(b);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +(firstLineParts[1] || 0);
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}

// ../node_modules/@sentry/node/build/esm/proxy/index.js
function debug2(...args) {
  logger.log("[https-proxy-agent]", ...args);
}

class HttpsProxyAgent extends Agent2 {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
    this.proxyHeaders = _nullishCoalesce(_optionalChain([opts, "optionalAccess", (_2) => _2.headers]), () => ({}));
    debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  async connect(req, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug2("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? undefined : servername
      });
    } else {
      debug2("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r\n`;
    }
    const proxyResponsePromise = parseProxyResponse(socket);
    socket.write(`${payload}\r\n`);
    const { connect: connect3, buffered } = await proxyResponsePromise;
    req.emit("proxyConnect", connect3);
    this.emit("proxyConnect", connect3, req);
    if (connect3.statusCode === 200) {
      req.once("socket", resume);
      if (opts.secureEndpoint) {
        debug2("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net.isIP(servername) ? undefined : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;
    req.once("socket", (s) => {
      debug2("Replaying proxy buffer for failed request");
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent.__initStatic();
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}

// ../node_modules/@sentry/node/build/esm/transports/http.js
var GZIP_THRESHOLD = 1024 * 32;
function streamFromBody(body) {
  return new Readable({
    read() {
      this.push(body);
      this.push(null);
    }
  });
}
function makeNodeTransport(options) {
  let urlSegments;
  try {
    urlSegments = new URL(options.url);
  } catch (e) {
    consoleSandbox(() => {
      console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.");
    });
    return createTransport(options, () => Promise.resolve({}));
  }
  const isHttps = urlSegments.protocol === "https:";
  const proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);
  const nativeHttpModule = isHttps ? https : http3;
  const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;
  const agent = proxy ? new HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2000 });
  const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
  return createTransport(options, requestExecutor);
}
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;
  const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some((exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption));
  if (urlIsExemptFromProxy) {
    return;
  } else {
    return proxy;
  }
}
function createRequestExecutor(options, httpModule, agent) {
  const { hostname, pathname, port, protocol, search } = new URL(options.url);
  return function makeRequest(request) {
    return new Promise((resolve2, reject) => {
      suppressTracing(() => {
        let body = streamFromBody(request.body);
        const headers = { ...options.headers };
        if (request.body.length > GZIP_THRESHOLD) {
          headers["content-encoding"] = "gzip";
          body = body.pipe(createGzip());
        }
        const req = httpModule.request({
          method: "POST",
          agent,
          headers,
          hostname,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts
        }, (res) => {
          res.on("data", () => {
          });
          res.on("end", () => {
          });
          res.setEncoding("utf8");
          const retryAfterHeader = _nullishCoalesce(res.headers["retry-after"], () => null);
          const rateLimitsHeader = _nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
          resolve2({
            statusCode: res.statusCode,
            headers: {
              "retry-after": retryAfterHeader,
              "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] || null : rateLimitsHeader
            }
          });
        });
        req.on("error", reject);
        body.pipe(req);
      });
    });
  };
}

// ../node_modules/@sentry/node/build/esm/utils/envToBool.js
var FALSY_ENV_VALUES = new Set(["false", "f", "n", "no", "off", "0"]);
var TRUTHY_ENV_VALUES = new Set(["true", "t", "y", "yes", "on", "1"]);
function envToBool(value, options) {
  const normalized = String(value).toLowerCase();
  if (FALSY_ENV_VALUES.has(normalized)) {
    return false;
  }
  if (TRUTHY_ENV_VALUES.has(normalized)) {
    return true;
  }
  return options && options.strict ? null : Boolean(value);
}

// ../node_modules/@sentry/node/build/esm/utils/module.js
import { posix, sep as sep2 } from "path";
function normalizeWindowsPath(path3) {
  return path3.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function createGetModuleFromFilename(basePath = process.argv[1] ? dirname(process.argv[1]) : process.cwd(), isWindows = sep2 === "\\") {
  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;
  return (filename) => {
    if (!filename) {
      return;
    }
    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;
    let { dir, base: file, ext } = posix.parse(normalizedFilename);
    if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
      file = file.slice(0, ext.length * -1);
    }
    if (!dir) {
      dir = ".";
    }
    const n = dir.lastIndexOf("/node_modules");
    if (n > -1) {
      return `${dir.slice(n + 14).replace(/\//g, ".")}:${file}`;
    }
    if (dir.startsWith(normalizedBase)) {
      let moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
      if (moduleName) {
        moduleName += ":";
      }
      moduleName += file;
      return moduleName;
    }
    return file;
  };
}

// ../node_modules/@sentry/node/build/esm/sdk/api.js
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE && GLOBAL_OBJ.SENTRY_RELEASE.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  const possibleReleaseNameOfGitProvider = process.env["GITHUB_SHA"] || process.env["CI_MERGE_REQUEST_SOURCE_BRANCH_SHA"] || process.env["CI_BUILD_REF"] || process.env["CI_COMMIT_SHA"] || process.env["BITBUCKET_COMMIT"];
  const possibleReleaseNameOfCiProvidersWithSpecificEnvVar = process.env["APPVEYOR_PULL_REQUEST_HEAD_COMMIT"] || process.env["APPVEYOR_REPO_COMMIT"] || process.env["CODEBUILD_RESOLVED_SOURCE_VERSION"] || process.env["AWS_COMMIT_ID"] || process.env["BUILD_SOURCEVERSION"] || process.env["GIT_CLONE_COMMIT_HASH"] || process.env["BUDDY_EXECUTION_REVISION"] || process.env["BUILDKITE_COMMIT"] || process.env["CIRCLE_SHA1"] || process.env["CIRRUS_CHANGE_IN_REPO"] || process.env["CF_REVISION"] || process.env["CM_COMMIT"] || process.env["CF_PAGES_COMMIT_SHA"] || process.env["DRONE_COMMIT_SHA"] || process.env["FC_GIT_COMMIT_SHA"] || process.env["HEROKU_TEST_RUN_COMMIT_VERSION"] || process.env["HEROKU_SLUG_COMMIT"] || process.env["RENDER_GIT_COMMIT"] || process.env["SEMAPHORE_GIT_SHA"] || process.env["TRAVIS_PULL_REQUEST_SHA"] || process.env["VERCEL_GIT_COMMIT_SHA"] || process.env["VERCEL_GITHUB_COMMIT_SHA"] || process.env["VERCEL_GITLAB_COMMIT_SHA"] || process.env["VERCEL_BITBUCKET_COMMIT_SHA"] || process.env["ZEIT_GITHUB_COMMIT_SHA"] || process.env["ZEIT_GITLAB_COMMIT_SHA"] || process.env["ZEIT_BITBUCKET_COMMIT_SHA"];
  const possibleReleaseNameOfCiProvidersWithGenericEnvVar = process.env["CI_COMMIT_ID"] || process.env["SOURCE_COMMIT"] || process.env["SOURCE_VERSION"] || process.env["GIT_COMMIT"] || process.env["COMMIT_REF"] || process.env["BUILD_VCS_NUMBER"] || process.env["CI_COMMIT_SHA"];
  return possibleReleaseNameOfGitProvider || possibleReleaseNameOfCiProvidersWithSpecificEnvVar || possibleReleaseNameOfCiProvidersWithGenericEnvVar || fallback;
}
var defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));

// ../node_modules/@sentry/node/build/esm/sdk/client.js
var import_api24 = __toESM(require_src(), 1);
import * as os2 from "os";
import { isMainThread, threadId } from "worker_threads";
var DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60000;

class NodeClient extends ServerRuntimeClient {
  constructor(options) {
    const clientOptions = {
      ...options,
      platform: "node",
      runtime: { name: "node", version: global.process.version },
      serverName: options.serverName || global.process.env.SENTRY_NAME || os2.hostname()
    };
    applySdkMetadata(clientOptions, "node");
    logger.log(`Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? "main" : `worker-${threadId}`}.`);
    super(clientOptions);
  }
  get tracer() {
    if (this._tracer) {
      return this._tracer;
    }
    const name = "@sentry/node";
    const version = SDK_VERSION;
    const tracer = import_api24.trace.getTracer(name, version);
    this._tracer = tracer;
    return tracer;
  }
  async flush(timeout) {
    const provider = this.traceProvider;
    const spanProcessor = _optionalChain([provider, "optionalAccess", (_) => _.activeSpanProcessor]);
    if (spanProcessor) {
      await spanProcessor.forceFlush();
    }
    if (this.getOptions().sendClientReports) {
      this._flushOutcomes();
    }
    return super.flush(timeout);
  }
  close(timeout) {
    if (this._clientReportInterval) {
      clearInterval(this._clientReportInterval);
    }
    if (this._clientReportOnExitFlushListener) {
      process.off("beforeExit", this._clientReportOnExitFlushListener);
    }
    return super.close(timeout);
  }
  startClientReportTracking() {
    const clientOptions = this.getOptions();
    if (clientOptions.sendClientReports) {
      this._clientReportOnExitFlushListener = () => {
        this._flushOutcomes();
      };
      this._clientReportInterval = setInterval(() => {
        DEBUG_BUILD4 && logger.log("Flushing client reports based on interval.");
        this._flushOutcomes();
      }, _nullishCoalesce(clientOptions.clientReportFlushInterval, () => DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)).unref();
      process.on("beforeExit", this._clientReportOnExitFlushListener);
    }
  }
}

// ../node_modules/@sentry/node/build/esm/sdk/initOtel.js
var import_api25 = __toESM(require_src(), 1);
import moduleModule from "module";
var import_semantic_conventions6 = __toESM(require_src2(), 1);
var import_import_in_the_middle2 = __toESM(require_import_in_the_middle(), 1);
function initOpenTelemetry(client) {
  if (client.getOptions().debug) {
    setupOpenTelemetryLogger();
  }
  const provider = setupOtel(client);
  client.traceProvider = provider;
}
function getRegisterOptions(esmHookConfig) {
  if (_optionalChain([esmHookConfig, "optionalAccess", (_) => _.onlyIncludeInstrumentedModules])) {
    const { addHookMessagePort } = import_import_in_the_middle2.createAddHookMessageChannel();
    return { data: { addHookMessagePort, include: esmHookConfig.include || [] }, transferList: [addHookMessagePort] };
  }
  return { data: esmHookConfig };
}
function maybeInitializeEsmLoader(esmHookConfig) {
  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split(".").map(Number);
  if (nodeMajor >= 22 || nodeMajor === 20 && nodeMinor >= 6 || nodeMajor === 18 && nodeMinor >= 19) {
    const importMetaUrl = typeof import.meta.url !== "undefined" ? import.meta.url : undefined;
    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered && importMetaUrl) {
      try {
        moduleModule.register("import-in-the-middle/hook.mjs", importMetaUrl, getRegisterOptions(esmHookConfig));
        GLOBAL_OBJ._sentryEsmLoaderHookRegistered = true;
      } catch (error) {
        logger.warn("Failed to register ESM hook", error);
      }
    }
  } else {
    consoleSandbox(() => {
      console.warn('[Sentry] You are using Node.js in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or use version 7.x of the Sentry Node.js SDK.');
    });
  }
}
function setupOtel(client) {
  const provider = new BasicTracerProvider({
    sampler: new SentrySampler(client),
    resource: new Resource({
      [import_semantic_conventions6.ATTR_SERVICE_NAME]: "node",
      [import_semantic_conventions6.SEMRESATTRS_SERVICE_NAMESPACE]: "sentry",
      [import_semantic_conventions6.ATTR_SERVICE_VERSION]: SDK_VERSION
    }),
    forceFlushTimeoutMillis: 500
  });
  provider.addSpanProcessor(new SentrySpanProcessor({
    timeout: client.getOptions().maxSpanWaitDuration
  }));
  provider.register({
    propagator: new SentryPropagator,
    contextManager: new SentryContextManager
  });
  return provider;
}
function setupOpenTelemetryLogger() {
  const otelLogger = new Proxy(logger, {
    get(target, prop, receiver) {
      const actualProp = prop === "verbose" ? "debug" : prop;
      return Reflect.get(target, actualProp, receiver);
    }
  });
  import_api25.diag.disable();
  import_api25.diag.setLogger(otelLogger, import_api25.DiagLogLevel.DEBUG);
}

// ../node_modules/@sentry/node/build/esm/sdk/index.js
function getCjsOnlyIntegrations() {
  return isCjs() ? [modulesIntegration()] : [];
}
function getDefaultIntegrationsWithoutPerformance() {
  return [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    contextLinesIntegration(),
    localVariablesIntegration(),
    nodeContextIntegration(),
    ...getCjsOnlyIntegrations()
  ];
}
function getDefaultIntegrations(options) {
  return [
    ...getDefaultIntegrationsWithoutPerformance(),
    ...shouldAddPerformanceIntegrations(options) ? getAutoPerformanceIntegrations() : []
  ];
}
function shouldAddPerformanceIntegrations(options) {
  if (!hasTracingEnabled(options)) {
    return false;
  }
  return options.enableTracing || options.tracesSampleRate != null || "tracesSampler" in options;
}
function init(options = {}) {
  return _init(options, getDefaultIntegrations);
}
function _init(_options = {}, getDefaultIntegrationsImpl) {
  const options = getClientOptions(_options, getDefaultIntegrationsImpl);
  if (options.debug === true) {
    if (DEBUG_BUILD4) {
      logger.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  if (!isCjs() && options.registerEsmLoaderHooks !== false) {
    maybeInitializeEsmLoader(options.registerEsmLoaderHooks === true ? undefined : options.registerEsmLoaderHooks);
  }
  setOpenTelemetryContextAsyncContextStrategy();
  const scope = getCurrentScope();
  scope.update(options.initialScope);
  if (options.spotlight && !options.integrations.some(({ name }) => name === INTEGRATION_NAME27)) {
    options.integrations.push(spotlightIntegration({
      sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : undefined
    }));
  }
  const client = new NodeClient(options);
  getCurrentScope().setClient(client);
  client.init();
  logger.log(`Running in ${isCjs() ? "CommonJS" : "ESM"} mode.`);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
  client.startClientReportTracking();
  updateScopeFromEnvVariables();
  if (!options.skipOpenTelemetrySetup) {
    initOpenTelemetry(client);
    validateOpenTelemetrySetup();
  }
  enhanceDscWithOpenTelemetryRootSpanName(client);
  setupEventContextTrace(client);
  return client;
}
function validateOpenTelemetrySetup() {
  if (!DEBUG_BUILD4) {
    return;
  }
  const setup = openTelemetrySetupCheck();
  const required = ["SentryContextManager", "SentryPropagator"];
  if (hasTracingEnabled()) {
    required.push("SentrySpanProcessor");
  }
  for (const k of required) {
    if (!setup.includes(k)) {
      logger.error(`You have to set up the ${k}. Without this, the OpenTelemetry & Sentry integration will not work properly.`);
    }
  }
  if (!setup.includes("SentrySampler")) {
    logger.warn("You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`.");
  }
}
function getClientOptions(options, getDefaultIntegrationsImpl) {
  const release2 = getRelease(options.release);
  const autoSessionTracking = typeof release2 !== "string" ? false : options.autoSessionTracking === undefined ? true : options.autoSessionTracking;
  if (options.spotlight == null) {
    const spotlightEnv = envToBool(process.env.SENTRY_SPOTLIGHT, { strict: true });
    if (spotlightEnv == null) {
      options.spotlight = process.env.SENTRY_SPOTLIGHT;
    } else {
      options.spotlight = spotlightEnv;
    }
  }
  const tracesSampleRate = getTracesSampleRate(options.tracesSampleRate);
  const baseOptions = dropUndefinedKeys({
    transport: makeNodeTransport,
    dsn: "https://9004e3d18c188b64157d782a6006bebe@o4507951796322304.ingest.us.sentry.io/4507951803662336",
    environment: process.env.SENTRY_ENVIRONMENT,
    sendClientReports: true
  });
  const overwriteOptions = dropUndefinedKeys({
    release: release2,
    autoSessionTracking,
    tracesSampleRate
  });
  const mergedOptions = {
    ...baseOptions,
    ...options,
    ...overwriteOptions
  };
  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = getDefaultIntegrationsImpl(mergedOptions);
  }
  const clientOptions = {
    ...mergedOptions,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup({
      defaultIntegrations: options.defaultIntegrations,
      integrations: options.integrations
    })
  };
  return clientOptions;
}
function getRelease(release2) {
  if (release2 !== undefined) {
    return release2;
  }
  const detectedRelease = getSentryRelease();
  if (detectedRelease !== undefined) {
    return detectedRelease;
  }
  return;
}
function getTracesSampleRate(tracesSampleRate) {
  if (tracesSampleRate !== undefined) {
    return tracesSampleRate;
  }
  const sampleRateFromEnv = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (!sampleRateFromEnv) {
    return;
  }
  const parsed = parseFloat(sampleRateFromEnv);
  return isFinite(parsed) ? parsed : undefined;
}
function updateScopeFromEnvVariables() {
  if (envToBool(process.env.SENTRY_USE_ENVIRONMENT) !== false) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const propagationContext = propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentScope().setPropagationContext(propagationContext);
  }
}
function startSessionTracking() {
  const client = getClient();
  if (client && client.getOptions().autoSessionTracking) {
    client.initSessionFlusher();
  }
  startSession();
  process.on("beforeExit", () => {
    const session = getIsolationScope().getSession();
    if (session && session.status !== "ok") {
      endSession();
    }
  });
}
// ../node_modules/@sentry/bun/build/esm/client.js
import * as os3 from "os";
class BunClient extends ServerRuntimeClient {
  constructor(options) {
    applySdkMetadata(options, "bun");
    const clientOptions = {
      ...options,
      platform: "javascript",
      runtime: { name: "bun", version: Bun.version },
      serverName: options.serverName || global.process.env.SENTRY_NAME || os3.hostname()
    };
    super(clientOptions);
  }
}

// ../node_modules/@sentry/bun/build/esm/integrations/bunserver.js
var INTEGRATION_NAME31 = "BunServer";
var _bunServerIntegration = () => {
  return {
    name: INTEGRATION_NAME31,
    setupOnce() {
      instrumentBunServe();
    }
  };
};
var bunServerIntegration = defineIntegration(_bunServerIntegration);
function instrumentBunServe() {
  Bun.serve = new Proxy(Bun.serve, {
    apply(serveTarget, serveThisArg, serveArgs) {
      instrumentBunServeOptions(serveArgs[0]);
      return serveTarget.apply(serveThisArg, serveArgs);
    }
  });
}
function instrumentBunServeOptions(serveOptions) {
  serveOptions.fetch = new Proxy(serveOptions.fetch, {
    apply(fetchTarget, fetchThisArg, fetchArgs) {
      return withIsolationScope2((isolationScope) => {
        const request = fetchArgs[0];
        const upperCaseMethod = request.method.toUpperCase();
        if (upperCaseMethod === "OPTIONS" || upperCaseMethod === "HEAD") {
          return fetchTarget.apply(fetchThisArg, fetchArgs);
        }
        const parsedUrl = parseUrl(request.url);
        const attributes = {
          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.bun.serve",
          [SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: request.method || "GET",
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
        };
        if (parsedUrl.search) {
          attributes["http.query"] = parsedUrl.search;
        }
        const url = getSanitizedUrlString(parsedUrl);
        isolationScope.setSDKProcessingMetadata({
          request: {
            url,
            method: request.method,
            headers: request.headers.toJSON()
          }
        });
        return continueTrace({ sentryTrace: request.headers.get("sentry-trace") || "", baggage: request.headers.get("baggage") }, () => {
          return startSpan({
            attributes,
            op: "http.server",
            name: `${request.method} ${parsedUrl.path || "/"}`
          }, async (span) => {
            try {
              const response = await fetchTarget.apply(fetchThisArg, fetchArgs);
              if (response && response.status) {
                setHttpStatus(span, response.status);
                isolationScope.setContext("response", {
                  headers: response.headers.toJSON(),
                  status_code: response.status
                });
              }
              return response;
            } catch (e) {
              captureException(e, {
                mechanism: {
                  type: "bun",
                  handled: false,
                  data: {
                    function: "serve"
                  }
                }
              });
              throw e;
            }
          });
        });
      });
    }
  });
}

// ../node_modules/@sentry/bun/build/esm/transports/index.js
function makeFetchTransport(options) {
  function makeRequest(request) {
    const requestOptions = {
      body: request.body,
      method: "POST",
      headers: options.headers
    };
    try {
      return suppressTracing(() => {
        return fetch(options.url, requestOptions).then((response) => {
          return {
            statusCode: response.status,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            }
          };
        });
      });
    } catch (e) {
      return rejectedSyncPromise(e);
    }
  }
  return createTransport(options, makeRequest);
}

// ../node_modules/@sentry/bun/build/esm/sdk.js
function getDefaultIntegrations2(_options) {
  return [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    contextLinesIntegration(),
    nodeContextIntegration(),
    modulesIntegration(),
    bunServerIntegration()
  ];
}
function init2(options = {}) {
  options.clientClass = BunClient;
  options.transport = options.transport || makeFetchTransport;
  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = getDefaultIntegrations2();
  }
  return init(options);
}
// src/env.ts
var isProd = true;
var DATABASE_URL = process.env["DATABASE_URL"];
var AMAZON_ACCESS_KEY = process.env["AMAZON_ACCESS_KEY"];
var AMAZON_SECRET_ACCESS_KEY = process.env["AMAZON_SECRET_ACCESS_KEY"];
var TWILIO_AUTH_TOKEN = process.env["TWILIO_AUTH_TOKEN"];
var TWILIO_SID = process.env["TWILIO_SID"];
var TWILIO_VERIFY_SERVICE_SID = process.env["TWILIO_VERIFY_SERVICE_SID"];
var SENTRY_DSN = process.env["SENTRY_DSN"];
var RESEND_API_KEY = process.env["RESEND_API_KEY"];
var IPINFO_TOKEN = process.env["IPINFO_TOKEN"];
var requiredProductionVariables = [
  "DATABASE_URL",
  "AMAZON_ACCESS_KEY",
  "AMAZON_SECRET_ACCESS_KEY",
  "TWILIO_SID",
  "TWILIO_VERIFY_SERVICE_SID",
  "SENTRY_DSN",
  "RESEND_API_KEY"
];
for (const variable of requiredProductionVariables) {
  if (!process.env[variable]) {
    if (isProd) {
      throw new Error(`Required production variable ${variable} is not defined.`);
    } else {
      console.warn(`Env variable ${variable} is not defined.`);
    }
  }
}
var optionalVariables = ["TWILIO_AUTH_TOKEN", "TWILIO_SID", "TWILIO_VERIFY_SERVICE_SID", "SENTRY_DSN", "IPINFO_TOKEN"];
optionalVariables.forEach((variable) => {
  if (!process.env[variable] && isProd) {
    console.warn(`${variable} env variable is not defined.`);
  }
});

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject2 = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format2) {
  return map.delete(format2);
}
function Has(format2) {
  return map.has(format2);
}
function Set2(format2, func) {
  map.set(format2, func);
}
function Get(format2) {
  return map.get(format2);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format2, check) {
    if (exports_format.Has(format2))
      throw new TypeSystemDuplicateFormat(format2);
    exports_format.Set(format2, check);
    return format2;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator2(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator2(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator2(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator2(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})\$`;
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path3, value) {
  return { type: errorType, schema, path: path3, value, message: GetErrorFunction()({ errorType, path: path3, schema, value }) };
}
function* FromAny(schema, references, path3, value) {
}
function* FromArray3(schema, references, path3, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path3, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path3, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path3, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path3}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path3, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path3}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path3, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path3, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path3, value);
  }
}
function* FromAsyncIterator(schema, references, path3, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path3, value);
}
function* FromBigInt(schema, references, path3, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path3, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path3, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path3, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path3, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path3, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path3, value);
  }
}
function* FromBoolean(schema, references, path3, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path3, value);
}
function* FromConstructor(schema, references, path3, value) {
  yield* Visit4(schema.returns, references, path3, value.prototype);
}
function* FromDate(schema, references, path3, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path3, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path3, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path3, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path3, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path3, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path3, value);
  }
}
function* FromFunction(schema, references, path3, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path3, value);
}
function* FromInteger(schema, references, path3, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path3, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path3, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path3, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path3, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path3, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path3, value);
  }
}
function* FromIntersect3(schema, references, path3, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path3, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path3, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path3}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path3}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path3, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path3, value);
}
function* FromLiteral2(schema, references, path3, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path3, value);
}
function* FromNever(schema, references, path3, value) {
  yield Create(ValueErrorType.Never, schema, path3, value);
}
function* FromNot(schema, references, path3, value) {
  if (Visit4(schema.not, references, path3, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path3, value);
}
function* FromNull(schema, references, path3, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path3, value);
}
function* FromNumber(schema, references, path3, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path3, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path3, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path3, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path3, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path3, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path3, value);
  }
}
function* FromObject(schema, references, path3, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path3, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path3, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path3, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path3}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path3}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path3}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path3}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path3}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path3}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path3, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path3, value);
}
function* FromRecord(schema, references, path3, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path3, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path3, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path3, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path3}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path3}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path3}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path3, value) {
  yield* Visit4(Deref(schema, references), references, path3, value);
}
function* FromRegExp(schema, references, path3, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path3, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path3, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path3, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path3, value);
  }
}
function* FromString(schema, references, path3, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path3, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path3, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path3, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path3, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path3, value);
    } else {
      const format2 = exports_format.Get(schema.format);
      if (!format2(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path3, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path3, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path3, value);
}
function* FromTemplateLiteral2(schema, references, path3, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path3, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path3, value);
  }
}
function* FromThis(schema, references, path3, value) {
  yield* Visit4(Deref(schema, references), references, path3, value);
}
function* FromTuple3(schema, references, path3, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path3, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path3, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path3, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path3}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path3, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path3, value);
}
function* FromUnion5(schema, references, path3, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path3, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path3, value);
  }
}
function* FromUint8Array(schema, references, path3, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path3, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path3, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path3, value);
  }
}
function* FromUnknown(schema, references, path3, value) {
}
function* FromVoid(schema, references, path3, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path3, value);
}
function* FromKind(schema, references, path3, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path3, value);
}
function* Visit4(schema, references, path3, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path3, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path3, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path3, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path3, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path3, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path3, value);
    case "Date":
      return yield* FromDate(schema_, references_, path3, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path3, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path3, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path3, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path3, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path3, value);
    case "Never":
      return yield* FromNever(schema_, references_, path3, value);
    case "Not":
      return yield* FromNot(schema_, references_, path3, value);
    case "Null":
      return yield* FromNull(schema_, references_, path3, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path3, value);
    case "Object":
      return yield* FromObject(schema_, references_, path3, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path3, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path3, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path3, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path3, value);
    case "String":
      return yield* FromString(schema_, references_, path3, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path3, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path3, value);
    case "This":
      return yield* FromThis(schema_, references_, path3, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path3, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path3, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path3, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path3, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path3, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path3, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path3, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val2] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val2;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union3, references, value) {
  const schemas = union3.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union3, references, value) {
  if ("default" in union3) {
    return typeof value === "function" ? union3.default : Clone2(union3.default);
  } else {
    const schema = SelectUnion(union3, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path3, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path3;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path3) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path3;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
function CreateUpdate(path3, value) {
  return { type: "update", path: path3, value };
}
function CreateInsert(path3, value) {
  return { type: "insert", path: path3, value };
}
function CreateDelete(path3) {
  return { type: "delete", path: path3 };
}
function* ObjectType4(path3, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path3, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path3}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path3}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path3}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path3}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path3, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path3, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path3}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path3}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path3}/${i}`);
  }
}
function* TypedArrayType2(path3, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path3, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path3}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path3, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path3, next);
}
function* Visit12(path3, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path3, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path3, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path3, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path3, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType6(root, path3, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path3, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path3}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path3, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path3, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path3}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path3, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path3, Clone2(next));
  }
}
function ValueType4(root, path3, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path3, next);
}
function Visit13(root, path3, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path3, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path3, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path3, current, next);
  if (IsValueType(next))
    return ValueType4(root, path3, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path3, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path3;
    this.value = value;
    this.error = error2;
  }
}
function Default4(schema, path3, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path3, value, error2);
  }
}
function FromArray11(schema, references, path3, value) {
  return IsArray(value) ? Default4(schema, path3, value.map((value2, index) => Visit14(schema.items, references, `${path3}/${index}`, value2))) : Default4(schema, path3, value);
}
function FromIntersect11(schema, references, path3, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path3, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path3}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path3, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path3}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path3, unknownProperties);
}
function FromNot5(schema, references, path3, value) {
  return Default4(schema, path3, Visit14(schema.not, references, path3, value));
}
function FromObject9(schema, references, path3, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path3, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path3}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path3, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path3}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path3, unknownProperties);
}
function FromRecord9(schema, references, path3, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path3, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path3}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path3, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path3}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path3, unknownProperties);
}
function FromRef8(schema, references, path3, value) {
  const target = Deref(schema, references);
  return Default4(schema, path3, Visit14(target, references, path3, value));
}
function FromThis8(schema, references, path3, value) {
  const target = Deref(schema, references);
  return Default4(schema, path3, Visit14(target, references, path3, value));
}
function FromTuple11(schema, references, path3, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path3, schema.items.map((schema2, index) => Visit14(schema2, references, `${path3}/${index}`, value[index]))) : Default4(schema, path3, value);
}
function FromUnion13(schema, references, path3, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path3, value);
    return Default4(schema, path3, decoded);
  }
  return Default4(schema, path3, value);
}
function Visit14(schema, references, path3, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path3, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path3, value);
    case "Not":
      return FromNot5(schema_, references_, path3, value);
    case "Object":
      return FromObject9(schema_, references_, path3, value);
    case "Record":
      return FromRecord9(schema_, references_, path3, value);
    case "Ref":
      return FromRef8(schema_, references_, path3, value);
    case "Symbol":
      return Default4(schema_, path3, value);
    case "This":
      return FromThis8(schema_, references_, path3, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path3, value);
    case "Union":
      return FromUnion13(schema_, references_, path3, value);
    default:
      return Default4(schema_, path3, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path3, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path3;
    this.value = value;
    this.error = error2;
  }
}
function Default5(schema, path3, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path3, value, error2);
  }
}
function FromArray12(schema, references, path3, value) {
  const defaulted = Default5(schema, path3, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path3}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path3, value) {
  const defaulted = Default5(schema, path3, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path3}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path3, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path3}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path3, value) {
  return Default5(schema.not, path3, Default5(schema, path3, value));
}
function FromObject10(schema, references, path3, value) {
  const defaulted = Default5(schema, path3, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path3}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path3}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path3, value) {
  const defaulted = Default5(schema, path3, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path3}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path3, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path3}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path3, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path3, value);
  return Default5(schema, path3, resolved);
}
function FromThis9(schema, references, path3, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path3, value);
  return Default5(schema, path3, resolved);
}
function FromTuple12(schema, references, path3, value) {
  const value1 = Default5(schema, path3, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path3}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path3, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path3, value);
    return Default5(schema, path3, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path3, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path3, value1);
  }
  return Default5(schema, path3, value);
}
function Visit15(schema, references, path3, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path3, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path3, value);
    case "Not":
      return FromNot6(schema_, references_, path3, value);
    case "Object":
      return FromObject10(schema_, references_, path3, value);
    case "Record":
      return FromRecord10(schema_, references_, path3, value);
    case "Ref":
      return FromRef9(schema_, references_, path3, value);
    case "This":
      return FromThis9(schema_, references_, path3, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path3, value);
    case "Union":
      return FromUnion14(schema_, references_, path3, value);
    default:
      return Default5(schema_, path3, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union3 = Union(mapped2);
  return TemplateLiteral([union3], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator2,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator2,
  Array: () => Array2,
  Any: () => Any
});

// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// ../node_modules/elysia/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format2, value2) {
      if (!exports_format.Has(format2))
        return false;
      const checkFunc = exports_format.Get(format2);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// ../node_modules/elysia/dist/bun/index.js
var L1 = Object.create;
var { getPrototypeOf: T1, defineProperty: k2, getOwnPropertyNames: E1 } = Object;
var q1 = Object.prototype.hasOwnProperty;
var U2 = ($, W, X) => {
  X = $ != null ? L1(T1($)) : {};
  const Z = W || !$ || !$.__esModule ? k2(X, "default", { value: $, enumerable: true }) : X;
  for (let j of E1($))
    if (!q1.call(Z, j))
      k2(Z, j, { get: () => $[j], enumerable: true });
  return Z;
};
var H1 = ($, W) => () => (W || $((W = { exports: {} }).exports, W), W.exports);
var o0 = H1((G8, $1) => {
  function _3($) {
    var W = $.indexOf("%");
    if (W === -1)
      return $;
    var X = $.length, Z = "", j = 0, J = 0, Y = W, G = o2;
    while (W > -1 && W < X) {
      var K = e2($[W + 1], 4), B = e2($[W + 2], 0), U = K | B, w = N2[U];
      if (G = N2[256 + G + w], J = J << 6 | U & N2[364 + w], G === o2)
        Z += $.slice(j, Y), Z += J <= 65535 ? String.fromCharCode(J) : String.fromCharCode(55232 + (J >> 10), 56320 + (J & 1023)), J = 0, j = W + 3, W = Y = $.indexOf("%", j);
      else if (G === w3)
        return null;
      else {
        if (W += 3, W < X && $.charCodeAt(W) === 37)
          continue;
        return null;
      }
    }
    return Z + $.slice(j);
  }
  function e2($, W) {
    var X = F3[$];
    return X === undefined ? 255 : X << W;
  }
  var o2 = 12, w3 = 0, N2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], F3 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  $1.exports = _3;
});
var T0 = ($, W) => {
  const X = W?.length ? {} : null;
  if (X)
    for (let Z of W)
      X[Z.part.charCodeAt(0)] = Z;
  return { part: $, store: null, inert: X, params: null, wildcardStore: null };
};
var v2 = ($, W) => ({ ...$, part: W });
var u2 = ($) => ({ name: $, store: null, inert: null });

class M0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add($, W, X, { ignoreError: Z = false, ignoreHistory: j = false } = {}) {
    if (typeof W !== "string")
      throw new TypeError("Route path must be a string");
    if (W === "")
      W = "/";
    else if (W[0] !== "/")
      W = `/${W}`;
    const J = W[W.length - 1] === "*", Y = W.match(M0.regex.optionalParams);
    if (Y) {
      const w = W.replaceAll("?", "");
      this.add($, w, X, { ignoreError: Z });
      for (let F = 0;F < Y.length; F++) {
        let Q = W.replace("/" + Y[F], "");
        this.add($, Q, X, { ignoreError: true });
      }
      return X;
    }
    if (Y)
      W = W.replaceAll("?", "");
    if (this.history.find(([w, F, Q]) => w === $ && F === W))
      return X;
    if (J || Y && W.charCodeAt(W.length - 1) === 63)
      W = W.slice(0, -1);
    if (!j)
      this.history.push([$, W, X]);
    const G = W.split(M0.regex.static), K = W.match(M0.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let B;
    if (!this.root[$])
      B = this.root[$] = T0("/");
    else
      B = this.root[$];
    let U = 0;
    for (let w = 0;w < G.length; ++w) {
      let F = G[w];
      if (w > 0) {
        const Q = K[U++].slice(1);
        if (B.params === null)
          B.params = u2(Q);
        else if (B.params.name !== Q)
          if (Z)
            return X;
          else
            throw new Error(`Cannot create route "${W}" with parameter "${Q}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
        const z = B.params;
        if (z.inert === null) {
          B = z.inert = T0(F);
          continue;
        }
        B = z.inert;
      }
      for (let Q = 0;; ) {
        if (Q === F.length) {
          if (Q < B.part.length) {
            const z = v2(B, B.part.slice(Q));
            Object.assign(B, T0(F, [z]));
          }
          break;
        }
        if (Q === B.part.length) {
          if (B.inert === null)
            B.inert = {};
          const z = B.inert[F.charCodeAt(Q)];
          if (z) {
            B = z, F = F.slice(Q), Q = 0;
            continue;
          }
          const D = T0(F.slice(Q));
          B.inert[F.charCodeAt(Q)] = D, B = D;
          break;
        }
        if (F[Q] !== B.part[Q]) {
          const z = v2(B, B.part.slice(Q)), D = T0(F.slice(Q));
          Object.assign(B, T0(B.part.slice(0, Q), [z, D])), B = D;
          break;
        }
        ++Q;
      }
    }
    if (U < K.length) {
      const w = K[U].slice(1);
      if (B.params === null)
        B.params = u2(w);
      else if (B.params.name !== w)
        if (Z)
          return X;
        else
          throw new Error(`Cannot create route "${W}" with parameter "${w}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
      if (B.params.store === null)
        B.params.store = X;
      return B.params.store;
    }
    if (J) {
      if (B.wildcardStore === null)
        B.wildcardStore = X;
      return B.wildcardStore;
    }
    if (B.store === null)
      B.store = X;
    return B.store;
  }
  find($, W) {
    const X = this.root[$];
    if (!X)
      return null;
    return w2(W, W.length, X, 0);
  }
}
var w2 = ($, W, X, Z) => {
  const j = X.part, J = j.length, Y = Z + J;
  if (J > 1) {
    if (Y > W)
      return null;
    if (J < 15) {
      for (let G = 1, K = Z + 1;G < J; ++G, ++K)
        if (j.charCodeAt(G) !== $.charCodeAt(K))
          return null;
    } else if ($.slice(Z, Y) !== j)
      return null;
  }
  if (Y === W) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const G = X.inert[$.charCodeAt(Y)];
    if (G !== undefined) {
      const K = w2($, W, G, Y);
      if (K !== null)
        return K;
    }
  }
  if (X.params !== null) {
    const { store: G, name: K, inert: B } = X.params, U = $.indexOf("/", Y);
    if (U !== Y) {
      if (U === -1 || U >= W) {
        if (G !== null) {
          const w = {};
          return w[K] = $.substring(Y, W), { store: G, params: w };
        }
      } else if (B !== null) {
        const w = w2($, W, B, U);
        if (w !== null)
          return w.params[K] = $.substring(Y, U), w;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Y, W) } };
  return null;
};
var E0 = ($) => {
  const W = typeof $ === "object" ? $.fn.toString() : typeof $ === "string" ? $.toString() : $, X = W.indexOf(")");
  if (W.charCodeAt(X + 2) === 61 && W.charCodeAt(X + 5) !== 123)
    return true;
  return W.includes("return");
};
var R1 = ($) => {
  if ($.startsWith("async"))
    $ = $.slice(5);
  $ = $.trimStart();
  let W = -1;
  if ($.charCodeAt(0) === 40) {
    if (W = $.indexOf("=>", $.indexOf(")")), W !== -1) {
      let j = W;
      while (j > 0)
        if ($.charCodeAt(--j) === 41)
          break;
      let J = $.slice(W + 2);
      if (J.charCodeAt(0) === 32)
        J = J.trimStart();
      return [$.slice(1, j), J, { isArrowReturn: J.charCodeAt(0) !== 123 }];
    }
  }
  if ($.startsWith("function")) {
    W = $.indexOf("(");
    const j = $.indexOf(")");
    return [$.slice(W + 1, j), $.slice(j + 2), { isArrowReturn: false }];
  }
  const X = $.indexOf("(");
  if (X !== -1) {
    const j = $.indexOf("\n", 2), J = $.slice(0, j), Y = J.lastIndexOf(")") + 1, G = $.slice(j + 1);
    return [J.slice(X, Y), "{" + G, { isArrowReturn: false }];
  }
  const Z = $.split("\n", 2);
  return [Z[0], Z[1], { isArrowReturn: false }];
};
var b1 = ($) => {
  const W = $.indexOf("{");
  if (W === -1)
    return [-1, 0];
  let X = W + 1, Z = 1;
  for (;X < $.length; X++) {
    const j = $.charCodeAt(X);
    if (j === 123)
      Z++;
    else if (j === 125)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [0, $.length];
  return [W, X + 1];
};
var x1 = ($) => {
  const W = $.lastIndexOf("}");
  if (W === -1)
    return [-1, 0];
  let X = W - 1, Z = 1;
  for (;X >= 0; X--) {
    const j = $.charCodeAt(X);
    if (j === 125)
      Z++;
    else if (j === 123)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [-1, 0];
  return [X, W + 1];
};
var h2 = ($) => {
  while (true) {
    const W = $.indexOf(":");
    if (W === -1)
      break;
    let X = $.indexOf(",", W);
    if (X === -1)
      X = $.indexOf("}", W) - 1;
    if (X === -2)
      X = $.length;
    $ = $.slice(0, W) + $.slice(X);
  }
  return $;
};
var m2 = ($) => {
  let W = false;
  if ($.charCodeAt(0) === 40)
    $ = $.slice(1, -1);
  if ($.charCodeAt(0) === 123)
    W = true, $ = $.slice(1, -1);
  $ = $.replace(/( |\t|\n)/g, "").trim();
  let X = [];
  while (true) {
    let [j, J] = b1($);
    if (j === -1)
      break;
    if (X.push($.slice(0, j - 1)), $.charCodeAt(J) === 44)
      J++;
    $ = $.slice(J);
  }
  if ($ = h2($), $)
    X = X.concat($.split(","));
  const Z = [];
  for (let j of X) {
    if (j.indexOf(",") === -1) {
      Z.push(j);
      continue;
    }
    for (let J of j.split(","))
      Z.push(J.trim());
  }
  return X = Z, { hasParenthesis: W, parameters: X };
};
var g1 = ($, W) => {
  const { parameters: X, hasParenthesis: Z } = m2($);
  if (!W.query && X.includes("query"))
    W.query = true;
  if (!W.headers && X.includes("headers"))
    W.headers = true;
  if (!W.body && X.includes("body"))
    W.body = true;
  if (!W.cookie && X.includes("cookie"))
    W.cookie = true;
  if (!W.set && X.includes("set"))
    W.set = true;
  if (!W.server && X.includes("server"))
    W.server = true;
  if (Z)
    return `{ ${X.join(", ")} }`;
  return X.join(", ");
};
var f1 = ($, W, X) => {
  const Z = W.indexOf($ + "\n", X), j = W.indexOf($ + "\t", X), J = W.indexOf($ + ",", X), Y = W.indexOf($ + ";", X), G = W.indexOf($ + " ", X);
  return [Z, j, J, Y, G].filter((K) => K > 0).sort((K, B) => K - B)[0] || -1;
};
var d2 = ($, W, X = 0) => {
  if (X > 5)
    return [];
  const Z = [];
  let j = W;
  while (true) {
    let J = f1(" = " + $, j);
    if (J === -1) {
      const K = j.indexOf(" = " + $);
      if (K + 3 + $.length !== j.length)
        break;
      J = K;
    }
    const Y = j.slice(0, J);
    let G = Y.slice(Y.lastIndexOf(" ") + 1);
    if (G === "}") {
      const [K, B] = x1(Y);
      Z.push(h2(j.slice(K, B))), j = j.slice(J + 3 + $.length);
      continue;
    }
    while (G.charCodeAt(0) === 44)
      G = G.slice(1);
    while (G.charCodeAt(0) === 9)
      G = G.slice(1);
    if (!G.includes("("))
      Z.push(G);
    j = j.slice(J + 3 + $.length);
  }
  for (let J of Z) {
    if (J.charCodeAt(0) === 123)
      continue;
    const Y = d2(J, W);
    if (Y.length > 0)
      Z.push(...Y);
  }
  return Z;
};
var y1 = ($) => {
  if (!$)
    return;
  if ($.charCodeAt(0) !== 123)
    return $;
  if ($ = $.slice(2, -2), !$.includes(",")) {
    if ($.includes("..."))
      return $.slice($.indexOf("...") + 3);
    return;
  }
  const X = $.indexOf("...");
  if (X === -1)
    return;
  return $.slice(X + 3).trimEnd();
};
var k1 = ($, W, X) => {
  const Z = (j, J) => $.includes(J + "." + j) || $.includes(J + '["' + j + '"]') || $.includes(J + "['" + j + "']");
  for (let j of W) {
    if (!j)
      continue;
    if (j.charCodeAt(0) === 123) {
      const J = m2(j).parameters;
      if (!X.query && J.includes("query"))
        X.query = true;
      if (!X.headers && J.includes("headers"))
        X.headers = true;
      if (!X.body && J.includes("body"))
        X.body = true;
      if (!X.cookie && J.includes("cookie"))
        X.cookie = true;
      if (!X.set && J.includes("set"))
        X.set = true;
      if (!X.query && J.includes("server"))
        X.server = true;
      continue;
    }
    if (!X.query && Z("query", j))
      X.query = true;
    if ($.includes("return " + j) || $.includes("return " + j + ".query"))
      X.query = true;
    if (!X.headers && Z("headers", j))
      X.headers = true;
    if (!X.body && Z("body", j))
      X.body = true;
    if (!X.cookie && Z("cookie", j))
      X.cookie = true;
    if (!X.set && Z("set", j))
      X.set = true;
    if (!X.server && Z("server", j))
      X.server = true;
    if (X.query && X.headers && X.body && X.cookie && X.set && X.server)
      break;
  }
  return W;
};
var v1 = ($, W, X) => {
  try {
    const Z = new RegExp(`(?:\\w)\\((?:.*)?${$}`, "gs");
    Z.test(W);
    const j = W.charCodeAt(Z.lastIndex);
    if (j === 41 || j === 44)
      return X.query = true, X.headers = true, X.body = true, X.cookie = true, X.set = true, X.server = true, true;
    return false;
  } catch (Z) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(W), console.log("--- context ---"), console.log($), true;
  }
};
var r0 = ($, W = { query: false, headers: false, body: false, cookie: false, set: false, server: false }) => {
  const X = [];
  if ($.handler && typeof $.handler === "function")
    X.push($.handler);
  if ($.request?.length)
    X.push(...$.request);
  if ($.beforeHandle?.length)
    X.push(...$.beforeHandle);
  if ($.parse?.length)
    X.push(...$.parse);
  if ($.error?.length)
    X.push(...$.error);
  if ($.transform?.length)
    X.push(...$.transform);
  if ($.afterHandle?.length)
    X.push(...$.afterHandle);
  if ($.mapResponse?.length)
    X.push(...$.mapResponse);
  if ($.afterResponse?.length)
    X.push(...$.afterResponse);
  for (let Z of X) {
    if (!Z)
      continue;
    const j = "fn" in Z ? Z.fn : Z, [J, Y, { isArrowReturn: G }] = R1(j.toString()), K = g1(J, W), B = y1(K);
    if (B) {
      const U = d2(B, Y);
      if (U.splice(0, -1, B), !v1(B, Y, W))
        k1(Y, U, W);
      if (!W.query && Y.includes("return " + B + ".query"))
        W.query = true;
    }
    if (W.query && W.headers && W.body && W.cookie && W.set && W.server)
      break;
  }
  return W;
};
function u1($) {
  return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
function i2($) {
  const W = h1.exec($);
  if (!W)
    return false;
  const X = +W[1], Z = +W[2], j = +W[3];
  return Z >= 1 && Z <= 12 && j >= 1 && j <= (Z === 2 && u1(X) ? 29 : m1[Z]);
}
function _2($) {
  return function W(X) {
    const Z = d1.exec(X);
    if (!Z)
      return false;
    const j = +Z[1], J = +Z[2], Y = +Z[3], G = Z[4], K = Z[5] === "-" ? -1 : 1, B = +(Z[6] || 0), U = +(Z[7] || 0);
    if (B > 23 || U > 59 || $ && !G)
      return false;
    if (j <= 23 && J <= 59 && Y < 60)
      return true;
    const w = J - U * K, F = j - B * K - (w < 0 ? 1 : 0);
    return (F === 23 || F === -1) && (w === 59 || w === -1) && Y < 61;
  };
}
function c2($) {
  const W = _2($);
  return function X(Z) {
    const j = Z.split(c1);
    return j.length === 2 && i2(j[0]) && W(j[1]);
  };
}
function i1($) {
  return p1.test($) && l1.test($);
}
function n1($) {
  return p2.lastIndex = 0, p2.test($);
}
function s1($) {
  return Number.isInteger($) && $ <= r1 && $ >= t1;
}
function a1($) {
  return Number.isInteger($);
}
function l2() {
  return true;
}
function e1($) {
  if (o1.test($))
    return false;
  try {
    return new RegExp($), true;
  } catch (W) {
    return false;
  }
}
var s0 = { date: i2, time: _2(true), "date-time": c2(true), "iso-time": _2(false), "iso-date-time": c2(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: i1, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: e1, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: n1, int32: { type: "number", validate: s1 }, int64: { type: "number", validate: a1 }, float: { type: "number", validate: l2 }, double: { type: "number", validate: l2 }, password: true, binary: true };
var h1 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var m1 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var d1 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var c1 = /t|\s/i;
var p1 = /\/|:/;
var l1 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var p2 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var t1 = -2147483648;
var r1 = 2147483647;
var o1 = /[^\\]\\Z/;
var r2 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var s2 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var a2 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var W3 = s0.date;
var X3 = s0["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", ($) => {
    const W = $.replace(/"/g, "");
    if (r2.test(W) || s2.test(W) || a2.test(W) || W3(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", ($) => {
    const W = $.replace(/"/g, "");
    if (r2.test(W) || s2.test(W) || a2.test(W) || X3(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
Object.entries(s0).forEach(($) => {
  const [W, X] = $;
  if (!exports_format.Has(W)) {
    if (X instanceof RegExp)
      TypeSystem.Format(W, (Z) => X.test(Z));
    else if (typeof X === "function")
      TypeSystem.Format(W, X);
  }
});
var V = Object.assign({}, Type);
var t2 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var F2 = ($, W) => {
  if (!(W instanceof Blob))
    return false;
  if ($.minSize && W.size < t2($.minSize))
    return false;
  if ($.maxSize && W.size > t2($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (W.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var Z3 = exports_type.Get("Files") ?? TypeSystem.Type("File", F2);
var j3 = exports_type.Get("Files") ?? TypeSystem.Type("Files", ($, W) => {
  if (!Array.isArray(W))
    return F2($, W);
  if ($.minItems && W.length < $.minItems)
    return false;
  if ($.maxItems && W.length > $.maxItems)
    return false;
  for (let X = 0;X < W.length; X++)
    if (!F2($, W[X]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
exports_type.Set("UnionEnum", ($, W) => {
  return (typeof W === "number" || typeof W === "string" || W === null) && $.enum.includes(W);
});
var X0 = { Numeric: ($) => {
  const W = Type.Number($);
  return V.Transform(V.Union([V.String({ format: "numeric", default: 0 }), V.Number($)], $)).Decode((X) => {
    const Z = +X;
    if (isNaN(Z))
      return X;
    if ($ && !exports_value2.Check(W, Z))
      throw new q("property", W, Z);
    return Z;
  }).Encode((X) => X);
}, Date: ($) => {
  const W = Type.Date($);
  return V.Transform(V.Union([Type.Date($), V.String({ format: "date", default: new Date().toISOString() }), V.String({ format: "date-time", default: new Date().toISOString() })], $)).Decode((X) => {
    if (X instanceof Date)
      return X;
    const Z = new Date(X);
    if (!exports_value2.Check(W, Z))
      throw new q("property", W, Z);
    return Z;
  }).Encode((X) => {
    if (typeof X === "string")
      return new Date(X);
    return X;
  });
}, BooleanString: ($) => {
  const W = Type.Boolean($);
  return V.Transform(V.Union([V.String({ format: "boolean", default: false }), V.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(W, X))
      throw new q("property", W, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, W) => {
  const X = V.Object($, W), Z = JSON.stringify(exports_value2.Create(X));
  let j;
  try {
    j = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ObjectString", default: Z }), X])).Decode((J) => {
    if (typeof J === "string") {
      if (J.charCodeAt(0) !== 123)
        throw new q("property", X, J);
      try {
        J = JSON.parse(J);
      } catch {
        throw new q("property", X, J);
      }
      if (j) {
        if (!j.Check(J))
          throw new q("property", X, J);
        return j.Decode(J);
      }
      if (!exports_value2.Check(X, J))
        throw new q("property", X, J);
      return exports_value2.Decode(X, J);
    }
    return J;
  }).Encode((J) => {
    if (typeof J === "string")
      try {
        J = JSON.parse(J);
      } catch {
        throw new q("property", X, J);
      }
    if (!exports_value2.Check(X, J))
      throw new q("property", X, J);
    return JSON.stringify(J);
  });
}, ArrayString: ($ = {}, W) => {
  const X = V.Array($, W), Z = JSON.stringify(exports_value2.Create(X));
  let j;
  try {
    j = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ArrayString", default: Z }), X])).Decode((J) => {
    if (typeof J === "string") {
      if (J.charCodeAt(0) !== 91)
        throw new q("property", X, J);
      try {
        J = JSON.parse(J);
      } catch {
        throw new q("property", X, J);
      }
      if (j) {
        if (!j.Check(J))
          throw new q("property", X, J);
        return j.Decode(J);
      }
      if (!exports_value2.Check(X, J))
        throw new q("property", X, J);
      return exports_value2.Decode(X, J);
    }
    return J;
  }).Encode((J) => {
    if (typeof J === "string")
      try {
        J = JSON.parse(J);
      } catch {
        throw new q("property", X, J);
      }
    if (!exports_value2.Check(X, J))
      throw new q("property", X, J);
    return JSON.stringify(J);
  });
}, File: Z3, Files: ($ = {}) => V.Transform(j3($)).Decode((W) => {
  if (Array.isArray(W))
    return W;
  return [W];
}).Encode((W) => W), Nullable: ($) => V.Union([$, V.Null()]), MaybeEmpty: ($) => V.Union([$, V.Null(), V.Undefined()]), Cookie: ($, { domain: W, expires: X, httpOnly: Z, maxAge: j, path: J, priority: Y, sameSite: G, secure: K, secrets: B, sign: U, ...w } = {}) => {
  const F = V.Object($, w);
  return F.config = { domain: W, expires: X, httpOnly: Z, maxAge: j, path: J, priority: Y, sameSite: G, secure: K, secrets: B, sign: U }, F;
}, UnionEnum: ($, W = {}) => {
  const X = $.every((Z) => typeof Z === "string") ? { type: "string" } : $.every((Z) => typeof Z === "number") ? { type: "number" } : $.every((Z) => Z === null) ? { type: "null" } : {};
  if ($.some((Z) => typeof Z === "object" && Z !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: $[0], ...W, [Kind]: "UnionEnum", ...X, enum: $ };
} };
V.BooleanString = X0.BooleanString;
V.ObjectString = X0.ObjectString;
V.ArrayString = X0.ArrayString;
V.Numeric = X0.Numeric;
V.File = ($ = {}) => X0.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
V.Files = ($ = {}) => X0.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
V.Nullable = ($) => X0.Nullable($);
V.MaybeEmpty = X0.MaybeEmpty;
V.Cookie = X0.Cookie;
V.Date = X0.Date;
V.UnionEnum = X0.UnionEnum;
function Q3($, W) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, Z = W || {}, j = Z.decode || G3, J = 0;
  while (J < $.length) {
    var Y = $.indexOf("=", J);
    if (Y === -1)
      break;
    var G = $.indexOf(";", J);
    if (G === -1)
      G = $.length;
    else if (G < Y) {
      J = $.lastIndexOf(";", Y - 1) + 1;
      continue;
    }
    var K = $.slice(J, Y).trim();
    if (X[K] === undefined) {
      var B = $.slice(Y + 1, G).trim();
      if (B.charCodeAt(0) === 34)
        B = B.slice(1, -1);
      X[K] = U3(B, j);
    }
    J = G + 1;
  }
  return X;
}
function Y3($, W, X) {
  var Z = X || {}, j = Z.encode || B3;
  if (typeof j !== "function")
    throw new TypeError("option encode is invalid");
  if (!a0.test($))
    throw new TypeError("argument name is invalid");
  var J = j(W);
  if (J && !a0.test(J))
    throw new TypeError("argument val is invalid");
  var Y = $ + "=" + J;
  if (Z.maxAge != null) {
    var G = Z.maxAge - 0;
    if (isNaN(G) || !isFinite(G))
      throw new TypeError("option maxAge is invalid");
    Y += "; Max-Age=" + Math.floor(G);
  }
  if (Z.domain) {
    if (!a0.test(Z.domain))
      throw new TypeError("option domain is invalid");
    Y += "; Domain=" + Z.domain;
  }
  if (Z.path) {
    if (!a0.test(Z.path))
      throw new TypeError("option path is invalid");
    Y += "; Path=" + Z.path;
  }
  if (Z.expires) {
    var K = Z.expires;
    if (!K3(K) || isNaN(K.valueOf()))
      throw new TypeError("option expires is invalid");
    Y += "; Expires=" + K.toUTCString();
  }
  if (Z.httpOnly)
    Y += "; HttpOnly";
  if (Z.secure)
    Y += "; Secure";
  if (Z.partitioned)
    Y += "; Partitioned";
  if (Z.priority) {
    var B = typeof Z.priority === "string" ? Z.priority.toLowerCase() : Z.priority;
    switch (B) {
      case "low":
        Y += "; Priority=Low";
        break;
      case "medium":
        Y += "; Priority=Medium";
        break;
      case "high":
        Y += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (Z.sameSite) {
    var U = typeof Z.sameSite === "string" ? Z.sameSite.toLowerCase() : Z.sameSite;
    switch (U) {
      case true:
        Y += "; SameSite=Strict";
        break;
      case "lax":
        Y += "; SameSite=Lax";
        break;
      case "strict":
        Y += "; SameSite=Strict";
        break;
      case "none":
        Y += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Y;
}
function G3($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
}
function B3($) {
  return encodeURIComponent($);
}
function K3($) {
  return J3.call($) === "[object Date]" || $ instanceof Date;
}
function U3($, W) {
  try {
    return W($);
  } catch (X) {
    return $;
  }
}
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var z2 = Q3;
var D2 = Y3;
var J3 = Object.prototype.toString;
var a0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var X1 = U2(o0(), 1);

class w0 {
  $;
  W;
  X;
  constructor($, W, X = {}) {
    this.name = $;
    this.jar = W;
    this.initial = X;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie($) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = $;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie($) {
    this.cookie = $;
  }
  get value() {
    return this.cookie.value;
  }
  set value($) {
    this.setCookie.value = $;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires($) {
    this.setCookie.expires = $;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge($) {
    this.setCookie.maxAge = $;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain($) {
    this.setCookie.domain = $;
  }
  get path() {
    return this.cookie.path;
  }
  set path($) {
    this.setCookie.path = $;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure($) {
    this.setCookie.secure = $;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly($) {
    this.setCookie.httpOnly = $;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite($) {
    this.setCookie.sameSite = $;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority($) {
    this.setCookie.priority = $;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned($) {
    this.setCookie.partitioned = $;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets($) {
    this.setCookie.secrets = $;
  }
  update($) {
    return this.setCookie = Object.assign(this.cookie, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  set($) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var W1 = ($, W, X) => {
  if (!$.cookie)
    $.cookie = {};
  return new Proxy(W, { get(Z, j) {
    if (j in W)
      return new w0(j, $.cookie, Object.assign({}, X ?? {}, W[j]));
    return new w0(j, $.cookie, Object.assign({}, X));
  } });
};
var e0 = async ($, W, { secrets: X, sign: Z, ...j } = {}) => {
  if (!W)
    return W1($, {}, j);
  const J = typeof X === "string";
  if (Z && Z !== true && !Array.isArray(Z))
    Z = [Z];
  const Y = {}, G = z2(W);
  for (let [K, B] of Object.entries(G)) {
    let U = X1.default(B);
    if (Z === true || Z?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        const w = await P2(U, X);
        if (w === false)
          throw new v0(K);
        U = w;
      } else {
        let w = true;
        for (let F = 0;F < X.length; F++) {
          const Q = await P2(U, X[F]);
          if (Q !== false) {
            w = true, U = Q;
            break;
          }
        }
        if (!w)
          throw new v0(K);
      }
    }
    Y[K] = { value: U };
  }
  return W1($, Y, j);
};
async function* h0($) {
  const W = $.body;
  if (!W)
    return;
  const X = W.getReader(), Z = new TextDecoder;
  try {
    while (true) {
      const { done: j, value: J } = await X.read();
      if (j)
        break;
      yield Z.decode(J);
    }
  } finally {
    X.releaseLock();
  }
}
var Z1 = "toJSON" in new Headers;
var c = ($) => {
  if (!$)
    return false;
  for (let W in $)
    return true;
  return false;
};
var u0 = ($, W) => {
  const X = $.size;
  if (!W && X || X && W && W.status !== 206 && W.status !== 304 && W.status !== 412 && W.status !== 416) {
    if (W && c(W.headers)) {
      if (W.headers instanceof Headers) {
        if (Z1)
          W.headers = W.headers.toJSON();
        else
          for (let [Z, j] of W.headers.entries())
            if (Z in W.headers)
              W.headers[Z] = j;
      }
      return new Response($, { status: W.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, W.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}`, "transfer-encoding": "chunked" } });
  }
  return new Response($);
};
var j1 = ($, W) => {
  if (!$)
    return $;
  $.delete("set-cookie");
  for (let X = 0;X < W.length; X++) {
    const Z = W[X].indexOf("=");
    $.append("set-cookie", `${W[X].slice(0, Z)}=${W[X].slice(Z + 1) || ""}`);
  }
  return $;
};
var J1 = ($) => {
  if (!$ || !c($))
    return;
  const W = [];
  for (let [X, Z] of Object.entries($)) {
    if (!X || !Z)
      continue;
    const j = Z.value;
    if (j === undefined || j === null)
      continue;
    W.push(D2(X, typeof j === "object" ? JSON.stringify(j) : j + "", Z));
  }
  if (W.length === 0)
    return;
  if (W.length === 1)
    return W[0];
  return W;
};
var B0 = async ($, W, X) => {
  let Z = $.next();
  if (Z instanceof Promise)
    Z = await Z;
  if (Z.done) {
    if (W)
      return x(Z.value, W, X);
    return Z0(Z.value, X);
  }
  return new Response(new ReadableStream({ async start(j) {
    let J = false;
    if (X?.signal.addEventListener("abort", () => {
      J = true;
      try {
        j.close();
      } catch {
      }
    }), Z.value !== undefined && Z.value !== null)
      if (typeof Z.value === "object")
        try {
          j.enqueue(Buffer.from(JSON.stringify(Z.value)));
        } catch {
          j.enqueue(Buffer.from(Z.value.toString()));
        }
      else
        j.enqueue(Buffer.from(Z.value.toString()));
    for await (let Y of $) {
      if (J)
        break;
      if (Y === undefined || Y === null)
        continue;
      if (typeof Y === "object")
        try {
          j.enqueue(Buffer.from(JSON.stringify(Y)));
        } catch {
          j.enqueue(Buffer.from(Y.toString()));
        }
      else
        j.enqueue(Buffer.from(Y.toString()));
      await new Promise((G) => setTimeout(() => G(), 0));
    }
    try {
      j.close();
    } catch {
    }
  } }), { ...W, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...W?.headers } });
};
var x = ($, W, X) => {
  if (c(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && c(W.cookie)) {
      const Z = J1(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = j1(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return u0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, x($.response, W, X);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return new Response("", W);
        return Response.json($, W);
      case "Response":
        let Z = false;
        if (W.headers instanceof Headers)
          for (let j of W.headers.keys())
            if (j === "set-cookie") {
              if (Z)
                continue;
              Z = true;
              for (let J of W.headers.getSetCookie())
                $.headers.append("set-cookie", J);
            } else
              $.headers.append(j, W.headers?.get(j) ?? "");
        else
          for (let j in W.headers)
            $.headers.append(j, W.headers[j]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(h0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((j) => x(j, W));
      case "Function":
        return x($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response) {
          let j = false;
          if (W.headers instanceof Headers)
            for (let J of W.headers.keys())
              if (J === "set-cookie") {
                if (j)
                  continue;
                j = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(J, W.headers?.get(J) ?? "");
          else
            for (let J in W.headers)
              $.headers.append(J, W.headers[J]);
          if (Z1)
            W.headers = $.headers.toJSON();
          else
            for (let [J, Y] of $.headers.entries())
              if (J in W.headers)
                W.headers[J] = Y;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((j) => x(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof p)
          return W.status = $.code, x($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return x($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return u0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, x($.response, W, X);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(h0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((Z) => {
          const j = Z0(Z, X);
          if (j !== undefined)
            return j;
          return new Response("");
        });
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((Z) => x(Z, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof p)
          return W.status = $.code, x($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return x($.toResponse(), W);
        if ("charCodeAt" in $) {
          const Z = $.charCodeAt(0);
          if (Z === 123 || Z === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var y = ($, W, X) => {
  if ($ === undefined || $ === null)
    return;
  if (c(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && c(W.cookie)) {
      const Z = J1(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = j1(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return u0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, y($.response, W, X);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return;
        return Response.json($, W);
      case "Response":
        let Z = false;
        if (W.headers instanceof Headers)
          for (let j of W.headers.keys())
            if (j === "set-cookie") {
              if (Z)
                continue;
              Z = true;
              for (let J of W.headers.getSetCookie())
                $.headers.append("set-cookie", J);
            } else
              $.headers.append(j, W.headers?.get(j) ?? "");
        else
          for (let j in W.headers)
            $.headers.append(j, W.headers[j]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(h0($), W, X);
        return $;
      case "Promise":
        return $.then((j) => {
          const J = y(j, W);
          if (J !== undefined)
            return J;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return y($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "FormData":
        return new Response($);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          let j = false;
          if (W.headers instanceof Headers)
            for (let J of W.headers.keys())
              if (J === "set-cookie") {
                if (j)
                  continue;
                j = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(J, W.headers?.get(J) ?? "");
          else
            for (let J in W.headers)
              $.headers.append(J, W.headers[J]);
          if ($.status !== W.status)
            W.status = $.status;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((j) => y(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof p)
          return W.status = $.code, y($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return y($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return u0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, y($.response, W, X);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(h0($));
        return $;
      case "Promise":
        return $.then((Z) => {
          const j = y(Z, W);
          if (j !== undefined)
            return j;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((Z) => y(Z, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof p)
          return W.status = $.code, y($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return y($.toResponse(), W);
        if ("charCodeAt" in $) {
          const Z = $.charCodeAt(0);
          if (Z === 123 || Z === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var Z0 = ($, W) => {
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return u0($);
    case "Array":
      return Response.json($);
    case "Object":
      return Response.json($);
    case "ElysiaCustomStatusResponse":
      return x($.response, { status: $.code, headers: {} });
    case "ReadableStream":
      return W?.signal.addEventListener("abort", { handleEvent() {
        if (!W?.signal.aborted)
          $.cancel(W);
      } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      if ($.headers.get("transfer-encoding") === "chunked")
        return B0(h0($));
      return $;
    case "Error":
      return K0($);
    case "Promise":
      return $.then((X) => Z0(X, W));
    case "Function":
      return Z0($(), W);
    case "Number":
    case "Boolean":
      return new Response($.toString());
    case "FormData":
      return new Response($);
    default:
      if ($ instanceof Response)
        return $;
      if ($ instanceof Promise)
        return $.then((X) => Z0(X, W));
      if ($ instanceof Error)
        return K0($);
      if ($ instanceof p)
        return x($.response, { status: $.code, headers: {} });
      if (typeof $?.next === "function")
        return B0($, undefined, W);
      if ("toResponse" in $)
        return Z0($.toResponse());
      if ("charCodeAt" in $) {
        const X = $.charCodeAt(0);
        if (X === 123 || X === 91)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      }
      return new Response($);
  }
};
var K0 = ($, W) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W?.status !== 200 ? W?.status ?? 500 : 500, headers: W?.headers });
var Q1 = ($, W, X = {}) => {
  if (typeof $ === "function")
    return;
  const Z = x($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0)
    return Z.clone.bind(Z);
};
var Y1 = ($, W, X = {}) => {
  if (typeof $ === "function" || $ instanceof Blob)
    return;
  const Z = x($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0) {
    if (!Z.headers.has("content-type"))
      Z.headers.append("content-type", "text/plain;charset=utf-8");
    return Z.clone.bind(Z);
  }
};
function A3($) {
  let W = $;
  while (W.endsWith("="))
    W = W.slice(0, -1);
  return W;
}
var R0 = ($, W) => {
  const X = new URL($);
  return X.pathname = W, X.toString();
};
var M3 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") && $.toString() !== "[object Object]" || c(Object.getPrototypeOf($));
var I2 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var d = ($, W, { skipKeys: X, override: Z = true } = {}) => {
  if (!I2($) || !I2(W))
    return $;
  for (let [j, J] of Object.entries(W)) {
    if (X?.includes(j))
      continue;
    if (!I2(J) || !(j in $) || M3(J)) {
      if (Z || !(j in $))
        $[j] = J;
      continue;
    }
    $[j] = d($[j], J, { skipKeys: X, override: Z });
  }
  return $;
};
var z3 = ($, W) => {
  const { properties: X, ...Z } = $ ?? {}, { properties: j, ...J } = W ?? {};
  return d(Z, J);
};
var f = ($ = [], W = []) => {
  if (!$)
    return [];
  if (!W)
    return $;
  const X = [], Z = [];
  if (!Array.isArray($))
    $ = [$];
  if (!Array.isArray(W))
    W = [W];
  for (let j of $)
    if (X.push(j), j.checksum)
      Z.push(j.checksum);
  for (let j of W)
    if (!Z.includes(j.checksum))
      X.push(j);
  return X;
};
var D3 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var N3 = D3.reduce(($, W) => ($[W] = true, $), {});
var U1 = ($, W) => {
  const X = (Z) => typeof Z === "object" && Object.keys(Z).every(Z2);
  if (X($) && X(W))
    return { ...$, ...W };
  else if ($ && !X($) && X(W))
    return { 200: $, ...W };
  return W ?? $;
};
var b0 = ($, W) => {
  return { body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: U1($?.response, W?.response) };
};
var i = ($, W) => {
  return { ...$, ...W, body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: U1($?.response, W?.response), type: $?.type || W?.type, detail: d(W?.detail ?? {}, $?.detail ?? {}), parse: f($?.parse, W?.parse), transform: f($?.transform, W?.transform), beforeHandle: f($?.beforeHandle, W?.beforeHandle), afterHandle: f($?.afterHandle, W?.afterHandle), mapResponse: f($?.mapResponse, W?.mapResponse), afterResponse: f($?.afterResponse, W?.afterResponse), trace: f($?.trace, W?.trace), error: f($?.error, W?.error) };
};
var V2 = ($, W, X = true) => {
  if (!Array.isArray(W))
    return h($, W, X);
  for (let Z of W)
    $ = h($, Z, X);
  return $;
};
var h = ($, W, X = true) => {
  if (!$)
    return $;
  if (W.untilObjectFound && !X && $.type === "object")
    return $;
  const Z = W.from[Kind];
  if ($.oneOf) {
    for (let Y = 0;Y < $.oneOf.length; Y++)
      $.oneOf[Y] = h($.oneOf[Y], W, X);
    return $;
  }
  if ($.anyOf) {
    for (let Y = 0;Y < $.anyOf.length; Y++)
      $.anyOf[Y] = h($.anyOf[Y], W, X);
    return $;
  }
  if ($.allOf) {
    for (let Y = 0;Y < $.allOf.length; Y++)
      $.allOf[Y] = h($.allOf[Y], W, X);
    return $;
  }
  if ($.not) {
    for (let Y = 0;Y < $.not.length; Y++)
      $.not[Y] = h($.not[Y], W, X);
    return $;
  }
  const j = X && !!W.excludeRoot;
  if ($[Kind] === Z) {
    const { anyOf: Y, oneOf: G, allOf: K, not: B, properties: U, items: w, ...F } = $, Q = W.to(F);
    let z;
    const D = (M) => {
      if (U && M.type === "object") {
        const O = {};
        for (let [P, b] of Object.entries(U))
          O[P] = h(b, W, false);
        return { ...F, ...M, properties: O };
      }
      if (w && M.type === "array")
        return { ...F, ...M, items: h(w, W, false) };
      const I = { ...F, ...M };
      if (delete I.required, U && M.type === "string" && M.format === "ObjectString" && M.default === "{}")
        z = V.ObjectString(U, F), I.default = JSON.stringify(exports_value2.Create(V.Object(U))), I.properties = U;
      if (w && M.type === "string" && M.format === "ArrayString" && M.default === "[]")
        z = V.ArrayString(w, F), I.default = JSON.stringify(exports_value2.Create(V.Array(w))), I.items = w;
      return I;
    };
    if (j) {
      if (U) {
        const M = {};
        for (let [I, O] of Object.entries(U))
          M[I] = h(O, W, false);
        return { ...F, properties: M };
      } else if (w?.map)
        return { ...F, items: w.map((M) => h(M, W, false)) };
      return F;
    }
    if (Q.anyOf)
      for (let M = 0;M < Q.anyOf.length; M++)
        Q.anyOf[M] = D(Q.anyOf[M]);
    else if (Q.oneOf)
      for (let M = 0;M < Q.oneOf.length; M++)
        Q.oneOf[M] = D(Q.oneOf[M]);
    else if (Q.allOf)
      for (let M = 0;M < Q.allOf.length; M++)
        Q.allOf[M] = D(Q.allOf[M]);
    else if (Q.not)
      for (let M = 0;M < Q.not.length; M++)
        Q.not[M] = D(Q.not[M]);
    if (z)
      Q[TransformKind] = z[TransformKind];
    if (Q.anyOf || Q.oneOf || Q.allOf || Q.not)
      return Q;
    if (U) {
      const M = {};
      for (let [I, O] of Object.entries(U))
        M[I] = h(O, W, false);
      return { ...F, ...Q, properties: M };
    } else if (w?.map)
      return { ...F, ...Q, items: w.map((M) => h(M, W, false)) };
    return { ...F, ...Q };
  }
  const J = $?.properties;
  if (J && X && W.rootOnly !== true)
    for (let [Y, G] of Object.entries(J))
      switch (G[Kind]) {
        case Z:
          const { anyOf: K, oneOf: B, allOf: U, not: w, type: F, ...Q } = G, z = W.to(Q);
          if (z.anyOf)
            for (let D = 0;D < z.anyOf.length; D++)
              z.anyOf[D] = { ...Q, ...z.anyOf[D] };
          else if (z.oneOf)
            for (let D = 0;D < z.oneOf.length; D++)
              z.oneOf[D] = { ...Q, ...z.oneOf[D] };
          else if (z.allOf)
            for (let D = 0;D < z.allOf.length; D++)
              z.allOf[D] = { ...Q, ...z.allOf[D] };
          else if (z.not)
            for (let D = 0;D < z.not.length; D++)
              z.not[D] = { ...Q, ...z.not[D] };
          J[Y] = { ...Q, ...h(Q, W, false) };
          break;
        case "Object":
        case "Union":
          J[Y] = h(G, W, false);
          break;
        default:
          if (G.items)
            for (let D = 0;D < G.items.length; D++)
              G.items[D] = h(G.items[D], W, false);
          else if (G.anyOf || G.oneOf || G.allOf || G.not)
            J[Y] = h(G, W, false);
          break;
      }
  return $;
};
var m = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: j = false, coerce: J = false, additionalCoerce: Y = [] } = {}) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  let G = typeof $ === "string" ? W[$] : $;
  if (J || Y)
    if (J)
      G = V2(G, [{ from: V.Number(), to: (U) => V.Numeric(U), untilObjectFound: true }, { from: V.Boolean(), to: (U) => V.BooleanString(U), untilObjectFound: true }, ...Array.isArray(Y) ? Y : [Y]]);
    else
      G = V2(G, [...Array.isArray(Y) ? Y : [Y]]);
  if (G.type === "object" && "additionalProperties" in G === false)
    G.additionalProperties = j;
  const K = (U) => exports_value2.Clean(G, U);
  if (X) {
    const U = { schema: G, references: "", checkFunc: () => {
    }, code: "", Check: (w) => exports_value2.Check(G, w), Errors: (w) => exports_value2.Errors(G, w), Code: () => "", Clean: K, Decode: (w) => exports_value2.Decode(G, w), Encode: (w) => exports_value2.Encode(G, w) };
    if (Z && G.additionalProperties === false)
      U.Clean = K;
    if (G.config) {
      if (U.config = G.config, U?.schema?.config)
        delete U.schema.config;
    }
    return U.parse = (w) => {
      try {
        return U.Decode(w);
      } catch (F) {
        throw [...U.Errors(w)].map(o);
      }
    }, U.safeParse = (w) => {
      try {
        return { success: true, data: U.Decode(w), error: null };
      } catch (F) {
        const Q = [...B.Errors(w)].map(o);
        return { success: false, data: null, error: Q[0]?.summary, errors: Q };
      }
    }, U;
  }
  const B = TypeCompiler.Compile(G, Object.values(W));
  if (B.Clean = K, G.config) {
    if (B.config = G.config, B?.schema?.config)
      delete B.schema.config;
  }
  return B.parse = (U) => {
    try {
      return B.Decode(U);
    } catch (w) {
      throw [...B.Errors(U)].map(o);
    }
  }, B.safeParse = (U) => {
    try {
      return { success: true, data: B.Decode(U), error: null };
    } catch (w) {
      const F = [...B.Errors(U)].map(o);
      return { success: false, data: null, error: F[0]?.summary, errors: F };
    }
  }, B;
};
var $2 = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: j = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  const J = typeof $ === "string" ? W[$] : $, Y = (K, B) => {
    const U = (F) => {
      if (!F || typeof F !== "object")
        return exports_value2.Clean(K, F);
      if (Array.isArray(F))
        F = exports_value2.Clean(K, F);
      else
        F = exports_value2.Clean(K, F);
      return F;
    };
    if (X)
      return { schema: K, references: "", checkFunc: () => {
      }, code: "", Check: (F) => exports_value2.Check(K, F), Errors: (F) => exports_value2.Errors(K, F), Code: () => "", Decode: (F) => exports_value2.Decode(K, F), Encode: (F) => exports_value2.Encode(K, F) };
    const w = TypeCompiler.Compile(K, B);
    if (Z && K.additionalProperties === false)
      w.Clean = U;
    return w;
  };
  if (Kind in J) {
    if ("additionalProperties" in J === false)
      J.additionalProperties = j;
    return { 200: Y(J, Object.values(W)) };
  }
  const G = {};
  return Object.keys(J).forEach((K) => {
    const B = J[+K];
    if (typeof B === "string") {
      if (B in W) {
        const U = W[B];
        U.type === "object" && "additionalProperties" in U, G[+K] = Kind in U ? Y(U, Object.values(W)) : U;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = j;
    G[+K] = Kind in B ? Y(B, Object.values(W)) : B;
  }), G;
};
var P3 = typeof Bun !== "undefined";
var I3 = P3 && typeof Bun.hash === "function";
var N0 = ($) => {
  if (I3)
    return Bun.hash($);
  let W = 9;
  for (let X = 0;X < $.length; )
    W = Math.imul(W ^ $.charCodeAt(X++), 387420489);
  return W = W ^ W >>> 9;
};
var A2;
var D0 = () => {
  if (!A2)
    A2 = [{ from: V.Object({}), to: () => V.ObjectString({}), excludeRoot: true }, { from: V.Array(V.Any()), to: () => V.ArrayString(V.Any()) }];
  return A2;
};
var O2;
var S2 = () => {
  if (!O2)
    O2 = [{ from: V.Number(), to: ($) => V.Numeric($), rootOnly: true }, { from: V.Boolean(), to: ($) => V.BooleanString($), rootOnly: true }];
  return O2;
};
var W2 = ({ validator: $, defaultConfig: W = {}, config: X, dynamic: Z, models: j }) => {
  let J = m($, { dynamic: Z, models: j, additionalProperties: true, coerce: true, additionalCoerce: D0() });
  if (c(W))
    if (J)
      J.config = z3(J.config, X);
    else
      J = m(V.Cookie({}), { dynamic: Z, models: j, additionalProperties: true }), J.config = W;
  return J;
};
var j0 = ($, W) => {
  if (!W)
    return;
  if (!Array.isArray(W)) {
    const Z = W;
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
    return Z;
  }
  const X = [...W];
  for (let Z of X) {
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
  }
  return X;
};
var C2 = ($, W, X) => {
  return { start: f($.start, j0(X, W?.start)), request: f($.request, j0(X, W?.request)), parse: f($.parse, j0(X, W?.parse)), transform: f($.transform, j0(X, W?.transform)), beforeHandle: f($.beforeHandle, j0(X, W?.beforeHandle)), afterHandle: f($.afterHandle, j0(X, W?.afterHandle)), mapResponse: f($.mapResponse, j0(X, W?.mapResponse)), afterResponse: f($.afterResponse, j0(X, W?.afterResponse)), trace: f($.trace, j0(X, W?.trace)), error: f($.error, j0(X, W?.error)), stop: f($.stop, j0(X, W?.stop)) };
};
var w1 = ($, W, { skipIfHasType: X = false } = {}) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (X)
      $.scope ??= W;
    else
      $.scope = W;
    return $;
  }
  for (let Z of $)
    if (X)
      Z.scope ??= W;
    else
      Z.scope = W;
  return $;
};
var z0 = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($))
    switch ($.scope) {
      case "global":
      case "scoped":
        return { ...$ };
      default:
        return { fn: $ };
    }
  const W = [];
  for (let X of $)
    switch (X.scope) {
      case "global":
      case "scoped":
        W.push({ ...X });
        break;
    }
  return W;
};
var L2 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: z0($?.parse), transform: z0($?.transform), beforeHandle: z0($?.beforeHandle), afterHandle: z0($?.afterHandle), mapResponse: z0($?.mapResponse), afterResponse: z0($?.afterResponse), error: z0($?.error), trace: z0($?.trace) };
};
var _0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var X2 = Object.fromEntries(Object.entries(_0).map(([$, W]) => [W, $]));
var B1 = new TextEncoder;
var x0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = await crypto.subtle.importKey("raw", B1.encode(W), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X, B1.encode($));
  return $ + "." + A3(Buffer.from(Z).toString("base64"));
};
var P2 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await x0(X, W) === $ ? X : false;
};
var _1 = ($, W) => {
  if (!$ || typeof $ !== "object" || !W)
    return;
  for (let [X, Z] of Object.entries(W)) {
    if (X in N3 || !(X in $))
      continue;
    const j = $[X];
    if (typeof j === "function")
      j(Z), delete W[X];
  }
};
var F1 = ({ globalHook: $, localHook: W }) => (X) => (Z, j) => {
  if (typeof Z === "function")
    Z = { fn: Z };
  if ("fn" in Z || Array.isArray(Z)) {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (Array.isArray(Z))
      W[X] = W[X].concat(Z);
    else
      W[X].push(Z);
    return;
  }
  const { insert: J = "after", stack: Y = "local" } = Z;
  if (typeof j === "function")
    j = { fn: j };
  if (Y === "global")
    if (!Array.isArray(j))
      if (J === "before")
        $[X].unshift(j);
      else
        $[X].push(j);
    else if (J === "before")
      $[X] = j.concat($[X]);
    else
      $[X] = $[X].concat(j);
  else {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (!Array.isArray(j))
      if (J === "before")
        W[X].unshift(j);
      else
        W[X].push(j);
    else if (J === "before")
      W[X] = j.concat(W[X]);
    else
      W[X] = W[X].concat(j);
  }
};
var O3 = ($) => {
  if (typeof $ === "number")
    return $;
  if ($.length < 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W))
      return null;
    return W;
  }
  if ($.length === 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W) || W.toString() !== $)
      return null;
    return W;
  }
  return null;
};
var Z2 = ($) => O3($) !== null;

class T2 {
  $;
  root = null;
  promises = [];
  constructor($ = console.error) {
    this.onError = $;
  }
  get size() {
    return this.promises.length;
  }
  add($) {
    return this.promises.push($), this.root ||= this.drain(), $;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch ($) {
        this.onError($);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then($, W) {
    return (this.root ?? Promise.resolve()).then($, W);
  }
}
var n = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (typeof $ === "function")
      return { fn: $ };
    else if ("fn" in $)
      return $;
  }
  const W = [];
  for (let X of $)
    if (typeof X === "function")
      W.push({ fn: X });
    else if ("fn" in X)
      W.push(X);
  return W;
};
var M1 = ($) => {
  return { ...$, start: n($?.start), request: n($?.request), parse: n($?.parse), transform: n($?.transform), beforeHandle: n($?.beforeHandle), afterHandle: n($?.afterHandle), mapResponse: n($?.mapResponse), afterResponse: n($?.afterResponse), trace: n($?.trace), error: n($?.error), stop: n($?.stop) };
};
var E2 = ($) => {
  return { ...$, start: $.start?.map((W) => W.fn), request: $.request?.map((W) => W.fn), parse: $.parse?.map((W) => W.fn), transform: $.transform?.map((W) => W.fn), beforeHandle: $.beforeHandle?.map((W) => W.fn), afterHandle: $.afterHandle?.map((W) => W.fn), afterResponse: $.afterResponse?.map((W) => W.fn), mapResponse: $.mapResponse?.map((W) => W.fn), trace: $.trace?.map((W) => W.fn), error: $.error?.map((W) => W.fn), stop: $.stop?.map((W) => W.fn) };
};
var m0 = ($) => ({ body: $.body, cookie: $.cookie, headers: $.headers, query: $.query, set: $.set, server: $.server });
var d0 = ($, W = 302) => Response.redirect($, W);
var V3 = Symbol("ElysiaFormData");
var P0 = Symbol("ElysiaRequestId");
var j2 = () => crypto.getRandomValues(new Uint32Array(1))[0];
var J2 = ($) => {
  const W = [];
  for (let X = 0;X < $.length; X++) {
    const Z = $[X];
    if (Z.checksum) {
      if (W.includes(Z.checksum))
        $.splice(X, 1), X--;
      W.push(Z.checksum);
    }
  }
  return $;
};
var v = ($, W = "scoped") => {
  if (W === "scoped") {
    for (let X of $)
      if ("scope" in X && X.scope === "local")
        X.scope = "scoped";
    return;
  }
  for (let X of $)
    if ("scope" in X)
      X.scope = "global";
};
var z1 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var I0 = Symbol("ElysiaErrorCode");
var p0 = (z1?.NODE_ENV ?? z1?.ENV) === "production";

class p {
  code;
  response;
  constructor($, W) {
    const X = W ?? ($ in X2 ? X2[$] : $);
    this.code = _0[$] ?? $, this.response = X;
  }
}
var q2 = ($, W) => new p($, W);

class Q2 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class A0 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}

class Y2 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Failed to parse body");
  }
}

class v0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W) {
    super(W ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}
var o = ($) => {
  if (!$)
    return { summary: undefined };
  const { message: W, path: X, value: Z, type: j } = $, J = X.slice(1).replaceAll("/", "."), Y = X === "";
  switch (j) {
    case 42:
      return { ...$, summary: Y ? "Value should not be provided" : `Property '${J}' should not be provided` };
    case 45:
      return { ...$, summary: Y ? "Value is missing" : `Property '${J}' is missing` };
    case 50:
      const G = W.indexOf("'"), K = W.slice(G + 1, W.indexOf("'", G + 1));
      return { ...$, summary: Y ? "Value should be an email" : `Property '${J}' should be ${K}` };
    case 54:
      return { ...$, summary: `${W.slice(0, 9)} property '${J}' to be ${W.slice(8)} but found: ${Z}` };
    case 62:
      const B = $.schema.anyOf.map((U) => `'${U?.format ?? U.type}'`).join(", ");
      return { ...$, summary: Y ? `Value should be one of ${B}` : `Property '${J}' should be one of: ${B}` };
    default:
      return { summary: W, ...$ };
  }
};

class q extends Error {
  $;
  W;
  X;
  code = "VALIDATION";
  status = 422;
  constructor($, W, X) {
    if (X && typeof X === "object" && X instanceof p)
      X = X.response;
    const Z = p0 ? undefined : ("Errors" in W) ? W.Errors(X).First() : exports_value2.Errors(W, X).First(), j = Z?.schema.error !== undefined ? typeof Z.schema.error === "function" ? Z.schema.error({ type: $, validator: W, value: X, get errors() {
      return [...W.Errors(X)].map(o);
    } }) : Z.schema.error : undefined, J = Z?.path || "root";
    let Y = "";
    if (j !== undefined)
      Y = typeof j === "object" ? JSON.stringify(j) : j + "";
    else if (p0)
      Y = JSON.stringify({ type: "validation", on: $, summary: o(Z).summary, message: Z?.message, found: X });
    else {
      const G = W?.schema ?? W, K = "Errors" in W ? [...W.Errors(X)].map(o) : [...exports_value2.Errors(W, X)].map(o);
      let B;
      try {
        B = exports_value2.Create(G);
      } catch (U) {
        B = { type: "Could not create expected value", message: U?.message, error: U };
      }
      Y = JSON.stringify({ type: "validation", on: $, summary: K[0]?.summary, property: J, message: Z?.message, expected: B, found: X, errors: K }, null, 2);
    }
    super(Y);
    this.type = $;
    this.validator = W;
    this.value = X;
    Object.setPrototypeOf(this, q.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(o) : [...exports_value2.Errors(this.validator, this.value)].map(o);
  }
  static simplifyModel($) {
    const W = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(W);
    } catch {
      return W;
    }
  }
  get model() {
    return q.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: { ...$, "content-type": "application/json" } });
  }
}
var H2 = { open($) {
  $.data.open?.($);
}, message($, W) {
  $.data.message?.($, W);
}, drain($) {
  $.data.drain?.($);
}, close($, W, X) {
  $.data.close?.($, W, X);
} };

class g0 {
  $;
  W;
  validator;
  _validator;
  constructor($, W) {
    this.raw = $;
    this.data = W;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else
      this.id = j2().toString();
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, W = undefined, X) => {
      if (this.validator?.Check(W) === false)
        throw new q("message", this.validator, W);
      if (typeof W === "object")
        W = JSON.stringify(W);
      return this.raw.publish($, W, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new q("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var R2 = "1.1.22";
var O0 = U2(o0(), 1);
function G2($) {
  const W = {};
  if (typeof $ !== "string")
    return W;
  let X = "", Z = "", j = -1, J = -1, Y = 0;
  const G = $.length;
  for (let K = 0;K < G; K++)
    switch ($.charCodeAt(K)) {
      case 38:
        const B = J > j;
        if (!B)
          J = K;
        if (X = $.slice(j + 1, J), B || X.length > 0) {
          if (Y & 1)
            X = X.replace(f0, " ");
          if (Y & 2)
            X = O0.default(X) || X;
          if (!W[X]) {
            if (B) {
              if (Z = $.slice(J + 1, K), Y & 4)
                Z = Z.replace(f0, " ");
              if (Y & 8)
                Z = O0.default(Z) || Z;
            }
            W[X] = Z;
          }
        }
        X = "", Z = "", j = K, J = K, Y = 0;
        break;
      case 61:
        if (J <= j)
          J = K;
        else
          Y |= 8;
        break;
      case 43:
        if (J > j)
          Y |= 4;
        else
          Y |= 1;
        break;
      case 37:
        if (J > j)
          Y |= 8;
        else
          Y |= 2;
        break;
    }
  if (j < G) {
    const K = J > j;
    if (X = $.slice(j + 1, K ? J : G), K || X.length > 0) {
      if (Y & 1)
        X = X.replace(f0, " ");
      if (Y & 2)
        X = O0.default(X) || X;
      if (!W[X]) {
        if (K) {
          if (Z = $.slice(J + 1, G), Y & 4)
            Z = Z.replace(f0, " ");
          if (Y & 8)
            Z = O0.default(Z) || Z;
        }
        W[X] = Z;
      }
    }
  }
  return W;
}
var f0 = /\+/g;
var l0 = ($) => {
  const W = {};
  if (typeof $ !== "string")
    return W;
  const X = $.length;
  let Z = "", j = "", J = -1, Y = -1, G = false, K = false, B = false, U = false, w = false, F = 0;
  for (let Q = 0;Q < X + 1; Q++) {
    if (Q !== X)
      F = $.charCodeAt(Q);
    else
      F = 38;
    switch (F) {
      case 38: {
        if (w = Y > J, !w)
          Y = Q;
        if (Z = $.slice(J + 1, Y), w || Z.length > 0) {
          if (B)
            Z = Z.replace(f0, " ");
          if (G)
            Z = O0.default(Z) || Z;
          if (w) {
            if (j = $.slice(Y + 1, Q), U)
              j = j.replace(f0, " ");
            if (K)
              j = O0.default(j) || j;
          }
          const z = W[Z];
          if (z === undefined)
            W[Z] = j;
          else if (z.pop)
            z.push(j);
          else
            W[Z] = [z, j];
        }
        j = "", J = Q, Y = Q, G = false, K = false, B = false, U = false;
        break;
      }
      case 61:
        if (Y <= J)
          Y = Q;
        else
          K = true;
        break;
      case 43:
        if (Y > J)
          U = true;
        else
          B = true;
        break;
      case 37:
        if (Y > J)
          K = true;
        else
          G = true;
        break;
    }
  }
  return W;
};
var N1 = U2(o0(), 1);
var i0 = Symbol("ElysiaTrace");
var F0 = () => {
  const { promise: $, resolve: W } = Promise.withResolvers(), { promise: X, resolve: Z } = Promise.withResolvers(), { promise: j, resolve: J } = Promise.withResolvers(), Y = [], G = [];
  return [(K) => {
    if (K)
      Y.push(K);
    return $;
  }, (K) => {
    const B = [], U = [];
    let w = null;
    for (let Q = 0;Q < (K.total ?? 0); Q++) {
      const { promise: z, resolve: D } = Promise.withResolvers(), { promise: M, resolve: I } = Promise.withResolvers(), { promise: O, resolve: P } = Promise.withResolvers(), b = [], T = [];
      B.push((E) => {
        if (E)
          b.push(E);
        return z;
      }), U.push((E) => {
        const r = { ...E, end: M, error: O, index: Q, onStop(L) {
          if (L)
            T.push(L);
          return M;
        } };
        D(r);
        for (let L = 0;L < b.length; L++)
          b[L](r);
        return (L = null) => {
          const g = performance.now();
          if (L)
            w = L;
          const R = { end: g, error: L, get elapsed() {
            return g - E.begin;
          } };
          for (let Y0 = 0;Y0 < T.length; Y0++)
            T[Y0](R);
          I(g), P(L);
        };
      });
    }
    const F = { ...K, end: X, error: j, onEvent(Q) {
      for (let z = 0;z < B.length; z++)
        B[z](Q);
    }, onStop(Q) {
      if (Q)
        G.push(Q);
      return X;
    } };
    W(F);
    for (let Q = 0;Q < Y.length; Q++)
      Y[Q](F);
    return { resolveChild: U, resolve(Q = null) {
      const z = performance.now();
      if (!Q && w)
        Q = w;
      const D = { end: z, error: Q, get elapsed() {
        return z - K.begin;
      } };
      for (let M = 0;M < G.length; M++)
        G[M](D);
      Z(z), J(Q);
    } };
  }];
};
var D1 = ($) => {
  return (W) => {
    const [X, Z] = F0(), [j, J] = F0(), [Y, G] = F0(), [K, B] = F0(), [U, w] = F0(), [F, Q] = F0(), [z, D] = F0(), [M, I] = F0(), [O, P] = F0();
    return $({ id: W[P0], context: W, set: W.set, onRequest: X, onParse: j, onTransform: Y, onBeforeHandle: K, onHandle: U, onAfterHandle: F, onMapResponse: M, onAfterResponse: O, onError: z }), { request: Z, parse: J, transform: G, beforeHandle: B, handle: w, afterHandle: Q, error: D, mapResponse: I, afterResponse: P };
  };
};
var T3 = new Headers().toJSON;
var P1 = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var t = ($) => {
  if (!$)
    return false;
  const W = $?.schema;
  return !!W && P1.optional in W;
};
var J0 = ($) => {
  if (!$)
    return false;
  const W = $?.schema ?? $;
  if (W.anyOf)
    return W.anyOf.some(J0);
  if (W.someOf)
    return W.someOf.some(J0);
  if (W.allOf)
    return W.allOf.some(J0);
  if (W.not)
    return W.not.some(J0);
  if (W.type === "object") {
    const X = W.properties;
    if ("additionalProperties" in W)
      return W.additionalProperties;
    for (let Z of Object.keys(X)) {
      const j = X[Z];
      if (j.type === "object") {
        if (J0(j))
          return true;
      } else if (j.anyOf) {
        for (let J = 0;J < j.anyOf.length; J++)
          if (J0(j.anyOf[J]))
            return true;
      }
      return j.additionalProperties;
    }
    return false;
  }
  return false;
};
var x2 = ({ context: $ = "c", trace: W, addFn: X }) => {
  if (!W.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let Z = 0;Z < W.length; Z++)
    X(`let report${Z}, reportChild${Z}, reportErr${Z}, reportErrChild${Z}; let trace${Z} = ${$}[ELYSIA_TRACE]?.[${Z}] ?? trace[${Z}](${$});\n`);
  return (Z, { name: j, total: J = 0 } = {}) => {
    if (!j)
      j = "anonymous";
    const Y = Z === "error" ? "reportErr" : "report";
    for (let G = 0;G < W.length; G++)
      X(`\n${Y}${G} = trace${G}.${Z}({id,event: '${Z}',name: '${j}',begin: performance.now(),total: ${J}})\n`);
    return { resolve() {
      for (let G = 0;G < W.length; G++)
        X(`\n${Y}${G}.resolve()\n`);
    }, resolveChild(G) {
      for (let K = 0;K < W.length; K++)
        X(`${Y}Child${K} = ${Y}${K}.resolveChild?.shift()?.({id,event: '${Z}',name: '${G}',begin: performance.now()})\n`);
      return (K) => {
        for (let B = 0;B < W.length; B++)
          if (K)
            X(`
                             	if (${K} instanceof Error)
                    				${Y}Child${B}?.(${K})
                           		else
                             		${Y}Child${B}?.()\n`);
          else
            X(`${Y}Child${B}?.()\n`);
      };
    } };
  };
};
var E3 = ({ injectResponse: $ = "", normalize: W = false, validator: X }) => ({ composeValidation: (Z, j = `c.${Z}`) => `c.set.status = 422; throw new ValidationError('${Z}', validator.${Z}, ${j})`, composeResponseValidation: (Z = "r") => {
  let j = "\n" + $ + "\n";
  j += `if(${Z} instanceof ElysiaCustomStatusResponse) {
			c.set.status = ${Z}.code
			${Z} = ${Z}.response
		}

		const isResponse = ${Z} instanceof Response\n\n`, j += "switch(c.set.status) {\n";
  for (let [J, Y] of Object.entries(X.response)) {
    if (j += `\tcase ${J}:
				if (!isResponse) {\n`, W && "Clean" in Y && !J0(Y))
      j += `${Z} = validator.response['${J}'].Clean(${Z})\n`;
    j += `if(validator.response['${J}'].Check(${Z}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${J}'], ${Z})
				}

				c.set.status = ${J}
			}

			break\n\n`;
  }
  return j += "\n}\n", j;
} });
var n8 = Symbol.for("TypeBox.Kind");
var V0 = ($, W) => {
  if (!W)
    return;
  if (W.type === "object") {
    const X = W.properties;
    if (!X)
      return false;
    for (let Z of Object.keys(X)) {
      const j = X[Z];
      if ($ in j)
        return true;
      if (j.type === "object") {
        if (V0($, j))
          return true;
      } else if (j.anyOf) {
        for (let J = 0;J < j.anyOf.length; J++)
          if (V0($, j.anyOf[J]))
            return true;
      }
    }
    return false;
  }
  return $ in W;
};
var b2 = Symbol.for("TypeBox.Transform");
var S0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const W = $.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (S0(Z))
          return true;
      } else if (Z.anyOf) {
        for (let J = 0;J < Z.anyOf.length; J++)
          if (S0(Z.anyOf[J]))
            return true;
      }
      if (b2 in Z)
        return true;
    }
    return false;
  }
  return b2 in $ || $.properties && b2 in $.properties;
};
var q3 = /(?:return|=>) \S+\(/g;
var C0 = ($) => {
  return ($?.fn ?? $).constructor.name === "AsyncFunction";
};
var k = ($) => {
  const W = $?.fn ?? $;
  if (W.constructor.name === "AsyncFunction")
    return true;
  const X = W.toString();
  if (X.includes("=> response.clone("))
    return false;
  if (X.includes("await"))
    return true;
  if (X.includes("async"))
    return true;
  return !!X.match(q3);
};
var B2 = ($) => {
  const W = $?.fn ?? $;
  return W.constructor.name === "AsyncGeneratorFunction" || W.constructor.name === "GeneratorFunction";
};
var I1 = ({ app: $, path: W, method: X, localHook: Z, hooks: j, validator: J, handler: Y, allowMeta: G = false, inference: K }) => {
  const B = typeof Y === "function";
  if (!B) {
    if (Y = x(Y, { headers: $.setHeaders ?? {} }), j.parse.length === 0 && j.transform.length === 0 && j.beforeHandle.length === 0 && j.afterHandle.length === 0)
      return Function("a", "return function () { return a.clone() }")(Y);
  }
  const U = B ? "handler(c)" : "handler", w = j.afterResponse.length > 0, F = j.trace.length > 0;
  let Q = "";
  if (K = r0(Object.assign(Z, { handler: Y }), K), K.server)
    Q += `\nObject.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})\n`;
  if (K.body)
    Q += "let isParsing = false\n";
  J.createBody?.(), J.createQuery?.(), J.createHeaders?.(), J.createParams?.(), J.createCookie?.(), J.createResponse?.();
  const z = K.query || !!J.query, D = X !== "$INTERNALWS" && X !== "GET" && X !== "HEAD" && (K.body || !!J.body || j.parse.length), M = $.setHeaders, I = M && !!Object.keys(M).length, O = K.headers || J.headers, P = K.cookie || !!J.cookie, b = P ? W2({ validator: J.cookie, defaultConfig: $.config.cookie, dynamic: !!$.config.aot, config: J.cookie?.config ?? {}, models: $.definitions.type }) : undefined, T = b?.config;
  let E = "";
  if (T?.sign) {
    if (!T.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${X}) ${W}.`);
    const N = !T.secrets ? undefined : typeof T.secrets === "string" ? T.secrets : T.secrets[0];
    if (E += `const _setCookie = c.set.cookie
		if(_setCookie) {`, T.sign === true)
      E += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${N}')
			}`;
    else
      for (let _ of T.sign)
        E += `if(_setCookie['${_}']?.value) { c.set.cookie['${_}'].value = await signCookie(_setCookie['${_}'].value, '${N}') }\n`;
    E += "}\n";
  }
  const r = $.config.normalize, { composeValidation: L, composeResponseValidation: g } = E3({ normalize: r, validator: J });
  if (O)
    Q += T3 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (P) {
    const N = (A, S) => {
      const C = T?.[A] ?? S;
      if (!C)
        return typeof S === "string" ? `${A}: "${S}",` : `${A}: ${S},`;
      if (typeof C === "string")
        return `${A}: '${C}',`;
      if (C instanceof Date)
        return `${A}: new Date(${C.getTime()}),`;
      return `${A}: ${C},`;
    }, _ = T ? `{
			secrets: ${T.secrets !== undefined ? typeof T.secrets === "string" ? `'${T.secrets}'` : "[" + T.secrets.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
			sign: ${T.sign === true ? true : T.sign !== undefined ? "[" + T.sign.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
			${N("domain")}
			${N("expires")}
			${N("httpOnly")}
			${N("maxAge")}
			${N("path", "/")}
			${N("priority")}
			${N("sameSite")}
			${N("secure")}
		}` : "undefined";
    if (O)
      Q += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${_})\n`;
    else
      Q += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${_})\n`;
  }
  if (z) {
    const N = [];
    if (J.query && J.query.schema.type === "object") {
      const _ = J.query.schema.properties;
      if (!J0(J.query))
        for (let [A, S] of Object.entries(_)) {
          let C = S;
          if (C && P1.optional in C && C.type === "array" && C.items)
            C = C.items;
          const { type: a, anyOf: H } = C, U0 = a === "array" || H?.some((u) => u.type === "string" && u.format === "ArrayString");
          N.push({ key: A, isArray: U0, isNestedObjectArray: U0 && C.items?.type === "object" || !!C.items?.anyOf?.some((u) => u.type === "object" || u.type === "array"), isObject: a === "object" || H?.some((u) => u.type === "string" && u.format === "ArrayString"), anyOf: !!H });
        }
    }
    if (!N.length)
      Q += `if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQueryFromURL(c.url.slice(c.qi + 1))
			}`;
    else
      Q += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${N.map(({ key: _, isArray: A, isObject: S, isNestedObjectArray: C, anyOf: a }, H) => {
        const U0 = `${H === 0 ? "let" : ""} memory = url.indexOf('&${_}=')
							let a${H}\n`;
        if (A)
          return U0 + (C ? `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${H} === undefined)
												a${H} = ''
											else
												a${H} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
											else temp = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${H} += temp

											if(memory === -1) break

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}

										try {
										    if(a${H}.charCodeAt(0) === 91)
												a${H} = JSON.parse(a${H})
											else
												a${H} = JSON.parse('[' + a${H} + ']')
										} catch {}\n` : `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${H} === undefined)
												a${H} = []

											if(memory === -1) {
												a${H}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g, ' '))
												break
											}
											else a${H}.push(decodeURIComponent(url.slice(start, memory)).replace(/\\+/g, ' '))

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}\n`);
        if (S)
          return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
										else a${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

										if (a${H} !== undefined) {
											try {
												a${H} = JSON.parse(a${H})
											} catch {}
										}
									}`;
        return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
										else {
											a${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

											${a ? `
											let deepMemory = url.indexOf('&${_}=', memory)

											if(deepMemory !== -1) {
												a${H} = [a${H}]
												let first = true

												while(true) {
													const start = deepMemory + ${_.length + 2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
													else value = decodeURIComponent(url.slice(start, deepMemory).replace(/\\+/g, ' '))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${H}.push(JSON.parse(value))
														} catch {
														 	a${H}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
												` : ""}
										}
									}`;
      }).join("\n")}

				c.query = {
					${N.map(({ key: _ }, A) => `'${_}': a${A}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
  }
  if (F)
    Q += "\nconst id = c[ELYSIA_REQUEST_ID]\n";
  const R = x2({ trace: j.trace, addFn: (N) => {
    Q += N;
  } });
  Q += "\ntry {\n";
  const Y0 = typeof Y === "function" && k(Y), e = F || j.afterResponse.length > 0 ? "c.response = " : "", y0 = P || D || Y0 || j.parse.length > 0 || j.afterHandle.some(k) || j.beforeHandle.some(k) || j.transform.some(k) || j.mapResponse.some(k), O1 = (typeof Y === "function" ? B2(Y) : false) || j.beforeHandle.some(B2) || j.afterHandle.some(B2) || j.transform.some(B2), t0 = K.cookie || K.set || O || F || J.response || B && I || O1, s = ", c.request";
  Q += `c.route = \`${W}\`\n`;
  const V1 = R("parse", { total: j.parse.length });
  if (D) {
    const N = j.parse.length || K.body || J.body;
    if (Q += "isParsing = true\n", j.type && !j.parse.length)
      switch (j.type) {
        case "json":
        case "application/json":
          if (t(J.body))
            Q += "try { c.body = await c.request.json() } catch {}";
          else
            Q += "c.body = await c.request.json()";
          break;
        case "text":
        case "text/plain":
          Q += "c.body = await c.request.text()\n";
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          Q += "c.body = parseQuery(await c.request.text())\n";
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          Q += "c.body = await c.request.arrayBuffer()\n";
          break;
        case "formdata":
        case "multipart/form-data":
          if (Q += "c.body = {}\n", t(J.body))
            Q += "let form; try { form = await c.request.formData() } catch {}";
          else
            Q += "const form = await c.request.formData()";
          Q += `\nif(form)
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						} else form = {}\n`;
          break;
      }
    else if (N) {
      if (Q += "\n", Q += O ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", Q += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n
					c.contentType = contentType\n`, j.parse.length) {
        Q += "let used = false\n";
        const _ = R("parse", { total: j.parse.length });
        for (let A = 0;A < j.parse.length; A++) {
          const S = _.resolveChild(j.parse[A].fn.name), C = `bo${A}`;
          if (A !== 0)
            Q += "if(!used) {\n";
          if (Q += `let ${C} = parse[${A}](c, contentType)\n`, Q += `if(${C} instanceof Promise) ${C} = await ${C}\n`, Q += `if(${C} !== undefined) { c.body = ${C}; used = true }\n`, S(), A !== 0)
            Q += "}";
        }
        _.resolve();
      }
      if (Q += "\ndelete c.contentType\n", j.parse.length)
        Q += "if (!used) {";
      if (j.type && !Array.isArray(j.type))
        switch (j.type) {
          case "json":
          case "application/json":
            if (t(J.body))
              Q += "try { c.body = await c.request.json() } catch {}";
            else
              Q += "c.body = await c.request.json()";
            break;
          case "text":
          case "text/plain":
            Q += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            Q += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            Q += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            Q += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}\n`;
            break;
        }
      else
        Q += `
					switch (contentType) {
						case 'application/json':
							${t(J.body) ? "try { c.body = await c.request.json() } catch {}" : "c.body = await c.request.json()"}
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
      if (j.parse.length)
        Q += "}";
      Q += "}\n";
    }
    Q += "\nisParsing = false\n";
  }
  if (V1.resolve(), j?.transform) {
    const N = R("transform", { total: j.transform.length });
    if (j.transform.length)
      Q += "\nlet transformed\n";
    for (let _ = 0;_ < j.transform.length; _++) {
      const A = j.transform[_], S = N.resolveChild(A.fn.name);
      if (Q += k(A) ? `transformed = await transform[${_}](c)\n` : `transformed = transform[${_}](c)\n`, A.subType === "mapDerive")
        Q += `if(transformed instanceof ElysiaCustomStatusResponse)
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;
      else
        Q += `if(transformed instanceof ElysiaCustomStatusResponse)
					throw transformed
				else
					Object.assign(c, transformed)\n`;
      S();
    }
    N.resolve();
  }
  if (J) {
    if (Q += "\n", J.headers) {
      if (r && "Clean" in J.headers && !J0(J.headers))
        Q += "c.headers = validator.headers.Clean(c.headers);\n";
      if (V0("default", J.headers.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.headers.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `c.headers['${N}'] ??= ${A}\n`;
        }
      if (t(J.headers))
        Q += "if(isNotEmpty(c.headers)) {";
      if (Q += `if(validator.headers.Check(c.headers) === false) {
				${L("headers")}
			}`, S0(J.headers.schema))
        Q += "c.headers = validator.headers.Decode(c.headers)\n";
      if (t(J.headers))
        Q += "}";
    }
    if (J.params) {
      if (V0("default", J.params.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.params.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `c.params['${N}'] ??= ${A}\n`;
        }
      if (Q += `if(validator.params.Check(c.params) === false) {
				${L("params")}
			}`, S0(J.params.schema))
        Q += "\nc.params = validator.params.Decode(c.params)\n";
    }
    if (J.query) {
      if (r && "Clean" in J.query && !J0(J.query))
        Q += "c.query = validator.query.Clean(c.query);\n";
      if (V0("default", J.query.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.query.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `if(c.query['${N}'] === undefined) c.query['${N}'] = ${A}\n`;
        }
      if (t(J.query))
        Q += "if(isNotEmpty(c.query)) {";
      if (Q += `if(validator.query.Check(c.query) === false) {
          		${L("query")}
			}`, S0(J.query.schema))
        Q += "\nc.query = validator.query.Decode(Object.assign({}, c.query))\n";
      if (t(J.query))
        Q += "}";
    }
    if (J.body) {
      if (r && "Clean" in J.body && !J0(J.body))
        Q += "c.body = validator.body.Clean(c.body);\n";
      const N = S0(J.body.schema);
      if (N || t(J.body))
        Q += '\nconst isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))\n';
      if (V0("default", J.body.schema)) {
        const _ = exports_value2.Default(J.body.schema, J.body.schema.type === "object" ? {} : undefined), A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
        if (Q += `if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${A}, c.body)
					} else { c.body = ${A} }`, t(J.body))
          Q += `
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${L("body")}
             			}
                    }`;
        else
          Q += `
    				if(validator.body.Check(c.body) === false) {
        				${L("body")}
         			}
                }`;
      } else if (t(J.body))
        Q += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${L("body")}
          		}`;
      else
        Q += `if(validator.body.Check(c.body) === false) {
         			${L("body")}
          		}`;
      if (N)
        Q += "\nif(isNotEmptyObject) c.body = validator.body.Decode(c.body)\n";
    }
    if (c(b?.schema?.properties ?? b?.schema?.schema ?? {})) {
      if (Q += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, V0("default", b.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(b.schema, {})))
          Q += `cookieValue['${N}'] = ${typeof _ === "object" ? JSON.stringify(_) : _}\n`;
      if (t(J.cookie))
        Q += "if(isNotEmpty(c.cookie)) {";
      if (Q += `if(validator.cookie.Check(cookieValue) === false) {
				${L("cookie", "cookieValue")}
			}`, S0(J.cookie.schema))
        Q += `\nfor(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value\n`;
      if (t(J.cookie))
        Q += "}";
    }
  }
  if (j?.beforeHandle) {
    const N = R("beforeHandle", { total: j.beforeHandle.length });
    let _ = false;
    for (let A = 0;A < j.beforeHandle.length; A++) {
      const S = j.beforeHandle[A], C = N.resolveChild(S.fn.name), a = E0(S);
      if (S.subType === "resolve" || S.subType === "mapResolve") {
        if (!_)
          _ = true, Q += "\nlet resolved\n";
        if (Q += k(S) ? `resolved = await beforeHandle[${A}](c);\n` : `resolved = beforeHandle[${A}](c);\n`, S.subType === "mapResolve")
          Q += `if(resolved instanceof ElysiaCustomStatusResponse)
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;
        else
          Q += `if(resolved instanceof ElysiaCustomStatusResponse)
						throw resolved
					else
						Object.assign(c, resolved)\n`;
      } else if (!a)
        Q += k(S) ? `await beforeHandle[${A}](c);\n` : `beforeHandle[${A}](c);\n`, C();
      else {
        if (Q += k(S) ? `be = await beforeHandle[${A}](c);\n` : `be = beforeHandle[${A}](c);\n`, C("be"), Q += "if(be !== undefined) {\n", N.resolve(), j.afterHandle?.length) {
          R("handle", { name: B ? Y.name : undefined }).resolve();
          const u = R("afterHandle", { total: j.afterHandle.length });
          for (let G0 = 0;G0 < j.afterHandle.length; G0++) {
            const L0 = j.afterHandle[G0], S1 = E0(L0), C1 = u.resolveChild(L0.fn.name);
            if (Q += "c.response = be\n", !S1)
              Q += k(L0.fn) ? `await afterHandle[${G0}](c, be)\n` : `afterHandle[${G0}](c, be)\n`;
            else
              Q += k(L0.fn) ? `af = await afterHandle[${G0}](c)\n` : `af = afterHandle[${G0}](c)\n`, Q += "if(af !== undefined) { c.response = be = af }\n";
            C1("af");
          }
          u.resolve();
        }
        if (J.response)
          Q += g("be");
        const U0 = R("mapResponse", { total: j.mapResponse.length });
        if (j.mapResponse.length) {
          Q += "\nc.response = be\n";
          for (let u = 0;u < j.mapResponse.length; u++) {
            const G0 = j.mapResponse[u], L0 = U0.resolveChild(G0.fn.name);
            Q += `\nif(mr === undefined) {
							mr = ${C0(G0) ? "await" : ""} onMapResponse[${u}](c)
							if(mr !== undefined) be = c.response = mr
						}\n`, L0();
          }
        }
        U0.resolve(), Q += E, Q += `return mapEarlyResponse(${e} be, c.set ${s})}\n`;
      }
    }
    N.resolve();
  }
  if (j?.afterHandle.length) {
    const N = R("handle", { name: B ? Y.name : undefined });
    if (j.afterHandle.length)
      Q += Y0 ? `let r = c.response = await ${U};\n` : `let r = c.response = ${U};\n`;
    else
      Q += Y0 ? `let r = await ${U};\n` : `let r = ${U};\n`;
    N.resolve();
    const _ = R("afterHandle", { total: j.afterHandle.length });
    for (let S = 0;S < j.afterHandle.length; S++) {
      const C = j.afterHandle[S], a = E0(C), H = _.resolveChild(C.fn.name);
      if (!a)
        Q += k(C.fn) ? `await afterHandle[${S}](c)\n` : `afterHandle[${S}](c)\n`, H();
      else if (Q += k(C.fn) ? `af = await afterHandle[${S}](c)\n` : `af = afterHandle[${S}](c)\n`, H("af"), J.response)
        Q += "if(af !== undefined) {", _.resolve(), Q += g("af"), Q += "c.response = af }";
      else
        Q += "if(af !== undefined) {", _.resolve(), Q += "c.response = af}\n";
    }
    if (_.resolve(), Q += "r = c.response\n", J.response)
      Q += g();
    Q += E;
    const A = R("mapResponse", { total: j.mapResponse.length });
    if (j.mapResponse.length)
      for (let S = 0;S < j.mapResponse.length; S++) {
        const C = j.mapResponse[S], a = A.resolveChild(C.fn.name);
        Q += `\nmr = ${C0(C) ? "await" : ""} onMapResponse[${S}](c)
				if(mr !== undefined) r = c.response = mr\n`, a();
      }
    if (A.resolve(), t0)
      Q += `return mapResponse(${e} r, c.set ${s})\n`;
    else
      Q += `return mapCompactResponse(${e} r ${s})\n`;
  } else {
    const N = R("handle", { name: B ? Y.name : undefined });
    if (J.response || j.mapResponse.length) {
      if (Q += Y0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), J.response)
        Q += g();
      R("afterHandle").resolve();
      const _ = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length) {
        Q += "\nc.response = r\n";
        for (let A = 0;A < j.mapResponse.length; A++) {
          const S = j.mapResponse[A], C = _.resolveChild(S.fn.name);
          Q += `\nif(mr === undefined) {
						mr = ${C0(S) ? "await" : ""} onMapResponse[${A}](c)
    					if(mr !== undefined) r = c.response = mr
					}\n`, C();
        }
      }
      if (_.resolve(), Q += E, Y instanceof Response)
        Q += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${s})
				else
					return ${U}.clone()` : `return ${U}.clone()`, Q += "\n";
      else if (t0)
        Q += `return mapResponse(${e} r, c.set ${s})\n`;
      else
        Q += `return mapCompactResponse(${e} r ${s})\n`;
    } else if (P || F) {
      Q += Y0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), R("afterHandle").resolve();
      const _ = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length) {
        Q += "\nc.response = r\n";
        for (let A = 0;A < j.mapResponse.length; A++) {
          const S = j.mapResponse[A], C = _.resolveChild(S.fn.name);
          Q += `\nif(mr === undefined) {
							mr = ${C0(S) ? "await" : ""} onMapResponse[${A}](c)
    						if(mr !== undefined) r = c.response = mr
						}\n`, C();
        }
      }
      if (_.resolve(), Q += E, t0)
        Q += `return mapResponse(${e} r, c.set ${s})\n`;
      else
        Q += `return mapCompactResponse(${e} r ${s})\n`;
    } else {
      N.resolve();
      const _ = Y0 ? `await ${U}` : U;
      if (R("afterHandle").resolve(), Y instanceof Response)
        Q += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${s})
				else
					return ${U}.clone()` : `return ${U}.clone()`, Q += "\n";
      else if (t0)
        Q += `return mapResponse(${e} ${_}, c.set ${s})\n`;
      else
        Q += `return mapCompactResponse(${e} ${_} ${s})\n`;
    }
  }
  if (Q += "\n} catch(error) {", D)
    Q += "\nif(isParsing) error = new ParseError()\n";
  if (!y0)
    Q += "\nreturn (async () => {\n";
  if (Q += "\nconst set = c.set\nif (!set.status || set.status < 300) set.status = error?.status || 500\n", F)
    for (let N = 0;N < j.trace.length; N++)
      Q += `report${N}?.resolve(error);reportChild${N}?.(error);\n`;
  const K2 = R("error", { total: j.error.length });
  if (j.error.length) {
    Q += `
				c.error = error
				if(error instanceof TypeBoxError) {
					c.code = "VALIDATION"
					c.set.status = 422
				} else
					c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;
    for (let N = 0;N < j.error.length; N++) {
      const _ = K2.resolveChild(j.error[N].fn.name);
      if (k(j.error[N]))
        Q += `\ner = await handleErrors[${N}](c)\n`;
      else
        Q += `\ner = handleErrors[${N}](c)\nif (er instanceof Promise) er = await er\n`;
      _();
      const A = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length)
        for (let S = 0;S < j.mapResponse.length; S++) {
          const C = j.mapResponse[S], a = A.resolveChild(C.fn.name);
          Q += `\nc.response = er\n
							er = ${C0(C) ? "await" : ""} onMapResponse[${S}](c)
							if(er instanceof Promise) er = await er\n`, a();
        }
      if (A.resolve(), Q += `er = mapEarlyResponse(er, set ${s})\n`, Q += "if (er) {", F) {
        for (let S = 0;S < j.trace.length; S++)
          Q += `\nreport${S}.resolve()\n`;
        K2.resolve();
      }
      Q += "return er\n}\n";
    }
  }
  if (K2.resolve(), Q += "return handleError(c, error, true)\n", !y0)
    Q += "})()";
  if (Q += "}", w || F) {
    if (Q += " finally { ", !y0)
      Q += ";(async () => {";
    const N = R("afterResponse", { total: j.afterResponse.length });
    if (w)
      for (let _ = 0;_ < j.afterResponse.length; _++) {
        const A = N.resolveChild(j.afterResponse[_].fn.name);
        Q += `\nawait afterResponse[${_}](c);\n`, A();
      }
    if (N.resolve(), !y0)
      Q += "})();";
    Q += "}";
  }
  Q = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			parseQueryFromURL,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ElysiaCustomStatusResponse,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer,
		TypeBoxError
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${y0 ? "async" : ""} function handle(c) {
		${j.beforeHandle.length ? "let be" : ""}
		${j.afterHandle.length ? "let af" : ""}
		${j.mapResponse.length ? "let mr" : ""}

		${G ? "c.schema = schema; c.defs = definitions" : ""}
		${Q}
	}`;
  try {
    return Function("hooks", Q)({ handler: Y, hooks: E2(j), validator: J, handleError: $.handleError, utils: { mapResponse: x, mapCompactResponse: Z0, mapEarlyResponse: y, parseQuery: l0, parseQueryFromURL: G2, isNotEmpty: c }, error: { NotFoundError: A0, ValidationError: q, InternalServerError: Q2, ParseError: Y2 }, schema: $.router.history, definitions: $.definitions.type, ERROR_CODE: I0, parseCookie: e0, signCookie: x0, decodeURIComponent: N1.default, ElysiaCustomStatusResponse: p, ELYSIA_TRACE: i0, ELYSIA_REQUEST_ID: P0, getServer: () => $.getServer(), TypeBoxError });
  } catch {
    const N = E2(j);
    console.log("[Composer] failed to generate optimized handler"), console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"), console.log("---"), console.log({ handler: typeof Y === "function" ? Y.toString() : Y, hooks: { ...N, transform: N?.transform?.map?.((_) => _.toString()), resolve: N?.resolve?.map?.((_) => _.toString()), beforeHandle: N?.beforeHandle?.map?.((_) => _.toString()), afterHandle: N?.afterHandle?.map?.((_) => _.toString()), mapResponse: N?.mapResponse?.map?.((_) => _.toString()), parse: N?.parse?.map?.((_) => _.toString()), error: N?.error?.map?.((_) => _.toString()), afterResponse: N?.afterResponse?.map?.((_) => _.toString()), stop: N?.stop?.map?.((_) => _.toString()) }, validator: J, definitions: $.definitions.type }), console.log("---"), process.exit(1);
  }
};
var g2 = ($) => {
  const W = $.config.handler?.standardHostname ?? true;
  let X = "", Z = "";
  const j = $.setHeaders;
  for (let D of Object.keys($.singleton.decorator))
    X += `,${D}: app.singleton.decorator.${D}`;
  const J = $.router, Y = $.event.trace.length > 0;
  let G = `
	const route = router.find(request.method, path) ${J.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params\n`;
  G += `if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)\n`;
  let K = "";
  for (let [D, { code: M, all: I, static: O }] of Object.entries(J.static.http.map)) {
    if (O)
      K += `case '${D}':\nswitch(request.method) {\n${M}\n${I ?? "default: break map"}}\n\n`;
    K += `case '${D}':\nswitch(request.method) {\n${M}\n${I ?? "default: break map"}}\n\n`;
  }
  const B = $.event.request.some(k);
  if (Z += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${$.event.request.length ? "const onRequest = app.event.request.map(x => x.fn)" : ""}
	${$.event.error.length ? "" : `\nconst error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });\n`}

	${$.event.trace.length ? `const ${$.event.trace.map((D, M) => `tr${M} = app.event.trace[${M}].fn`).join(",")}` : ""}

	${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    Z += "let re";
  if (Z += `\nconst url = request.url
		const s = url.indexOf('/', ${W ? 11 : 7})
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)\n`, Z += `${Y ? "const id = randomId()" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(j ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${$.inference.server ? `, get server() {
							return getServer()
						}` : ""}
			${Y ? ",[ELYSIA_REQUEST_ID]: id" : ""}
			${X}
		}\n`, $.event.trace.length)
    Z += `\nctx[ELYSIA_TRACE] = [${$.event.trace.map((D, M) => `tr${M}(ctx)`).join(",")}]\n`;
  const w = x2({ context: "ctx", trace: $.event.trace, addFn(D) {
    Z += D;
  } })("request", { attribute: "ctx", total: $.event.request.length });
  if ($.event.request.length) {
    Z += "\n try {\n";
    for (let D = 0;D < $.event.request.length; D++) {
      const M = $.event.request[D], I = E0(M), O = k(M), P = w.resolveChild($.event.request[D].fn.name);
      if (I)
        Z += `re = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${D}](ctx),
					ctx.set,
					request
				)\n`, P("re"), Z += "if(re !== undefined) return re\n";
      else
        Z += `${O ? "await" : ""} onRequest[${D}](ctx)\n`, P();
    }
    Z += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
  }
  w.resolve();
  const F = $.router.static.ws, Q = $.router.ws;
  if (Object.keys(F).length || Q.history.length) {
    Z += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [D, M] of Object.entries(F))
      Z += `
					case '${D}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${M}](ctx)

						break`;
    Z += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}\n`;
  }
  if (Z += `
		map: switch(path) {
			${K}

			default:
				break
		}

		${G}
	}\n`, $.extender.higherOrderFunctions.length) {
    let D = "map";
    for (let M = 0;M < $.extender.higherOrderFunctions.length; M++)
      D = `hoc[${M}](${D}, request)`;
    Z += `return function hocMap(request) { return ${D}(request) }`;
  } else
    Z += "return map";
  const z = f2($);
  return $.handleError = z, Function("data", Z)({ app: $, mapEarlyResponse: y, NotFoundError: A0, randomId: j2, handleError: z, error: q2, redirect: d0, ELYSIA_TRACE: i0, ELYSIA_REQUEST_ID: P0, getServer: () => $.getServer() });
};
var f2 = ($) => {
  const W = $.event;
  let X = "";
  X += `const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ElysiaCustomStatusResponse,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${$.event.error.find(k) || $.event.mapResponse.find(k) ? "async" : ""} function(context, error, skipGlobal) {`;
  const Z = $.event.trace.length > 0;
  if (Z)
    X += "\nconst id = context[ELYSIA_REQUEST_ID]\n";
  const j = x2({ context: "context", trace: W.trace, addFn: (G) => {
    X += G;
  } });
  X += `
		const set = context.set
		let r

		if(!context.code)
			context.code = error.code ?? error[ERROR_CODE]

		if(!(context.error instanceof Error))
			context.error = error

		if(error instanceof ElysiaCustomStatusResponse) {
			error.status = error.code
			error.message = error.response
		}\n`;
  const J = Z || W.afterResponse.length > 0 || W.afterResponse.length > 0 ? "context.response = " : "";
  for (let G = 0;G < $.event.error.length; G++) {
    const K = $.event.error[G], B = `${k(K) ? "await " : ""}onError[${G}](context)`;
    if (X += "\nif(skipGlobal !== true) {\n", E0(K)) {
      X += `r = ${B}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r instanceof ElysiaCustomStatusResponse) {
					error.status = error.code
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status\n`;
      const U = j("mapResponse", { total: W.mapResponse.length, name: "context" });
      if (W.mapResponse.length)
        for (let w = 0;w < W.mapResponse.length; w++) {
          const F = W.mapResponse[w], Q = U.resolveChild(F.fn.name);
          X += `\ncontext.response = r
						r = ${C0(F) ? "await" : ""} onMapResponse[${w}](context)\n`, Q();
        }
      U.resolve(), X += `return mapResponse(${J} r, set, context.request)}\n`;
    } else
      X += B + "\n";
    X += "\n}\n";
  }
  X += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)\n`;
  const Y = j("mapResponse", { total: W.mapResponse.length, name: "context" });
  if (W.mapResponse.length)
    for (let G = 0;G < W.mapResponse.length; G++) {
      const K = W.mapResponse[G], B = Y.resolveChild(K.fn.name);
      X += `\ncontext.response = error
			error = ${C0(K) ? "await" : ""} onMapResponse[${G}](context)\n`, B();
    }
  return Y.resolve(), X += `\nreturn mapResponse(${J} error, set, context.request)\n}\n}`, Function("inject", X)({ app: $, mapResponse: x, ERROR_CODE: I0, ElysiaCustomStatusResponse: p, ELYSIA_TRACE: i0, ELYSIA_REQUEST_ID: P0 });
};
var y2 = ($) => async (W) => {
  const X = W.url, Z = X.indexOf("/", 11), j = X.indexOf("?", Z + 1), J = j === -1 ? X.substring(Z) : X.substring(Z, j), Y = { cookie: {}, status: 200, headers: {} }, G = Object.assign({}, $.singleton.decorator, { set: Y, store: $.singleton.store, request: W, path: J, qi: j, redirect: d0 });
  try {
    for (let I = 0;I < $.event.request.length; I++) {
      const O = $.event.request[I].fn;
      let P = O(G);
      if (P instanceof Promise)
        P = await P;
      if (P = y(P, Y), P)
        return G.response = P;
    }
    const K = $.router.dynamic.find(W.method, J) ?? $.router.dynamic.find("ALL", J);
    if (!K)
      throw new A0;
    const { handle: B, hooks: U, validator: w, content: F } = K.store;
    let Q;
    if (W.method !== "GET" && W.method !== "HEAD")
      if (F)
        switch (F) {
          case "application/json":
            Q = await W.json();
            break;
          case "text/plain":
            Q = await W.text();
            break;
          case "application/x-www-form-urlencoded":
            Q = l0(await W.text());
            break;
          case "application/octet-stream":
            Q = await W.arrayBuffer();
            break;
          case "multipart/form-data":
            Q = {};
            const I = await W.formData();
            for (let O of I.keys()) {
              if (Q[O])
                continue;
              const P = I.getAll(O);
              if (P.length === 1)
                Q[O] = P[0];
              else
                Q[O] = P;
            }
            break;
        }
      else {
        let I = W.headers.get("content-type");
        if (I) {
          const O = I.indexOf(";");
          if (O !== -1)
            I = I.slice(0, O);
          G.contentType = I;
          for (let P = 0;P < U.parse.length; P++) {
            const b = U.parse[P].fn;
            let T = b(G, I);
            if (T instanceof Promise)
              T = await T;
            if (T) {
              Q = T;
              break;
            }
          }
          if (delete G.contentType, Q === undefined)
            switch (I) {
              case "application/json":
                Q = await W.json();
                break;
              case "text/plain":
                Q = await W.text();
                break;
              case "application/x-www-form-urlencoded":
                Q = l0(await W.text());
                break;
              case "application/octet-stream":
                Q = await W.arrayBuffer();
                break;
              case "multipart/form-data":
                Q = {};
                const P = await W.formData();
                for (let b of P.keys()) {
                  if (Q[b])
                    continue;
                  const T = P.getAll(b);
                  if (T.length === 1)
                    Q[b] = T[0];
                  else
                    Q[b] = T;
                }
                break;
            }
        }
      }
    G.body = Q, G.params = K?.params || undefined, G.query = j === -1 ? {} : G2(X.substring(j + 1)), G.headers = {};
    for (let [I, O] of W.headers.entries())
      G.headers[I] = O;
    const z = Object.assign({}, $.config?.cookie, w?.cookie?.config), D = W.headers.get("cookie");
    G.cookie = await e0(G.set, D, z ? { secrets: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let I = 0;I < U.transform.length; I++) {
      const O = U.transform[I], P = O.fn(G);
      if (O.subType === "derive")
        if (P instanceof Promise)
          Object.assign(G, await P);
        else
          Object.assign(G, P);
      else if (P instanceof Promise)
        await P;
    }
    if (w) {
      if (w.createHeaders?.()) {
        const I = {};
        for (let O in W.headers)
          I[O] = W.headers.get(O);
        if (w.headers.Check(I) === false)
          throw new q("header", w.headers, I);
      } else if (w.headers?.Decode)
        G.headers = w.headers.Decode(G.headers);
      if (w.createParams?.()?.Check(G.params) === false)
        throw new q("params", w.params, G.params);
      else if (w.params?.Decode)
        G.params = w.params.Decode(G.params);
      if (w.createQuery?.()?.Check(G.query) === false)
        throw new q("query", w.query, G.query);
      else if (w.query?.Decode)
        G.query = w.query.Decode(G.query);
      if (w.createCookie?.()) {
        let I = {};
        for (let [O, P] of Object.entries(G.cookie))
          I[O] = P.value;
        if (w.cookie.Check(I) === false)
          throw new q("cookie", w.cookie, I);
        else if (w.cookie?.Decode)
          I = w.cookie.Decode(I);
      }
      if (w.createBody?.()?.Check(Q) === false)
        throw new q("body", w.body, Q);
      else if (w.body?.Decode)
        G.body = w.body.Decode(Q);
    }
    for (let I = 0;I < U.beforeHandle.length; I++) {
      const O = U.beforeHandle[I];
      let P = O.fn(G);
      if (O.subType === "resolve") {
        if (P instanceof Promise)
          Object.assign(G, await P);
        else
          Object.assign(G, P);
        continue;
      } else if (P instanceof Promise)
        P = await P;
      if (P !== undefined) {
        G.response = P;
        for (let T = 0;T < U.afterHandle.length; T++) {
          let E = U.afterHandle[T].fn(G);
          if (E instanceof Promise)
            E = await E;
          if (E)
            P = E;
        }
        const b = y(P, G.set);
        if (b)
          return G.response = b;
      }
    }
    let M = B(G);
    if (M instanceof Promise)
      M = await M;
    if (!U.afterHandle.length) {
      const I = M instanceof p ? M.code : Y.status ? typeof Y.status === "string" ? _0[Y.status] : Y.status : 200, O = w?.createResponse?.()?.[I];
      if (O?.Check(M) === false)
        throw new q("response", O, M);
      else if (O?.Decode)
        M = O.Decode(M);
    } else {
      G.response = M;
      for (let I = 0;I < U.afterHandle.length; I++) {
        let O = U.afterHandle[I].fn(G);
        if (O instanceof Promise)
          O = await O;
        const P = y(O, G.set);
        if (P !== undefined) {
          const b = w?.response?.[P.status];
          if (b?.Check(P) === false)
            throw new q("response", b, P);
          else if (b?.Decode)
            M = b.Decode(M);
          return G.response = P;
        }
      }
    }
    if (G.set.cookie && z?.sign) {
      const I = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [O, P] of Object.entries(G.set.cookie))
          G.set.cookie[O].value = await x0(P.value, "${secret}");
      else {
        const O = w?.cookie?.schema?.properties;
        for (let P of z.sign) {
          if (!(P in O))
            continue;
          if (G.set.cookie[P]?.value)
            G.set.cookie[P].value = await x0(G.set.cookie[P].value, I);
        }
      }
    }
    return G.response = x(M, G.set);
  } catch (K) {
    if (K.status)
      Y.status = K.status;
    return $.handleError(G, K);
  } finally {
    for (let K of $.event.afterResponse)
      await K.fn(G);
  }
};
var A1 = ($) => async (W, X) => {
  const Z = Object.assign(W, { error: X, code: X.code });
  Z.set = W.set;
  for (let j = 0;j < $.event.error.length; j++) {
    let Y = $.event.error[j].fn(Z);
    if (Y instanceof Promise)
      Y = await Y;
    if (Y !== undefined && Y !== null)
      return W.response = x(Y, W.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: W.set.headers, status: X.status ?? 500 });
};

class Q0 {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Scoped: false, Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  static version = R2;
  version = R2;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  definitions = { type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return b0(b0(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new M0, ws: new M0, dynamic: new M0, static: { http: { static: {}, handlers: [], map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false };
  getServer() {
    return this.server;
  }
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new T2;
    return this._promisedModules;
  }
  constructor($ = {}) {
    if ($.tags)
      if (!$.detail)
        $.detail = { tags: $.tags };
      else
        $.detail.tags = $.tags;
    if ($.nativeStaticResponse === undefined)
      $.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig($ ?? {}), $?.analytic && ($?.name || $?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  env($, W = Bun?.env ?? process.env) {
    if (m($, { dynamic: true, additionalProperties: true, coerce: true }).Check(W) === false) {
      const Z = new q("env", $, W);
      throw new Error(Z.all.map((j) => j.summary).join("\n"));
    }
    return this;
  }
  wrap($) {
    return this.extender.higherOrderFunctions.push({ checksum: N0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ }), this;
  }
  applyMacro($) {
    if (this.extender.macros.length) {
      const W = F1({ globalHook: this.event, localHook: $ }), X = { events: { global: this.event, local: $ }, onParse: W("parse"), onTransform: W("transform"), onBeforeHandle: W("beforeHandle"), onAfterHandle: W("afterHandle"), mapResponse: W("mapResponse"), onAfterResponse: W("afterResponse"), onError: W("error") };
      for (let Z of this.extender.macros)
        _1(Z.fn(X), $);
    }
  }
  applyConfig($) {
    return this.config = { prefix: "", aot: true, strictPath: false, global: false, analytic: false, normalize: true, ...$, cookie: { path: "/", ...$?.cookie }, experimental: $?.experimental ?? {}, seed: $?.seed === undefined ? "" : $?.seed }, this;
  }
  get models() {
    const $ = {};
    for (let [W, X] of Object.entries(this.definitions.type))
      $[W] = m(X);
    return $;
  }
  add($, W, X, Z, { allowMeta: j = false, skipPrefix: J = false } = { allowMeta: false, skipPrefix: false }) {
    if (Z = M1(Z), W !== "" && W.charCodeAt(0) !== 47)
      W = "/" + W;
    if (this.config.prefix && !J && !this.config.scoped)
      W = this.config.prefix + W;
    if (Z?.type)
      switch (Z.type) {
        case "text":
          Z.type = "text/plain";
          break;
        case "json":
          Z.type = "application/json";
          break;
        case "formdata":
          Z.type = "multipart/form-data";
          break;
        case "urlencoded":
          Z.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          Z.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const Y = this.definitions.type, G = !this.config.aot, K = { ...this.validator.getCandidate() }, B = { body: Z?.body ?? K?.body, headers: Z?.headers ?? K?.headers, params: Z?.params ?? K?.params, query: Z?.query ?? K?.query, cookie: Z?.cookie ?? K?.cookie, response: Z?.response ?? K?.response }, U = () => B.cookie ? W2({ validator: B.cookie, defaultConfig: this.config.cookie, config: B.cookie?.config ?? {}, dynamic: G, models: Y }) : undefined, w = this.config.normalize, F = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: m(B.body, { dynamic: G, models: Y, normalize: w, additionalCoerce: S2() }), headers: m(B.headers, { dynamic: G, models: Y, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: D0() }), params: m(B.params, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() }), query: m(B.query, { dynamic: G, models: Y, normalize: w, coerce: true, additionalCoerce: D0() }), cookie: U(), response: $2(B.response, { dynamic: G, models: Y, normalize: w }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = m(B.body, { dynamic: G, models: Y, normalize: w, additionalCoerce: S2() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = m(B.headers, { dynamic: G, models: Y, additionalProperties: !w, coerce: true, additionalCoerce: D0() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = m(B.params, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = m(B.query, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = U();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = $2(B.response, { dynamic: G, models: Y, normalize: w });
    } }, Q = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
    if (Z = i(Z, K), Z.tags)
      if (!Z.detail)
        Z.detail = { tags: Z.tags };
      else
        Z.detail.tags = Z.tags;
    if (c(this.config.detail))
      Z.detail = d(Object.assign({}, this.config.detail), Z.detail);
    this.applyMacro(Z);
    const z = i(this.event, Z);
    if (this.config.aot === false) {
      if (this.router.dynamic.add($, W, { validator: F, hooks: z, content: Z?.type, handle: X }), this.config.strictPath === false)
        this.router.dynamic.add($, Q, { validator: F, hooks: z, content: Z?.type, handle: X });
      this.router.history.push({ method: $, path: W, composed: null, handler: X, hooks: z });
      return;
    }
    const D = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, M = m0(this.inference), I = typeof X !== "function" ? Q1(X, z, this.setHeaders) : undefined, O = typeof X !== "function" ? Y1(X, z, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
      this.router.static.http.static[W] = O();
    const P = () => I1({ app: this, path: W, method: $, localHook: i(Z), hooks: z, validator: F, handler: X, allowMeta: j, inference: M }), b = D ? P() : (L) => {
      return P()(L);
    }, T = this.router.history.length;
    if (this.routeTree.has($ + W))
      for (let L = 0;L < this.router.history.length; L++) {
        const g = this.router.history[L];
        if (g.path === W && g.method === $) {
          const R = this.router.history.splice(L, 1)[0];
          if (R && this.routeTree.has(R?.method + R?.path))
            this.routeTree.delete(R.method + R.path);
        }
      }
    else
      this.routeTree.set($ + W, T);
    this.router.history.push({ method: $, path: W, composed: b, handler: X, hooks: z });
    const E = this.router.static.http, r = { handler: D ? b : undefined, compile: P };
    if ($ === "$INTERNALWS") {
      const L = this.config.strictPath ? undefined : W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
        const g = E.handlers.length;
        if (E.handlers.push((R) => (E.handlers[g] = P())(R)), this.router.static.ws[W] = g, L)
          this.router.static.ws[L] = g;
      } else if (this.router.ws.add("ws", W, r), L)
        this.router.ws.add("ws", L, r);
      return;
    }
    if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
      const L = E.handlers.length;
      if (E.handlers.push(I ?? ((R) => (E.handlers[L] = P())(R))), !E.map[W])
        E.map[W] = { code: "" };
      const g = I ? "" : "ctx";
      if ($ === "ALL")
        E.map[W].all = `default: return st[${L}](${g})\n`;
      else
        E.map[W].code = `case '${$}': return st[${L}](${g})\n${E.map[W].code}`;
      if (!this.config.strictPath) {
        if (!E.map[Q])
          E.map[Q] = { code: "" };
        if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
          this.router.static.http.static[Q] = O();
        if ($ === "ALL")
          E.map[Q].all = `default: return st[${L}](${g})\n`;
        else
          E.map[Q].code = `case '${$}': return st[${L}](${g})\n${E.map[Q].code}`;
      }
    } else if (this.router.http.add($, W, r), !this.config.strictPath) {
      const L = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (this.config.nativeStaticResponse === true && I && ($ === "GET" || $ === "ALL"))
        this.router.static.http.static[L] = I();
      this.router.http.add($, L, r);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($, W) {
    if (!W)
      return this.on("parse", $);
    return this.on($, "parse", W);
  }
  onTransform($, W) {
    if (!W)
      return this.on("transform", $);
    return this.on($, "transform", W);
  }
  resolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "resolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  mapResolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapResolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  onBeforeHandle($, W) {
    if (!W)
      return this.on("beforeHandle", $);
    return this.on($, "beforeHandle", W);
  }
  onAfterHandle($, W) {
    if (!W)
      return this.on("afterHandle", $);
    return this.on($, "afterHandle", W);
  }
  mapResponse($, W) {
    if (!W)
      return this.on("mapResponse", $);
    return this.on($, "mapResponse", W);
  }
  onAfterResponse($, W) {
    if (!W)
      return this.on("afterResponse", $);
    return this.on($, "afterResponse", W);
  }
  trace($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    if (!Array.isArray(W))
      W = [W];
    for (let X of W)
      this.on($, "trace", D1(X));
    return this;
  }
  error($, W) {
    switch (typeof $) {
      case "string":
        return W.prototype[I0] = $, this.definitions.error[$] = W, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, Z] of Object.entries($))
      Z.prototype[I0] = X, this.definitions.error[X] = Z;
    return this;
  }
  onError($, W) {
    if (!W)
      return this.on("error", $);
    return this.on($, "error", W);
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W, X) {
    let Z;
    switch (typeof $) {
      case "string":
        Z = $, X = W;
        break;
      case "object":
        if (Z = W, !Array.isArray(W) && typeof W === "object")
          X = W;
        break;
    }
    if (Array.isArray(X))
      X = n(X);
    else if (typeof X === "function")
      X = [{ fn: X }];
    else
      X = [X];
    const j = X;
    for (let J of j)
      J.scope = typeof $ === "string" ? "local" : $?.as ?? "local";
    if (Z !== "trace")
      r0({ [Z]: j.map((J) => J.fn) }, this.inference);
    for (let J of j) {
      const Y = w1(J, "global", { skipIfHasType: true });
      switch (Z) {
        case "start":
          this.event.start.push(Y);
          break;
        case "request":
          this.event.request.push(Y);
          break;
        case "parse":
          this.event.parse.push(Y);
          break;
        case "transform":
          this.event.transform.push(Y);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Y);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Y);
          break;
        case "mapResponse":
          this.event.mapResponse.push(Y);
          break;
        case "afterResponse":
          this.event.afterResponse.push(Y);
          break;
        case "trace":
          this.event.trace.push(Y);
          break;
        case "error":
          this.event.error.push(Y);
          break;
        case "stop":
          this.event.stop.push(Y);
          break;
      }
    }
    return this;
  }
  propagate() {
    return v(this.event.parse), v(this.event.transform), v(this.event.beforeHandle), v(this.event.afterHandle), v(this.event.mapResponse), v(this.event.afterResponse), v(this.event.trace), v(this.event.error), this;
  }
  as($) {
    const W = { plugin: "scoped", global: "global" }[$];
    if (v(this.event.parse, W), v(this.event.transform, W), v(this.event.beforeHandle, W), v(this.event.afterHandle, W), v(this.event.mapResponse, W), v(this.event.afterResponse, W), v(this.event.trace, W), v(this.event.error, W), $ === "plugin")
      this.validator.scoped = b0(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if ($ === "global")
      this.validator.global = b0(this.validator.global, b0(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group($, W, X) {
    const Z = new Q0({ ...this.config, prefix: "" });
    Z.singleton = { ...this.singleton }, Z.definitions = { ...this.definitions }, Z.getServer = () => this.getServer(), Z.inference = m0(this.inference), Z.extender = { ...this.extender };
    const j = typeof W === "object", J = (j ? X : W)(Z);
    if (this.singleton = d(this.singleton, Z.singleton), this.definitions = d(this.definitions, Z.definitions), J.event.request.length)
      this.event.request = [...this.event.request || [], ...J.event.request || []];
    if (J.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...J.event.mapResponse || []];
    return this.model(J.definitions.type), Object.values(Z.router.history).forEach(({ method: Y, path: G, handler: K, hooks: B }) => {
      if (G = (j ? "" : this.config.prefix) + $ + G, j) {
        const U = W, w = B;
        this.add(Y, G, K, i(U, { ...w || {}, error: !w.error ? J.event.error : Array.isArray(w.error) ? [...w.error || {}, ...J.event.error || {}] : [w.error, ...J.event.error || {}] }));
      } else
        this.add(Y, G, K, i(B, { error: J.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W) {
    if (!W) {
      if (typeof $ === "object") {
        this.applyMacro($);
        const j = $.as ?? "local";
        if (this.validator[j] = { body: $.body ?? this.validator[j]?.body, headers: $.headers ?? this.validator[j]?.headers, params: $.params ?? this.validator[j]?.params, query: $.query ?? this.validator[j]?.query, response: $.response ?? this.validator[j]?.response, cookie: $.cookie ?? this.validator[j]?.cookie }, $.parse)
          this.on({ as: j }, "parse", $.parse);
        if ($.transform)
          this.on({ as: j }, "transform", $.transform);
        if ($.beforeHandle)
          this.on({ as: j }, "beforeHandle", $.beforeHandle);
        if ($.afterHandle)
          this.on({ as: j }, "afterHandle", $.afterHandle);
        if ($.mapResponse)
          this.on({ as: j }, "mapResponse", $.mapResponse);
        if ($.afterResponse)
          this.on({ as: j }, "afterResponse", $.afterResponse);
        if ($.error)
          this.on({ as: j }, "error", $.error);
        if ($.detail)
          if (this.config.detail)
            this.config.detail = d(Object.assign({}, this.config.detail), $.detail);
          else
            this.config.detail = $.detail;
        if ($?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: $.tags };
          else
            this.config.detail.tags = $.tags;
        return this;
      }
      return this.guard({}, $);
    }
    const X = new Q0({ ...this.config, prefix: "" });
    X.singleton = { ...this.singleton }, X.definitions = { ...this.definitions }, X.inference = m0(this.inference), X.extender = { ...this.extender };
    const Z = W(X);
    if (this.singleton = d(this.singleton, X.singleton), this.definitions = d(this.definitions, X.definitions), Z.getServer = () => this.server, Z.event.request.length)
      this.event.request = [...this.event.request || [], ...Z.event.request || []];
    if (Z.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...Z.event.mapResponse || []];
    return this.model(Z.definitions.type), Object.values(X.router.history).forEach(({ method: j, path: J, handler: Y, hooks: G }) => {
      this.add(j, J, Y, i($, { ...G || {}, error: !G.error ? Z.event.error : Array.isArray(G.error) ? [...G.error || {}, ...Z.event.error || []] : [G.error, ...Z.event.error || []] }));
    }), this;
  }
  use($, W) {
    if (W?.scoped)
      return this.guard({}, (X) => X.use($));
    if (Array.isArray($)) {
      let X = this;
      for (let Z of $)
        X = this.use(Z);
      return X;
    }
    if ($ instanceof Promise)
      return this.promisedModules.add($.then((X) => {
        if (typeof X === "function")
          return X(this);
        if (X instanceof Q0)
          return this._use(X).compile();
        if (typeof X.default === "function")
          return X.default(this);
        if (X.default instanceof Q0)
          return this._use(X.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((X) => X.compile())), this;
    return this._use($);
  }
  _use($) {
    if (typeof $ === "function") {
      const j = $(this);
      if (j instanceof Promise)
        return this.promisedModules.add(j.then((J) => {
          if (J instanceof Q0) {
            J.getServer = () => this.getServer(), J.getGlobalRoutes = () => this.getGlobalRoutes(), J.model(this.definitions.type), J.error(this.definitions.error);
            for (let { method: Y, path: G, handler: K, hooks: B } of Object.values(J.router.history))
              this.add(Y, G, K, i(B, { error: J.event.error }));
            return J.compile(), J;
          }
          if (typeof J === "function")
            return J(this);
          if (typeof J.default === "function")
            return J.default(this);
          return this._use(J);
        }).then((J) => J.compile())), this;
      return j;
    }
    const { name: W, seed: X } = $.config;
    $.getServer = () => this.getServer(), $.getGlobalRoutes = () => this.getGlobalRoutes(), $.model(this.definitions.type), $.error(this.definitions.error);
    const Z = $.config.scoped;
    if (Z) {
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const J = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: Y }) => J === Y))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton.decorator, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.subType === "derive").map((Y) => ({ fn: Y.fn.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.subType === "derive").map((Y) => ({ fn: Y.fn.toString(), stack: new Error().stack ?? "" })) });
      }
      $.extender.macros = this.extender.macros.concat($.extender.macros);
      const j = [];
      for (let J = 0;J < $.extender.macros.length; J++) {
        const Y = this.extender.macros[J];
        if (j.includes(Y.checksum))
          $.extender.macros.splice(J, 1), J--;
        j.push(Y.checksum);
      }
      if ($.onRequest((J) => {
        Object.assign(J, this.singleton.decorator), Object.assign(J.store, this.singleton.store);
      }), $.event.trace.length)
        $.event.trace.push(...$.event.trace);
      if (!$.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if ($.event.error.length)
        $.event.error.push(...this.event.error);
      if ($.config.aot)
        $.compile();
      if (Z === true && $.config.prefix) {
        this.mount($.config.prefix + "/", $.fetch);
        for (let J of $.router.history)
          this.routeTree.set(J.method + `${$.config.prefix}${J.path}`, this.router.history.length), this.router.history.push({ ...J, path: `${$.config.prefix}${J.path}`, hooks: i(J.hooks, { error: this.event.error }) });
      } else {
        this.mount($.fetch);
        for (let J of $.router.history)
          this.routeTree.set(J.method + `${$.config.prefix}${J.path}`, this.router.history.length), this.router.history.push({ ...J, path: `${$.config.prefix}${J.path}`, hooks: i(J.hooks, { error: this.event.error }) });
      }
      return this;
    } else {
      if (this.headers($.setHeaders), W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const J = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (!this.dependencies[W].some(({ checksum: Y }) => J === Y))
          this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      } else
        this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      J2(this.extender.macros), J2(this.extender.higherOrderFunctions);
      const j = [];
      for (let J = 0;J < this.extender.higherOrderFunctions.length; J++) {
        const Y = this.extender.higherOrderFunctions[J];
        if (Y.checksum) {
          if (j.includes(Y.checksum))
            this.extender.higherOrderFunctions.splice(J, 1), J--;
          j.push(Y.checksum);
        }
      }
      this.inference = { body: this.inference.body || $.inference.body, cookie: this.inference.cookie || $.inference.cookie, headers: this.inference.headers || $.inference.headers, query: this.inference.query || $.inference.query, set: this.inference.set || $.inference.set, server: this.inference.server || $.inference.server };
    }
    this.decorate($.singleton.decorator), this.state($.singleton.store), this.model($.definitions.type), this.error($.definitions.error), $.extender.macros = this.extender.macros.concat($.extender.macros);
    for (let { method: j, path: J, handler: Y, hooks: G } of Object.values($.router.history))
      this.add(j, J, Y, i(G, { error: $.event.error }));
    if (!Z)
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const j = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: J }) => j === J))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((J) => J?.subType === "derive").map((J) => ({ fn: J.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((J) => J?.subType === "resolve").map((J) => ({ fn: J.toString(), stack: new Error().stack ?? "" })) }), this.event = C2(this.event, L2($.event), j);
      } else
        this.event = C2(this.event, L2($.event));
    return this.validator.global = i(this.validator.global, { ...$.validator.global }), this.validator.local = i(this.validator.local, { ...$.validator.scoped }), this;
  }
  macro($) {
    const W = { checksum: N0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ };
    return this.extender.macros.push(W), this;
  }
  mount($, W) {
    if ($ instanceof Q0 || typeof $ === "function" || $.length === 0 || $ === "/") {
      const j = typeof $ === "function" ? $ : $ instanceof Q0 ? $.compile().fetch : W instanceof Q0 ? W.compile().fetch : W, J = async ({ request: Y, path: G }) => {
        if (Y.method === "GET" || Y.method === "HEAD" || !Y.headers.get("content-type"))
          return j(new Request(R0(Y.url, G || "/"), Y));
        return j(new Request(R0(Y.url, G || "/"), { ...Y, body: await Y.arrayBuffer() }));
      };
      return this.all("/*", J, { type: "none" }), this;
    }
    const X = $.length;
    if (W instanceof Q0)
      W = W.compile().fetch;
    const Z = async ({ request: j, path: J }) => {
      if (j.method === "GET" || j.method === "HEAD" || !j.headers.get("content-type"))
        return W(new Request(R0(j.url, J.slice(X) || "/"), j));
      return W(new Request(R0(j.url, J.slice(X) || "/"), { ...j, body: await j.arrayBuffer() }));
    };
    return this.all($, Z, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), Z, { type: "none" }), this;
  }
  get($, W, X) {
    return this.add("GET", $, W, X), this;
  }
  post($, W, X) {
    return this.add("POST", $, W, X), this;
  }
  put($, W, X) {
    return this.add("PUT", $, W, X), this;
  }
  patch($, W, X) {
    return this.add("PATCH", $, W, X), this;
  }
  delete($, W, X) {
    return this.add("DELETE", $, W, X), this;
  }
  options($, W, X) {
    return this.add("OPTIONS", $, W, X), this;
  }
  all($, W, X) {
    return this.add("ALL", $, W, X), this;
  }
  head($, W, X) {
    return this.add("HEAD", $, W, X), this;
  }
  connect($, W, X) {
    return this.add("CONNECT", $, W, X), this;
  }
  route($, W, X, Z) {
    return this.add($.toUpperCase(), W, X, Z, Z?.config), this;
  }
  ws($, W) {
    const X = W.transformMessage ? Array.isArray(W.transformMessage) ? W.transformMessage : [W.transformMessage] : undefined;
    let Z = null;
    const j = m(W?.body, { models: this.definitions.type, normalize: this.config.normalize }), J = m(W?.response, { models: this.definitions.type, normalize: this.config.normalize }), Y = (G) => {
      if (typeof G === "string") {
        const K = G?.charCodeAt(0);
        if (K === 47 || K === 123)
          try {
            G = JSON.parse(G);
          } catch {
          }
        else if (Z2(G))
          G = +G;
      }
      if (X?.length)
        for (let K = 0;K < X.length; K++) {
          const B = X[K](G);
          if (B !== undefined)
            G = B;
        }
      return G;
    };
    return this.route("$INTERNALWS", $, (G) => {
      const { set: K, path: B, qi: U, headers: w, query: F, params: Q } = G;
      if (Z === null)
        Z = this.getServer();
      if (Z?.upgrade(G.request, { headers: typeof W.upgrade === "function" ? W.upgrade(G) : W.upgrade, data: { validator: J, open(z) {
        W.open?.(new g0(z, G));
      }, message: (z, D) => {
        const M = Y(D);
        if (j?.Check(M) === false)
          return void z.send(new q("message", j, M).message);
        W.message?.(new g0(z, G), M);
      }, drain(z) {
        W.drain?.(new g0(z, G));
      }, close(z, D, M) {
        W.close?.(new g0(z, G), D, M);
      } } }))
        return;
      return K.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W.beforeHandle, transform: W.transform, headers: W.headers, params: W.params, query: W.query }), this;
  }
  state($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.store)
            this.singleton.store[W] = d(this.singleton.store[W], X, { override: Z === "override" });
          else
            this.singleton.store[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.store = d(this.singleton.store, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.store))
            this.singleton.store[W] = X;
        } else
          this.singleton.store = X(this.singleton.store);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.store))
          this.singleton.store[W] = X;
        return this;
    }
  }
  decorate($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.decorator)
            this.singleton.decorator[W] = d(this.singleton.decorator[W], X, { override: Z === "override" });
          else
            this.singleton.decorator[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.decorator = d(this.singleton.decorator, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.decorator))
            this.singleton.decorator[W] = X;
        } else
          this.singleton.decorator = X(this.singleton.decorator);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.decorator))
          this.singleton.decorator[W] = X;
        return this;
    }
  }
  derive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "derive", fn: W };
    return this.onTransform($, X);
  }
  model($, W) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, Z]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = Z;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W, this;
  }
  mapDerive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapDerive", fn: W };
    return this.onTransform($, X);
  }
  affix($, W, X) {
    if (X === "")
      return this;
    const Z = ["_", "-", " "], j = (K) => K[0].toUpperCase() + K.slice(1), J = $ === "prefix" ? (K, B) => Z.includes(K.at(-1) ?? "") ? K + B : K + j(B) : Z.includes(X.at(-1) ?? "") ? (K, B) => B + K : (K, B) => B + j(K), Y = (K) => {
      const B = {};
      switch (K) {
        case "decorator":
          for (let U in this.singleton.decorator)
            B[J(X, U)] = this.singleton.decorator[U];
          this.singleton.decorator = B;
          break;
        case "state":
          for (let U in this.singleton.store)
            B[J(X, U)] = this.singleton.store[U];
          this.singleton.store = B;
          break;
        case "model":
          for (let U in this.definitions.type)
            B[J(X, U)] = this.definitions.type[U];
          this.definitions.type = B;
          break;
        case "error":
          for (let U in this.definitions.error)
            B[J(X, U)] = this.definitions.error[U];
          this.definitions.error = B;
          break;
      }
    }, G = Array.isArray(W) ? W : [W];
    for (let K of G.some((B) => B === "all") ? ["decorator", "state", "model", "error"] : G)
      Y(K);
    return this;
  }
  prefix($, W) {
    return this.affix("prefix", $, W);
  }
  suffix($, W) {
    return this.affix("suffix", $, W);
  }
  compile() {
    if (this.fetch = this.config.aot ? g2(this) : y2(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? g2(this) : y2(this))($);
  };
  handleError = async ($, W) => (this.handleError = this.config.aot ? f2(this) : A1(this))($, W);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if (!Z2($))
        throw new Error("Port must be a numeric value");
      $ = parseInt($);
    }
    const X = this.fetch, Z = typeof $ === "object" ? { development: !p0, reusePort: true, ...this.config.serve || {}, ...$ || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...H2 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !p0, reusePort: true, ...this.config.serve || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...H2 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    this.server = Bun?.serve(Z);
    for (let j = 0;j < this.event.start.length; j++)
      this.event.start[j].fn(this);
    if (W)
      W(this.server);
    return process.on("beforeExit", () => {
      if (this.server) {
        this.server.stop(), this.server = null;
        for (let j = 0;j < this.event.stop.length; j++)
          this.event.stop[j].fn(this);
      }
    }), this.promisedModules.then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async ($) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop($), this.server = null, this.event.stop.length)
        for (let W = 0;W < this.event.stop.length; W++)
          this.event.stop[W].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// ../node_modules/@elysiajs/cors/dist/index.mjs
var isBun = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  headers.forEach((_, key) => {
    keys += key + ", ";
  });
  if (keys)
    keys = keys.slice(0, -1);
  return keys;
};
var processOrigin = (origin, request, from) => {
  if (Array.isArray(origin))
    return origin.some((o2) => processOrigin(o2, request, from));
  switch (typeof origin) {
    case "string":
      if (origin.indexOf("://") === -1)
        return from.includes(origin);
      return origin === from;
    case "function":
      return origin(request) === true;
    case "object":
      if (origin instanceof RegExp)
        return origin.test(from);
  }
  return false;
};
var cors = (config2) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config2 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Q0({
    name: "@elysiajs/cors",
    seed: config2,
    aot
  });
  const anyOrigin = origins?.some((o2) => o2 === "*");
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i3 = 0;i3 < origins.length; i3++) {
        const value2 = processOrigin(origins[i3], request, from);
        if (value2 === true) {
          set2.headers.vary = origin ? "Origin" : "*";
          set2.headers["access-control-allow-origin"] = from || "*";
          return;
        }
        if (value2)
          headers.push(value2);
      }
    }
    set2.headers.vary = "Origin";
    if (headers.length)
      set2.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (!method)
      return;
    if (methods === true)
      return set2.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["access-control-allow-methods"] = methods;
    set2.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set2, request, headers }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set2.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set2, request }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = headers;
    }
  });
};
var src_default = cors;

// ../node_modules/elysia-helmet/dist/index.js
var x3 = { "default-src": ["'self'"], "base-uri": ["'self'"], "font-src": ["'self'", "https:", "data:"], "form-action": ["'self'"], "frame-ancestors": ["'self'"], "img-src": ["'self'", "data:"], "object-src": ["'none'"], "script-src": ["'self'"], "script-src-attr": ["'none'"], "style-src": ["'self'", "https:", "'unsafe-inline'"], "upgrade-insecure-requests": [] };
var b = (e) => e.replace(/[A-Z]/g, (o2) => `-${o2.toLowerCase()}`);
var D = (e) => /;|,/.test(e);
var V4 = (e, o2) => Object.prototype.hasOwnProperty.call(e, o2);
var X = () => ({ ...x3 });
var T = (e) => {
  const o2 = X(), { useDefaults: r = true, directives: n2 = o2 } = e, s = new Map, c3 = new Set, l = new Set;
  for (let t3 in n2) {
    if (!V4(n2, t3))
      continue;
    if (t3.length === 0 || /[^a-zA-Z0-9-]/.test(t3))
      throw new Error(`Content-Security-Policy received an invalid directive name ${JSON.stringify(t3)}`);
    const i3 = b(t3);
    if (c3.has(i3))
      throw new Error(`Content-Security-Policy received a duplicate directive ${JSON.stringify(i3)}`);
    c3.add(i3);
    const a = n2[t3];
    if (a === null) {
      if (i3 === "default-src")
        throw new Error("Content-Security-Policy needs a default-src but it was set to `null`.");
      l.add(i3);
      continue;
    }
    if (!a)
      throw new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(i3)}`);
    const y3 = typeof a === "string" ? [a] : a;
    for (let R of y3)
      if (typeof R === "string" && D(R))
        throw new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(i3)}`);
    s.set(i3, y3);
  }
  if (r)
    Object.entries(o2).forEach(([t3, i3]) => {
      if (!s.has(t3) && !l.has(t3))
        s.set(t3, i3);
    });
  if (!s.size)
    throw new Error("Content-Security-Policy has no directives. Either set some or disable the header");
  return s;
};
var A = (e) => {
  let o2;
  const r = [];
  return e.forEach((n2, s) => {
    const c3 = n2.reduce((l, t3) => `${l} ${t3}`, "");
    if (!c3)
      r.push(s);
    else if (D(c3))
      o2 = new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(s)}`);
    else
      r.push(`${s}${c3}`);
  }), o2 || r.join(";");
};
var u = (e = {}) => {
  const o2 = e.reportOnly ? "Content-Security-Policy-Report-Only" : "Content-Security-Policy", r = T(e), n2 = A(r);
  if (n2 instanceof Error)
    throw n2;
  return [o2, n2];
};
var N = new Set(["require-corp", "credentialless"]);
var $ = ({ policy: e = "require-corp" }) => {
  if (N.has(e))
    return e;
  throw new Error(`Cross-Origin-Embedder-Policy does not support the ${JSON.stringify(e)} policy`);
};
var p3 = (e = {}) => {
  return ["Cross-Origin-Embedder-Policy", $(e)];
};
var I = new Set(["same-origin", "same-origin-allow-popups", "unsafe-none"]);
var L = ({ policy: e = "same-origin" }) => {
  if (I.has(e))
    return e;
  throw new Error(`Cross-Origin-Opener-Policy does not support the ${JSON.stringify(e)} policy`);
};
var d3 = (e = {}) => {
  return ["Cross-Origin-Opener-Policy", L(e)];
};
var F = new Set(["same-origin", "same-site", "cross-origin"]);
var J = ({ policy: e = "same-origin" }) => {
  if (F.has(e))
    return e;
  throw new Error(`Cross-Origin-Resource-Policy does not support the ${JSON.stringify(e)} policy`);
};
var g = (e = {}) => {
  return ["Cross-Origin-Resource-Policy", J(e)];
};
var f3 = () => {
  return ["Cross-Origin-Resource-Policy", "?1"];
};
var _ = new Set(["no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url", ""]);
var M = ({ policy: e = "no-referrer" }) => {
  const o2 = typeof e === "string" ? [e] : e;
  if (o2.length === 0)
    throw new Error("Referrer-Policy received no policy tokens");
  const r = new Set;
  return o2.forEach((n2) => {
    if (!_.has(n2))
      throw new Error(`Referrer-Policy received an unexpected policy token ${JSON.stringify(n2)}`);
    else if (r.has(n2))
      throw new Error(`Referrer-Policy received a duplicate policy token ${JSON.stringify(n2)}`);
    r.add(n2);
  }), o2.join(",");
};
var O = (e = {}) => {
  return ["Referrer-Policy", M(e)];
};
var z = (e = 15552000) => {
  if (e >= 0 && Number.isFinite(e))
    return Math.floor(e);
  throw new Error(`Strict-Transport-Security: ${JSON.stringify(e)} is not a valid value for maxAge. Please choose a positive integer.`);
};
var j = (e) => {
  if ("maxage" in e)
    throw new Error("Strict-Transport-Security received an unsupported property, `maxage`. Did you mean to pass `maxAge`?");
  if ("includeSubdomains" in e)
    throw new Error('Strict-Transport-Security middleware should use `includeSubDomains` instead of `includeSubdomains`. (The correct one has an uppercase "D".)');
  const o2 = [`max-age=${z(e.maxAge)}`];
  if (e.includeSubDomains === undefined || e.includeSubDomains)
    o2.push("includeSubDomains");
  if (e.preload)
    o2.push("preload");
  return o2.join("; ");
};
var m3 = (e = {}) => {
  return ["Strict-Transport-Security", j(e)];
};
var h3 = () => {
  return ["X-Content-Type-Options", "nosniff"];
};
var P = (e = {}) => {
  return ["X-DNS-Prefetch-Control", e.allow ? "on" : "off"];
};
var S = () => {
  return ["X-Download-Options", "noopen"];
};
var k3 = ({ action: e = "sameorigin" }) => {
  const o2 = typeof e === "string" ? e.toUpperCase() : e;
  switch (o2) {
    case "SAME-ORIGIN":
      return "SAMEORIGIN";
    case "DENY":
    case "SAMEORIGIN":
      return o2;
    default:
      throw new Error(`X-Frame-Options received an invalid action ${JSON.stringify(e)}`);
  }
};
var w = (e = {}) => {
  return ["X-Frame-Options", k3(e)];
};
var q4 = new Set(["none", "master-only", "by-content-type", "all"]);
var G = ({ permittedPolicies: e = "none" }) => {
  if (q4.has(e))
    return e;
  throw new Error(`X-Permitted-Cross-Domain-Policies does not support ${JSON.stringify(e)}`);
};
var E = (e = {}) => {
  return ["X-Permitted-Cross-Domain-Policies", G(e)];
};
var C = () => {
  return ["X-XSS-Protection", "0"];
};
var v3 = (e, o2, r) => {
  switch (r.contentSecurityPolicy) {
    case undefined:
    case true:
      e(u());
      break;
    case false:
      break;
    default:
      e(u(r.contentSecurityPolicy));
      break;
  }
  switch (r.crossOriginEmbedderPolicy) {
    case undefined:
    case false:
      break;
    case true:
      e(p3());
      break;
    default:
      e(p3(r.crossOriginEmbedderPolicy));
      break;
  }
  switch (r.crossOriginOpenerPolicy) {
    case undefined:
    case true:
      e(d3());
      break;
    case false:
      break;
    default:
      e(d3(r.crossOriginOpenerPolicy));
      break;
  }
  switch (r.crossOriginResourcePolicy) {
    case undefined:
    case true:
      e(g());
      break;
    case false:
      break;
    default:
      e(g(r.crossOriginResourcePolicy));
      break;
  }
  switch (r.originAgentCluster) {
    case undefined:
    case true:
      e(f3());
      break;
    case false:
      break;
    default:
      e(f3());
      break;
  }
  switch (r.referrerPolicy) {
    case undefined:
    case true:
      e(O());
      break;
    case false:
      break;
    default:
      e(O(r.referrerPolicy));
      break;
  }
  if ("strictTransportSecurity" in r && "hsts" in r)
    throw new Error("Strict-Transport-Security option was specified twice. Remove `hsts` to silence this warning.");
  const n2 = r.strictTransportSecurity ?? r.hsts;
  switch (n2) {
    case undefined:
    case true:
      e(m3());
      break;
    case false:
      break;
    default:
      e(m3(n2));
      break;
  }
  if ("xContentTypeOptions" in r && "noSniff" in r)
    throw new Error("X-Content-Type-Options option was specified twice. Remove `noSniff` to silence this warning.");
  switch (r.xContentTypeOptions ?? r.noSniff) {
    case undefined:
    case true:
      e(h3());
      break;
    case false:
      break;
    default:
      e(h3());
      break;
  }
  if ("xDnsPrefetchControl" in r && "dnsPrefetchControl" in r)
    throw new Error("X-DNS-Prefetch-Control option was specified twice. Remove `dnsPrefetchControl` to silence this warning.");
  const c3 = r.xDnsPrefetchControl ?? r.dnsPrefetchControl;
  switch (c3) {
    case undefined:
    case true:
      e(P());
      break;
    case false:
      break;
    default:
      e(P(c3));
      break;
  }
  if ("xDownloadOptions" in r && "ieNoOpen" in r)
    throw new Error("X-Download-Options option was specified twice. Remove `ieNoOpen` to silence this warning.");
  switch (r.xDownloadOptions ?? r.ieNoOpen) {
    case undefined:
    case true:
      e(S());
      break;
    case false:
      break;
    default:
      e(S());
      break;
  }
  if ("xFrameOptions" in r && "frameguard" in r)
    throw new Error("X-Frame-Options option was specified twice. Remove `frameguard` to silence this warning.");
  const t3 = r.xFrameOptions ?? r.frameguard;
  switch (t3) {
    case undefined:
    case true:
      e(w());
      break;
    case false:
      break;
    default:
      e(w(t3));
      break;
  }
  if ("xPermittedCrossDomainPolicies" in r && "permittedCrossDomainPolicies" in r)
    throw new Error("X-Permitted-Cross-Domain-Policies option was specified twice. Remove `permittedCrossDomainPolicies` to silence this warning.");
  const i3 = r.xPermittedCrossDomainPolicies ?? r.permittedCrossDomainPolicies;
  switch (i3) {
    case undefined:
    case true:
      e(E());
      break;
    case false:
      break;
    default:
      e(E(i3));
      break;
  }
  if ("xPoweredBy" in r && "hidePoweredBy" in r)
    throw new Error("X-Powered-By option was specified twice. Remove `hidePoweredBy` to silence this warning.");
  switch (r.xPoweredBy ?? r.hidePoweredBy) {
    case undefined:
    case true:
      o2("X-Powered-By");
      break;
    case false:
      break;
    default:
      o2("X-Powered-By");
      break;
  }
  if ("xXssProtection" in r && "xssFilter" in r)
    throw new Error("X-XSS-Protection option was specified twice. Remove `xssFilter` to silence this warning.");
  switch (r.xXssProtection ?? r.xssFilter) {
    case undefined:
    case true:
      e(C());
      break;
    case false:
      break;
    default:
      e(C());
      break;
  }
};
var Ae = (e = {}) => {
  return new Q0({ name: "elysia-helmet", seed: e.seed ?? "", aot: e.aot ?? true }).onRequest(({ set: o2 }) => {
    v3(([r, n2]) => o2.headers[r] = n2, (r) => delete o2.headers[r], e);
  });
};

// src/types/errors.ts
class InlineError extends Error {
  code;
  constructor(code, message) {
    super(message ?? "An error occurred");
    this.code = code;
  }
}

// src/utils/log.ts
class Log {
  scope;
  static shared = new Log("shared");
  constructor(scope) {
    this.scope = scope;
  }
  error(messageOrError, error3) {
    if (typeof messageOrError === "string") {
      console.error(this.scope, messageOrError, error3);
    } else {
      console.error(this.scope, messageOrError);
    }
  }
  warn(messageOrError, error3) {
    if (typeof messageOrError === "string") {
      console.warn(this.scope, messageOrError, error3);
    } else {
      console.warn(this.scope, messageOrError);
    }
  }
  debug(...args) {
    console.debug(this.scope, ...args);
  }
}

// src/setup.ts
var setup = new Q0({ name: "setup" }).use(src_default({
  origin: [
    "https://inline.chat",
    "https://app.inline.chat",
    "http://localhost:8001"
  ]
})).use(Ae({
  contentSecurityPolicy: false
})).error("INLINE_ERROR", InlineError).onError(({ code, error: error3 }) => {
  Log.shared.error("Top level error " + code, error3);
});

// src/controllers/root.ts
var relativeBuildDate = () => {
  let date3 = new Date("2024-11-03T10:10:37.318Z");
  let diff = new Date().getTime() - date3.getTime();
  let seconds = Math.floor(diff / 1000);
  let minutes = Math.floor(seconds / 60);
  let hours = Math.floor(minutes / 60);
  let days = Math.floor(hours / 24);
  return `${days}d ${hours}h ${minutes}m ${seconds}s ago`;
};
var version = "0.0.1";
var gitCommitHash = "42621fd";
var root = new Q0().use(setup).get("/", () => `\uD83D\uDEA7 inline server is running \u2022 /** version: ${version} \u2022 deploy time: ${relativeBuildDate()} \u2022 commit: ${gitCommitHash} */`);

// ../node_modules/postgres/src/index.js
import os4 from "os";
import fs from "fs";

// ../node_modules/postgres/src/query.js
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve2, reject;
    super((a, b3) => {
      resolve2 = a;
      reject = b3;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x4) => (this.active = false, resolve2(x4));
    this.reject = (x4) => (this.active = false, reject(x4));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise3 = new Promise((resolve2, reject) => {
            this.cursorFn = (value2) => {
              resolve2({ value: value2, done: false });
              return new Promise((r) => prev = r);
            };
            this.resolve = () => (this.active = false, resolve2({ done: true }));
            this.reject = (x4) => (this.active = false, reject(x4));
          });
          this.execute();
          return promise3;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x4 = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x4;
  return originCache.get(xs);
}

// ../node_modules/postgres/src/errors.js
class PostgresError extends Error {
  constructor(x4) {
    super(x4.message);
    this.name = this.constructor.name;
    Object.assign(this, x4);
  }
}
var Errors3 = {
  connection,
  postgres,
  generic,
  notSupported
};
function connection(x4, options, socket) {
  const { host, port } = socket || options;
  const error3 = Object.assign(new Error("write " + x4 + " " + (options.path || host + ":" + port)), {
    code: x4,
    errno: x4,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error3, connection);
  return error3;
}
function postgres(x4) {
  const error3 = new PostgresError(x4);
  Error.captureStackTrace(error3, postgres);
  return error3;
}
function generic(code, message) {
  const error3 = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error3, generic);
  return error3;
}
function notSupported(x4) {
  const error3 = Object.assign(new Error(x4 + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x4
  });
  Error.captureStackTrace(error3, notSupported);
  return error3;
}

// ../node_modules/postgres/src/types.js
var types = {
  string: {
    to: 25,
    from: null,
    serialize: (x4) => "" + x4
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x4) => "" + x4,
    parse: (x4) => +x4
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x4) => JSON.stringify(x4),
    parse: (x4) => JSON.parse(x4)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x4) => x4 === true ? "t" : "f",
    parse: (x4) => x4 === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x4) => (x4 instanceof Date ? x4 : new Date(x4)).toISOString(),
    parse: (x4) => new Date(x4)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x4) => "\\x" + Buffer.from(x4).toString("hex"),
    parse: (x4) => Buffer.from(x4.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier2 extends NotTagged {
  constructor(value2) {
    super();
    this.value = escapeIdentifier(value2);
  }
}

class Parameter extends NotTagged {
  constructor(value2, type3, array3) {
    super();
    this.value = value2;
    this.type = type3;
    this.array = array3;
  }
}

class Builder extends NotTagged {
  constructor(first, rest3) {
    super();
    this.first = first;
    this.rest = rest3;
  }
  build(before, parameters3, types2, options) {
    const keyword = builders.map(([x4, fn]) => ({ fn, i: before.search(x4) })).sort((a, b3) => a.i - b3.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters3, types2, options);
  }
}
function handleValue(x4, parameters3, types2, options) {
  let value2 = x4 instanceof Parameter ? x4.value : x4;
  if (value2 === undefined) {
    x4 instanceof Parameter ? x4.value = options.transform.undefined : value2 = x4 = options.transform.undefined;
    if (value2 === undefined)
      throw Errors3.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types2.push(x4 instanceof Parameter ? (parameters3.push(x4.value), x4.array ? x4.array[x4.type || inferType(x4.value)] || x4.type || firstIsString(x4.value) : x4.type) : (parameters3.push(x4), inferType(x4)));
}
var defaultHandlers = typeHandlers(types);
function stringify(q5, string3, value2, parameters3, types2, options) {
  for (let i3 = 1;i3 < q5.strings.length; i3++) {
    string3 += stringifyValue2(string3, value2, parameters3, types2, options) + q5.strings[i3];
    value2 = q5.args[i3];
  }
  return string3;
}
function stringifyValue2(string3, value2, parameters3, types2, o2) {
  return value2 instanceof Builder ? value2.build(string3, parameters3, types2, o2) : value2 instanceof Query ? fragment(value2, parameters3, types2, o2) : value2 instanceof Identifier2 ? value2.value : value2 && value2[0] instanceof Query ? value2.reduce((acc, x4) => acc + " " + fragment(x4, parameters3, types2, o2), "") : handleValue(value2, parameters3, types2, o2);
}
function fragment(q5, parameters3, types2, options) {
  q5.fragment = true;
  return stringify(q5, q5.strings[0], q5.args[0], parameters3, types2, options);
}
function valuesBuilder(first, parameters3, types2, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue2("values", row[column], parameters3, types2, options)).join(",") + ")").join(",");
}
function values(first, rest3, parameters3, types2, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest3.length ? rest3.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters3, types2, columns, options);
}
function select(first, rest3, parameters3, types2, options) {
  typeof first === "string" && (first = [first].concat(rest3));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value2;
  const columns = rest3.length ? rest3.flat() : Object.keys(first);
  return columns.map((x4) => {
    value2 = first[x4];
    return (value2 instanceof Query ? fragment(value2, parameters3, types2, options) : value2 instanceof Identifier2 ? value2.value : handleValue(value2, parameters3, types2, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x4) : x4);
  }).join(",");
}
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x4 = values(...xs);
    return x4 === "()" ? "(null)" : x4;
  },
  select,
  as: select,
  returning: select,
  "\\(": select,
  update(first, rest3, parameters3, types2, options) {
    return (rest3.length ? rest3.flat() : Object.keys(first)).map((x4) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x4) : x4) + "=" + stringifyValue2("values", first[x4], parameters3, types2, options));
  },
  insert(first, rest3, parameters3, types2, options) {
    const columns = rest3.length ? rest3.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters3, types2, columns, options);
  }
}).map(([x4, fn]) => [new RegExp("((?:^|[\\s(])" + x4 + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
function notTagged() {
  throw Errors3.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
function firstIsString(x4) {
  if (Array.isArray(x4))
    return firstIsString(x4[0]);
  return typeof x4 === "string" ? 1009 : 0;
}
var mergeUserTypes = function(types2) {
  const user = typeHandlers(types2 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
function typeHandlers(types2) {
  return Object.keys(types2).reduce((acc, k4) => {
    types2[k4].from && [].concat(types2[k4].from).forEach((x4) => acc.parsers[x4] = types2[k4].parse);
    if (types2[k4].serialize) {
      acc.serializers[types2[k4].to] = types2[k4].serialize;
      types2[k4].from && [].concat(types2[k4].from).forEach((x4) => acc.serializers[x4] = types2[k4].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column } }) {
  return xs.map((x4) => escapeIdentifier(column.to ? column.to(x4) : x4)).join(",");
}
var escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x4) {
  return x4 instanceof Parameter ? x4.type : x4 instanceof Date ? 1184 : x4 instanceof Uint8Array ? 17 : x4 === true || x4 === false ? 16 : typeof x4 === "bigint" ? 20 : Array.isArray(x4) ? inferType2(x4[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
function arrayEscape(x4) {
  return x4.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
}
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x4) => arraySerializer2(x4, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x4) => {
    if (x4 === undefined) {
      x4 = options.transform.undefined;
      if (x4 === undefined)
        throw Errors3.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x4 === null ? "null" : '"' + arrayEscape(serializer ? serializer(x4.type ? x4.value : x4) : "" + x4) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x4, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x4, parser, typarray);
};
function arrayParserLoop(s, x4, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x4.length; s.i++) {
    s.char = x4[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x4[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x4[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x4, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x4.slice(s.last, s.i)) : x4.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x4.slice(s.last, s.i)) : x4.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x4.slice(s.last, s.i + 1)) : x4.slice(s.last, s.i + 1));
  return xs;
}
var toCamel = (x4) => {
  let str = x4[0];
  for (let i3 = 1;i3 < x4.length; i3++)
    str += x4[i3] === "_" ? x4[++i3].toUpperCase() : x4[i3];
  return str;
};
var toPascal = (x4) => {
  let str = x4[0].toUpperCase();
  for (let i3 = 1;i3 < x4.length; i3++)
    str += x4[i3] === "_" ? x4[++i3].toUpperCase() : x4[i3];
  return str;
};
var toKebab = (x4) => x4.replace(/_/g, "-");
var fromCamel = (x4) => x4.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x4) => (x4.slice(0, 1) + x4.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x4) => x4.replace(/-/g, "_");
function createJsonTransform(fn) {
  return function jsonTransform(x4, column) {
    return typeof x4 === "object" && x4 !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x4) ? x4.map((x5) => jsonTransform(x5, column)) : Object.entries(x4).reduce((acc, [k4, v4]) => Object.assign(acc, { [fn(k4)]: jsonTransform(v4, column) }), {}) : x4;
  };
}
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// ../node_modules/postgres/src/connection.js
import net2 from "net";
import tls2 from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import { performance as performance3 } from "perf_hooks";

// ../node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// ../node_modules/postgres/src/queue.js
var queue_default = Queue;
function Queue(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x4) => {
      const index2 = xs.indexOf(x4);
      return index2 === -1 ? null : (xs.splice(index2, 1), x4);
    },
    push: (x4) => (xs.push(x4), x4),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
}

// ../node_modules/postgres/src/bytes.js
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x4) => {
  const v4 = x4.charCodeAt(0);
  acc[x4] = () => {
    buffer[0] = v4;
    b3.i = 5;
    return b3;
  };
  return acc;
}, {});
var b3 = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x4) {
    b3.i += x4;
    return b3;
  },
  str(x4) {
    const length = Buffer.byteLength(x4);
    fit(length);
    b3.i += buffer.write(x4, b3.i, length, "utf8");
    return b3;
  },
  i16(x4) {
    fit(2);
    buffer.writeUInt16BE(x4, b3.i);
    b3.i += 2;
    return b3;
  },
  i32(x4, i3) {
    if (i3 || i3 === 0) {
      buffer.writeUInt32BE(x4, i3);
      return b3;
    }
    fit(4);
    buffer.writeUInt32BE(x4, b3.i);
    b3.i += 4;
    return b3;
  },
  z(x4) {
    fit(x4);
    buffer.fill(0, b3.i, b3.i + x4);
    b3.i += x4;
    return b3;
  },
  raw(x4) {
    buffer = Buffer.concat([buffer.subarray(0, b3.i), x4]);
    b3.i = buffer.length;
    return b3;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b3.i - at, at);
    const out = buffer.subarray(0, b3.i);
    b3.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b3;
function fit(x4) {
  if (buffer.length - b3.i < x4) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x4);
    prev.copy(buffer);
  }
}
function reset() {
  b3.i = 0;
  return b3;
}

// ../node_modules/postgres/src/connection.js
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {
};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};
function Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform: transform4,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query2) {
      initial = query2 || true;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x4;
    try {
      x4 = options.socket ? await Promise.resolve(options.socket(options)) : new net2.Socket;
    } catch (e) {
      error3(e);
      return;
    }
    x4.on("error", error3);
    x4.on("close", closed);
    x4.on("drain", drain);
    return x4;
  }
  async function cancel({ pid, secret }, resolve2, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect3();
      socket.once("error", reject);
      socket.once("close", resolve2);
    } catch (error4) {
      reject(error4);
    }
  }
  function execute(q5) {
    if (terminated)
      return queryError(q5, Errors3.connection("CONNECTION_DESTROYED", options));
    if (q5.cancelled)
      return;
    try {
      q5.state = backend;
      query ? sent.push(q5) : (query = q5, query.active = true);
      build(q5);
      return write(toBuffer(q5)) && !q5.describeFirst && !q5.cursorFn && sent.length < max_pipeline && (!q5.options.onexecute || q5.options.onexecute(connection2));
    } catch (error4) {
      sent.length === 0 && write(Sync);
      errored(error4);
      return true;
    }
  }
  function toBuffer(q5) {
    if (q5.parameters.length >= 65534)
      throw Errors3.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q5.options.simple ? bytes_default().Q().str(q5.statement.string + bytes_default.N).end() : q5.describeFirst ? Buffer.concat([describe(q5), Flush]) : q5.prepare ? q5.prepared ? prepared(q5) : Buffer.concat([describe(q5), prepared(q5)]) : unnamed(q5);
  }
  function describe(q5) {
    return Buffer.concat([
      Parse(q5.statement.string, q5.parameters, q5.statement.types, q5.statement.name),
      Describe("S", q5.statement.name)
    ]);
  }
  function prepared(q5) {
    return Buffer.concat([
      Bind(q5.parameters, q5.statement.types, q5.statement.name, q5.cursorName),
      q5.cursorFn ? Execute("", q5.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q5) {
    return Buffer.concat([
      Parse(q5.statement.string, q5.parameters, q5.statement.types),
      DescribeUnnamed,
      prepared(q5)
    ]);
  }
  function build(q5) {
    const parameters3 = [], types2 = [];
    const string3 = stringify(q5, q5.strings[0], q5.args[0], parameters3, types2, options);
    !q5.tagged && q5.args.forEach((x4) => handleValue(x4, parameters3, types2, options));
    q5.prepare = options.prepare && ("prepare" in q5.options ? q5.options.prepare : true);
    q5.string = string3;
    q5.signature = q5.prepare && types2 + string3;
    q5.onlyDescribe && delete statements[q5.signature];
    q5.parameters = q5.parameters || parameters3;
    q5.prepared = q5.prepare && q5.signature in statements;
    q5.describeFirst = q5.onlyDescribe || parameters3.length && !q5.prepared;
    q5.statement = q5.prepared ? statements[q5.signature] : { string: string3, types: types2, name: q5.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string3, parameters3, types2);
  }
  function write(x4, fn) {
    chunk = chunk ? Buffer.concat([chunk, x4]) : Buffer.from(x4);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x4 = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x4;
  }
  function connectTimedOut() {
    errored(Errors3.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x4) => r(x4[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls2.connect({
      socket,
      servername: net2.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error3);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query && onopen(connection2);
  }
  function data(x4) {
    if (incomings) {
      incomings.push(x4);
      remaining -= x4.length;
      if (remaining >= 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x4 : Buffer.concat([incoming, x4], incoming.length + x4.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query && (query.cursorFn || query.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect3() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect3, closedDate ? closedDate + delay - performance3.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err) {
      error3(err);
    }
  }
  function error3(err) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err);
    while (sent.length)
      queryError(sent.shift(), err);
  }
  function errored(err) {
    stream && (stream.destroy(err), stream = null);
    query && queryError(query, err);
    initial && (queryError(initial, err), initial = null);
  }
  function queryError(query2, err) {
    Object.defineProperties(err, {
      stack: { value: err.stack + query2.origin.replace(/.*\n/, "\n"), enumerable: options.debug },
      query: { value: query2.string, enumerable: options.debug },
      parameters: { value: query2.parameters, enumerable: options.debug },
      args: { value: query2.args, enumerable: options.debug },
      types: { value: query2.statement && query2.statement.types, enumerable: options.debug }
    });
    query2.reject(err);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query || initial || sent.length)
      error3(Errors3.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    socket.removeAllListeners();
    socket = null;
    if (initial)
      return reconnect();
    !hadError && (query || sent.length) && error3(Errors3.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance3.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors3.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x4 = xs[0]) {
    (x4 === 68 ? DataRow : x4 === 100 ? CopyData : x4 === 65 ? NotificationResponse : x4 === 83 ? ParameterStatus : x4 === 90 ? ReadyForQuery : x4 === 67 ? CommandComplete : x4 === 50 ? BindComplete : x4 === 49 ? ParseComplete : x4 === 116 ? ParameterDescription : x4 === 84 ? RowDescription : x4 === 82 ? Authentication : x4 === 110 ? NoData : x4 === 75 ? BackendKeyData : x4 === 69 ? ErrorResponse : x4 === 115 ? PortalSuspended : x4 === 51 ? CloseComplete : x4 === 71 ? CopyInResponse : x4 === 78 ? NoticeResponse : x4 === 72 ? CopyOutResponse : x4 === 99 ? CopyDone : x4 === 73 ? EmptyQueryResponse : x4 === 86 ? FunctionCallResponse : x4 === 118 ? NegotiateProtocolVersion : x4 === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x4) {
    let index = 7;
    let length2;
    let column;
    let value2;
    const row = query.isRaw ? new Array(query.statement.columns.length) : {};
    for (let i3 = 0;i3 < query.statement.columns.length; i3++) {
      column = query.statement.columns[i3];
      length2 = x4.readInt32BE(index);
      index += 4;
      value2 = length2 === -1 ? null : query.isRaw === true ? x4.subarray(index, index += length2) : column.parser === undefined ? x4.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x4.toString("utf8", index + 1, index += length2)) : column.parser(x4.toString("utf8", index, index += length2));
      query.isRaw ? row[i3] = query.isRaw === true ? value2 : transform4.value.from ? transform4.value.from(value2, column) : value2 : row[column.name] = transform4.value.from ? transform4.value.from(value2, column) : value2;
    }
    query.forEachFn ? query.forEachFn(transform4.row.from ? transform4.row.from(row) : row, result) : result[rows++] = transform4.row.from ? transform4.row.from(row) : row;
  }
  function ParameterStatus(x4) {
    const [k4, v4] = x4.toString("utf8", 5, x4.length - 1).split(bytes_default.N);
    backendParameters[k4] = v4;
    if (options.parameters[k4] !== v4) {
      options.parameters[k4] = v4;
      onparameter && onparameter(k4, v4);
    }
  }
  function ReadyForQuery(x4) {
    query && query.options.simple && query.resolve(results || result);
    query = results = null;
    result = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial === true && (initial = null);
        return fetchArrayTypes();
      }
      initial !== true && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))
      Connection(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject);
    if (query)
      return;
    connection2.reserved ? !connection2.reserved.release && x4[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x4) {
    rows = 0;
    for (let i3 = x4.length - 1;i3 > 0; i3--) {
      if (x4[i3] === 32 && x4[i3 + 1] < 58 && result.count === null)
        result.count = +x4.toString("utf8", i3 + 1, x4.length - 1);
      if (x4[i3 - 1] >= 65) {
        result.command = x4.toString("utf8", 5, i3);
        result.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors3.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query.options.simple)
      return BindComplete();
    if (query.cursorFn) {
      result.count && query.cursorFn(result);
      write(Sync);
    }
    query.resolve(result);
  }
  function ParseComplete() {
    query.parsing = false;
  }
  function BindComplete() {
    !result.statement && (result.statement = query.statement);
    result.columns = query.statement.columns;
  }
  function ParameterDescription(x4) {
    const length2 = x4.readUInt16BE(5);
    for (let i3 = 0;i3 < length2; ++i3)
      !query.statement.types[i3] && (query.statement.types[i3] = x4.readUInt32BE(7 + i3 * 4));
    query.prepare && (statements[query.signature] = query.statement);
    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false);
  }
  function RowDescription(x4) {
    if (result.command) {
      results = results || [result];
      results.push(result = new Result);
      result.count = null;
      query.statement.columns = null;
    }
    const length2 = x4.readUInt16BE(5);
    let index = 7;
    let start;
    query.statement.columns = Array(length2);
    for (let i3 = 0;i3 < length2; ++i3) {
      start = index;
      while (x4[index++] !== 0)
        ;
      const table = x4.readUInt32BE(index);
      const number3 = x4.readUInt16BE(index + 4);
      const type3 = x4.readUInt32BE(index + 6);
      query.statement.columns[i3] = {
        name: transform4.column.from ? transform4.column.from(x4.toString("utf8", start, index - 1)) : x4.toString("utf8", start, index - 1),
        parser: parsers2[type3],
        table,
        number: number3,
        type: type3
      };
      index += 18;
    }
    result.statement = query.statement;
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  async function Authentication(x4, type3 = x4.readUInt32BE(5)) {
    (type3 === 3 ? AuthenticationCleartextPassword : type3 === 5 ? AuthenticationMD5Password : type3 === 10 ? SASL : type3 === 11 ? SASLContinue : type3 === 12 ? SASLFinal : type3 !== 0 ? UnknownAuth : noop)(x4, type3);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x4) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x4.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i3 = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i3 - 4, i3).end());
  }
  async function SASLContinue(x4) {
    const res = x4.toString("utf8", 9).split(",").reduce((acc, x5) => (acc[x5[0]] = x5.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + "," + "r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x4) {
    if (x4.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors3.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result.statement = query.statement;
    result.statement.columns = [];
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  function BackendKeyData(x4) {
    backend.pid = x4.readUInt32BE(5);
    backend.secret = x4.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types2 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types2.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x4, xs) {
    return x4 === "read-write" && xs.default_transaction_read_only === "on" || x4 === "read-only" && xs.default_transaction_read_only === "off" || x4 === "primary" && xs.in_hot_standby === "on" || x4 === "standby" && xs.in_hot_standby === "off" || x4 === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query2 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query2.resolve = ([[a], [b4]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b4.pg_is_in_recovery ? "on" : "off";
    };
    query2.execute();
  }
  function ErrorResponse(x4) {
    query && (query.cursorFn || query.describeFirst) && write(Sync);
    const error4 = Errors3.postgres(parseError(x4));
    query && query.retried ? errored(query.retried) : query && query.prepared && retryRoutines.has(error4.routine) ? retry(query, error4) : errored(error4);
  }
  function retry(q5, error4) {
    delete statements[q5.signature];
    q5.retried = error4;
    execute(q5);
  }
  function NotificationResponse(x4) {
    if (!onnotify)
      return;
    let index = 9;
    while (x4[index++] !== 0)
      ;
    onnotify(x4.toString("utf8", 9, index - 1), x4.toString("utf8", index, x4.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x4 = await Promise.resolve(query.cursorFn(result));
      rows = 0;
      x4 === CLOSE ? write(Close(query.portal)) : (result = new Result, write(Execute("", query.cursorRows)));
    } catch (err) {
      write(Sync);
      query.reject(err);
    }
  }
  function CloseComplete() {
    result.count && query.cursorFn(result);
    query.resolve(result);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error4, callback) {
        callback(error4);
        socket.write(bytes_default().f().str(error4 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error4, callback) {
        callback(error4);
        socket.write(bytes_default().f().str(error4 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyData(x4) {
    stream && (stream.push(x4.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x4) {
    onnotice ? onnotice(parseError(x4)) : console.log(parseError(x4));
  }
  function EmptyQueryResponse() {
  }
  function FunctionCallResponse() {
    errored(Errors3.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors3.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x4) {
    console.error("Postgres.js : Unknown Message:", x4[0]);
  }
  function UnknownAuth(x4, type3) {
    console.error("Postgres.js : Unknown Auth:", type3);
  }
  function Bind(parameters3, types2, statement = "", portal = "") {
    let prev, type3;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters3.length);
    parameters3.forEach((x4, i3) => {
      if (x4 === null)
        return bytes_default.i32(4294967295);
      type3 = types2[i3];
      parameters3[i3] = x4 = type3 in options.serializers ? options.serializers[type3](x4) : "" + x4;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x4).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters3, types2, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters3.length);
    parameters3.forEach((x4, i3) => bytes_default.i32(types2[i3] || 0));
    return bytes_default.end();
  }
  function Describe(x4, name = "") {
    return bytes_default().D().str(x4).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v4]) => v4).map(([k4, v4]) => k4 + bytes_default.N + v4).join(bytes_default.N)).z(2).end(0);
  }
}
function parseError(x4) {
  const error3 = {};
  let start = 5;
  for (let i3 = 5;i3 < x4.length - 1; i3++) {
    if (x4[i3] === 0) {
      error3[errorFields[x4[start]]] = x4.toString("utf8", start + 1, i3);
      start = i3 + 1;
    }
  }
  return error3;
}
function md5(x4) {
  return crypto2.createHash("md5").update(x4).digest("hex");
}
function hmac(key, x4) {
  return crypto2.createHmac("sha256", key).update(x4).digest();
}
function sha256(x4) {
  return crypto2.createHash("sha256").update(x4).digest();
}
function xor(a, b4) {
  const length = Math.max(a.length, b4.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i3 = 0;i3 < length; i3++)
    buffer2[i3] = a[i3] ^ b4[i3];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
}

// ../node_modules/postgres/src/subscribe.js
var noop2 = () => {
};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init3(sql, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close: close2 } = sql;
  sql.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close2();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2, onerror = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init3(sql, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x4) => {
      connected(x4);
      onsubscribe();
      stream && stream.on("error", onerror);
      return { unsubscribe, state, sql };
    });
  }
  function connected(x4) {
    stream = x4.stream;
    state.pid = x4.state.pid;
    state.secret = x4.state.secret;
  }
  async function init3(sql2, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql2.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x4] = xs;
    const stream2 = await sql2.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x4.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x4.consistent_point.split("/").map((x5) => Buffer.from(("00000000" + x5).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error3);
    stream2.on("close", sql2.close);
    return { stream: stream2, state: xs.state };
    function error3(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x5) {
      if (x5[0] === 119) {
        parse2(x5.subarray(25), state2, sql2.options.parsers, handle, options.transform);
      } else if (x5[0] === 107 && x5[17]) {
        state2.lsn = x5.subarray(1, 9);
        pong();
      }
    }
    function handle(a, b4) {
      const path3 = b4.relation.schema + "." + b4.relation.table;
      call("*", a, b4);
      call("*:" + path3, a, b4);
      b4.relation.keys.length && call("*:" + path3 + "=" + b4.relation.keys.map((x5) => a[x5.name]), a, b4);
      call(b4.command, a, b4);
      call(b4.command + ":" + path3, a, b4);
      b4.relation.keys.length && call(b4.command + ":" + path3 + "=" + b4.relation.keys.map((x5) => a[x5.name]), a, b4);
    }
    function pong() {
      const x5 = Buffer.alloc(34);
      x5[0] = "r".charCodeAt(0);
      x5.fill(state2.lsn, 1);
      x5.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x5);
    }
  }
  function call(x4, a, b4) {
    subscribers.has(x4) && subscribers.get(x4).forEach(({ fn }) => fn(a, b4, x4));
  }
}
function Time(x4) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x4 / BigInt(1000)));
}
function parse2(x4, state, parsers2, handle, transform4) {
  const char = (acc, [k4, v4]) => (acc[k4.charCodeAt(0)] = v4, acc);
  Object.entries({
    R: (x5) => {
      let i3 = 1;
      const r = state[x5.readUInt32BE(i3)] = {
        schema: x5.toString("utf8", i3 += 4, i3 = x5.indexOf(0, i3)) || "pg_catalog",
        table: x5.toString("utf8", i3 + 1, i3 = x5.indexOf(0, i3 + 1)),
        columns: Array(x5.readUInt16BE(i3 += 2)),
        keys: []
      };
      i3 += 2;
      let columnIndex = 0, column;
      while (i3 < x5.length) {
        column = r.columns[columnIndex++] = {
          key: x5[i3++],
          name: transform4.column.from ? transform4.column.from(x5.toString("utf8", i3, i3 = x5.indexOf(0, i3))) : x5.toString("utf8", i3, i3 = x5.indexOf(0, i3)),
          type: x5.readUInt32BE(i3 += 1),
          parser: parsers2[x5.readUInt32BE(i3)],
          atttypmod: x5.readUInt32BE(i3 += 4)
        };
        column.key && r.keys.push(column);
        i3 += 4;
      }
    },
    Y: () => {
    },
    O: () => {
    },
    B: (x5) => {
      state.date = Time(x5.readBigInt64BE(9));
      state.lsn = x5.subarray(1, 9);
    },
    I: (x5) => {
      let i3 = 1;
      const relation = state[x5.readUInt32BE(i3)];
      const { row } = tuples(x5, relation.columns, i3 += 7, transform4);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x5) => {
      let i3 = 1;
      const relation = state[x5.readUInt32BE(i3)];
      i3 += 4;
      const key = x5[i3] === 75;
      handle(key || x5[i3] === 79 ? tuples(x5, relation.columns, i3 += 3, transform4).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x5) => {
      let i3 = 1;
      const relation = state[x5.readUInt32BE(i3)];
      i3 += 4;
      const key = x5[i3] === 75;
      const xs = key || x5[i3] === 79 ? tuples(x5, relation.columns, i3 += 3, transform4) : null;
      xs && (i3 = xs.i);
      const { row } = tuples(x5, relation.columns, i3 + 3, transform4);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {
    },
    C: () => {
    }
  }).reduce(char, {})[x4[0]](x4);
}
function tuples(x4, columns, xi, transform4) {
  let type3, column, value2;
  const row = transform4.raw ? new Array(columns.length) : {};
  for (let i3 = 0;i3 < columns.length; i3++) {
    type3 = x4[xi++];
    column = columns[i3];
    value2 = type3 === 110 ? null : type3 === 117 ? undefined : column.parser === undefined ? x4.toString("utf8", xi + 4, xi += 4 + x4.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x4.toString("utf8", xi + 5, xi += 4 + x4.readUInt32BE(xi))) : column.parser(x4.toString("utf8", xi + 4, xi += 4 + x4.readUInt32BE(xi)));
    transform4.raw ? row[i3] = transform4.raw === true ? value2 : transform4.value.from ? transform4.value.from(value2, column) : value2 : row[column.name] = transform4.value.from ? transform4.value.from(value2, column) : value2;
  }
  return { i: xi, row: transform4.row.from ? transform4.row.from(row) : row };
}
function parseEvent(x4) {
  const xs = x4.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x4);
  const [, command, path3, key] = xs;
  return (command || "*") + (path3 ? ":" + (path3.indexOf(".") === -1 ? "public." + path3 : path3) : "") + (key ? "=" + key : "");
}

// ../node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve2, reject) => {
    await sql.begin(async (sql2) => {
      let finish;
      !oid && ([{ oid }] = await sql2`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql2`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql2`select lo_close(${fd})`.then(finish),
        tell: () => sql2`select lo_tell64(${fd})`,
        read: (x4) => sql2`select loread(${fd}, ${x4}) as data`,
        write: (x4) => sql2`select lowrite(${fd}, ${x4})`,
        truncate: (x4) => sql2`select lo_truncate64(${fd}, ${x4})`,
        seek: (x4, whence = 0) => sql2`select lo_lseek64(${fd}, ${x4}, ${whence})`,
        size: () => sql2`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve2(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// ../node_modules/postgres/src/index.js
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x4) => BigInt(x4),
    serialize: (x4) => x4.toString()
  }
});
var src_default2 = Postgres;
function Postgres(a, b4) {
  const options = parseOptions(a, b4), subscribe = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql = Sql(handler);
  Object.assign(sql, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close: close2,
    end
  });
  return sql;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type3]) => {
      acc[name] = (x4) => new Parameter(x4, type3.to);
      return acc;
    }, typed);
    Object.assign(sql2, {
      types: typed,
      typed,
      unsafe: unsafe3,
      notify,
      array: array3,
      json,
      file
    });
    return sql2;
    function typed(value2, type3) {
      return new Parameter(value2, type3);
    }
    function sql2(strings, ...args) {
      const query = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier2(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query;
    }
    function unsafe3(string3, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([string3], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
    function file(path3, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([], args, (query2) => {
        fs.readFile(path3, "utf8", (err, string3) => {
          if (err)
            return query2.reject(err);
          query2.strings = [string3];
          handler2(query2);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql2 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c3, x4) {
        c3 in listen.channels && listen.channels[c3].listeners.forEach((l) => l.fn(x4));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists = name in channels;
    if (exists) {
      channels[name].listeners.push(listener);
      const result2 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result2.state, unlisten };
    }
    channels[name] = { result: sql2`listen ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x4) => x4 !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql2`unlisten ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue = queue_default();
    const c3 = open.length ? open.shift() : await new Promise((r) => {
      queries.push({ reserve: r });
      closed.length && connect3(closed.shift());
    });
    move(c3, reserved);
    c3.reserved = () => queue.length ? c3.execute(queue.shift()) : move(c3, reserved);
    c3.reserved.release = true;
    const sql2 = Sql(handler2);
    sql2.release = () => {
      c3.reserved = null;
      onopen(c3);
    };
    return sql2;
    function handler2(q5) {
      c3.queue === full ? queue.push(q5) : c3.execute(q5) || move(c3, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection2, prepare = null;
    try {
      await sql.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection2, fn),
        new Promise((_3, reject) => connection2.onclose = reject)
      ]);
    } catch (error3) {
      throw error3;
    }
    async function scope(c3, fn2, name) {
      const sql2 = Sql(handler2);
      sql2.savepoint = savepoint;
      sql2.prepare = (x4) => prepare = x4.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result;
      name && await sql2`savepoint ${sql2(name)}`;
      try {
        result = await new Promise((resolve2, reject) => {
          const x4 = fn2(sql2);
          Promise.resolve(Array.isArray(x4) ? Promise.all(x4) : x4).then(resolve2, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql2`rollback to ${sql2(name)}` : sql2`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql2`prepare transaction '${sql2.unsafe(prepare)}'` : await sql2`commit`;
      }
      return result;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql3) => sql3.apply(sql3, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c3, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q5) {
        q5.catch((e) => uncaughtError || (uncaughtError = e));
        c3.queue === full ? queries2.push(q5) : c3.execute(q5) || move(c3, full);
      }
    }
    function onexecute(c3) {
      connection2 = c3;
      move(c3, reserved);
      c3.reserved = () => queries2.length ? c3.execute(queries2.shift()) : move(c3, reserved);
    }
  }
  function move(c3, queue) {
    c3.queue.remove(c3);
    queue.push(c3);
    c3.queue = queue;
    queue === open ? c3.idleTimer.start() : c3.idleTimer.cancel();
    return c3;
  }
  function json(x4) {
    return new Parameter(x4, 3802);
  }
  function array3(x4, type3) {
    if (!Array.isArray(x4))
      return array3(Array.from(arguments));
    return new Parameter(x4, type3 || (x4.length ? inferType(x4) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query) {
    if (ending)
      return query.reject(Errors3.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query);
    if (closed.length)
      return connect3(closed.shift(), query);
    busy.length ? go(busy.shift(), query) : queries.push(query);
  }
  function go(c3, query) {
    return c3.execute(query) ? move(c3, busy) : move(c3, full);
  }
  function cancel(query) {
    return new Promise((resolve2, reject) => {
      query.state ? query.active ? connection_default(options).cancel(query.state, resolve2, reject) : query.cancelled = { resolve: resolve2, reject } : (queries.remove(query), query.cancelled = true, query.reject(Errors3.generic("57014", "canceling statement due to user request")), resolve2());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c3) => c3.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close2() {
    await Promise.all(connections.map((c3) => c3.end()));
  }
  async function destroy(resolve2) {
    await Promise.all(connections.map((c3) => c3.terminate()));
    while (queries.length)
      queries.shift().reject(Errors3.connection("CONNECTION_DESTROYED", options));
    resolve2();
  }
  function connect3(c3, query) {
    move(c3, connecting);
    c3.connect(query);
    return c3;
  }
  function onend(c3) {
    move(c3, ended);
  }
  function onopen(c3) {
    if (queries.length === 0)
      return move(c3, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0) {
      const query = queries.shift();
      if (query.reserve)
        return query.reserve(c3);
      ready = c3.execute(query);
    }
    ready ? move(c3, busy) : move(c3, full);
  }
  function onclose(c3, e) {
    move(c3, closed);
    c3.reserved = null;
    c3.onclose && (c3.onclose(e), c3.onclose = null);
    options.onclose && options.onclose(c3.id);
    queries.length && connect3(c3, queries.shift());
  }
}
function parseOptions(a, b4) {
  if (a && a.shared)
    return a;
  const env2 = process.env, o2 = (!a || typeof a === "string" ? b4 : a) || {}, { url, multihost } = parseUrl2(a), query = [...url.searchParams].reduce((a3, [b5, c3]) => (a3[b5] = c3, a3), {}), host = o2.hostname || o2.host || multihost || url.hostname || env2.PGHOST || "localhost", port = o2.port || url.port || env2.PGPORT || 5432, user = o2.user || o2.username || url.username || env2.PGUSERNAME || env2.PGUSER || osUsername();
  o2.no_prepare && (o2.prepare = false);
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
  "timeout" in o2 && (console.log("The timeout option is deprecated, use idle_timeout instead"), o2.idle_timeout = o2.timeout);
  query.sslrootcert === "system" && (query.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x4) => x4.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x4) => parseInt(x4.split(":")[1] || port)),
    path: o2.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o2.database || o2.db || (url.pathname || "").slice(1) || env2.PGDATABASE || user,
    user,
    pass: o2.pass || o2.password || url.password || env2.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k4, d4]) => {
      const value2 = k4 in o2 ? o2[k4] : (k4 in query) ? query[k4] === "disable" || query[k4] === "false" ? false : query[k4] : env2["PG" + k4.toUpperCase()] || d4;
      acc[k4] = typeof value2 === "string" && ints.includes(k4) ? +value2 : value2;
      return acc;
    }, {}),
    connection: {
      application_name: "postgres.js",
      ...o2.connection,
      ...Object.entries(query).reduce((acc, [k4, v4]) => ((k4 in defaults) || (acc[k4] = v4), acc), {})
    },
    types: o2.types || {},
    target_session_attrs: tsa(o2, url, env2),
    onnotice: o2.onnotice,
    onnotify: o2.onnotify,
    onclose: o2.onclose,
    onparameter: o2.onparameter,
    socket: o2.socket,
    transform: parseTransform(o2.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o2.types)
  };
}
function tsa(o2, url, env2) {
  const x4 = o2.target_session_attrs || url.searchParams.get("target_session_attrs") || env2.PGTARGETSESSIONATTRS;
  if (!x4 || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x4))
    return x4;
  throw new Error("target_session_attrs " + x4 + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x4) {
  return {
    undefined: x4.undefined,
    column: {
      from: typeof x4.column === "function" ? x4.column : x4.column && x4.column.from,
      to: x4.column && x4.column.to
    },
    value: {
      from: typeof x4.value === "function" ? x4.value : x4.value && x4.value.from,
      to: x4.value && x4.value.to
    },
    row: {
      from: typeof x4.row === "function" ? x4.row : x4.row && x4.row.from,
      to: x4.row && x4.row.to
    }
  };
}
function parseUrl2(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return os4.userInfo().username;
  } catch (_3) {
    return process.env.USERNAME || "mo";
  }
}

// ../node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value2, type3) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  if (value2 instanceof type3) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type3, entityKind)) {
    throw new Error(`Class "${type3.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value2).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type3[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config2) {
    this.writer = config2?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p4) => {
      try {
        return JSON.stringify(p4);
      } catch {
        return String(p4);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger2 {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// ../node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value2) => {
      onFinally?.();
      return value2;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// ../node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// ../node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema3, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema3;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// ../node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// ../node_modules/drizzle-orm/version.js
var version2 = "0.35.2";

// ../node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version2);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// ../node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config2) {
    this.table = table;
    this.config = config2;
    this.name = config2.name;
    this.keyAsName = config2.keyAsName;
    this.notNull = config2.notNull;
    this.default = config2.default;
    this.defaultFn = config2.defaultFn;
    this.onUpdateFn = config2.onUpdateFn;
    this.hasDefault = config2.hasDefault;
    this.primary = config2.primaryKey;
    this.isUnique = config2.isUnique;
    this.uniqueName = config2.uniqueName;
    this.uniqueType = config2.uniqueType;
    this.dataType = config2.dataType;
    this.columnType = config2.columnType;
    this.generated = config2.generated;
    this.generatedIdentity = config2.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value2) {
    return value2;
  }
  mapToDriverValue(value2) {
    return value2;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// ../node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value2) {
    this.config.default = value2;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// ../node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config2, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config2();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}
function foreignKey(config2) {
  function mappedConfig() {
    const { name, columns, foreignColumns } = config2;
    return {
      name,
      columns,
      foreignColumns
    };
  }
  return new ForeignKeyBuilder(mappedConfig);
}

// ../node_modules/drizzle-orm/pg-core/unique-constraint.js
function unique(name) {
  return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

class UniqueConstraintBuilder {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  static [entityKind] = "PgUniqueConstraintBuilder";
  columns;
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
}

class UniqueOnConstraintBuilder {
  static [entityKind] = "PgUniqueOnConstraintBuilder";
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
}

class UniqueConstraint {
  constructor(table, columns, nullsNotDistinct, name) {
    this.table = table;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  static [entityKind] = "PgUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
}

// ../node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i3 = startFrom;i3 < arrayString.length; i3++) {
    const char = arrayString[i3];
    if (char === "\\") {
      i3++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i3).replace(/\\/g, ""), i3 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i3).replace(/\\/g, ""), i3];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i3 = startFrom;
  let lastCharIsComma = false;
  while (i3 < arrayString.length) {
    const char = arrayString[i3];
    if (char === ",") {
      if (lastCharIsComma || i3 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i3++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i3 += 2;
      continue;
    }
    if (char === '"') {
      const [value22, startFrom2] = parsePgArrayValue(arrayString, i3 + 1, true);
      result.push(value22);
      i3 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i3 + 1];
    }
    if (char === "{") {
      const [value22, startFrom2] = parsePgNestedArray(arrayString, i3 + 1);
      result.push(value22);
      i3 = startFrom2;
      continue;
    }
    const [value2, newStartFrom] = parsePgArrayValue(arrayString, i3, false);
    result.push(value2);
    i3 = newStartFrom;
  }
  return [result, i3];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array3) {
  return `{${array3.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size2) {
    return new PgArrayBuilder(this.config.name, this, size2);
  }
  references(ref3, actions = {}) {
    this.foreignKeyConfigs.push({ ref: ref3, actions });
    return this;
  }
  unique(name, config2) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config2?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref: ref3, actions }) => {
      return iife((ref22, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref22();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref3, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config2) {
    if (!config2.uniqueName) {
      config2.uniqueName = uniqueKeyName(table, [config2.name]);
    }
    super(table, config2);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

class IndexedColumn {
  static [entityKind] = "IndexedColumn";
  constructor(name, keyAsName, type3, indexConfig) {
    this.name = name;
    this.keyAsName = keyAsName;
    this.type = type3;
    this.indexConfig = indexConfig;
  }
  name;
  keyAsName;
  type;
  indexConfig;
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size2) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size2;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config2, baseColumn, range) {
    super(table, config2);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config2.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      value2 = parsePgArray(value2);
    }
    return value2.map((v4) => this.baseColumn.mapFromDriverValue(v4));
  }
  mapToDriverValue(value2, isNestedArray = false) {
    const a = value2.map((v4) => v4 === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v4, true) : this.baseColumn.mapToDriverValue(v4));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// ../node_modules/drizzle-orm/pg-core/columns/enum.js
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}

class PgEnumColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  build(table) {
    return new PgEnumColumn(table, this.config);
  }
}

class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config2) {
    super(table, config2);
    this.enum = config2.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
function pgEnum(enumName, values2) {
  return pgEnumWithSchema(enumName, values2, undefined);
}
function pgEnumWithSchema(enumName, values2, schema3) {
  const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name ?? "", enumInstance), {
    enumName,
    enumValues: values2,
    schema: schema3,
    [isPgEnumSym]: true
  });
  return enumInstance;
}

// ../node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, selection, alias, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// ../node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value2) {
  return value2 !== null && value2 !== undefined && typeof value2.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value2) {
    this.value = Array.isArray(value2) ? value2 : [value2];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config2) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config2);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config2 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config2;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i3, p4] of chunk.entries()) {
          result.push(p4);
          if (i3 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config2);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config2,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config2);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config2), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config2);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config2);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config2);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config2), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value2) {
    this.value = value2;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value2) {
  return typeof value2 === "object" && value2 !== null && "mapToDriverValue" in value2 && typeof value2.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value2) => value2
};
var noopEncoder = {
  mapToDriverValue: (value2) => value2
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value2, encoder = noopEncoder) {
    this.value = value2;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join5(chunks, separator) {
    const result = [];
    for (const [i3, chunk] of chunks.entries()) {
      if (i3 > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join5;
  function identifier(value2) {
    return new Name(value2);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value2, encoder) {
    return new Param(value2, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values2) {
  return params.map((p4) => {
    if (is(p4, Placeholder)) {
      if (!(p4.name in values2)) {
        throw new Error(`No value for placeholder "${p4.name}" was provided`);
      }
      return values2[p4.name];
    }
    if (is(p4, Param) && is(p4.value, Placeholder)) {
      if (!(p4.value.name in values2)) {
        throw new Error(`No value for placeholder "${p4.value.name}" was provided`);
      }
      return p4.encoder.mapToDriverValue(values2[p4.value.name]);
    }
    return p4;
  });
}

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name: name2, schema: schema3, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema: schema3,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path: path3, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node2 = result2;
    for (const [pathChunkIndex, pathChunk] of path3.entries()) {
      if (pathChunkIndex < path3.length - 1) {
        if (!(pathChunk in node2)) {
          node2[pathChunk] = {};
        }
        node2 = node2[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value2 = node2[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path3.length === 2) {
          const objectName = path3[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value2 === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values2) {
  const entries = Object.entries(values2).filter(([, value2]) => value2 !== undefined).map(([key, value2]) => {
    if (is(value2, SQL)) {
      return [key, value2];
    } else {
      return [key, new Param(value2, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b4) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b4
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type3 = typeof data["logger"];
    if (type3 !== "boolean" && (type3 !== "object" || typeof data["logger"]["logQuery"] !== "function") && type3 !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type3 = typeof data["logger"];
    if (type3 !== "object" && type3 !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type3 = typeof data["logger"];
    if (type3 !== "string" && type3 !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type3 = typeof data["connection"];
    if (type3 !== "string" && type3 !== "object" && type3 !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type3 = typeof data["client"];
    if (type3 !== "object" && type3 !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// ../node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest3 } = this.dialect.sqlToQuery(this.getSQL());
    return rest3;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgInsertBuilder";
  values(values2) {
    values2 = Array.isArray(values2) ? values2 : [values2];
    if (values2.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values2.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values: values2, withList };
  }
  static [entityKind] = "PgInsert";
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config2 = {}) {
    if (config2.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
      const whereSql = config2.where ? sql` where ${config2.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config2) {
    if (config2.where && (config2.targetWhere || config2.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config2.where ? sql` where ${config2.where}` : undefined;
    const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : undefined;
    const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest3 } = this.dialect.sqlToQuery(this.getSQL());
    return rest3;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// ../node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value2 = target[prop];
    if (is(value2, Column)) {
      return new Proxy(value2, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value2;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c3) => {
    if (is(c3, Column)) {
      return aliasedTableColumn(c3, alias);
    }
    if (is(c3, SQL)) {
      return mapColumnsInSQLToAlias(c3, alias);
    }
    if (is(c3, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c3, alias);
    }
    return c3;
  }));
}

// ../node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i3) => {
    const formattedWord = i3 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema3 = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema3}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema3 = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema3}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// ../node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// ../node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// ../node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "number") {
      return value2;
    }
    return Number(value2);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value2) {
    return BigInt(value2);
  }
}
function bigint3(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (config2.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "number") {
      return value2;
    }
    return Number(value2);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value2) {
    return BigInt(value2);
  }
}
function bigserial(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (config2.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean3(name) {
  return new PgBooleanBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config2) {
    super(name, "string", "PgChar");
    this.config.length = config2.length;
    this.config.enumValues = config2.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgCharBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config2) {
    super(table, config2);
    this.sqlName = config2.customTypeParams.dataType(config2.fieldConfig);
    this.mapTo = config2.customTypeParams.toDriver;
    this.mapFrom = config2.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value2) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value2) : value2;
  }
  mapToDriverValue(value2) {
    return typeof this.mapTo === "function" ? this.mapTo(value2) : value2;
  }
}
function customType(customTypeParams) {
  return (a, b4) => {
    const { name, config: config2 } = getColumnNameAndConfig(a, b4);
    return new PgCustomColumnBuilder(name, config2, customTypeParams);
  };
}

// ../node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// ../node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value2) {
    return new Date(value2);
  }
  mapToDriverValue(value2) {
    return value2.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date3(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (config2?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      return Number.parseFloat(value2);
    }
    return value2;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      return Number.parseInt(value2);
    }
    return value2;
  }
}
function integer3(name) {
  return new PgIntegerBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgIntervalBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config2) {
    super(table, config2);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value2) {
    return JSON.stringify(value2);
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      try {
        return JSON.parse(value2);
      } catch {
        return value2;
      }
    }
    return value2;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config2) {
    super(table, config2);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value2) {
    return JSON.stringify(value2);
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      try {
        return JSON.parse(value2);
      } catch {
        return value2;
      }
    }
    return value2;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value2) {
    const [a, b4, c3] = value2.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b4), Number.parseFloat(c3)];
  }
  mapToDriverValue(value2) {
    return `{${value2[0]},${value2[1]},${value2[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value2) {
    const [a, b4, c3] = value2.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b4), c: Number.parseFloat(c3) };
  }
  mapToDriverValue(value2) {
    return `{${value2.a},${value2.b},${value2.c}}`;
  }
}
function line(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config2) {
    super(table, config2);
    this.precision = config2.precision;
    this.scale = config2.scale;
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgNumericBuilder(name, config2?.precision, config2?.scale);
}

// ../node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      const [x4, y3] = value2.slice(1, -1).split(",");
      return [Number.parseFloat(x4), Number.parseFloat(y3)];
    }
    return [value2.x, value2.y];
  }
  mapToDriverValue(value2) {
    return `(${value2[0]},${value2[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value2) {
    if (typeof value2 === "string") {
      const [x4, y3] = value2.slice(1, -1).split(",");
      return { x: Number.parseFloat(x4), y: Number.parseFloat(y3) };
    }
    return value2;
  }
  mapToDriverValue(value2) {
    return `(${value2.x},${value2.y})`;
  }
}
function point(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c3 = 0;c3 < hex.length; c3 += 2) {
    bytes.push(Number.parseInt(hex.slice(c3, c3 + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer2 = new ArrayBuffer(8);
  const view = new DataView(buffer2);
  for (let i3 = 0;i3 < 8; i3++) {
    view.setUint8(i3, bytes[offset + i3]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x4 = bytesToFloat64(bytes, offset);
    offset += 8;
    const y3 = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x4, y3];
  }
  throw new Error("Unsupported geometry type");
}

// ../node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value2) {
    return parseEWKB(value2);
  }
  mapToDriverValue(value2) {
    return `point(${value2[0]} ${value2[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value2) {
    const parsed = parseEWKB(value2);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value2) {
    return `point(${value2.x} ${value2.y})`;
  }
}
function geometry(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config2) {
    super(table, config2);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value2) => {
    if (typeof value2 === "string") {
      return Number.parseFloat(value2);
    }
    return value2;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value2) => {
    if (typeof value2 === "string") {
      return Number(value2);
    }
    return value2;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config2) {
    super(name, "string", "PgText");
    this.config.enumValues = config2.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgTextBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config2) {
    super(table, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgTimeBuilder(name, config2.withTimezone ?? false, config2.precision);
}

// ../node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config2) {
    super(table, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value2) => {
    return new Date(this.withTimezone ? value2 : value2 + "+0000");
  };
  mapToDriverValue = (value2) => {
    return value2.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config2) {
    super(table, config2);
    this.withTimezone = config2.withTimezone;
    this.precision = config2.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  if (config2?.mode === "string") {
    return new PgTimestampStringBuilder(name, config2.withTimezone ?? false, config2.precision);
  }
  return new PgTimestampBuilder(name, config2?.withTimezone ?? false, config2?.precision);
}

// ../node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// ../node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config2) {
    super(name, "string", "PgVarchar");
    this.config.length = config2.length;
    this.config.enumValues = config2.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b4 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgVarcharBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config2) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config2.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgBinaryVectorBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config2) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config2.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value2) {
    return JSON.stringify(value2);
  }
  mapFromDriverValue(value2) {
    return value2.slice(1, -1).split(",").map((v4) => Number.parseFloat(v4));
  }
}
function halfvec(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgHalfVectorBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config2) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config2.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgSparseVectorBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config2) {
    super(name, "array", "PgVector");
    this.config.dimensions = config2.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value2) {
    return JSON.stringify(value2);
  }
  mapFromDriverValue(value2) {
    return value2.slice(1, -1).split(",").map((v4) => Number.parseFloat(v4));
  }
}
function vector(a, b4) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b4);
  return new PgVectorBuilder(name, config2);
}

// ../node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint: bigint3,
    bigserial,
    boolean: boolean3,
    char,
    cidr,
    customType,
    date: date3,
    doublePrecision,
    inet,
    integer: integer3,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// ../node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  [InlineForeignKeys] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
function pgTableWithSchema(name, columns, extraConfig, schema3, baseName = name) {
  const rawTable = new PgTable(name, schema3, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// ../node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// ../node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value2, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value2) && !is(value2, Param) && !is(value2, Placeholder) && !is(value2, Column) && !is(value2, Table) && !is(value2, View)) {
    return new Param(value2, column);
  }
  return value2;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c3) => c3 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c3) => c3 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not3(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values2.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} in ${bindIfParam(values2, column)}`;
}
function notInArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values2.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values2, column)}`;
}
function isNull(value2) {
  return sql`${value2} is null`;
}
function isNotNull(value2) {
  return sql`${value2} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value2) {
  return sql`${column} like ${value2}`;
}
function notLike(column, value2) {
  return sql`${column} not like ${value2}`;
}
function ilike(column, value2) {
  return sql`${column} ilike ${value2}`;
}
function notIlike(column, value2) {
  return sql`${column} not ilike ${value2}`;
}

// ../node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config2) {
    this.table = table;
    this.config = config2;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config2, isNullable) {
    super(sourceTable, referencedTable, config2?.relationName);
    this.config = config2;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config2) {
    super(sourceTable, referencedTable, config2?.relationName);
    this.config = config2;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not: not3,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema3, configHelpers) {
  if (Object.keys(schema3).length === 1 && "default" in schema3 && !is(schema3["default"], Table)) {
    schema3 = schema3["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value2] of Object.entries(schema3)) {
    if (is(value2, Table)) {
      const dbName = getTableUniqueName(value2);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value2[Table.Symbol.Name],
        schema: value2[Table.Symbol.Schema],
        columns: value2[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value2[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value2[Table.Symbol.ExtraConfigBuilder]?.(value2[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value2, Relations)) {
      const dbName = getTableUniqueName(value2.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value2.config(configHelpers(value2.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(table, (helpers3) => Object.fromEntries(Object.entries(relations2(helpers3)).map(([key, value2]) => [
    key,
    value2.withFieldName(key)
  ])));
}
function createOne(sourceTable) {
  return function one(table, config2) {
    return new One(sourceTable, table, config2, config2?.fields.reduce((res, f4) => res && f4.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config2) {
    return new Many(sourceTable, referencedTable, config2);
  };
}
function normalizeRelation(schema3, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema3[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value2) => value2) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value2 = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value2 === null ? null : decoder.mapFromDriverValue(value2);
    }
  }
  return result;
}

// ../node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// ../node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config2) {
    this.casing = new CasingCache(config2?.casing);
  }
  async migrate(migrations, session, config2) {
    const migrationsTable = typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config2 === "string" ? "drizzle" : config2.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `\$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i3, w3] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w3._.alias)} as (${w3._.sql})`);
      if (i3 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set2) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set2[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i3) => {
      const col = tableColumns[colName];
      const value2 = set2[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value2}`;
      if (i3 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set: set2, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table, set2);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i3) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c3) => {
            if (is(c3, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c3));
            }
            return c3;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i3 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f4 of fieldsList) {
      if (is(f4.field, Column) && getTableName(f4.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f4.field.table)) {
        const tableName = getTableName(f4.field.table);
        throw new Error(`Your "${f4.path.join("->")}" field references a column "${tableName}"."${f4.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
        if (table[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
        if (is(table2, PgTable)) {
          const tableName = table2[PgTable.Symbol.Name];
          const tableSchema = table2[PgTable.Symbol.Schema];
          const origTableName = table2[PgTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else if (is(table2, View)) {
          const viewName = table2[ViewBaseConfig].name;
          const viewSchema = table2[ViewBaseConfig].schema;
          const origViewName = table2[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest3] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest3.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest3);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type: type3, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i3 = 0;i3 < singleOrderBy.queryChunks.length; i3++) {
            const chunk = singleOrderBy.queryChunks[i3];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i3] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type3} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: values2, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_3, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    for (const [valueIndex, value2] of values2.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value2[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else if (!col.default && col.onUpdateFn !== undefined) {
            const onUpdateFnResult = col.onUpdateFn();
            const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
            valueList.push(newValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values2.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema: schema3,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config2,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config2 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value2]) => ({
        dbKey: value2.name,
        tsKey: key,
        field: aliasedTableColumn(value2, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value2]) => [key, aliasedTableColumn(value2, tableAlias)]));
      if (config2.where) {
        const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config2.columns) {
        let isIncludeMode = false;
        for (const [field, value2] of Object.entries(config2.columns)) {
          if (value2 === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value2 === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c3) => config2.columns?.[c3] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config2.with) {
        selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config2.extras) {
        extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
        for (const [tsKey, value2] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value2, tableAlias)
          });
        }
      }
      for (const { tsKey, value: value2 } of fieldsSelection) {
        selection.push({
          dbKey: is(value2, SQL.Aliased) ? value2.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value2, Column) ? aliasedTableColumn(value2, tableAlias) : value2,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config2.limit;
      offset = config2.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i3) => eq(aliasedTableColumn(normalizedRelation.references[i3], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema: schema3,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema3[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// ../node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config2) {
    this.config = { ...config2 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value2 = columns[prop];
    if (is(value2, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value2.isSelectionField) {
        return value2.sql;
      }
      const newValue = value2.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value2, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value2;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value2, Column)) {
      if (this.config.alias) {
        return new Proxy(value2, new ColumnAliasProxyHandler(new Proxy(value2.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value2;
    }
    if (typeof value2 !== "object" || value2 === null) {
      return value2;
    }
    return new Proxy(value2, new SelectionProxyHandler(this.config));
  }
}

// ../node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config2) {
    this.fields = config2.fields;
    this.session = config2.session;
    this.dialect = config2.dialect;
    if (config2.withList) {
      this.withList = config2.withList;
    }
    this.distinct = config2.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source._.selectedFields).map((key) => [key, source[key]]));
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join5) => join5.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  createSetOperator(type3, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type: type3, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config2 = {}) {
    this.config.lockingClause = { strength, config: config2 };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest3 } = this.dialect.sqlToQuery(this.getSQL());
    return rest3;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config: config2, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config2.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type3, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type: type3,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union: union4,
  unionAll,
  intersect: intersect3,
  intersectAll,
  except,
  exceptAll
});
var union4 = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect3 = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select: select2, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest3 } = this.dialect.sqlToQuery(this.getSQL());
    return rest3;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}

// ../node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  set(values2) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values2), this.session, this.dialect, this.withList);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table, withList };
  }
  static [entityKind] = "PgUpdate";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest3 } = this.dialect.sqlToQuery(this.getSQL());
    return rest3;
  }
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value2) => {
      onFinally?.();
      return value2;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config2) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config2 ? config2 : {}, "many");
  }
  findFirst(config2) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config2 ? { ...config2, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect, session, config2, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config2;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
}

// ../node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// ../node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema3) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema3 ? {
      schema: schema3.schema,
      fullSchema: schema3.fullSchema,
      tableNamesMap: schema3.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema3.fullSchema, this._.schema, this._.tableNamesMap, schema3.fullSchema[tableName], columns, dialect, session);
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with(alias) {
    const self2 = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder(self2.dialect));
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select: select2, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config2) {
    return this.session.transaction(transaction, config2);
  }
}

// ../node_modules/drizzle-orm/pg-core/checks.js
class CheckBuilder {
  constructor(name, value2) {
    this.name = name;
    this.value = value2;
  }
  static [entityKind] = "PgCheckBuilder";
  brand;
  build(table) {
    return new Check3(table, this);
  }
}

class Check3 {
  constructor(table, builder) {
    this.table = table;
    this.name = builder.name;
    this.value = builder.value;
  }
  static [entityKind] = "PgCheck";
  name;
  value;
}
function check3(name, value2) {
  return new CheckBuilder(name, value2);
}

// ../node_modules/drizzle-orm/pg-core/indexes.js
class IndexBuilderOn {
  constructor(unique2, name) {
    this.unique = unique2;
    this.name = name;
  }
  static [entityKind] = "PgIndexBuilderOn";
  on(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = it.defaultConfig;
      return clonedIndexedColumn;
    }), this.unique, true, this.name);
  }
  using(method, ...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, true, this.name, method);
  }
}

class IndexBuilder {
  static [entityKind] = "PgIndexBuilder";
  config;
  constructor(columns, unique2, only, name, method = "btree") {
    this.config = {
      name,
      columns,
      unique: unique2,
      only,
      method
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  with(obj) {
    this.config.with = obj;
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  build(table) {
    return new Index2(this.config, table);
  }
}

class Index2 {
  static [entityKind] = "PgIndex";
  config;
  constructor(config2, table) {
    this.config = { ...config2, table };
  }
}
function index(name) {
  return new IndexBuilderOn(false, name);
}
function uniqueIndex(name) {
  return new IndexBuilderOn(true, name);
}

// ../node_modules/drizzle-orm/pg-core/sequence.js
class PgSequence {
  constructor(seqName, seqOptions, schema3) {
    this.seqName = seqName;
    this.seqOptions = seqOptions;
    this.schema = schema3;
  }
  static [entityKind] = "PgSequence";
}
function pgSequence(name, options) {
  return pgSequenceWithSchema(name, options, undefined);
}
function pgSequenceWithSchema(name, options, schema3) {
  return new PgSequence(name, options, schema3);
}

// ../node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query) {
    this.query = query;
  }
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.execute();
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema3, nestedIndex = 0) {
    super(dialect, session, schema3);
    this.schema = schema3;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config2) {
    const chunks = [];
    if (config2.isolationLevel) {
      chunks.push(`isolation level ${config2.isolationLevel}`);
    }
    if (config2.accessMode) {
      chunks.push(config2.accessMode);
    }
    if (typeof config2.deferrable === "boolean") {
      chunks.push(config2.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config2) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config2)}`);
  }
}

// ../node_modules/drizzle-orm/postgres-js/session.js
class PostgresJsPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger2, fields, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params });
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "PostgresJsPreparedQuery";
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      const { fields, queryString: query, client, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", () => {
          return client.unsafe(query, params);
        });
      }
      const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": query,
          "drizzle.query.params": JSON.stringify(params)
        });
        return client.unsafe(query, params).values();
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      return tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": this.queryString,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.client.unsafe(this.queryString, params);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class PostgresJsSession extends PgSession {
  constructor(client, dialect, schema3, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema3;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger2;
  }
  static [entityKind] = "PostgresJsSession";
  logger;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper) {
    return new PostgresJsPreparedQuery(this.client, query.sql, query.params, this.logger, fields, isResponseInArrayMode, customResultMapper);
  }
  query(query, params) {
    this.logger.logQuery(query, params);
    return this.client.unsafe(query, params).values();
  }
  queryObjects(query, params) {
    return this.client.unsafe(query, params);
  }
  transaction(transaction, config2) {
    return this.client.begin(async (client) => {
      const session = new PostgresJsSession(client, this.dialect, this.schema, this.options);
      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);
      if (config2) {
        await tx.setTransaction(config2);
      }
      return transaction(tx);
    });
  }
}

class PostgresJsTransaction extends PgTransaction {
  constructor(dialect, session, schema3, nestedIndex = 0) {
    super(dialect, session, schema3, nestedIndex);
    this.session = session;
  }
  static [entityKind] = "PostgresJsTransaction";
  transaction(transaction) {
    return this.session.client.savepoint((client) => {
      const session = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);
      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);
      return transaction(tx);
    });
  }
}

// ../node_modules/drizzle-orm/postgres-js/driver.js
class PostgresJsDatabase extends PgDatabase {
  static [entityKind] = "PostgresJsDatabase";
}
function construct(client, config2 = {}) {
  const transparentParser = (val2) => val2;
  for (const type3 of ["1184", "1082", "1083", "1114"]) {
    client.options.parsers[type3] = transparentParser;
    client.options.serializers[type3] = transparentParser;
  }
  client.options.serializers["114"] = transparentParser;
  client.options.serializers["3802"] = transparentParser;
  const dialect = new PgDialect({ casing: config2.casing });
  let logger2;
  if (config2.logger === true) {
    logger2 = new DefaultLogger;
  } else if (config2.logger !== false) {
    logger2 = config2.logger;
  }
  let schema3;
  if (config2.schema) {
    const tablesConfig = extractTablesRelationalConfig(config2.schema, createTableRelationsHelpers);
    schema3 = {
      fullSchema: config2.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new PostgresJsSession(client, dialect, schema3, { logger: logger2 });
  const db = new PostgresJsDatabase(dialect, session, schema3);
  db.$client = client;
  return db;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = src_default2(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection: connection2, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection2 === "object" && connection2.url !== undefined) {
      const { url, ...config2 } = connection2;
      const instance2 = src_default2(url, config2);
      return construct(instance2, drizzleConfig);
    }
    const instance = src_default2(connection2);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config2) {
    return construct({}, config2);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/db/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  waitlist: () => waitlist,
  users: () => users,
  userIdSequence: () => userIdSequence,
  thereUsers: () => thereUsers,
  spaces: () => spaces,
  spaceRelations: () => spaceRelations,
  sessions: () => sessions,
  rolesEnum: () => rolesEnum,
  messages: () => messages2,
  membersRelations: () => membersRelations,
  members: () => members,
  lower: () => lower,
  loginCodes: () => loginCodes,
  dialogs: () => dialogs,
  clientTypeEnum: () => clientTypeEnum,
  chats: () => chats,
  chatTypeEnum: () => chatTypeEnum
});

// src/db/schema/waitlist.ts
var waitlist = pgTable("waitlist", {
  id: serial().primaryKey(),
  email: varchar("email", { length: 256 }).notNull().unique(),
  verified: boolean3("verified").default(false).notNull(),
  name: varchar("name", { length: 256 }),
  userAgent: text("user_agent"),
  timeZone: varchar("time_zone", { length: 256 }),
  date: timestamp("date", { mode: "date", withTimezone: true }).defaultNow()
});
// src/db/schema/there.ts
var thereUsers = pgTable("there_users", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 256 }).notNull().unique(),
  name: varchar("name", { length: 256 }),
  timeZone: varchar("time_zone", { length: 256 }),
  date: timestamp("date", { mode: "date", withTimezone: true }).defaultNow()
});
// src/db/schema/users.ts
function lower(email) {
  return sql`lower(${email})`;
}
var userIdSequence = pgSequence("user_id", {
  startWith: 1000,
  minValue: 1000,
  cycle: false,
  cache: 100,
  increment: 3
});
var users = pgTable("users", {
  id: integer3("id").default(sql`nextval('user_id')`).primaryKey(),
  email: varchar("email", { length: 256 }).unique(),
  phoneNumber: varchar("phone_number", { length: 15 }).unique(),
  emailVerified: boolean3("email_verified"),
  phoneVerified: boolean3("phone_verified"),
  firstName: varchar("first_name", { length: 256 }),
  lastName: varchar("last_name", { length: 256 }),
  username: varchar("username", { length: 256 }),
  deleted: boolean3("deleted"),
  date: timestamp("date", { mode: "date", precision: 3 }).defaultNow()
}, (table) => ({
  users_username_unique: uniqueIndex("users_username_unique").on(lower(table.username))
}));
// src/db/schema/sessions.ts
var clientTypeEnum = pgEnum("client_type", ["ios", "macos", "web"]);
var sessions = pgTable("sessions", {
  id: serial().primaryKey(),
  userId: integer3("user_id").notNull().references(() => users.id),
  tokenHash: varchar("token_hash", { length: 64 }).notNull(),
  revoked: timestamp({ mode: "date", precision: 3 }),
  lastActive: timestamp("last_active", { mode: "date", precision: 3 }),
  country: text(),
  region: text(),
  city: text(),
  timezone: text(),
  ip: text(),
  deviceName: text(),
  clientType: clientTypeEnum("client_type"),
  clientVersion: text(),
  osVersion: text(),
  date: timestamp({ mode: "date", precision: 3 })
});
// src/db/schema/loginCodes.ts
var loginCodes = pgTable("login_codes", {
  id: serial().primaryKey(),
  email: varchar("email", { length: 256 }).unique(),
  phoneNumber: varchar("phone_number", { length: 15 }).unique(),
  code: varchar("code", { length: 10 }).notNull(),
  expiresAt: timestamp("expires_at", { mode: "date", precision: 3 }).notNull(),
  attempts: smallint("attempts").default(0),
  date: timestamp("date", { mode: "date", precision: 3 }).defaultNow()
});
// src/db/schema/common.ts
var bytea = customType({
  dataType() {
    return "bytea";
  }
});
var creationDate = timestamp("date", {
  mode: "date",
  precision: 3
}).defaultNow().notNull();

// src/db/schema/members.ts
var rolesEnum = pgEnum("member_roles", ["owner", "admin", "member"]);
var members = pgTable("members", {
  id: serial().primaryKey(),
  userId: integer3("user_id").notNull().references(() => users.id, {
    onDelete: "cascade"
  }),
  spaceId: integer3("space_id").notNull().references(() => spaces.id, {
    onDelete: "cascade"
  }),
  role: rolesEnum().default("member"),
  date: creationDate
}, (table) => ({ uniqueUserInSpace: unique().on(table.userId, table.spaceId) }));
var membersRelations = relations(members, ({ one }) => ({
  user: one(users, {
    fields: [members.userId],
    references: [users.id]
  }),
  space: one(spaces, {
    fields: [members.spaceId],
    references: [spaces.id]
  })
}));

// src/db/schema/spaces.ts
var spaces = pgTable("spaces", {
  id: serial().primaryKey(),
  name: varchar({ length: 256 }).notNull(),
  handle: varchar({ length: 32 }).unique(),
  date: creationDate
});
var spaceRelations = relations(spaces, ({ many }) => ({
  members: many(members)
}));
// src/db/schema/messages.ts
var messages2 = pgTable("messages", {
  globalId: bigserial("global_id", { mode: "bigint" }).primaryKey(),
  messageId: integer3("message_id").notNull(),
  text: text(),
  chatId: integer3("chat_id").notNull().references(() => chats.id, {
    onDelete: "cascade"
  }),
  fromId: integer3("from_id").notNull().references(() => users.id),
  editDate: timestamp("edit_date", { mode: "date", precision: 3 }),
  date: creationDate
}, (table) => ({
  messageIdPerChatUnique: unique("msg_id_per_chat_unique").on(table.messageId, table.chatId),
  messageIdPerChatIndex: index("msg_id_per_chat_index").on(table.messageId, table.chatId)
}));

// src/db/schema/chats.ts
var chatTypeEnum = pgEnum("chat_types", ["private", "thread"]);
var chats = pgTable("chats", {
  id: integer3().primaryKey().generatedAlwaysAsIdentity(),
  type: chatTypeEnum().notNull(),
  title: varchar({ length: 150 }),
  description: text(),
  emoji: varchar({ length: 20 }),
  maxMsgId: integer3("max_msg_id"),
  spaceId: integer3("space_id").references(() => spaces.id),
  spacePublic: boolean3("space_public"),
  threadNumber: integer3("thread_number"),
  minUserId: integer3("min_user_id").references(() => users.id),
  maxUserId: integer3("max_user_id").references(() => users.id),
  date: creationDate
}, (table) => ({
  userIdsCheckConstraint: check3("user_ids_check", sql`${table.minUserId} < ${table.maxUserId}`),
  userIdsUniqueContraint: unique("user_ids_unique").on(table.minUserId, table.maxUserId),
  spaceThreadNumberUniqueContraint: unique("space_thread_number_unique").on(table.spaceId, table.threadNumber),
  maxMsgIdForeignKey: foreignKey({
    name: "max_msg_id_fk",
    columns: [table.id, table.maxMsgId],
    foreignColumns: [messages2.chatId, messages2.messageId]
  }).onDelete("set null")
}));
// src/db/schema/dialogs.ts
var dialogs = pgTable("dialogs", {
  id: serial().primaryKey(),
  chatId: integer3("chat_id").references(() => chats.id, {
    onDelete: "cascade"
  }),
  userId: integer3("user_id").references(() => users.id),
  date: creationDate
}, (table) => ({
  chatIdUserIdUnique: unique("chat_id_user_id_unique").on(table.chatId, table.userId)
}));
// src/db/index.ts
var queryClient = src_default2(DATABASE_URL);
var db = drizzle(queryClient, {
  schema: exports_schema
});

// src/db/models/waitlist.ts
async function insertIntoWaitlist(subscriber) {
  return db.insert(waitlist).values(subscriber).returning();
}

// src/controllers/extra/waitlist.ts
var waitlist3 = new Q0({ prefix: "/waitlist" }).use(setup).post("/subscribe", async ({ body }) => {
  await insertIntoWaitlist(body);
  return {
    ok: true
  };
}, {
  body: V.Object({
    email: V.String(),
    name: V.Optional(V.String()),
    userAgent: V.Optional(V.String()),
    timeZone: V.Optional(V.String())
  })
}).post("/verify", () => "todo");

// src/db/models/there.ts
async function insertThereUser(subscriber) {
  return db.insert(thereUsers).values(subscriber).returning();
}

// src/controllers/extra/there.ts
var there2 = new Q0({ prefix: "/api/there" }).use(setup).post("/signup", async ({ body }) => {
  await insertThereUser(body);
  return {
    ok: true
  };
}, {
  body: V.Object({
    email: V.String(),
    name: V.Optional(V.String()),
    timeZone: V.Optional(V.String())
  })
});

// ../node_modules/pathe/dist/shared/pathe.ff20891b.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath2(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize4 = function(path3) {
  if (path3.length === 0) {
    return ".";
  }
  path3 = normalizeWindowsPath2(path3);
  const isUNCPath = path3.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute3(path3);
  const trailingSeparator = path3[path3.length - 1] === "/";
  path3 = normalizeString(path3, !isPathAbsolute);
  if (path3.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path3 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path3)) {
    path3 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path3}`;
    }
    return `//${path3}`;
  }
  return isPathAbsolute && !isAbsolute3(path3) ? `/${path3}` : path3;
};
function normalizeString(path3, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char2 = null;
  for (let index2 = 0;index2 <= path3.length; ++index2) {
    if (index2 < path3.length) {
      char2 = path3[index2];
    } else if (char2 === "/") {
      break;
    } else {
      char2 = "/";
    }
    if (char2 === "/") {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index2;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path3.slice(lastSlash + 1, index2)}`;
        } else {
          res = path3.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (char2 === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute3 = function(p4) {
  return _IS_ABSOLUTE_RE.test(p4);
};
// ../node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema3) {
  return "type" in schema3 || "properties" in schema3 || "items" in schema3;
}
function isDateTimeProperty(key, schema3) {
  return (key === "createdAt" || key === "updatedAt") && "anyOf" in schema3 && Array.isArray(schema3.anyOf);
}
function transformDateProperties(schema3) {
  if (!isSchemaObject(schema3) || typeof schema3 !== "object" || schema3 === null) {
    return schema3;
  }
  const newSchema = { ...schema3 };
  Object.entries(newSchema).forEach(([key, value2]) => {
    if (isSchemaObject(value2)) {
      if (isDateTimeProperty(key, value2)) {
        const dateTimeFormat = value2.anyOf?.find((item) => isSchemaObject(item) && item.format === "date-time");
        if (dateTimeFormat) {
          const dateTimeSchema = {
            type: "string",
            format: "date-time",
            default: dateTimeFormat.default
          };
          newSchema[key] = dateTimeSchema;
        }
      } else {
        newSchema[key] = transformDateProperties(value2);
      }
    }
  });
  return newSchema;
}
var SwaggerUIRender = (info, version3, theme, stringifiedSwaggerOptions, autoDarkMode) => {
  const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
  if (swaggerOptions.components && swaggerOptions.components.schemas) {
    swaggerOptions.components.schemas = Object.fromEntries(Object.entries(swaggerOptions.components.schemas).map(([key, schema3]) => [
      key,
      transformDateProperties(schema3)
    ]));
  }
  const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;
var ScalarRender = (info, version3, config2, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config2.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config2.spec?.url}"
      data-configuration='${JSON.stringify(config2)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version3}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}\$`;
var PatternNumberExact2 = `^${PatternNumber2}\$`;
var PatternStringExact2 = `^${PatternString2}\$`;
var ExtendsResult2;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
var toOpenAPIPath = (path4) => path4.split("/").map((x4) => {
  if (x4.startsWith(":")) {
    x4 = x4.slice(1, x4.length);
    if (x4.endsWith("?"))
      x4 = x4.slice(0, -1);
    x4 = `{${x4}}`;
  }
  return x4;
}).join("/");
var mapProperties = (name, schema3, models) => {
  if (schema3 === undefined)
    return [];
  if (typeof schema3 === "string")
    if (schema3 in models)
      schema3 = models[schema3];
    else
      throw new Error(`Can't find model ${schema3}`);
  return Object.entries(schema3?.properties ?? []).map(([key, value2]) => {
    const {
      type: valueType = undefined,
      description,
      examples,
      ...schemaKeywords
    } = value2;
    return {
      description,
      examples,
      schema: { type: valueType, ...schemaKeywords },
      in: name,
      name: key,
      required: schema3.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types2, schema3) => {
  if (typeof schema3 === "object" && ["void", "undefined", "null"].includes(schema3.type))
    return;
  const responses = {};
  for (const type3 of types2) {
    responses[type3] = {
      schema: typeof schema3 === "string" ? {
        $ref: `#/components/schemas/${schema3}`
      } : { ...schema3 }
    };
  }
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path4 of paths.split("/")) {
    if (path4.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path4.slice(1, -1));
    } else {
      operationId += capitalize2(path4);
    }
  }
  return operationId;
};
var cloneHook = (hook) => {
  if (!hook)
    return;
  return { ...hook };
};
var registerSchemaPath = ({
  schema: schema3,
  path: path4,
  method,
  hook,
  models
}) => {
  hook = cloneHook(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path4 = toOpenAPIPath(path4);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = cloneHook(hook?.body);
  const paramsSchema = cloneHook(hook?.params);
  const headerSchema = cloneHook(hook?.headers);
  const querySchema = cloneHook(hook?.query);
  let responseSchema = cloneHook(hook?.response);
  if (typeof responseSchema === "object") {
    if (Kind2 in responseSchema) {
      const {
        type: type3,
        properties,
        required: required3,
        additionalProperties,
        patternProperties,
        ...rest3
      } = responseSchema;
      responseSchema = {
        "200": {
          ...rest3,
          description: rest3.description,
          content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
            type: type3,
            properties,
            patternProperties,
            items: responseSchema.items,
            required: required3
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value2]) => {
        if (typeof value2 === "string") {
          if (!models[value2])
            return;
          const {
            type: type3,
            properties,
            required: required3,
            additionalProperties: _12,
            patternProperties: _22,
            ...rest3
          } = models[value2];
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, value2)
          };
        } else {
          const {
            type: type3,
            properties,
            required: required3,
            additionalProperties,
            patternProperties,
            ...rest3
          } = value2;
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
              type: type3,
              properties,
              patternProperties,
              items: value2.items,
              required: required3
            } : value2)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const {
      type: type3,
      properties,
      required: required3,
      additionalProperties: _12,
      patternProperties: _22,
      ...rest3
    } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest3,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters3 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema3[path4] = {
    ...schema3[path4] ? schema3[path4] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters3 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path4),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          required: true,
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, docsPath, {
  excludeStaticFile = true,
  exclude: exclude3 = []
}) => {
  const newPaths = {};
  const excludePaths = [`/${docsPath}`, `/${docsPath}/json`].map((p4) => normalize4(p4));
  for (const [key, value2] of Object.entries(paths))
    if (!exclude3.some((x4) => {
      if (typeof x4 === "string")
        return key === x4;
      return x4.test(key);
    }) && !excludePaths.includes(key) && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value2).forEach((method) => {
        const schema3 = value2[method];
        if (key.includes("{")) {
          if (!schema3.parameters)
            schema3.parameters = [];
          schema3.parameters = [
            ...key.split("/").filter((x4) => x4.startsWith("{") && !schema3.parameters.find((params) => params.in === "path" && params.name === x4.slice(1, x4.length - 1))).map((x4) => ({
              schema: { type: "string" },
              in: "path",
              name: x4.slice(1, x4.length - 1),
              required: true
            })),
            ...schema3.parameters
          ];
        }
        if (!schema3.responses)
          schema3.responses = {
            200: {}
          };
      });
      newPaths[key] = value2;
    }
  return newPaths;
};
var swagger = async ({
  provider = "scalar",
  scalarVersion = "latest",
  scalarCDN = "",
  scalarConfig = {},
  documentation = {},
  version: version3 = "5.9.0",
  excludeStaticFile = true,
  path: path4 = "/swagger",
  exclude: exclude3 = [],
  swaggerOptions = {},
  theme = `https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui.css`,
  autoDarkMode = true,
  excludeMethods = ["OPTIONS"],
  excludeTags = []
} = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"],
  excludeTags: []
}) => {
  const schema3 = {};
  let totalRoutes = 0;
  if (!version3)
    version3 = `https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path4.startsWith("/") ? path4.slice(1) : path4;
  const app = new Q0({ name: "@elysiajs/swagger" });
  app.get(path4, function documentation2() {
    const combinedSwaggerOptions = {
      url: `/${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value2) => {
      if (typeof value2 == "function")
        return;
      return value2;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `/${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version3, theme, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(info, scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  }).get(path4 === "/" ? "/json" : `${path4}/json`, function openAPISchema() {
    const routes = app.getGlobalRoutes();
    if (routes.length !== totalRoutes) {
      const ALLOWED_METHODS = ["GET", "PUT", "POST", "DELETE", "OPTIONS", "HEAD", "PATCH", "TRACE"];
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (route.hooks?.detail?.hide === true)
          return;
        if (excludeMethods.includes(route.method))
          return;
        if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL")
          return;
        if (route.method === "ALL") {
          ALLOWED_METHODS.forEach((method) => {
            registerSchemaPath({
              schema: schema3,
              hook: route.hooks,
              method,
              path: route.path,
              models: app.definitions?.type,
              contentType: route.hooks.type
            });
          });
          return;
        }
        registerSchemaPath({
          schema: schema3,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: {
        ...filterPaths(schema3, relativePath, {
          excludeStaticFile,
          exclude: Array.isArray(exclude3) ? exclude3 : [exclude3]
        }),
        ...documentation.paths
      },
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};
var src_default3 = swagger;

// src/utils/auth.ts
import crypto4 from "crypto";

// ../node_modules/nanoid/index.js
import { webcrypto as crypto3 } from "crypto";

// ../node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto3.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto3.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function random(bytes) {
  fillPool(bytes -= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
}
function customRandom(alphabet, defaultSize, getRandom) {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size2 = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i3 = step;
      while (i3--) {
        id += alphabet[bytes[i3] & mask] || "";
        if (id.length === size2)
          return id;
      }
    }
  };
}
function customAlphabet(alphabet, size2 = 21) {
  return customRandom(alphabet, size2, random);
}
function nanoid(size2 = 21) {
  fillPool(size2 -= 0);
  let id = "";
  for (let i3 = poolOffset - size2;i3 < poolOffset; i3++) {
    id += urlAlphabet[pool[i3] & 63];
  }
  return id;
}

// src/utils/auth.ts
var import_nanoid_dictionary = __toESM(require_nanoid_dictionary(), 1);
var MAX_LOGIN_ATTEMPTS = 5;
var USER_TOKEN_PREFIX = "IN";
var USER_TOKEN_LENGTH = 32;
function secureRandomSixDigitNumber() {
  return crypto4.randomInt(1e5, 1e6);
}
var nanoid2 = customAlphabet(import_nanoid_dictionary.alphanumeric, USER_TOKEN_LENGTH);
async function generateToken(userId) {
  const randomPart = nanoid2();
  const token = `${userId}:${USER_TOKEN_PREFIX}${randomPart}`;
  const tokenHash = hashToken(token);
  return { token, tokenHash };
}
function hashToken(token) {
  const hasher = new Bun.CryptoHasher("sha256");
  hasher.update(token);
  return hasher.digest("base64");
}

// src/controllers/plugins.ts
var authenticate = new Q0({ name: "authenticate" }).state("currentUserId", 0).guard({
  as: "scoped",
  headers: V.Object({
    authorization: V.Optional(V.TemplateLiteral("Bearer ${string}"))
  }),
  beforeHandle: async ({ headers, store }) => {
    let auth = headers["authorization"];
    let token = normalizeToken(auth);
    if (!token) {
      throw new InlineError(403 /* UNAUTHORIZED */, "Unauthorized");
    }
    store.currentUserId = await getUserIdFromToken(token);
  }
});
var authenticateGet = new Q0({ name: "authenticate" }).state("currentUserId", 0).guard({
  as: "scoped",
  params: V.Object({
    token: V.Optional(V.String())
  }),
  beforeHandle: async ({ headers, params, store }) => {
    let auth = params.token ?? headers["authorization"];
    let token = normalizeToken(auth);
    if (!token) {
      throw new InlineError(403 /* UNAUTHORIZED */, "Unauthorized");
    }
    store.currentUserId = await getUserIdFromToken(token);
  }
});
var normalizeToken = (token) => {
  if (typeof token !== "string") {
    return null;
  }
  return token.replace("Bearer ", "").trim();
};
var getUserIdFromToken = async (token) => {
  let supposedUserId = token.split(":")[0];
  let tokenHash = hashToken(token);
  let session = await db.query.sessions.findFirst({
    where: and(eq(sessions.tokenHash, tokenHash), isNull(sessions.revoked))
  });
  if (!session) {
    throw new InlineError(403 /* UNAUTHORIZED */, "Unauthorized");
  }
  if (session.userId !== parseInt(supposedUserId, 10)) {
    console.error("userId mismatch", session.userId, supposedUserId);
    throw new InlineError(403 /* UNAUTHORIZED */, "Unauthorized");
  }
  return session.userId;
};

// src/controllers/v1/helpers.ts
var TMakeApiResponse = (type3) => {
  const success = V.Object({ ok: V.Literal(true), result: type3 });
  const failure = V.Object({
    ok: V.Literal(false),
    errorCode: V.Optional(V.Number()),
    description: V.Optional(V.String())
  });
  return V.Union([success, failure]);
};
var handleError = new Q0().error("INLINE_ERROR", InlineError).onError({ as: "scoped" }, ({ code, error: error3 }) => {
  if (code === "NOT_FOUND")
    return {
      ok: false,
      errorCode: 404,
      description: "Method not found"
    };
  if (error3 instanceof InlineError) {
    return {
      ok: false,
      errorCode: error3.code,
      description: error3.message
    };
  } else if (code === "VALIDATION") {
    return {
      ok: false,
      errorCode: 400 /* INAVLID_ARGS */,
      description: "Validation error"
    };
  } else {
    Log.shared.error("Top level error, " + code, error3);
    return {
      ok: false,
      errorCode: 500 /* SERVER_ERROR */,
      description: "Server error"
    };
  }
});
var makeApiRoute = (path4, inputType, outputType, method) => {
  const response = TMakeApiResponse(outputType);
  const getRoute = new Q0({ tags: ["GET"] }).use(authenticateGet).get(`/:token?${path4}`, async ({ query: input, store, server, request }) => {
    const ip = request.headers.get("x-forwarded-for") ?? request.headers.get("cf-connecting-ip") ?? request.headers.get("x-real-ip") ?? server?.requestIP(request)?.address;
    const context8 = { currentUserId: store.currentUserId, ip };
    let result = await method(input, context8);
    return { ok: true, result };
  }, {
    query: inputType,
    response
  });
  const postRoute = new Q0({ tags: ["POST"] }).use(authenticate).post(path4, async ({ body: input, store, server, request }) => {
    const ip = request.headers.get("x-forwarded-for") ?? request.headers.get("cf-connecting-ip") ?? request.headers.get("x-real-ip") ?? server?.requestIP(request)?.address;
    const context8 = { currentUserId: store.currentUserId, ip };
    let result = await method(input, context8);
    return { ok: true, result };
  }, {
    body: inputType,
    response
  });
  return new Q0().use(getRoute).use(postRoute);
};
var makeUnauthApiRoute = (path4, inputType, outputType, method) => {
  const response = TMakeApiResponse(outputType);
  const getRoute = new Q0({ tags: ["GET"] }).get(`${path4}`, async ({ query: input, server, request }) => {
    const ip = request.headers.get("x-forwarded-for") ?? request.headers.get("cf-connecting-ip") ?? request.headers.get("x-real-ip") ?? server?.requestIP(request)?.address;
    const context8 = { ip };
    let result = await method(input, context8);
    return { ok: true, result };
  }, {
    query: inputType,
    response
  });
  const postRoute = new Q0({ tags: ["POST"] }).post(path4, async ({ body: input, server, request }) => {
    const ip = request.headers.get("x-forwarded-for") ?? request.headers.get("cf-connecting-ip") ?? request.headers.get("x-real-ip") ?? server?.requestIP(request)?.address;
    const context8 = { ip };
    let result = await method(input, context8);
    return { ok: true, result };
  }, {
    body: inputType,
    response
  });
  return new Q0().use(getRoute).use(postRoute);
};

// src/utils/validate.ts
var isValidEmail = (email) => {
  if (!email) {
    return false;
  }
  if (!/^\S+@\S+\.\S+$/.test(email)) {
    return false;
  }
  return true;
};
var isValidPhoneNumber = (phoneNumber) => {
  if (!phoneNumber) {
    return false;
  }
  if (!/^\+[1-9]\d{1,14}$/.test(phoneNumber)) {
    return false;
  }
  return true;
};
var validateUpToFourSegementSemver = (version3) => {
  if (!/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,3}$/.test(version3)) {
    return false;
  }
  return true;
};
var validateIanaTimezone = (timezone) => {
  if (!timezone) {
    return false;
  }
  if (timezone.length > 64) {
    return false;
  }
  if (timezone === "UTC" || timezone === "GMT") {
    return true;
  }
  const validRegex = /^(Africa|America|Antarctica|Asia|Atlantic|Australia|Europe|Indian|Pacific)\/([A-Za-z_]+)(\/[A-Za-z_]+)?$/;
  const etcRegex = /^Etc\/(GMT[+-]\d{1,2}|UTC|UCT|Greenwich|Universal|Zulu)$/;
  return validRegex.test(timezone) || etcRegex.test(timezone);
};

// src/utils/normalize.ts
var normalizeEmail = (email) => {
  return email.trim().toLowerCase();
};

// ../node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value3 = {};
__export(exports_value3, {
  IsUndefined: () => IsUndefined5,
  IsUint8Array: () => IsUint8Array5,
  IsSymbol: () => IsSymbol5,
  IsString: () => IsString5,
  IsRegExp: () => IsRegExp4,
  IsObject: () => IsObject5,
  IsNumber: () => IsNumber5,
  IsNull: () => IsNull5,
  IsIterator: () => IsIterator5,
  IsFunction: () => IsFunction5,
  IsDate: () => IsDate5,
  IsBoolean: () => IsBoolean5,
  IsBigInt: () => IsBigInt5,
  IsAsyncIterator: () => IsAsyncIterator5,
  IsArray: () => IsArray5
});
function IsAsyncIterator5(value2) {
  return IsObject5(value2) && !IsArray5(value2) && !IsUint8Array5(value2) && Symbol.asyncIterator in value2;
}
function IsArray5(value2) {
  return Array.isArray(value2);
}
function IsBigInt5(value2) {
  return typeof value2 === "bigint";
}
function IsBoolean5(value2) {
  return typeof value2 === "boolean";
}
function IsDate5(value2) {
  return value2 instanceof globalThis.Date;
}
function IsFunction5(value2) {
  return typeof value2 === "function";
}
function IsIterator5(value2) {
  return IsObject5(value2) && !IsArray5(value2) && !IsUint8Array5(value2) && Symbol.iterator in value2;
}
function IsNull5(value2) {
  return value2 === null;
}
function IsNumber5(value2) {
  return typeof value2 === "number";
}
function IsObject5(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function IsRegExp4(value2) {
  return value2 instanceof globalThis.RegExp;
}
function IsString5(value2) {
  return typeof value2 === "string";
}
function IsSymbol5(value2) {
  return typeof value2 === "symbol";
}
function IsUint8Array5(value2) {
  return value2 instanceof globalThis.Uint8Array;
}
function IsUndefined5(value2) {
  return value2 === undefined;
}

// ../node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType7(value2) {
  return value2.map((value3) => Visit17(value3));
}
function DateType5(value2) {
  return new Date(value2.getTime());
}
function Uint8ArrayType3(value2) {
  return new Uint8Array(value2);
}
function RegExpType2(value2) {
  return new RegExp(value2.source, value2.flags);
}
function ObjectType7(value2) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value2)) {
    result[key] = Visit17(value2[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value2)) {
    result[key] = Visit17(value2[key]);
  }
  return result;
}
function Visit17(value2) {
  return IsArray5(value2) ? ArrayType7(value2) : IsDate5(value2) ? DateType5(value2) : IsUint8Array5(value2) ? Uint8ArrayType3(value2) : IsRegExp4(value2) ? RegExpType2(value2) : IsObject5(value2) ? ObjectType7(value2) : value2;
}
function Clone4(value2) {
  return Visit17(value2);
}

// ../node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest2(schemas) {
  return schemas.map((schema3) => CloneType2(schema3));
}
function CloneType2(schema3, options = {}) {
  return { ...Clone4(schema3), ...options };
}
// ../node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError2 extends Error {
  constructor(message) {
    super(message);
  }
}
// ../node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind3 = Symbol.for("TypeBox.Transform");
var ReadonlyKind3 = Symbol.for("TypeBox.Readonly");
var OptionalKind3 = Symbol.for("TypeBox.Optional");
var Hint3 = Symbol.for("TypeBox.Hint");
var Kind3 = Symbol.for("TypeBox.Kind");
// ../node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly3(value3) {
  return IsObject5(value3) && value3[ReadonlyKind3] === "Readonly";
}
function IsOptional3(value3) {
  return IsObject5(value3) && value3[OptionalKind3] === "Optional";
}
function IsAny3(value3) {
  return IsKindOf3(value3, "Any");
}
function IsArray6(value3) {
  return IsKindOf3(value3, "Array");
}
function IsAsyncIterator6(value3) {
  return IsKindOf3(value3, "AsyncIterator");
}
function IsBigInt6(value3) {
  return IsKindOf3(value3, "BigInt");
}
function IsBoolean6(value3) {
  return IsKindOf3(value3, "Boolean");
}
function IsConstructor3(value3) {
  return IsKindOf3(value3, "Constructor");
}
function IsDate6(value3) {
  return IsKindOf3(value3, "Date");
}
function IsFunction6(value3) {
  return IsKindOf3(value3, "Function");
}
function IsInteger4(value3) {
  return IsKindOf3(value3, "Integer");
}
function IsIntersect3(value3) {
  return IsKindOf3(value3, "Intersect");
}
function IsIterator6(value3) {
  return IsKindOf3(value3, "Iterator");
}
function IsKindOf3(value3, kind) {
  return IsObject5(value3) && Kind3 in value3 && value3[Kind3] === kind;
}
function IsLiteral3(value3) {
  return IsKindOf3(value3, "Literal");
}
function IsMappedKey3(value3) {
  return IsKindOf3(value3, "MappedKey");
}
function IsMappedResult3(value3) {
  return IsKindOf3(value3, "MappedResult");
}
function IsNever3(value3) {
  return IsKindOf3(value3, "Never");
}
function IsNot3(value3) {
  return IsKindOf3(value3, "Not");
}
function IsNull6(value3) {
  return IsKindOf3(value3, "Null");
}
function IsNumber6(value3) {
  return IsKindOf3(value3, "Number");
}
function IsObject6(value3) {
  return IsKindOf3(value3, "Object");
}
function IsPromise4(value3) {
  return IsKindOf3(value3, "Promise");
}
function IsRecord3(value3) {
  return IsKindOf3(value3, "Record");
}
function IsRef3(value3) {
  return IsKindOf3(value3, "Ref");
}
function IsRegExp5(value3) {
  return IsKindOf3(value3, "RegExp");
}
function IsString6(value3) {
  return IsKindOf3(value3, "String");
}
function IsSymbol6(value3) {
  return IsKindOf3(value3, "Symbol");
}
function IsTemplateLiteral3(value3) {
  return IsKindOf3(value3, "TemplateLiteral");
}
function IsThis3(value3) {
  return IsKindOf3(value3, "This");
}
function IsTransform3(value3) {
  return IsObject5(value3) && TransformKind3 in value3;
}
function IsTuple3(value3) {
  return IsKindOf3(value3, "Tuple");
}
function IsUndefined6(value3) {
  return IsKindOf3(value3, "Undefined");
}
function IsUnion3(value3) {
  return IsKindOf3(value3, "Union");
}
function IsUint8Array6(value3) {
  return IsKindOf3(value3, "Uint8Array");
}
function IsUnknown3(value3) {
  return IsKindOf3(value3, "Unknown");
}
function IsUnsafe3(value3) {
  return IsKindOf3(value3, "Unsafe");
}
function IsVoid3(value3) {
  return IsKindOf3(value3, "Void");
}
function IsKind3(value3) {
  return IsObject5(value3) && Kind3 in value3 && IsString5(value3[Kind3]);
}
function IsSchema3(value3) {
  return IsAny3(value3) || IsArray6(value3) || IsBoolean6(value3) || IsBigInt6(value3) || IsAsyncIterator6(value3) || IsConstructor3(value3) || IsDate6(value3) || IsFunction6(value3) || IsInteger4(value3) || IsIntersect3(value3) || IsIterator6(value3) || IsLiteral3(value3) || IsMappedKey3(value3) || IsMappedResult3(value3) || IsNever3(value3) || IsNot3(value3) || IsNull6(value3) || IsNumber6(value3) || IsObject6(value3) || IsPromise4(value3) || IsRecord3(value3) || IsRef3(value3) || IsRegExp5(value3) || IsString6(value3) || IsSymbol6(value3) || IsTemplateLiteral3(value3) || IsThis3(value3) || IsTuple3(value3) || IsUndefined6(value3) || IsUnion3(value3) || IsUint8Array6(value3) || IsUnknown3(value3) || IsUnsafe3(value3) || IsVoid3(value3) || IsKind3(value3);
}
// ../node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type4 = {};
__export(exports_type4, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError2,
  IsVoid: () => IsVoid4,
  IsUnsafe: () => IsUnsafe4,
  IsUnknown: () => IsUnknown4,
  IsUnionLiteral: () => IsUnionLiteral2,
  IsUnion: () => IsUnion4,
  IsUndefined: () => IsUndefined7,
  IsUint8Array: () => IsUint8Array7,
  IsTuple: () => IsTuple4,
  IsTransform: () => IsTransform4,
  IsThis: () => IsThis4,
  IsTemplateLiteral: () => IsTemplateLiteral4,
  IsSymbol: () => IsSymbol7,
  IsString: () => IsString7,
  IsSchema: () => IsSchema4,
  IsRegExp: () => IsRegExp6,
  IsRef: () => IsRef4,
  IsRecursive: () => IsRecursive2,
  IsRecord: () => IsRecord4,
  IsReadonly: () => IsReadonly4,
  IsProperties: () => IsProperties2,
  IsPromise: () => IsPromise5,
  IsOptional: () => IsOptional4,
  IsObject: () => IsObject7,
  IsNumber: () => IsNumber7,
  IsNull: () => IsNull7,
  IsNot: () => IsNot4,
  IsNever: () => IsNever4,
  IsMappedResult: () => IsMappedResult4,
  IsMappedKey: () => IsMappedKey4,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString2,
  IsLiteralNumber: () => IsLiteralNumber2,
  IsLiteralBoolean: () => IsLiteralBoolean2,
  IsLiteral: () => IsLiteral4,
  IsKindOf: () => IsKindOf4,
  IsKind: () => IsKind4,
  IsIterator: () => IsIterator7,
  IsIntersect: () => IsIntersect4,
  IsInteger: () => IsInteger5,
  IsFunction: () => IsFunction7,
  IsDate: () => IsDate7,
  IsConstructor: () => IsConstructor4,
  IsBoolean: () => IsBoolean7,
  IsBigInt: () => IsBigInt7,
  IsAsyncIterator: () => IsAsyncIterator7,
  IsArray: () => IsArray7,
  IsAny: () => IsAny4
});
class TypeGuardUnknownTypeError2 extends TypeBoxError2 {
}
var KnownTypes2 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern2(value3) {
  try {
    new RegExp(value3);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree2(value3) {
  if (!IsString5(value3))
    return false;
  for (let i3 = 0;i3 < value3.length; i3++) {
    const code = value3.charCodeAt(i3);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties2(value3) {
  return IsOptionalBoolean2(value3) || IsSchema4(value3);
}
function IsOptionalBigInt2(value3) {
  return IsUndefined5(value3) || IsBigInt5(value3);
}
function IsOptionalNumber2(value3) {
  return IsUndefined5(value3) || IsNumber5(value3);
}
function IsOptionalBoolean2(value3) {
  return IsUndefined5(value3) || IsBoolean5(value3);
}
function IsOptionalString2(value3) {
  return IsUndefined5(value3) || IsString5(value3);
}
function IsOptionalPattern2(value3) {
  return IsUndefined5(value3) || IsString5(value3) && IsControlCharacterFree2(value3) && IsPattern2(value3);
}
function IsOptionalFormat2(value3) {
  return IsUndefined5(value3) || IsString5(value3) && IsControlCharacterFree2(value3);
}
function IsOptionalSchema2(value3) {
  return IsUndefined5(value3) || IsSchema4(value3);
}
function IsReadonly4(value3) {
  return IsObject5(value3) && value3[ReadonlyKind3] === "Readonly";
}
function IsOptional4(value3) {
  return IsObject5(value3) && value3[OptionalKind3] === "Optional";
}
function IsAny4(value3) {
  return IsKindOf4(value3, "Any") && IsOptionalString2(value3.$id);
}
function IsArray7(value3) {
  return IsKindOf4(value3, "Array") && value3.type === "array" && IsOptionalString2(value3.$id) && IsSchema4(value3.items) && IsOptionalNumber2(value3.minItems) && IsOptionalNumber2(value3.maxItems) && IsOptionalBoolean2(value3.uniqueItems) && IsOptionalSchema2(value3.contains) && IsOptionalNumber2(value3.minContains) && IsOptionalNumber2(value3.maxContains);
}
function IsAsyncIterator7(value3) {
  return IsKindOf4(value3, "AsyncIterator") && value3.type === "AsyncIterator" && IsOptionalString2(value3.$id) && IsSchema4(value3.items);
}
function IsBigInt7(value3) {
  return IsKindOf4(value3, "BigInt") && value3.type === "bigint" && IsOptionalString2(value3.$id) && IsOptionalBigInt2(value3.exclusiveMaximum) && IsOptionalBigInt2(value3.exclusiveMinimum) && IsOptionalBigInt2(value3.maximum) && IsOptionalBigInt2(value3.minimum) && IsOptionalBigInt2(value3.multipleOf);
}
function IsBoolean7(value3) {
  return IsKindOf4(value3, "Boolean") && value3.type === "boolean" && IsOptionalString2(value3.$id);
}
function IsConstructor4(value3) {
  return IsKindOf4(value3, "Constructor") && value3.type === "Constructor" && IsOptionalString2(value3.$id) && IsArray5(value3.parameters) && value3.parameters.every((schema3) => IsSchema4(schema3)) && IsSchema4(value3.returns);
}
function IsDate7(value3) {
  return IsKindOf4(value3, "Date") && value3.type === "Date" && IsOptionalString2(value3.$id) && IsOptionalNumber2(value3.exclusiveMaximumTimestamp) && IsOptionalNumber2(value3.exclusiveMinimumTimestamp) && IsOptionalNumber2(value3.maximumTimestamp) && IsOptionalNumber2(value3.minimumTimestamp) && IsOptionalNumber2(value3.multipleOfTimestamp);
}
function IsFunction7(value3) {
  return IsKindOf4(value3, "Function") && value3.type === "Function" && IsOptionalString2(value3.$id) && IsArray5(value3.parameters) && value3.parameters.every((schema3) => IsSchema4(schema3)) && IsSchema4(value3.returns);
}
function IsInteger5(value3) {
  return IsKindOf4(value3, "Integer") && value3.type === "integer" && IsOptionalString2(value3.$id) && IsOptionalNumber2(value3.exclusiveMaximum) && IsOptionalNumber2(value3.exclusiveMinimum) && IsOptionalNumber2(value3.maximum) && IsOptionalNumber2(value3.minimum) && IsOptionalNumber2(value3.multipleOf);
}
function IsProperties2(value3) {
  return IsObject5(value3) && Object.entries(value3).every(([key, schema3]) => IsControlCharacterFree2(key) && IsSchema4(schema3));
}
function IsIntersect4(value3) {
  return IsKindOf4(value3, "Intersect") && (IsString5(value3.type) && value3.type !== "object" ? false : true) && IsArray5(value3.allOf) && value3.allOf.every((schema3) => IsSchema4(schema3) && !IsTransform4(schema3)) && IsOptionalString2(value3.type) && (IsOptionalBoolean2(value3.unevaluatedProperties) || IsOptionalSchema2(value3.unevaluatedProperties)) && IsOptionalString2(value3.$id);
}
function IsIterator7(value3) {
  return IsKindOf4(value3, "Iterator") && value3.type === "Iterator" && IsOptionalString2(value3.$id) && IsSchema4(value3.items);
}
function IsKindOf4(value3, kind) {
  return IsObject5(value3) && Kind3 in value3 && value3[Kind3] === kind;
}
function IsLiteralString2(value3) {
  return IsLiteral4(value3) && IsString5(value3.const);
}
function IsLiteralNumber2(value3) {
  return IsLiteral4(value3) && IsNumber5(value3.const);
}
function IsLiteralBoolean2(value3) {
  return IsLiteral4(value3) && IsBoolean5(value3.const);
}
function IsLiteral4(value3) {
  return IsKindOf4(value3, "Literal") && IsOptionalString2(value3.$id) && IsLiteralValue2(value3.const);
}
function IsLiteralValue2(value3) {
  return IsBoolean5(value3) || IsNumber5(value3) || IsString5(value3);
}
function IsMappedKey4(value3) {
  return IsKindOf4(value3, "MappedKey") && IsArray5(value3.keys) && value3.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult4(value3) {
  return IsKindOf4(value3, "MappedResult") && IsProperties2(value3.properties);
}
function IsNever4(value3) {
  return IsKindOf4(value3, "Never") && IsObject5(value3.not) && Object.getOwnPropertyNames(value3.not).length === 0;
}
function IsNot4(value3) {
  return IsKindOf4(value3, "Not") && IsSchema4(value3.not);
}
function IsNull7(value3) {
  return IsKindOf4(value3, "Null") && value3.type === "null" && IsOptionalString2(value3.$id);
}
function IsNumber7(value3) {
  return IsKindOf4(value3, "Number") && value3.type === "number" && IsOptionalString2(value3.$id) && IsOptionalNumber2(value3.exclusiveMaximum) && IsOptionalNumber2(value3.exclusiveMinimum) && IsOptionalNumber2(value3.maximum) && IsOptionalNumber2(value3.minimum) && IsOptionalNumber2(value3.multipleOf);
}
function IsObject7(value3) {
  return IsKindOf4(value3, "Object") && value3.type === "object" && IsOptionalString2(value3.$id) && IsProperties2(value3.properties) && IsAdditionalProperties2(value3.additionalProperties) && IsOptionalNumber2(value3.minProperties) && IsOptionalNumber2(value3.maxProperties);
}
function IsPromise5(value3) {
  return IsKindOf4(value3, "Promise") && value3.type === "Promise" && IsOptionalString2(value3.$id) && IsSchema4(value3.item);
}
function IsRecord4(value3) {
  return IsKindOf4(value3, "Record") && value3.type === "object" && IsOptionalString2(value3.$id) && IsAdditionalProperties2(value3.additionalProperties) && IsObject5(value3.patternProperties) && ((schema3) => {
    const keys = Object.getOwnPropertyNames(schema3.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema3.patternProperties) && IsSchema4(schema3.patternProperties[keys[0]]);
  })(value3);
}
function IsRecursive2(value3) {
  return IsObject5(value3) && Hint3 in value3 && value3[Hint3] === "Recursive";
}
function IsRef4(value3) {
  return IsKindOf4(value3, "Ref") && IsOptionalString2(value3.$id) && IsString5(value3.$ref);
}
function IsRegExp6(value3) {
  return IsKindOf4(value3, "RegExp") && IsOptionalString2(value3.$id) && IsString5(value3.source) && IsString5(value3.flags) && IsOptionalNumber2(value3.maxLength) && IsOptionalNumber2(value3.minLength);
}
function IsString7(value3) {
  return IsKindOf4(value3, "String") && value3.type === "string" && IsOptionalString2(value3.$id) && IsOptionalNumber2(value3.minLength) && IsOptionalNumber2(value3.maxLength) && IsOptionalPattern2(value3.pattern) && IsOptionalFormat2(value3.format);
}
function IsSymbol7(value3) {
  return IsKindOf4(value3, "Symbol") && value3.type === "symbol" && IsOptionalString2(value3.$id);
}
function IsTemplateLiteral4(value3) {
  return IsKindOf4(value3, "TemplateLiteral") && value3.type === "string" && IsString5(value3.pattern) && value3.pattern[0] === "^" && value3.pattern[value3.pattern.length - 1] === "$";
}
function IsThis4(value3) {
  return IsKindOf4(value3, "This") && IsOptionalString2(value3.$id) && IsString5(value3.$ref);
}
function IsTransform4(value3) {
  return IsObject5(value3) && TransformKind3 in value3;
}
function IsTuple4(value3) {
  return IsKindOf4(value3, "Tuple") && value3.type === "array" && IsOptionalString2(value3.$id) && IsNumber5(value3.minItems) && IsNumber5(value3.maxItems) && value3.minItems === value3.maxItems && (IsUndefined5(value3.items) && IsUndefined5(value3.additionalItems) && value3.minItems === 0 || IsArray5(value3.items) && value3.items.every((schema3) => IsSchema4(schema3)));
}
function IsUndefined7(value3) {
  return IsKindOf4(value3, "Undefined") && value3.type === "undefined" && IsOptionalString2(value3.$id);
}
function IsUnionLiteral2(value3) {
  return IsUnion4(value3) && value3.anyOf.every((schema3) => IsLiteralString2(schema3) || IsLiteralNumber2(schema3));
}
function IsUnion4(value3) {
  return IsKindOf4(value3, "Union") && IsOptionalString2(value3.$id) && IsObject5(value3) && IsArray5(value3.anyOf) && value3.anyOf.every((schema3) => IsSchema4(schema3));
}
function IsUint8Array7(value3) {
  return IsKindOf4(value3, "Uint8Array") && value3.type === "Uint8Array" && IsOptionalString2(value3.$id) && IsOptionalNumber2(value3.minByteLength) && IsOptionalNumber2(value3.maxByteLength);
}
function IsUnknown4(value3) {
  return IsKindOf4(value3, "Unknown") && IsOptionalString2(value3.$id);
}
function IsUnsafe4(value3) {
  return IsKindOf4(value3, "Unsafe");
}
function IsVoid4(value3) {
  return IsKindOf4(value3, "Void") && value3.type === "void" && IsOptionalString2(value3.$id);
}
function IsKind4(value3) {
  return IsObject5(value3) && Kind3 in value3 && IsString5(value3[Kind3]) && !KnownTypes2.includes(value3[Kind3]);
}
function IsSchema4(value3) {
  return IsObject5(value3) && (IsAny4(value3) || IsArray7(value3) || IsBoolean7(value3) || IsBigInt7(value3) || IsAsyncIterator7(value3) || IsConstructor4(value3) || IsDate7(value3) || IsFunction7(value3) || IsInteger5(value3) || IsIntersect4(value3) || IsIterator7(value3) || IsLiteral4(value3) || IsMappedKey4(value3) || IsMappedResult4(value3) || IsNever4(value3) || IsNot4(value3) || IsNull7(value3) || IsNumber7(value3) || IsObject7(value3) || IsPromise5(value3) || IsRecord4(value3) || IsRef4(value3) || IsRegExp6(value3) || IsString7(value3) || IsSymbol7(value3) || IsTemplateLiteral4(value3) || IsThis4(value3) || IsTuple4(value3) || IsUndefined7(value3) || IsUnion4(value3) || IsUint8Array7(value3) || IsUnknown4(value3) || IsUnsafe4(value3) || IsVoid4(value3) || IsKind4(value3));
}
// ../node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean3 = "(true|false)";
var PatternNumber3 = "(0|[1-9][0-9]*)";
var PatternString3 = "(.*)";
var PatternBooleanExact3 = `^${PatternBoolean3}\$`;
var PatternNumberExact3 = `^${PatternNumber3}\$`;
var PatternStringExact3 = `^${PatternString3}\$`;
// ../node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format2 = {};
__export(exports_format2, {
  Set: () => Set5,
  Has: () => Has4,
  Get: () => Get4,
  Entries: () => Entries3,
  Delete: () => Delete5,
  Clear: () => Clear3
});
var map3 = new Map;
function Entries3() {
  return new Map(map3);
}
function Clear3() {
  return map3.clear();
}
function Delete5(format3) {
  return map3.delete(format3);
}
function Has4(format3) {
  return map3.has(format3);
}
function Set5(format3, func) {
  map3.set(format3, func);
}
function Get4(format3) {
  return map3.get(format3);
}
// ../node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type5 = {};
__export(exports_type5, {
  Set: () => Set6,
  Has: () => Has5,
  Get: () => Get5,
  Entries: () => Entries4,
  Delete: () => Delete6,
  Clear: () => Clear4
});
var map4 = new Map;
function Entries4() {
  return new Map(map4);
}
function Clear4() {
  return map4.clear();
}
function Delete6(kind) {
  return map4.delete(kind);
}
function Has5(kind) {
  return map4.has(kind);
}
function Set6(kind, func) {
  map4.set(kind, func);
}
function Get5(kind) {
  return map4.get(kind);
}
// ../node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes2(T4, S3) {
  return T4.includes(S3);
}
function SetDistinct2(T4) {
  return [...new Set(T4)];
}
function SetIntersect2(T4, S3) {
  return T4.filter((L3) => S3.includes(L3));
}
function SetIntersectManyResolve2(T4, Init) {
  return T4.reduce((Acc, L3) => {
    return SetIntersect2(Acc, L3);
  }, Init);
}
function SetIntersectMany2(T4) {
  return T4.length === 1 ? T4[0] : T4.length > 1 ? SetIntersectManyResolve2(T4.slice(1), T4[0]) : [];
}
function SetUnionMany2(T4) {
  const Acc = [];
  for (const L3 of T4)
    Acc.push(...L3);
  return Acc;
}
// ../node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any2(options = {}) {
  return { ...options, [Kind3]: "Any" };
}
// ../node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array3(schema3, options = {}) {
  return {
    ...options,
    [Kind3]: "Array",
    type: "array",
    items: CloneType2(schema3)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator3(items, options = {}) {
  return {
    ...options,
    [Kind3]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType2(items)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey2(value3, key) {
  const { [key]: _3, ...rest3 } = value3;
  return rest3;
}
function Discard2(value3, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value3);
}
// ../node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never2(options = {}) {
  return {
    ...options,
    [Kind3]: "Never",
    not: {}
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult2(properties) {
  return {
    [Kind3]: "MappedResult",
    properties
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor2(parameters3, returns, options) {
  return {
    ...options,
    [Kind3]: "Constructor",
    type: "Constructor",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function3(parameters3, returns, options) {
  return {
    ...options,
    [Kind3]: "Function",
    type: "Function",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate2(T4, options) {
  return { ...options, [Kind3]: "Union", anyOf: CloneRest2(T4) };
}

// ../node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional2(T4) {
  return T4.some((L3) => IsOptional3(L3));
}
function RemoveOptionalFromRest3(T4) {
  return T4.map((L3) => IsOptional3(L3) ? RemoveOptionalFromType3(L3) : L3);
}
function RemoveOptionalFromType3(T4) {
  return Discard2(T4, [OptionalKind3]);
}
function ResolveUnion2(T4, options) {
  return IsUnionOptional2(T4) ? Optional2(UnionCreate2(RemoveOptionalFromRest3(T4), options)) : UnionCreate2(RemoveOptionalFromRest3(T4), options);
}
function UnionEvaluated2(T4, options = {}) {
  return T4.length === 0 ? Never2(options) : T4.length === 1 ? CloneType2(T4[0], options) : ResolveUnion2(T4, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union3(T4, options = {}) {
  return T4.length === 0 ? Never2(options) : T4.length === 1 ? CloneType2(T4[0], options) : UnionCreate2(T4, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError2 extends TypeBoxError2 {
}
function Unescape2(pattern2) {
  return pattern2.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped2(pattern2, index2, char2) {
  return pattern2[index2] === char2 && pattern2.charCodeAt(index2 - 1) !== 92;
}
function IsOpenParen2(pattern2, index2) {
  return IsNonEscaped2(pattern2, index2, "(");
}
function IsCloseParen2(pattern2, index2) {
  return IsNonEscaped2(pattern2, index2, ")");
}
function IsSeparator2(pattern2, index2) {
  return IsNonEscaped2(pattern2, index2, "|");
}
function IsGroup2(pattern2) {
  if (!(IsOpenParen2(pattern2, 0) && IsCloseParen2(pattern2, pattern2.length - 1)))
    return false;
  let count = 0;
  for (let index2 = 0;index2 < pattern2.length; index2++) {
    if (IsOpenParen2(pattern2, index2))
      count += 1;
    if (IsCloseParen2(pattern2, index2))
      count -= 1;
    if (count === 0 && index2 !== pattern2.length - 1)
      return false;
  }
  return true;
}
function InGroup2(pattern2) {
  return pattern2.slice(1, pattern2.length - 1);
}
function IsPrecedenceOr2(pattern2) {
  let count = 0;
  for (let index2 = 0;index2 < pattern2.length; index2++) {
    if (IsOpenParen2(pattern2, index2))
      count += 1;
    if (IsCloseParen2(pattern2, index2))
      count -= 1;
    if (IsSeparator2(pattern2, index2) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd2(pattern2) {
  for (let index2 = 0;index2 < pattern2.length; index2++) {
    if (IsOpenParen2(pattern2, index2))
      return true;
  }
  return false;
}
function Or2(pattern2) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index2 = 0;index2 < pattern2.length; index2++) {
    if (IsOpenParen2(pattern2, index2))
      count += 1;
    if (IsCloseParen2(pattern2, index2))
      count -= 1;
    if (IsSeparator2(pattern2, index2) && count === 0) {
      const range2 = pattern2.slice(start, index2);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index2 + 1;
    }
  }
  const range = pattern2.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern2) {
  function Group(value3, index2) {
    if (!IsOpenParen2(value3, index2))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index2;scan < value3.length; scan++) {
      if (IsOpenParen2(value3, scan))
        count += 1;
      if (IsCloseParen2(value3, scan))
        count -= 1;
      if (count === 0)
        return [index2, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern3, index2) {
    for (let scan = index2;scan < pattern3.length; scan++) {
      if (IsOpenParen2(pattern3, scan))
        return [index2, scan];
    }
    return [index2, pattern3.length];
  }
  const expressions = [];
  for (let index2 = 0;index2 < pattern2.length; index2++) {
    if (IsOpenParen2(pattern2, index2)) {
      const [start, end] = Group(pattern2, index2);
      const range = pattern2.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index2 = end;
    } else {
      const [start, end] = Range(pattern2, index2);
      const range = pattern2.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index2 = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse2(pattern2) {
  return IsGroup2(pattern2) ? TemplateLiteralParse2(InGroup2(pattern2)) : IsPrecedenceOr2(pattern2) ? Or2(pattern2) : IsPrecedenceAnd2(pattern2) ? And2(pattern2) : { type: "const", const: Unescape2(pattern2) };
}
function TemplateLiteralParseExact2(pattern2) {
  return TemplateLiteralParse2(pattern2.slice(1, pattern2.length - 1));
}

// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError2 extends TypeBoxError2 {
}
function IsNumberExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression2(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema3) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError2 extends TypeBoxError2 {
}
function* GenerateReduce2(buffer2) {
  if (buffer2.length === 1)
    return yield* buffer2[0];
  for (const left of buffer2[0]) {
    for (const right of GenerateReduce2(buffer2.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema3) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}
// ../node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal2(value3, options = {}) {
  return {
    ...options,
    [Kind3]: "Literal",
    const: value3,
    type: typeof value3
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean3(options = {}) {
  return {
    ...options,
    [Kind3]: "Boolean",
    type: "boolean"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt3(options = {}) {
  return {
    ...options,
    [Kind3]: "BigInt",
    type: "bigint"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number3(options = {}) {
  return {
    ...options,
    [Kind3]: "Number",
    type: "number"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String3(options = {}) {
  return { ...options, [Kind3]: "String", type: "string" };
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion20(syntax2) {
  const trim = syntax2.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number3() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal4) => Literal2(literal4.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax2) {
  if (syntax2[1] !== "{") {
    const L3 = Literal2("$");
    const R = FromSyntax2(syntax2.slice(1));
    return yield* [L3, ...R];
  }
  for (let i3 = 2;i3 < syntax2.length; i3++) {
    if (syntax2[i3] === "}") {
      const L3 = FromUnion20(syntax2.slice(2, i3));
      const R = FromSyntax2(syntax2.slice(i3 + 1));
      return yield* [...L3, ...R];
    }
  }
  yield Literal2(syntax2);
}
function* FromSyntax2(syntax2) {
  for (let i3 = 0;i3 < syntax2.length; i3++) {
    if (syntax2[i3] === "$") {
      const L3 = Literal2(syntax2.slice(0, i3));
      const R = FromTerminal2(syntax2.slice(i3));
      return yield* [L3, ...R];
    }
  }
  yield Literal2(syntax2);
}
function TemplateLiteralSyntax2(syntax2) {
  return [...FromSyntax2(syntax2)];
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError2 extends TypeBoxError2 {
}
function Escape3(value3) {
  return value3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit18(schema3, acc) {
  return IsTemplateLiteral3(schema3) ? schema3.pattern.slice(1, schema3.pattern.length - 1) : IsUnion3(schema3) ? `(${schema3.anyOf.map((schema4) => Visit18(schema4, acc)).join("|")})` : IsNumber6(schema3) ? `${acc}${PatternNumber3}` : IsInteger4(schema3) ? `${acc}${PatternNumber3}` : IsBigInt6(schema3) ? `${acc}${PatternNumber3}` : IsString6(schema3) ? `${acc}${PatternString3}` : IsLiteral3(schema3) ? `${acc}${Escape3(schema3.const.toString())}` : IsBoolean6(schema3) ? `${acc}${PatternBoolean3}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema3[Kind3]}'`);
  })();
}
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema3) => Visit18(schema3, "")).join("")}$`;
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion2(schema3) {
  const R = TemplateLiteralGenerate2(schema3);
  const L3 = R.map((S3) => Literal2(S3));
  return UnionEvaluated2(L3);
}
// ../node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral2(unresolved, options = {}) {
  const pattern2 = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return { ...options, [Kind3]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// ../node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral7(T4) {
  const R = TemplateLiteralGenerate2(T4);
  return R.map((S3) => S3.toString());
}
function FromUnion21(T4) {
  const Acc = [];
  for (const L3 of T4)
    Acc.push(...IndexPropertyKeys2(L3));
  return Acc;
}
function FromLiteral7(T4) {
  return [T4.toString()];
}
function IndexPropertyKeys2(T4) {
  return [...new Set(IsTemplateLiteral3(T4) ? FromTemplateLiteral7(T4) : IsUnion3(T4) ? FromUnion21(T4.anyOf) : IsLiteral3(T4) ? FromLiteral7(T4.const) : IsNumber6(T4) ? ["[number]"] : IsInteger4(T4) ? ["[number]"] : [])];
}

// ../node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties20(T4, P4, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P4)) {
    Acc[K2] = Index3(T4, IndexPropertyKeys2(P4[K2]), options);
  }
  return Acc;
}
function FromMappedResult13(T4, R, options) {
  return FromProperties20(T4, R.properties, options);
}
function IndexFromMappedResult2(T4, R, options) {
  const P4 = FromMappedResult13(T4, R, options);
  return MappedResult2(P4);
}

// ../node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest9(T4, K) {
  return T4.map((L3) => IndexFromPropertyKey2(L3, K));
}
function FromIntersectRest2(T4) {
  return T4.filter((L3) => !IsNever3(L3));
}
function FromIntersect18(T4, K) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest9(T4, K)));
}
function FromUnionRest2(T4) {
  return T4.some((L3) => IsNever3(L3)) ? [] : T4;
}
function FromUnion22(T4, K) {
  return UnionEvaluated2(FromUnionRest2(FromRest9(T4, K)));
}
function FromTuple15(T4, K) {
  return K in T4 ? T4[K] : K === "[number]" ? UnionEvaluated2(T4) : Never2();
}
function FromArray16(T4, K) {
  return K === "[number]" ? T4 : Never2();
}
function FromProperty3(T4, K) {
  return K in T4 ? T4[K] : Never2();
}
function IndexFromPropertyKey2(T4, K) {
  return IsIntersect3(T4) ? FromIntersect18(T4.allOf, K) : IsUnion3(T4) ? FromUnion22(T4.anyOf, K) : IsTuple3(T4) ? FromTuple15(T4.items ?? [], K) : IsArray6(T4) ? FromArray16(T4.items, K) : IsObject6(T4) ? FromProperty3(T4.properties, K) : Never2();
}
function IndexFromPropertyKeys2(T4, K) {
  return K.map((L3) => IndexFromPropertyKey2(T4, L3));
}
function FromSchema2(T4, K) {
  return UnionEvaluated2(IndexFromPropertyKeys2(T4, K));
}
function Index3(T4, K, options = {}) {
  return IsMappedResult3(K) ? CloneType2(IndexFromMappedResult2(T4, K, options)) : IsMappedKey3(K) ? CloneType2(IndexFromMappedKey2(T4, K, options)) : IsSchema3(K) ? CloneType2(FromSchema2(T4, IndexPropertyKeys2(K)), options) : CloneType2(FromSchema2(T4, K), options);
}

// ../node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey2(T4, K, options) {
  return { [K]: Index3(T4, [K], options) };
}
function MappedIndexPropertyKeys2(T4, K, options) {
  return K.reduce((Acc, L3) => {
    return { ...Acc, ...MappedIndexPropertyKey2(T4, L3, options) };
  }, {});
}
function MappedIndexProperties2(T4, K, options) {
  return MappedIndexPropertyKeys2(T4, K.keys, options);
}
function IndexFromMappedKey2(T4, K, options) {
  const P4 = MappedIndexProperties2(T4, K, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator3(items, options = {}) {
  return {
    ...options,
    [Kind3]: "Iterator",
    type: "Iterator",
    items: CloneType2(items)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object2(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional3(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema3(options.additionalProperties) ? { additionalProperties: CloneType2(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType2(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind3]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind3]: "Object", type: "object", properties: clonedProperties };
}
var Object3 = _Object2;
// ../node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise3(item, options = {}) {
  return {
    ...options,
    [Kind3]: "Promise",
    type: "Promise",
    item: CloneType2(item)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly2(schema3) {
  return Discard2(CloneType2(schema3), [ReadonlyKind3]);
}
function AddReadonly2(schema3) {
  return { ...CloneType2(schema3), [ReadonlyKind3]: "Readonly" };
}
function ReadonlyWithFlag2(schema3, F3) {
  return F3 === false ? RemoveReadonly2(schema3) : AddReadonly2(schema3);
}
function Readonly2(schema3, enable) {
  const F3 = enable ?? true;
  return IsMappedResult3(schema3) ? ReadonlyFromMappedResult2(schema3, F3) : ReadonlyWithFlag2(schema3, F3);
}

// ../node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties21(K, F3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly2(K[K2], F3);
  return Acc;
}
function FromMappedResult14(R, F3) {
  return FromProperties21(R.properties, F3);
}
function ReadonlyFromMappedResult2(R, F3) {
  const P4 = FromMappedResult14(R, F3);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple2(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind3]: "Tuple", type: "array", items: CloneRest2(items), additionalItems, minItems, maxItems } : { ...options, [Kind3]: "Tuple", type: "array", minItems, maxItems };
}
// ../node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult15(K, P4) {
  return K in P4 ? FromSchemaType2(K, P4[K]) : MappedResult2(P4);
}
function MappedKeyToKnownMappedResultProperties2(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties2(P4) {
  const Acc = {};
  for (const L3 of P4)
    Acc[L3] = Literal2(L3);
  return Acc;
}
function MappedKeyToMappedResultProperties2(K, P4) {
  return SetIncludes2(P4, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P4);
}
function FromMappedKey5(K, P4) {
  const R = MappedKeyToMappedResultProperties2(K, P4);
  return FromMappedResult15(K, R);
}
function FromRest10(K, T4) {
  return T4.map((L3) => FromSchemaType2(K, L3));
}
function FromProperties22(K, T4) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T4))
    Acc[K2] = FromSchemaType2(K, T4[K2]);
  return Acc;
}
function FromSchemaType2(K, T4) {
  return IsOptional3(T4) ? Optional2(FromSchemaType2(K, Discard2(T4, [OptionalKind3]))) : IsReadonly3(T4) ? Readonly2(FromSchemaType2(K, Discard2(T4, [ReadonlyKind3]))) : IsMappedResult3(T4) ? FromMappedResult15(K, T4.properties) : IsMappedKey3(T4) ? FromMappedKey5(K, T4.keys) : IsConstructor3(T4) ? Constructor2(FromRest10(K, T4.parameters), FromSchemaType2(K, T4.returns)) : IsFunction6(T4) ? Function3(FromRest10(K, T4.parameters), FromSchemaType2(K, T4.returns)) : IsAsyncIterator6(T4) ? AsyncIterator3(FromSchemaType2(K, T4.items)) : IsIterator6(T4) ? Iterator3(FromSchemaType2(K, T4.items)) : IsIntersect3(T4) ? Intersect3(FromRest10(K, T4.allOf)) : IsUnion3(T4) ? Union3(FromRest10(K, T4.anyOf)) : IsTuple3(T4) ? Tuple2(FromRest10(K, T4.items ?? [])) : IsObject6(T4) ? Object3(FromProperties22(K, T4.properties)) : IsArray6(T4) ? Array3(FromSchemaType2(K, T4.items)) : IsPromise4(T4) ? Promise3(FromSchemaType2(K, T4.item)) : T4;
}
function MappedFunctionReturnType2(K, T4) {
  const Acc = {};
  for (const L3 of K)
    Acc[L3] = FromSchemaType2(L3, T4);
  return Acc;
}
function Mapped2(key, map5, options = {}) {
  const K = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const RT = map5({ [Kind3]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType2(K, RT);
  return CloneType2(Object3(R), options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional2(schema3) {
  return Discard2(CloneType2(schema3), [OptionalKind3]);
}
function AddOptional2(schema3) {
  return { ...CloneType2(schema3), [OptionalKind3]: "Optional" };
}
function OptionalWithFlag2(schema3, F3) {
  return F3 === false ? RemoveOptional2(schema3) : AddOptional2(schema3);
}
function Optional2(schema3, enable) {
  const F3 = enable ?? true;
  return IsMappedResult3(schema3) ? OptionalFromMappedResult2(schema3, F3) : OptionalWithFlag2(schema3, F3);
}

// ../node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties23(P4, F3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Optional2(P4[K2], F3);
  return Acc;
}
function FromMappedResult16(R, F3) {
  return FromProperties23(R.properties, F3);
}
function OptionalFromMappedResult2(R, F3) {
  const P4 = FromMappedResult16(R, F3);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate2(T4, options) {
  const allObjects = T4.every((schema3) => IsObject6(schema3));
  const clonedUnevaluatedProperties = IsSchema3(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType2(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema3(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind3]: "Intersect", type: "object", allOf: CloneRest2(T4) } : { ...options, ...clonedUnevaluatedProperties, [Kind3]: "Intersect", allOf: CloneRest2(T4) };
}

// ../node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional2(T4) {
  return T4.every((L3) => IsOptional3(L3));
}
function RemoveOptionalFromType4(T4) {
  return Discard2(T4, [OptionalKind3]);
}
function RemoveOptionalFromRest4(T4) {
  return T4.map((L3) => IsOptional3(L3) ? RemoveOptionalFromType4(L3) : L3);
}
function ResolveIntersect2(T4, options) {
  return IsIntersectOptional2(T4) ? Optional2(IntersectCreate2(RemoveOptionalFromRest4(T4), options)) : IntersectCreate2(RemoveOptionalFromRest4(T4), options);
}
function IntersectEvaluated2(T4, options = {}) {
  if (T4.length === 0)
    return Never2(options);
  if (T4.length === 1)
    return CloneType2(T4[0], options);
  if (T4.some((schema3) => IsTransform3(schema3)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(T4, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect3(T4, options = {}) {
  if (T4.length === 0)
    return Never2(options);
  if (T4.length === 1)
    return CloneType2(T4[0], options);
  if (T4.some((schema3) => IsTransform3(schema3)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(T4, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest11(T4) {
  return T4.map((L3) => AwaitedResolve2(L3));
}
function FromIntersect19(T4) {
  return Intersect3(FromRest11(T4));
}
function FromUnion23(T4) {
  return Union3(FromRest11(T4));
}
function FromPromise8(T4) {
  return AwaitedResolve2(T4);
}
function AwaitedResolve2(T4) {
  return IsIntersect3(T4) ? FromIntersect19(T4.allOf) : IsUnion3(T4) ? FromUnion23(T4.anyOf) : IsPromise4(T4) ? FromPromise8(T4.item) : T4;
}
function Awaited2(T4, options = {}) {
  return CloneType2(AwaitedResolve2(T4), options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest12(T4) {
  const Acc = [];
  for (const L3 of T4)
    Acc.push(KeyOfPropertyKeys2(L3));
  return Acc;
}
function FromIntersect20(T4) {
  const C3 = FromRest12(T4);
  const R = SetUnionMany2(C3);
  return R;
}
function FromUnion24(T4) {
  const C3 = FromRest12(T4);
  const R = SetIntersectMany2(C3);
  return R;
}
function FromTuple16(T4) {
  return T4.map((_3, I4) => I4.toString());
}
function FromArray17(_3) {
  return ["[number]"];
}
function FromProperties24(T4) {
  return globalThis.Object.getOwnPropertyNames(T4);
}
function FromPatternProperties2(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys2(T4) {
  return IsIntersect3(T4) ? FromIntersect20(T4.allOf) : IsUnion3(T4) ? FromUnion24(T4.anyOf) : IsTuple3(T4) ? FromTuple16(T4.items ?? []) : IsArray6(T4) ? FromArray17(T4.items) : IsObject6(T4) ? FromProperties24(T4.properties) : IsRecord3(T4) ? FromPatternProperties2(T4.patternProperties) : [];
}
var includePatternProperties2 = false;
function KeyOfPattern2(schema3) {
  includePatternProperties2 = true;
  const keys = KeyOfPropertyKeys2(schema3);
  includePatternProperties2 = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}

// ../node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest2(T4) {
  return T4.map((L3) => L3 === "[number]" ? Number3() : Literal2(L3));
}
function KeyOf2(T4, options = {}) {
  if (IsMappedResult3(T4)) {
    return KeyOfFromMappedResult2(T4, options);
  } else {
    const K = KeyOfPropertyKeys2(T4);
    const S3 = KeyOfPropertyKeysToRest2(K);
    const U = UnionEvaluated2(S3);
    return CloneType2(U, options);
  }
}

// ../node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties25(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf2(K[K2], options);
  return Acc;
}
function FromMappedResult17(R, options) {
  return FromProperties25(R.properties, options);
}
function KeyOfFromMappedResult2(R, options) {
  const P4 = FromMappedResult17(R, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries2(schema3) {
  const keys = KeyOfPropertyKeys2(schema3);
  const schemas = IndexFromPropertyKeys2(schema3, keys);
  return keys.map((_3, index2) => [keys[index2], schemas[index2]]);
}
// ../node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys2(T4) {
  const Acc = [];
  for (const L3 of T4)
    Acc.push(...KeyOfPropertyKeys2(L3));
  return SetDistinct2(Acc);
}
function FilterNever2(T4) {
  return T4.filter((L3) => !IsNever3(L3));
}
function CompositeProperty2(T4, K) {
  const Acc = [];
  for (const L3 of T4)
    Acc.push(...IndexFromPropertyKeys2(L3, [K]));
  return FilterNever2(Acc);
}
function CompositeProperties2(T4, K) {
  const Acc = {};
  for (const L3 of K) {
    Acc[L3] = IntersectEvaluated2(CompositeProperty2(T4, L3));
  }
  return Acc;
}
function Composite2(T4, options = {}) {
  const K = CompositeKeys2(T4);
  const P4 = CompositeProperties2(T4, K);
  const R = Object3(P4, options);
  return R;
}
// ../node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date3(options = {}) {
  return {
    ...options,
    [Kind3]: "Date",
    type: "Date"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null2(options = {}) {
  return {
    ...options,
    [Kind3]: "Null",
    type: "null"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol3(options) {
  return { ...options, [Kind3]: "Symbol", type: "symbol" };
}
// ../node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined2(options = {}) {
  return { ...options, [Kind3]: "Undefined", type: "undefined" };
}
// ../node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array3(options = {}) {
  return { ...options, [Kind3]: "Uint8Array", type: "Uint8Array" };
}
// ../node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown2(options = {}) {
  return {
    ...options,
    [Kind3]: "Unknown"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray18(T4) {
  return T4.map((L3) => FromValue2(L3, false));
}
function FromProperties26(value3) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value3))
    Acc[K] = Readonly2(FromValue2(value3[K], false));
  return Acc;
}
function ConditionalReadonly2(T4, root2) {
  return root2 === true ? T4 : Readonly2(T4);
}
function FromValue2(value3, root2) {
  return IsAsyncIterator5(value3) ? ConditionalReadonly2(Any2(), root2) : IsIterator5(value3) ? ConditionalReadonly2(Any2(), root2) : IsArray5(value3) ? Readonly2(Tuple2(FromArray18(value3))) : IsUint8Array5(value3) ? Uint8Array3() : IsDate5(value3) ? Date3() : IsObject5(value3) ? ConditionalReadonly2(Object3(FromProperties26(value3)), root2) : IsFunction5(value3) ? ConditionalReadonly2(Function3([], Unknown2()), root2) : IsUndefined5(value3) ? Undefined2() : IsNull5(value3) ? Null2() : IsSymbol5(value3) ? Symbol3() : IsBigInt5(value3) ? BigInt3() : IsNumber5(value3) ? Literal2(value3) : IsBoolean5(value3) ? Literal2(value3) : IsString5(value3) ? Literal2(value3) : Object3({});
}
function Const2(T4, options = {}) {
  return CloneType2(FromValue2(T4, true), options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters2(schema3, options = {}) {
  return Tuple2(CloneRest2(schema3.parameters), { ...options });
}
// ../node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest13(schema3, references) {
  return schema3.map((schema4) => Deref3(schema4, references));
}
function FromProperties27(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref3(properties[K], references);
  }
  return Acc;
}
function FromConstructor8(schema3, references) {
  schema3.parameters = FromRest13(schema3.parameters, references);
  schema3.returns = Deref3(schema3.returns, references);
  return schema3;
}
function FromFunction7(schema3, references) {
  schema3.parameters = FromRest13(schema3.parameters, references);
  schema3.returns = Deref3(schema3.returns, references);
  return schema3;
}
function FromIntersect21(schema3, references) {
  schema3.allOf = FromRest13(schema3.allOf, references);
  return schema3;
}
function FromUnion25(schema3, references) {
  schema3.anyOf = FromRest13(schema3.anyOf, references);
  return schema3;
}
function FromTuple17(schema3, references) {
  if (IsUndefined5(schema3.items))
    return schema3;
  schema3.items = FromRest13(schema3.items, references);
  return schema3;
}
function FromArray19(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromObject13(schema3, references) {
  schema3.properties = FromProperties27(schema3.properties, references);
  return schema3;
}
function FromPromise9(schema3, references) {
  schema3.item = Deref3(schema3.item, references);
  return schema3;
}
function FromAsyncIterator7(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromIterator7(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromRef12(schema3, references) {
  const target = references.find((remote) => remote.$id === schema3.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema3.$ref}`);
  const discard3 = Discard2(target, ["$id"]);
  return Deref3(discard3, references);
}
function DerefResolve2(schema3, references) {
  return IsConstructor3(schema3) ? FromConstructor8(schema3, references) : IsFunction6(schema3) ? FromFunction7(schema3, references) : IsIntersect3(schema3) ? FromIntersect21(schema3, references) : IsUnion3(schema3) ? FromUnion25(schema3, references) : IsTuple3(schema3) ? FromTuple17(schema3, references) : IsArray6(schema3) ? FromArray19(schema3, references) : IsObject6(schema3) ? FromObject13(schema3, references) : IsPromise4(schema3) ? FromPromise9(schema3, references) : IsAsyncIterator6(schema3) ? FromAsyncIterator7(schema3, references) : IsIterator6(schema3) ? FromIterator7(schema3, references) : IsRef3(schema3) ? FromRef12(schema3, references) : schema3;
}
function Deref3(schema3, references) {
  return DerefResolve2(CloneType2(schema3), CloneRest2(references));
}
// ../node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum2(item, options = {}) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value3) => Literal2(value3));
  return Union3(anyOf, { ...options, [Hint3]: "Enum" });
}
// ../node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError2 extends TypeBoxError2 {
}
var ExtendsResult3;
(function(ExtendsResult4) {
  ExtendsResult4[ExtendsResult4["Union"] = 0] = "Union";
  ExtendsResult4[ExtendsResult4["True"] = 1] = "True";
  ExtendsResult4[ExtendsResult4["False"] = 2] = "False";
})(ExtendsResult3 || (ExtendsResult3 = {}));
function IntoBooleanResult2(result) {
  return result === ExtendsResult3.False ? result : ExtendsResult3.True;
}
function Throw2(message) {
  throw new ExtendsResolverError2(message);
}
function IsStructuralRight2(right) {
  return exports_type4.IsNever(right) || exports_type4.IsIntersect(right) || exports_type4.IsUnion(right) || exports_type4.IsUnknown(right) || exports_type4.IsAny(right);
}
function StructuralRight2(left, right) {
  return exports_type4.IsNever(right) ? FromNeverRight2(left, right) : exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
}
function FromAnyRight2(left, right) {
  return ExtendsResult3.True;
}
function FromAny5(left, right) {
  return exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) && right.anyOf.some((schema3) => exports_type4.IsAny(schema3) || exports_type4.IsUnknown(schema3)) ? ExtendsResult3.True : exports_type4.IsUnion(right) ? ExtendsResult3.Union : exports_type4.IsUnknown(right) ? ExtendsResult3.True : exports_type4.IsAny(right) ? ExtendsResult3.True : ExtendsResult3.Union;
}
function FromArrayRight2(left, right) {
  return exports_type4.IsUnknown(left) ? ExtendsResult3.False : exports_type4.IsAny(left) ? ExtendsResult3.Union : exports_type4.IsNever(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromArray20(left, right) {
  return exports_type4.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult3.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsArray(right) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromAsyncIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsAsyncIterator(right) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromBigInt6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsBigInt(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromBooleanRight2(left, right) {
  return exports_type4.IsLiteralBoolean(left) ? ExtendsResult3.True : exports_type4.IsBoolean(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromBoolean6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsBoolean(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromConstructor9(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsConstructor(right) ? ExtendsResult3.False : left.parameters.length > right.parameters.length ? ExtendsResult3.False : !left.parameters.every((schema3, index2) => IntoBooleanResult2(Visit19(right.parameters[index2], schema3)) === ExtendsResult3.True) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.returns, right.returns));
}
function FromDate6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsDate(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromFunction8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsFunction(right) ? ExtendsResult3.False : left.parameters.length > right.parameters.length ? ExtendsResult3.False : !left.parameters.every((schema3, index2) => IntoBooleanResult2(Visit19(right.parameters[index2], schema3)) === ExtendsResult3.True) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.returns, right.returns));
}
function FromIntegerRight2(left, right) {
  return exports_type4.IsLiteral(left) && exports_value3.IsNumber(left.const) ? ExtendsResult3.True : exports_type4.IsNumber(left) || exports_type4.IsInteger(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromInteger6(left, right) {
  return exports_type4.IsInteger(right) || exports_type4.IsNumber(right) ? ExtendsResult3.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult3.False;
}
function FromIntersectRight2(left, right) {
  return right.allOf.every((schema3) => Visit19(left, schema3) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromIntersect22(left, right) {
  return left.allOf.some((schema3) => Visit19(schema3, right) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsIterator(right) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromLiteral8(left, right) {
  return exports_type4.IsLiteral(right) && right.const === left.const ? ExtendsResult3.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsString(right) ? FromStringRight2(left, right) : exports_type4.IsNumber(right) ? FromNumberRight2(left, right) : exports_type4.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type4.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult3.False;
}
function FromNeverRight2(left, right) {
  return ExtendsResult3.False;
}
function FromNever6(left, right) {
  return ExtendsResult3.True;
}
function UnwrapTNot2(schema3) {
  let [current, depth] = [schema3, 0];
  while (true) {
    if (!exports_type4.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
}
function FromNot8(left, right) {
  return exports_type4.IsNot(left) ? Visit19(UnwrapTNot2(left), right) : exports_type4.IsNot(right) ? Visit19(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
}
function FromNull6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsNull(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromNumberRight2(left, right) {
  return exports_type4.IsLiteralNumber(left) ? ExtendsResult3.True : exports_type4.IsNumber(left) || exports_type4.IsInteger(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromNumber6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsInteger(right) || exports_type4.IsNumber(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function IsObjectPropertyCount2(schema3, count) {
  return Object.getOwnPropertyNames(schema3.properties).length === count;
}
function IsObjectStringLike2(schema3) {
  return IsObjectArrayLike2(schema3);
}
function IsObjectSymbolLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "description" in schema3.properties && exports_type4.IsUnion(schema3.properties.description) && schema3.properties.description.anyOf.length === 2 && (exports_type4.IsString(schema3.properties.description.anyOf[0]) && exports_type4.IsUndefined(schema3.properties.description.anyOf[1]) || exports_type4.IsString(schema3.properties.description.anyOf[1]) && exports_type4.IsUndefined(schema3.properties.description.anyOf[0]));
}
function IsObjectNumberLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectBooleanLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectBigIntLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectDateLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectUint8ArrayLike2(schema3) {
  return IsObjectArrayLike2(schema3);
}
function IsObjectFunctionLike2(schema3) {
  const length = Number3();
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit19(schema3.properties["length"], length)) === ExtendsResult3.True;
}
function IsObjectConstructorLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectArrayLike2(schema3) {
  const length = Number3();
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit19(schema3.properties["length"], length)) === ExtendsResult3.True;
}
function IsObjectPromiseLike2(schema3) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "then" in schema3.properties && IntoBooleanResult2(Visit19(schema3.properties["then"], then)) === ExtendsResult3.True;
}
function Property2(left, right) {
  return Visit19(left, right) === ExtendsResult3.False ? ExtendsResult3.False : exports_type4.IsOptional(left) && !exports_type4.IsOptional(right) ? ExtendsResult3.False : ExtendsResult3.True;
}
function FromObjectRight2(left, right) {
  return exports_type4.IsUnknown(left) ? ExtendsResult3.False : exports_type4.IsAny(left) ? ExtendsResult3.Union : exports_type4.IsNever(left) || exports_type4.IsLiteralString(left) && IsObjectStringLike2(right) || exports_type4.IsLiteralNumber(left) && IsObjectNumberLike2(right) || exports_type4.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || exports_type4.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type4.IsBigInt(left) && IsObjectBigIntLike2(right) || exports_type4.IsString(left) && IsObjectStringLike2(right) || exports_type4.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type4.IsNumber(left) && IsObjectNumberLike2(right) || exports_type4.IsInteger(left) && IsObjectNumberLike2(right) || exports_type4.IsBoolean(left) && IsObjectBooleanLike2(right) || exports_type4.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || exports_type4.IsDate(left) && IsObjectDateLike2(right) || exports_type4.IsConstructor(left) && IsObjectConstructorLike2(right) || exports_type4.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult3.True : exports_type4.IsRecord(left) && exports_type4.IsString(RecordKey2(left)) ? (() => {
    return right[Hint3] === "Record" ? ExtendsResult3.True : ExtendsResult3.False;
  })() : exports_type4.IsRecord(left) && exports_type4.IsNumber(RecordKey2(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult3.True : ExtendsResult3.False;
  })() : ExtendsResult3.False;
}
function FromObject14(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : !exports_type4.IsObject(right) ? ExtendsResult3.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type4.IsOptional(right.properties[key])) {
        return ExtendsResult3.False;
      }
      if (exports_type4.IsOptional(right.properties[key])) {
        return ExtendsResult3.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult3.False) {
        return ExtendsResult3.False;
      }
    }
    return ExtendsResult3.True;
  })();
}
function FromPromise10(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult3.True : !exports_type4.IsPromise(right) ? ExtendsResult3.False : IntoBooleanResult2(Visit19(left.item, right.item));
}
function RecordKey2(schema3) {
  return PatternNumberExact3 in schema3.patternProperties ? Number3() : (PatternStringExact3 in schema3.patternProperties) ? String3() : Throw2("Unknown record key pattern");
}
function RecordValue2(schema3) {
  return PatternNumberExact3 in schema3.patternProperties ? schema3.patternProperties[PatternNumberExact3] : (PatternStringExact3 in schema3.patternProperties) ? schema3.patternProperties[PatternStringExact3] : Throw2("Unable to get record value schema");
}
function FromRecordRight2(left, right) {
  const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
  return exports_type4.IsLiteralString(left) && exports_type4.IsNumber(Key) && IntoBooleanResult2(Visit19(left, Value)) === ExtendsResult3.True ? ExtendsResult3.True : exports_type4.IsUint8Array(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsString(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsArray(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult3.False) {
        return ExtendsResult3.False;
      }
    }
    return ExtendsResult3.True;
  })() : ExtendsResult3.False;
}
function FromRecord12(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsRecord(right) ? ExtendsResult3.False : Visit19(RecordValue2(left), RecordValue2(right));
}
function FromRegExp5(left, right) {
  const L3 = exports_type4.IsRegExp(left) ? String3() : left;
  const R = exports_type4.IsRegExp(right) ? String3() : right;
  return Visit19(L3, R);
}
function FromStringRight2(left, right) {
  return exports_type4.IsLiteral(left) && exports_value3.IsString(left.const) ? ExtendsResult3.True : exports_type4.IsString(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromString6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsString(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromSymbol6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsSymbol(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromTemplateLiteral8(left, right) {
  return exports_type4.IsTemplateLiteral(left) ? Visit19(TemplateLiteralToUnion2(left), right) : exports_type4.IsTemplateLiteral(right) ? Visit19(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple2(left, right) {
  return exports_type4.IsArray(right) && left.items !== undefined && left.items.every((schema3) => Visit19(schema3, right.items) === ExtendsResult3.True);
}
function FromTupleRight2(left, right) {
  return exports_type4.IsNever(left) ? ExtendsResult3.True : exports_type4.IsUnknown(left) ? ExtendsResult3.False : exports_type4.IsAny(left) ? ExtendsResult3.Union : ExtendsResult3.False;
}
function FromTuple18(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult3.True : exports_type4.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult3.True : !exports_type4.IsTuple(right) ? ExtendsResult3.False : exports_value3.IsUndefined(left.items) && !exports_value3.IsUndefined(right.items) || !exports_value3.IsUndefined(left.items) && exports_value3.IsUndefined(right.items) ? ExtendsResult3.False : exports_value3.IsUndefined(left.items) && !exports_value3.IsUndefined(right.items) ? ExtendsResult3.True : left.items.every((schema3, index2) => Visit19(schema3, right.items[index2]) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUint8Array5(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsUint8Array(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUndefined6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsVoid(right) ? FromVoidRight2(left, right) : exports_type4.IsUndefined(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnionRight2(left, right) {
  return right.anyOf.some((schema3) => Visit19(left, schema3) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnion26(left, right) {
  return left.anyOf.every((schema3) => Visit19(schema3, right) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnknownRight2(left, right) {
  return ExtendsResult3.True;
}
function FromUnknown5(left, right) {
  return exports_type4.IsNever(right) ? FromNeverRight2(left, right) : exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : exports_type4.IsString(right) ? FromStringRight2(left, right) : exports_type4.IsNumber(right) ? FromNumberRight2(left, right) : exports_type4.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type4.IsBoolean(right) ? FromBooleanRight2(left, right) : exports_type4.IsArray(right) ? FromArrayRight2(left, right) : exports_type4.IsTuple(right) ? FromTupleRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsUnknown(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromVoidRight2(left, right) {
  return exports_type4.IsUndefined(left) ? ExtendsResult3.True : exports_type4.IsUndefined(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromVoid5(left, right) {
  return exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsVoid(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function Visit19(left, right) {
  return exports_type4.IsTemplateLiteral(left) || exports_type4.IsTemplateLiteral(right) ? FromTemplateLiteral8(left, right) : exports_type4.IsRegExp(left) || exports_type4.IsRegExp(right) ? FromRegExp5(left, right) : exports_type4.IsNot(left) || exports_type4.IsNot(right) ? FromNot8(left, right) : exports_type4.IsAny(left) ? FromAny5(left, right) : exports_type4.IsArray(left) ? FromArray20(left, right) : exports_type4.IsBigInt(left) ? FromBigInt6(left, right) : exports_type4.IsBoolean(left) ? FromBoolean6(left, right) : exports_type4.IsAsyncIterator(left) ? FromAsyncIterator8(left, right) : exports_type4.IsConstructor(left) ? FromConstructor9(left, right) : exports_type4.IsDate(left) ? FromDate6(left, right) : exports_type4.IsFunction(left) ? FromFunction8(left, right) : exports_type4.IsInteger(left) ? FromInteger6(left, right) : exports_type4.IsIntersect(left) ? FromIntersect22(left, right) : exports_type4.IsIterator(left) ? FromIterator8(left, right) : exports_type4.IsLiteral(left) ? FromLiteral8(left, right) : exports_type4.IsNever(left) ? FromNever6(left, right) : exports_type4.IsNull(left) ? FromNull6(left, right) : exports_type4.IsNumber(left) ? FromNumber6(left, right) : exports_type4.IsObject(left) ? FromObject14(left, right) : exports_type4.IsRecord(left) ? FromRecord12(left, right) : exports_type4.IsString(left) ? FromString6(left, right) : exports_type4.IsSymbol(left) ? FromSymbol6(left, right) : exports_type4.IsTuple(left) ? FromTuple18(left, right) : exports_type4.IsPromise(left) ? FromPromise10(left, right) : exports_type4.IsUint8Array(left) ? FromUint8Array5(left, right) : exports_type4.IsUndefined(left) ? FromUndefined6(left, right) : exports_type4.IsUnion(left) ? FromUnion26(left, right) : exports_type4.IsUnknown(left) ? FromUnknown5(left, right) : exports_type4.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[Kind3]}'`);
}
function ExtendsCheck2(left, right) {
  return Visit19(left, right);
}
// ../node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties28(P4, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Extends2(P4[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult18(Left, Right, True, False, options) {
  return FromProperties28(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P4 = FromMappedResult18(Left, Right, True, False, options);
  return MappedResult2(P4);
}

// ../node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve2(left, right, trueType, falseType) {
  const R = ExtendsCheck2(left, right);
  return R === ExtendsResult3.Union ? Union3([trueType, falseType]) : R === ExtendsResult3.True ? trueType : falseType;
}
function Extends2(L3, R, T4, F3, options = {}) {
  return IsMappedResult3(L3) ? ExtendsFromMappedResult2(L3, R, T4, F3, options) : IsMappedKey3(L3) ? CloneType2(ExtendsFromMappedKey2(L3, R, T4, F3, options)) : CloneType2(ExtendsResolve2(L3, R, T4, F3), options);
}

// ../node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey4(K, U, L3, R, options) {
  return {
    [K]: Extends2(Literal2(K), U, L3, R, options)
  };
}
function FromPropertyKeys4(K, U, L3, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U, L3, R, options) };
  }, {});
}
function FromMappedKey6(K, U, L3, R, options) {
  return FromPropertyKeys4(K.keys, U, L3, R, options);
}
function ExtendsFromMappedKey2(T4, U, L3, R, options) {
  const P4 = FromMappedKey6(T4, U, L3, R, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect4(schema3) {
  return schema3.allOf.every((schema4) => ExtendsUndefinedCheck2(schema4));
}
function Union4(schema3) {
  return schema3.anyOf.some((schema4) => ExtendsUndefinedCheck2(schema4));
}
function Not3(schema3) {
  return !ExtendsUndefinedCheck2(schema3.not);
}
function ExtendsUndefinedCheck2(schema3) {
  return schema3[Kind3] === "Intersect" ? Intersect4(schema3) : schema3[Kind3] === "Union" ? Union4(schema3) : schema3[Kind3] === "Not" ? Not3(schema3) : schema3[Kind3] === "Undefined" ? true : false;
}
// ../node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral2(L3, R) {
  return Exclude2(TemplateLiteralToUnion2(L3), R);
}

// ../node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest2(L3, R) {
  const excluded = L3.filter((inner) => ExtendsCheck2(inner, R) === ExtendsResult3.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
}
function Exclude2(L3, R, options = {}) {
  if (IsTemplateLiteral3(L3))
    return CloneType2(ExcludeFromTemplateLiteral2(L3, R), options);
  if (IsMappedResult3(L3))
    return CloneType2(ExcludeFromMappedResult2(L3, R), options);
  return CloneType2(IsUnion3(L3) ? ExcludeRest2(L3.anyOf, R) : ExtendsCheck2(L3, R) !== ExtendsResult3.False ? Never2() : L3, options);
}

// ../node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties29(P4, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Exclude2(P4[K2], U);
  return Acc;
}
function FromMappedResult19(R, T4) {
  return FromProperties29(R.properties, T4);
}
function ExcludeFromMappedResult2(R, T4) {
  const P4 = FromMappedResult19(R, T4);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral2(L3, R) {
  return Extract2(TemplateLiteralToUnion2(L3), R);
}

// ../node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest2(L3, R) {
  const extracted = L3.filter((inner) => ExtendsCheck2(inner, R) !== ExtendsResult3.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
}
function Extract2(L3, R, options = {}) {
  if (IsTemplateLiteral3(L3))
    return CloneType2(ExtractFromTemplateLiteral2(L3, R), options);
  if (IsMappedResult3(L3))
    return CloneType2(ExtractFromMappedResult2(L3, R), options);
  return CloneType2(IsUnion3(L3) ? ExtractRest2(L3.anyOf, R) : ExtendsCheck2(L3, R) !== ExtendsResult3.False ? L3 : Never2(), options);
}

// ../node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties30(P4, T4) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Extract2(P4[K2], T4);
  return Acc;
}
function FromMappedResult20(R, T4) {
  return FromProperties30(R.properties, T4);
}
function ExtractFromMappedResult2(R, T4) {
  const P4 = FromMappedResult20(R, T4);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType2(schema3, options = {}) {
  return CloneType2(schema3.returns, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer2(options = {}) {
  return {
    ...options,
    [Kind3]: "Integer",
    type: "integer"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey2(K, M2, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M2, options)
  };
}
function MappedIntrinsicPropertyKeys2(K, M2, options) {
  return K.reduce((Acc, L3) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L3, M2, options) };
  }, {});
}
function MappedIntrinsicProperties2(T4, M2, options) {
  return MappedIntrinsicPropertyKeys2(T4["keys"], M2, options);
}
function IntrinsicFromMappedKey2(T4, M2, options) {
  const P4 = MappedIntrinsicProperties2(T4, M2, options);
  return MappedResult2(P4);
}

// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize2(value3) {
  const [first, rest3] = [value3.slice(0, 1), value3.slice(1)];
  return [first.toLowerCase(), rest3].join("");
}
function ApplyCapitalize2(value3) {
  const [first, rest3] = [value3.slice(0, 1), value3.slice(1)];
  return [first.toUpperCase(), rest3].join("");
}
function ApplyUppercase2(value3) {
  return value3.toUpperCase();
}
function ApplyLowercase2(value3) {
  return value3.toLowerCase();
}
function FromTemplateLiteral9(schema3, mode, options) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite3)
    return { ...schema3, pattern: FromLiteralValue2(schema3.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value3) => Literal2(value3));
  const mapped4 = FromRest14(literals, mode);
  const union7 = Union3(mapped4);
  return TemplateLiteral2([union7], options);
}
function FromLiteralValue2(value3, mode) {
  return typeof value3 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value3) : mode === "Capitalize" ? ApplyCapitalize2(value3) : mode === "Uppercase" ? ApplyUppercase2(value3) : mode === "Lowercase" ? ApplyLowercase2(value3) : value3 : value3.toString();
}
function FromRest14(T4, M2) {
  return T4.map((L3) => Intrinsic2(L3, M2));
}
function Intrinsic2(schema3, mode, options = {}) {
  return IsMappedKey3(schema3) ? IntrinsicFromMappedKey2(schema3, mode, options) : IsTemplateLiteral3(schema3) ? FromTemplateLiteral9(schema3, mode, schema3) : IsUnion3(schema3) ? Union3(FromRest14(schema3.anyOf, mode), options) : IsLiteral3(schema3) ? Literal2(FromLiteralValue2(schema3.const, mode), options) : schema3;
}

// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize2(T4, options = {}) {
  return Intrinsic2(T4, "Capitalize", options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase2(T4, options = {}) {
  return Intrinsic2(T4, "Lowercase", options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize2(T4, options = {}) {
  return Intrinsic2(T4, "Uncapitalize", options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase2(T4, options = {}) {
  return Intrinsic2(T4, "Uppercase", options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not4(schema3, options) {
  return {
    ...options,
    [Kind3]: "Not",
    not: CloneType2(schema3)
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties31(P4, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Omit2(P4[K2], K, options);
  return Acc;
}
function FromMappedResult21(R, K, options) {
  return FromProperties31(R.properties, K, options);
}
function OmitFromMappedResult2(R, K, options) {
  const P4 = FromMappedResult21(R, K, options);
  return MappedResult2(P4);
}

// ../node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect23(T4, K) {
  return T4.map((T5) => OmitResolve2(T5, K));
}
function FromUnion27(T4, K) {
  return T4.map((T5) => OmitResolve2(T5, K));
}
function FromProperty4(T4, K) {
  const { [K]: _3, ...R } = T4;
  return R;
}
function FromProperties32(T4, K) {
  return K.reduce((T5, K2) => FromProperty4(T5, K2), T4);
}
function OmitResolve2(T4, K) {
  return IsIntersect3(T4) ? Intersect3(FromIntersect23(T4.allOf, K)) : IsUnion3(T4) ? Union3(FromUnion27(T4.anyOf, K)) : IsObject6(T4) ? Object3(FromProperties32(T4.properties, K)) : Object3({});
}
function Omit2(T4, K, options = {}) {
  if (IsMappedKey3(K))
    return OmitFromMappedKey2(T4, K, options);
  if (IsMappedResult3(T4))
    return OmitFromMappedResult2(T4, K, options);
  const I4 = IsSchema3(K) ? IndexPropertyKeys2(K) : K;
  const D4 = Discard2(T4, [TransformKind3, "$id", "required"]);
  const R = CloneType2(OmitResolve2(T4, I4), options);
  return { ...D4, ...R };
}

// ../node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey5(T4, K, options) {
  return {
    [K]: Omit2(T4, [K], options)
  };
}
function FromPropertyKeys5(T4, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey5(T4, LK, options) };
  }, {});
}
function FromMappedKey7(T4, K, options) {
  return FromPropertyKeys5(T4, K.keys, options);
}
function OmitFromMappedKey2(T4, K, options) {
  const P4 = FromMappedKey7(T4, K, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters2(schema3, options = {}) {
  return Tuple2(CloneRest2(schema3.parameters), { ...options });
}
// ../node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest15(T4) {
  return T4.map((L3) => PartialResolve2(L3));
}
function FromProperties33(T4) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T4))
    Acc[K] = Optional2(T4[K]);
  return Acc;
}
function PartialResolve2(T4) {
  return IsIntersect3(T4) ? Intersect3(FromRest15(T4.allOf)) : IsUnion3(T4) ? Union3(FromRest15(T4.anyOf)) : IsObject6(T4) ? Object3(FromProperties33(T4.properties)) : Object3({});
}
function Partial2(T4, options = {}) {
  if (IsMappedResult3(T4))
    return PartialFromMappedResult2(T4, options);
  const D4 = Discard2(T4, [TransformKind3, "$id", "required"]);
  const R = CloneType2(PartialResolve2(T4), options);
  return { ...D4, ...R };
}

// ../node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties34(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial2(K[K2], options);
  return Acc;
}
function FromMappedResult22(R, options) {
  return FromProperties34(R.properties, options);
}
function PartialFromMappedResult2(R, options) {
  const P4 = FromMappedResult22(R, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties35(P4, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Pick2(P4[K2], K, options);
  return Acc;
}
function FromMappedResult23(R, K, options) {
  return FromProperties35(R.properties, K, options);
}
function PickFromMappedResult2(R, K, options) {
  const P4 = FromMappedResult23(R, K, options);
  return MappedResult2(P4);
}

// ../node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect24(T4, K) {
  return T4.map((T5) => PickResolve2(T5, K));
}
function FromUnion28(T4, K) {
  return T4.map((T5) => PickResolve2(T5, K));
}
function FromProperties36(T4, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T4)
      Acc[K2] = T4[K2];
  return Acc;
}
function PickResolve2(T4, K) {
  return IsIntersect3(T4) ? Intersect3(FromIntersect24(T4.allOf, K)) : IsUnion3(T4) ? Union3(FromUnion28(T4.anyOf, K)) : IsObject6(T4) ? Object3(FromProperties36(T4.properties, K)) : Object3({});
}
function Pick2(T4, K, options = {}) {
  if (IsMappedKey3(K))
    return PickFromMappedKey2(T4, K, options);
  if (IsMappedResult3(T4))
    return PickFromMappedResult2(T4, K, options);
  const I4 = IsSchema3(K) ? IndexPropertyKeys2(K) : K;
  const D4 = Discard2(T4, [TransformKind3, "$id", "required"]);
  const R = CloneType2(PickResolve2(T4, I4), options);
  return { ...D4, ...R };
}

// ../node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey6(T4, K, options) {
  return {
    [K]: Pick2(T4, [K], options)
  };
}
function FromPropertyKeys6(T4, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey6(T4, LK, options) };
  }, {});
}
function FromMappedKey8(T4, K, options) {
  return FromPropertyKeys6(T4, K.keys, options);
}
function PickFromMappedKey2(T4, K, options) {
  const P4 = FromMappedKey8(T4, K, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional2(schema3) {
  return Readonly2(Optional2(schema3));
}
// ../node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern2(pattern3, T4, options) {
  return {
    ...options,
    [Kind3]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType2(T4) }
  };
}
function RecordCreateFromKeys2(K, T4, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType2(T4);
  return Object3(Acc, { ...options, [Hint3]: "Record" });
}
function FromTemplateLiteralKey2(K, T4, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T4, options) : RecordCreateFromPattern2(K.pattern, T4, options);
}
function FromUnionKey2(K, T4, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(K)), T4, options);
}
function FromLiteralKey2(K, T4, options) {
  return RecordCreateFromKeys2([K.toString()], T4, options);
}
function FromRegExpKey2(K, T4, options) {
  return RecordCreateFromPattern2(K.source, T4, options);
}
function FromStringKey2(K, T4, options) {
  const pattern3 = IsUndefined5(K.pattern) ? PatternStringExact3 : K.pattern;
  return RecordCreateFromPattern2(pattern3, T4, options);
}
function FromIntegerKey2(_3, T4, options) {
  return RecordCreateFromPattern2(PatternNumberExact3, T4, options);
}
function FromNumberKey2(_3, T4, options) {
  return RecordCreateFromPattern2(PatternNumberExact3, T4, options);
}
function Record2(K, T4, options = {}) {
  return IsUnion3(K) ? FromUnionKey2(K.anyOf, T4, options) : IsTemplateLiteral3(K) ? FromTemplateLiteralKey2(K, T4, options) : IsLiteral3(K) ? FromLiteralKey2(K.const, T4, options) : IsInteger4(K) ? FromIntegerKey2(K, T4, options) : IsNumber6(K) ? FromNumberKey2(K, T4, options) : IsRegExp5(K) ? FromRegExpKey2(K, T4, options) : IsString6(K) ? FromStringKey2(K, T4, options) : Never2(options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal2 = 0;
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = callback({ [Kind3]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType2({ ...options, [Hint3]: "Recursive", ...thisType });
}
// ../node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref2(unresolved, options = {}) {
  if (IsString5(unresolved))
    return { ...options, [Kind3]: "Ref", $ref: unresolved };
  if (IsUndefined5(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind3]: "Ref",
    $ref: unresolved.$id
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp3(unresolved, options = {}) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind3]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// ../node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest16(T4) {
  return T4.map((L3) => RequiredResolve2(L3));
}
function FromProperties37(T4) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T4))
    Acc[K] = Discard2(T4[K], [OptionalKind3]);
  return Acc;
}
function RequiredResolve2(T4) {
  return IsIntersect3(T4) ? Intersect3(FromRest16(T4.allOf)) : IsUnion3(T4) ? Union3(FromRest16(T4.anyOf)) : IsObject6(T4) ? Object3(FromProperties37(T4.properties)) : Object3({});
}
function Required2(T4, options = {}) {
  if (IsMappedResult3(T4)) {
    return RequiredFromMappedResult2(T4, options);
  } else {
    const D4 = Discard2(T4, [TransformKind3, "$id", "required"]);
    const R = CloneType2(RequiredResolve2(T4), options);
    return { ...D4, ...R };
  }
}

// ../node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties38(P4, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P4))
    Acc[K2] = Required2(P4[K2], options);
  return Acc;
}
function FromMappedResult24(R, options) {
  return FromProperties38(R.properties, options);
}
function RequiredFromMappedResult2(R, options) {
  const P4 = FromMappedResult24(R, options);
  return MappedResult2(P4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve2(T4) {
  return IsIntersect3(T4) ? CloneRest2(T4.allOf) : IsUnion3(T4) ? CloneRest2(T4.anyOf) : IsTuple3(T4) ? CloneRest2(T4.items ?? []) : [];
}
function Rest2(T4) {
  return CloneRest2(RestResolve2(T4));
}
// ../node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType2(schema3, options = {}) {
  return CloneType2(schema3.returns, options);
}
// ../node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict2(schema4) {
  return JSON.parse(JSON.stringify(schema4));
}
// ../node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder2 {
  constructor(schema4) {
    this.schema = schema4;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder2(this.schema, decode2);
  }
}

class TransformEncodeBuilder2 {
  constructor(schema4, decode2) {
    this.schema = schema4;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema4) {
    const Encode2 = (value3) => schema4[TransformKind3].Encode(encode2(value3));
    const Decode2 = (value3) => this.decode(schema4[TransformKind3].Decode(value3));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema4, [TransformKind3]: Codec };
  }
  EncodeSchema(encode2, schema4) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema4, [TransformKind3]: Codec };
  }
  Encode(encode2) {
    const schema4 = CloneType2(this.schema);
    return IsTransform3(schema4) ? this.EncodeTransform(encode2, schema4) : this.EncodeSchema(encode2, schema4);
  }
}
function Transform2(schema4) {
  return new TransformDecodeBuilder2(schema4);
}
// ../node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe2(options = {}) {
  return {
    ...options,
    [Kind3]: options[Kind3] ?? "Unsafe"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void2(options = {}) {
  return {
    ...options,
    [Kind3]: "Void",
    type: "void"
  };
}
// ../node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type6 = {};
__export(exports_type6, {
  Void: () => Void2,
  Uppercase: () => Uppercase2,
  Unsafe: () => Unsafe2,
  Unknown: () => Unknown2,
  Union: () => Union3,
  Undefined: () => Undefined2,
  Uncapitalize: () => Uncapitalize2,
  Uint8Array: () => Uint8Array3,
  Tuple: () => Tuple2,
  Transform: () => Transform2,
  TemplateLiteral: () => TemplateLiteral2,
  Symbol: () => Symbol3,
  String: () => String3,
  Strict: () => Strict2,
  ReturnType: () => ReturnType2,
  Rest: () => Rest2,
  Required: () => Required2,
  RegExp: () => RegExp3,
  Ref: () => Ref2,
  Recursive: () => Recursive2,
  Record: () => Record2,
  ReadonlyOptional: () => ReadonlyOptional2,
  Readonly: () => Readonly2,
  Promise: () => Promise3,
  Pick: () => Pick2,
  Partial: () => Partial2,
  Parameters: () => Parameters2,
  Optional: () => Optional2,
  Omit: () => Omit2,
  Object: () => Object3,
  Number: () => Number3,
  Null: () => Null2,
  Not: () => Not4,
  Never: () => Never2,
  Mapped: () => Mapped2,
  Lowercase: () => Lowercase2,
  Literal: () => Literal2,
  KeyOf: () => KeyOf2,
  Iterator: () => Iterator3,
  Intersect: () => Intersect3,
  Integer: () => Integer2,
  InstanceType: () => InstanceType2,
  Index: () => Index3,
  Function: () => Function3,
  Extract: () => Extract2,
  Extends: () => Extends2,
  Exclude: () => Exclude2,
  Enum: () => Enum2,
  Deref: () => Deref3,
  Date: () => Date3,
  ConstructorParameters: () => ConstructorParameters2,
  Constructor: () => Constructor2,
  Const: () => Const2,
  Composite: () => Composite2,
  Capitalize: () => Capitalize2,
  Boolean: () => Boolean3,
  BigInt: () => BigInt3,
  Awaited: () => Awaited2,
  AsyncIterator: () => AsyncIterator3,
  Array: () => Array3,
  Any: () => Any2
});

// ../node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type2 = exports_type6;
// src/config.ts
var EMAIL_PROVIDER = process.env["EMAIL_PROVIDER"] === "SES" ? "SES" : "RESEND";

// ../node_modules/@aws-sdk/client-sesv2/dist-es/SESv2Client.js
init_dist_es3();
init_dist_es4();
init_dist_es5();
init_dist_es8();
init_dist_es11();
var import_core83 = __toESM(require_dist_cjs15(), 1);
init_dist_es12();
init_dist_es17();
init_dist_es22();
init_dist_es21();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/auth/httpAuthSchemeProvider.js
var import_core57 = __toESM(require_dist_cjs20(), 1);
init_dist_es10();
var defaultSESv2HttpAuthSchemeParametersProvider = async (config5, context8, input) => {
  return {
    operation: getSmithyContext(context8).operation,
    region: await normalizeProvider2(config5.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "ses",
      region: authParameters.region
    },
    propertiesExtractor: (config5, context8) => ({
      signingProperties: {
        config: config5,
        context: context8
      }
    })
  };
}
var defaultSESv2HttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options;
};
var resolveHttpAuthSchemeConfig = (config5) => {
  const config_0 = import_core57.resolveAwsSdkSigV4Config(config5);
  return {
    ...config_0
  };
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "ses"
  };
};
var commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
// ../node_modules/@aws-sdk/client-sesv2/package.json
var package_default = {
  name: "@aws-sdk/client-sesv2",
  description: "AWS SDK for JavaScript Sesv2 Client for Node.js, Browser and React Native",
  version: "3.675.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-sesv2",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sesv2"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/client-sso-oidc": "3.675.0",
    "@aws-sdk/client-sts": "3.675.0",
    "@aws-sdk/core": "3.667.0",
    "@aws-sdk/credential-provider-node": "3.675.0",
    "@aws-sdk/middleware-host-header": "3.667.0",
    "@aws-sdk/middleware-logger": "3.667.0",
    "@aws-sdk/middleware-recursion-detection": "3.667.0",
    "@aws-sdk/middleware-user-agent": "3.669.0",
    "@aws-sdk/region-config-resolver": "3.667.0",
    "@aws-sdk/types": "3.667.0",
    "@aws-sdk/util-endpoints": "3.667.0",
    "@aws-sdk/util-user-agent-browser": "3.675.0",
    "@aws-sdk/util-user-agent-node": "3.669.0",
    "@smithy/config-resolver": "^3.0.9",
    "@smithy/core": "^2.4.8",
    "@smithy/fetch-http-handler": "^3.2.9",
    "@smithy/hash-node": "^3.0.7",
    "@smithy/invalid-dependency": "^3.0.7",
    "@smithy/middleware-content-length": "^3.0.9",
    "@smithy/middleware-endpoint": "^3.1.4",
    "@smithy/middleware-retry": "^3.0.23",
    "@smithy/middleware-serde": "^3.0.7",
    "@smithy/middleware-stack": "^3.0.7",
    "@smithy/node-config-provider": "^3.1.8",
    "@smithy/node-http-handler": "^3.2.4",
    "@smithy/protocol-http": "^4.1.4",
    "@smithy/smithy-client": "^3.4.0",
    "@smithy/types": "^3.5.0",
    "@smithy/url-parser": "^3.0.7",
    "@smithy/util-base64": "^3.0.0",
    "@smithy/util-body-length-browser": "^3.0.0",
    "@smithy/util-body-length-node": "^3.0.0",
    "@smithy/util-defaults-mode-browser": "^3.0.23",
    "@smithy/util-defaults-mode-node": "^3.0.23",
    "@smithy/util-endpoints": "^2.1.3",
    "@smithy/util-middleware": "^3.0.7",
    "@smithy/util-retry": "^3.0.7",
    "@smithy/util-utf8": "^3.0.0",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@tsconfig/node16": "16.1.3",
    "@types/node": "^16.18.96",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=16.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sesv2",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sesv2"
  }
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeConfig.js
var import_core82 = __toESM(require_dist_cjs20(), 1);
init_dist_es45();
init_dist_es29();
init_dist_es11();
init_dist_es32();
init_dist_es22();
init_dist_es15();
init_dist_es27();
init_dist_es33();
init_dist_es19();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeConfig.shared.js
var import_core81 = __toESM(require_dist_cjs20(), 1);
init_dist_es21();
init_dist_es16();
init_dist_es34();
init_dist_es31();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/endpoint/endpointResolver.js
init_dist_es7();
init_dist_es6();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/endpoint/ruleset.js
var s7 = "required";
var t7 = "fn";
var u7 = "argv";
var v10 = "ref";
var a6 = true;
var b8 = "isSet";
var c7 = "booleanEquals";
var d8 = "error";
var e4 = "endpoint";
var f8 = "tree";
var g7 = "PartitionResult";
var h8 = { [s7]: false, type: "String" };
var i7 = { [s7]: true, default: false, type: "Boolean" };
var j8 = { [v10]: "Endpoint" };
var k8 = { [t7]: c7, [u7]: [{ [v10]: "UseFIPS" }, true] };
var l6 = { [t7]: c7, [u7]: [{ [v10]: "UseDualStack" }, true] };
var m8 = {};
var n5 = { [t7]: "getAttr", [u7]: [{ [v10]: g7 }, "supportsFIPS"] };
var o5 = { [t7]: c7, [u7]: [true, { [t7]: "getAttr", [u7]: [{ [v10]: g7 }, "supportsDualStack"] }] };
var p8 = [k8];
var q9 = [l6];
var r6 = [{ [v10]: "Region" }];
var _data4 = { version: "1.0", parameters: { Region: h8, UseDualStack: i7, UseFIPS: i7, Endpoint: h8 }, rules: [{ conditions: [{ [t7]: b8, [u7]: [j8] }], rules: [{ conditions: p8, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d8 }, { conditions: q9, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d8 }, { endpoint: { url: j8, properties: m8, headers: m8 }, type: e4 }], type: f8 }, { conditions: [{ [t7]: b8, [u7]: r6 }], rules: [{ conditions: [{ [t7]: "aws.partition", [u7]: r6, assign: g7 }], rules: [{ conditions: [k8, l6], rules: [{ conditions: [{ [t7]: c7, [u7]: [a6, n5] }, o5], rules: [{ endpoint: { url: "https://email-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m8, headers: m8 }, type: e4 }], type: f8 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d8 }], type: f8 }, { conditions: p8, rules: [{ conditions: [{ [t7]: c7, [u7]: [n5, a6] }], rules: [{ endpoint: { url: "https://email-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m8, headers: m8 }, type: e4 }], type: f8 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d8 }], type: f8 }, { conditions: q9, rules: [{ conditions: [o5], rules: [{ endpoint: { url: "https://email.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m8, headers: m8 }, type: e4 }], type: f8 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d8 }], type: f8 }, { endpoint: { url: "https://email.{Region}.{PartitionResult#dnsSuffix}", properties: m8, headers: m8 }, type: e4 }], type: f8 }], type: f8 }, { error: "Invalid Configuration: Missing Region", type: d8 }] };
var ruleSet4 = _data4;

// ../node_modules/@aws-sdk/client-sesv2/dist-es/endpoint/endpointResolver.js
var cache4 = new EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
});
var defaultEndpointResolver4 = (endpointParams, context8 = {}) => {
  return cache4.get(endpointParams, () => resolveEndpoint(ruleSet4, {
    endpointParams,
    logger: context8.logger
  }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeConfig.shared.js
var getRuntimeConfig7 = (config6) => {
  return {
    apiVersion: "2019-09-27",
    base64Decoder: config6?.base64Decoder ?? fromBase642,
    base64Encoder: config6?.base64Encoder ?? toBase642,
    disableHostPrefix: config6?.disableHostPrefix ?? false,
    endpointProvider: config6?.endpointProvider ?? defaultEndpointResolver4,
    extensions: config6?.extensions ?? [],
    httpAuthSchemeProvider: config6?.httpAuthSchemeProvider ?? defaultSESv2HttpAuthSchemeProvider,
    httpAuthSchemes: config6?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core81.AwsSdkSigV4Signer
      }
    ],
    logger: config6?.logger ?? new NoOpLogger,
    serviceId: config6?.serviceId ?? "SESv2",
    urlParser: config6?.urlParser ?? parseUrl3,
    utf8Decoder: config6?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config6?.utf8Encoder ?? toUtf8
  };
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeConfig.js
init_dist_es21();
init_dist_es35();
init_dist_es21();
var getRuntimeConfig8 = (config6) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config6);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig7(config6);
  import_core82.emitWarningIfUnsupportedVersion(process.version);
  return {
    ...clientSharedValues,
    ...config6,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config6?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config6?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config6?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    maxAttempts: config6?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config6?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: NodeHttpHandler.create(config6?.requestHandler ?? defaultConfigProvider),
    retryMode: config6?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config6?.sha256 ?? Hash3.bind(null, "sha256"),
    streamCollector: config6?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config6?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config6?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    userAgentAppId: config6?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS)
  };
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeExtensions.js
init_dist_es36();
init_dist_es2();
init_dist_es21();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration4 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig4 = (config6) => {
  return {
    httpAuthSchemes: config6.httpAuthSchemes(),
    httpAuthSchemeProvider: config6.httpAuthSchemeProvider(),
    credentials: config6.credentials()
  };
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/runtimeExtensions.js
var asPartial4 = (t4) => t4;
var resolveRuntimeExtensions4 = (runtimeConfig, extensions5) => {
  const extensionConfiguration = {
    ...asPartial4(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial4(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial4(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial4(getHttpAuthExtensionConfiguration4(runtimeConfig))
  };
  extensions5.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig4(extensionConfiguration)
  };
};

// ../node_modules/@aws-sdk/client-sesv2/dist-es/SESv2Client.js
class SESv2Client extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig8(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveRetryConfig(_config_2);
    const _config_4 = resolveRegionConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveEndpointConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions4(_config_7, configuration?.extensions || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(import_core83.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultSESv2HttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config6) => new import_core83.DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config6.credentials
      })
    }));
    this.middlewareStack.use(import_core83.getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}

// ../node_modules/@aws-sdk/client-sesv2/dist-es/protocols/Aws_restJson1.js
var import_core84 = __toESM(require_dist_cjs20(), 1);
var import_core85 = __toESM(require_dist_cjs15(), 1);
init_dist_es21();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/models/models_0.js
init_dist_es21();

// ../node_modules/@aws-sdk/client-sesv2/dist-es/models/SESv2ServiceException.js
init_dist_es21();
class SESv2ServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SESv2ServiceException.prototype);
  }
}

// ../node_modules/@aws-sdk/client-sesv2/dist-es/models/models_0.js
class AccountSuspendedException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "AccountSuspendedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccountSuspendedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AccountSuspendedException.prototype);
  }
}

class AlreadyExistsException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "AlreadyExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "AlreadyExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AlreadyExistsException.prototype);
  }
}

class BadRequestException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "BadRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "BadRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, BadRequestException.prototype);
  }
}
class InternalServiceErrorException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "InternalServiceErrorException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServiceErrorException";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalServiceErrorException.prototype);
  }
}

class NotFoundException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "NotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "NotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotFoundException.prototype);
  }
}

class TooManyRequestsException2 extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyRequestsException2.prototype);
  }
}
class ConcurrentModificationException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "ConcurrentModificationException",
      $fault: "server",
      ...opts
    });
    this.name = "ConcurrentModificationException";
    this.$fault = "server";
    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
  }
}

class ConflictException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "ConflictException",
      $fault: "client",
      ...opts
    });
    this.name = "ConflictException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ConflictException.prototype);
  }
}
class LimitExceededException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "LimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, LimitExceededException.prototype);
  }
}
class MailFromDomainNotVerifiedException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "MailFromDomainNotVerifiedException",
      $fault: "client",
      ...opts
    });
    this.name = "MailFromDomainNotVerifiedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MailFromDomainNotVerifiedException.prototype);
  }
}

class MessageRejected extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "MessageRejected",
      $fault: "client",
      ...opts
    });
    this.name = "MessageRejected";
    this.$fault = "client";
    Object.setPrototypeOf(this, MessageRejected.prototype);
  }
}

class SendingPausedException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "SendingPausedException",
      $fault: "client",
      ...opts
    });
    this.name = "SendingPausedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SendingPausedException.prototype);
  }
}
class InvalidNextTokenException extends SESv2ServiceException {
  constructor(opts) {
    super({
      name: "InvalidNextTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidNextTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidNextTokenException.prototype);
  }
}

// ../node_modules/@aws-sdk/client-sesv2/dist-es/protocols/Aws_restJson1.js
var se_SendEmailCommand = async (input, context8) => {
  const b4 = import_core85.requestBuilder(input, context8);
  const headers = {
    "content-type": "application/json"
  };
  b4.bp("/v2/email/outbound-emails");
  let body;
  body = JSON.stringify(take(input, {
    ConfigurationSetName: [],
    Content: (_4) => se_EmailContent(_4, context8),
    Destination: (_4) => _json(_4),
    EmailTags: (_4) => _json(_4),
    FeedbackForwardingEmailAddress: [],
    FeedbackForwardingEmailAddressIdentityArn: [],
    FromEmailAddress: [],
    FromEmailAddressIdentityArn: [],
    ListManagementOptions: (_4) => _json(_4),
    ReplyToAddresses: (_4) => _json(_4)
  }));
  b4.m("POST").h(headers).b(body);
  return b4.build();
};
var de_SendEmailCommand = async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError4(output, context8);
  }
  const contents = map5({
    $metadata: deserializeMetadata5(output)
  });
  const data = expectNonNull(expectObject(await import_core84.parseJsonBody(output.body, context8)), "body");
  const doc = take(data, {
    MessageId: expectString
  });
  Object.assign(contents, doc);
  return contents;
};
var de_CommandError4 = async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await import_core84.parseJsonErrorBody(output.body, context8)
  };
  const errorCode = import_core84.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.sesv2#BadRequestException":
      throw await de_BadRequestExceptionRes(parsedOutput, context8);
    case "InternalServiceErrorException":
    case "com.amazonaws.sesv2#InternalServiceErrorException":
      throw await de_InternalServiceErrorExceptionRes(parsedOutput, context8);
    case "NotFoundException":
    case "com.amazonaws.sesv2#NotFoundException":
      throw await de_NotFoundExceptionRes(parsedOutput, context8);
    case "TooManyRequestsException":
    case "com.amazonaws.sesv2#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes2(parsedOutput, context8);
    case "AlreadyExistsException":
    case "com.amazonaws.sesv2#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context8);
    case "ConcurrentModificationException":
    case "com.amazonaws.sesv2#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context8);
    case "LimitExceededException":
    case "com.amazonaws.sesv2#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context8);
    case "AccountSuspendedException":
    case "com.amazonaws.sesv2#AccountSuspendedException":
      throw await de_AccountSuspendedExceptionRes(parsedOutput, context8);
    case "MailFromDomainNotVerifiedException":
    case "com.amazonaws.sesv2#MailFromDomainNotVerifiedException":
      throw await de_MailFromDomainNotVerifiedExceptionRes(parsedOutput, context8);
    case "MessageRejected":
    case "com.amazonaws.sesv2#MessageRejected":
      throw await de_MessageRejectedRes(parsedOutput, context8);
    case "SendingPausedException":
    case "com.amazonaws.sesv2#SendingPausedException":
      throw await de_SendingPausedExceptionRes(parsedOutput, context8);
    case "InvalidNextTokenException":
    case "com.amazonaws.sesv2#InvalidNextTokenException":
      throw await de_InvalidNextTokenExceptionRes(parsedOutput, context8);
    case "ConflictException":
    case "com.amazonaws.sesv2#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError5({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError5 = withBaseException(SESv2ServiceException);
var de_AccountSuspendedExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new AccountSuspendedException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_AlreadyExistsExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new AlreadyExistsException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_BadRequestExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new BadRequestException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ConcurrentModificationExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ConflictExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ConflictException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InternalServiceErrorExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InternalServiceErrorException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidNextTokenExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidNextTokenException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_LimitExceededExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_MailFromDomainNotVerifiedExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new MailFromDomainNotVerifiedException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_MessageRejectedRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new MessageRejected({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NotFoundExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new NotFoundException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_SendingPausedExceptionRes = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new SendingPausedException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_TooManyRequestsExceptionRes2 = async (parsedOutput, context8) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException2({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var se_EmailContent = (input, context8) => {
  return take(input, {
    Raw: (_4) => se_RawMessage(_4, context8),
    Simple: _json,
    Template: _json
  });
};
var se_RawMessage = (input, context8) => {
  return take(input, {
    Data: context8.base64Encoder
  });
};
var deserializeMetadata5 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// ../node_modules/@aws-sdk/client-sesv2/dist-es/commands/SendEmailCommand.js
init_dist_es17();
var import_middleware_serde18 = __toESM(require_dist_cjs3(), 1);
init_dist_es21();
class SendEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config6, o6) {
  return [
    import_middleware_serde18.getSerdePlugin(config6, this.serialize, this.deserialize),
    getEndpointPlugin(config6, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService_v2", "SendEmail", {}).n("SESv2Client", "SendEmailCommand").f(undefined, undefined).ser(se_SendEmailCommand).de(de_SendEmailCommand).build() {
}

// src/libs/ses.ts
var sesClient = new SESv2Client({
  credentials: {
    accessKeyId: AMAZON_ACCESS_KEY,
    secretAccessKey: AMAZON_SECRET_ACCESS_KEY
  },
  region: "us-east-1"
});
var sendEmail = async (input) => {
  const sesInput = {
    Content: {
      Simple: {
        Subject: {
          Data: input.content.subject
        },
        Body: input.content.type === "html" ? { Html: { Data: input.content.html } } : { Text: { Data: input.content.text } }
      }
    },
    FromEmailAddress: `"Inline" <${input.from}>`,
    Destination: { ToAddresses: [input.to] },
    ReplyToAddresses: ["hi@inline.chat"]
  };
  return await sesClient.send(new SendEmailCommand(sesInput));
};

// ../node_modules/@react-email/render/dist/node/index.mjs
init_server_node();

// ../node_modules/domelementtype/lib/esm/index.js
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// ../node_modules/domhandler/lib/esm/node.js
class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive5 = false) {
    return cloneNode(this, recursive5);
  }
}

class DataNode extends Node {
  constructor(data) {
    super();
    this.data = data;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}

class Text2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}

class Comment2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}

class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}

class NodeWithChildren extends Node {
  constructor(children) {
    super();
    this.children = children;
  }
  get firstChild() {
    var _a3;
    return (_a3 = this.children[0]) !== null && _a3 !== undefined ? _a3 : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}

class CDATA2 extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}

class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}

class Element2 extends NodeWithChildren {
  constructor(name, attribs, children = [], type5 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type5;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a3, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a3 = this["x-attribsNamespace"]) === null || _a3 === undefined ? undefined : _a3[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
      };
    });
  }
}
function isTag2(node2) {
  return isTag(node2);
}
function isCDATA(node2) {
  return node2.type === ElementType.CDATA;
}
function isText(node2) {
  return node2.type === ElementType.Text;
}
function isComment(node2) {
  return node2.type === ElementType.Comment;
}
function isDirective(node2) {
  return node2.type === ElementType.Directive;
}
function isDocument(node2) {
  return node2.type === ElementType.Root;
}
function cloneNode(node2, recursive5 = false) {
  let result;
  if (isText(node2)) {
    result = new Text2(node2.data);
  } else if (isComment(node2)) {
    result = new Comment2(node2.data);
  } else if (isTag2(node2)) {
    const children = recursive5 ? cloneChildren(node2.children) : [];
    const clone5 = new Element2(node2.name, { ...node2.attribs }, children);
    children.forEach((child) => child.parent = clone5);
    if (node2.namespace != null) {
      clone5.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone5["x-attribsNamespace"] = { ...node2["x-attribsNamespace"] };
    }
    if (node2["x-attribsPrefix"]) {
      clone5["x-attribsPrefix"] = { ...node2["x-attribsPrefix"] };
    }
    result = clone5;
  } else if (isCDATA(node2)) {
    const children = recursive5 ? cloneChildren(node2.children) : [];
    const clone5 = new CDATA2(children);
    children.forEach((child) => child.parent = clone5);
    result = clone5;
  } else if (isDocument(node2)) {
    const children = recursive5 ? cloneChildren(node2.children) : [];
    const clone5 = new Document(children);
    children.forEach((child) => child.parent = clone5);
    if (node2["x-mode"]) {
      clone5["x-mode"] = node2["x-mode"];
    }
    result = clone5;
  } else if (isDirective(node2)) {
    const instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node2.type}`);
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i4 = 1;i4 < children.length; i4++) {
    children[i4].prev = children[i4 - 1];
    children[i4 - 1].next = children[i4];
  }
  return children;
}

// ../node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error5) {
    this.handleCallback(error5);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type5 = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element2(name, attribs, undefined, type5);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node3 = new Text2(data);
      this.addNode(node3);
      this.lastNode = node3;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node3 = new Comment2(data);
    this.addNode(node3);
    this.lastNode = node3;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text4 = new Text2("");
    const node3 = new CDATA2([text4]);
    this.addNode(node3);
    text4.parent = node3;
    this.lastNode = text4;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node3 = new ProcessingInstruction(name, data);
    this.addNode(node3);
  }
  handleCallback(error5) {
    if (typeof this.callback === "function") {
      this.callback(error5, this.dom);
    } else if (error5) {
      throw error5;
    }
  }
  addNode(node3) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node3.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node3.endIndex = this.parser.endIndex;
    }
    parent.children.push(node3);
    if (previousSibling) {
      node3.prev = previousSibling;
      previousSibling.next = node3;
    }
    node3.parent = parent;
    this.lastNode = null;
  }
}

// ../node_modules/leac/lib/leac.mjs
var e5 = /\n/g;
function n9(n10) {
  const o6 = [...n10.matchAll(e5)].map((e6) => e6.index || 0);
  o6.unshift(-1);
  const s5 = t11(o6, 0, o6.length);
  return (e6) => r10(s5, e6);
}
function t11(e6, n10, r4) {
  if (r4 - n10 == 1)
    return { offset: e6[n10], index: n10 + 1 };
  const o6 = Math.ceil((n10 + r4) / 2), s5 = t11(e6, n10, o6), l4 = t11(e6, o6, r4);
  return { offset: s5.offset, low: s5, high: l4 };
}
function r10(e6, n10) {
  return function(e7) {
    return Object.prototype.hasOwnProperty.call(e7, "index");
  }(e6) ? { line: e6.index, column: n10 - e6.offset } : r10(e6.high.offset < n10 ? e6.high : e6.low, n10);
}
function o6(e6, t4 = "", r4 = {}) {
  const o7 = typeof t4 != "string" ? t4 : r4, l4 = typeof t4 == "string" ? t4 : "", c4 = e6.map(s9), f4 = !!o7.lineNumbers;
  return function(e7, t12 = 0) {
    const r11 = f4 ? n9(e7) : () => ({ line: 0, column: 0 });
    let o8 = t12;
    const s5 = [];
    e:
      for (;o8 < e7.length; ) {
        let n10 = false;
        for (const t13 of c4) {
          t13.regex.lastIndex = o8;
          const c8 = t13.regex.exec(e7);
          if (c8 && c8[0].length > 0) {
            if (!t13.discard) {
              const e8 = r11(o8), n11 = typeof t13.replace == "string" ? c8[0].replace(new RegExp(t13.regex.source, t13.regex.flags), t13.replace) : c8[0];
              s5.push({ state: l4, name: t13.name, text: n11, offset: o8, len: c8[0].length, line: e8.line, column: e8.column });
            }
            if (o8 = t13.regex.lastIndex, n10 = true, t13.push) {
              const n11 = t13.push(e7, o8);
              s5.push(...n11.tokens), o8 = n11.offset;
            }
            if (t13.pop)
              break e;
            break;
          }
        }
        if (!n10)
          break;
      }
    return { tokens: s5, offset: o8, complete: e7.length <= o8 };
  };
}
function s9(e6, n10) {
  return { ...e6, regex: l10(e6, n10) };
}
function l10(e6, n10) {
  if (e6.name.length === 0)
    throw new Error(`Rule #${n10} has empty name, which is not allowed.`);
  if (function(e7) {
    return Object.prototype.hasOwnProperty.call(e7, "regex");
  }(e6))
    return function(e7) {
      if (e7.global)
        throw new Error(`Regular expression /${e7.source}/${e7.flags} contains the global flag, which is not allowed.`);
      return e7.sticky ? e7 : new RegExp(e7.source, e7.flags + "y");
    }(e6.regex);
  if (function(e7) {
    return Object.prototype.hasOwnProperty.call(e7, "str");
  }(e6)) {
    if (e6.str.length === 0)
      throw new Error(`Rule #${n10} ("${e6.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c8(e6.str), "y");
  }
  return new RegExp(c8(e6.name), "y");
}
function c8(e6) {
  return e6.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}

// ../node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i4) => {
    let position = i4;
    let value3 = undefined;
    if (i4 < data.tokens.length) {
      value3 = onToken(data.tokens[i4], data, i4);
      if (value3 !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i4);
    }
    return value3 === undefined ? { matched: false } : {
      matched: true,
      position,
      value: value3
    };
  };
}
function mapInner(r4, f4) {
  return r4.matched ? {
    matched: true,
    position: r4.position,
    value: f4(r4.value, r4.position)
  } : r4;
}
function mapOuter(r4, f4) {
  return r4.matched ? f4(r4) : r4;
}
function map6(p4, mapper) {
  return (data, i4) => mapInner(p4(data, i4), (v7, j5) => mapper(v7, data, i4, j5));
}
function option(p4, def) {
  return (data, i4) => {
    const r4 = p4(data, i4);
    return r4.matched ? r4 : {
      matched: true,
      position: i4,
      value: def
    };
  };
}
function choice(...ps) {
  return (data, i4) => {
    for (const p4 of ps) {
      const result = p4(data, i4);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa3, pb2) {
  return (data, i4) => {
    const r12 = pa3(data, i4);
    return r12.matched ? r12 : pb2(data, i4);
  };
}
function takeWhile(p4, test) {
  return (data, i4) => {
    const values2 = [];
    let success = true;
    do {
      const r4 = p4(data, i4);
      if (r4.matched && test(r4.value, values2.length + 1, data, i4, r4.position)) {
        values2.push(r4.value);
        i4 = r4.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i4,
      value: values2
    };
  };
}
function many(p4) {
  return takeWhile(p4, () => true);
}
function many1(p4) {
  return ab3(p4, many(p4), (head, tail) => [head, ...tail]);
}
function ab3(pa3, pb2, join10) {
  return (data, i4) => mapOuter(pa3(data, i4), (ma3) => mapInner(pb2(data, ma3.position), (vb3, j5) => join10(ma3.value, vb3, data, i4, j5)));
}
function left(pa3, pb2) {
  return ab3(pa3, pb2, (va3) => va3);
}
function right(pa3, pb2) {
  return ab3(pa3, pb2, (va3, vb3) => vb3);
}
function abc(pa3, pb2, pc2, join10) {
  return (data, i4) => mapOuter(pa3(data, i4), (ma3) => mapOuter(pb2(data, ma3.position), (mb3) => mapInner(pc2(data, mb3.position), (vc2, j5) => join10(ma3.value, mb3.value, vc2, data, i4, j5))));
}
function middle(pa3, pb2, pc2) {
  return abc(pa3, pb2, pc2, (ra3, rb6) => rb6);
}
function all(...ps) {
  return (data, i4) => {
    const result = [];
    let position = i4;
    for (const p4 of ps) {
      const r12 = p4(data, position);
      if (r12.matched) {
        result.push(r12.value);
        position = r12.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten2(...ps) {
  return flatten1(all(...ps));
}
function flatten1(p4) {
  return map6(p4, (vs) => vs.flatMap((v7) => v7));
}
function chainReduce(acc, f4) {
  return (data, i4) => {
    let loop = true;
    let acc1 = acc;
    let pos = i4;
    do {
      const r4 = f4(acc1, data, pos)(data, pos);
      if (r4.matched) {
        acc1 = r4.value;
        pos = r4.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p4, reducer) {
  return chainReduce(acc, (acc2) => map6(p4, (v7, data, i4, j5) => reducer(acc2, v7, data, i4, j5)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain3(pLeft, (v02) => reduceLeft(v02, ab3(pOper, pRight, (f4, y4) => [f4, y4]), (acc, [f4, y4]) => f4(acc, y4)));
}
function chain3(p4, f4) {
  return (data, i4) => mapOuter(p4(data, i4), (m12) => f4(m12.value, data, i4, m12.position)(data, m12.position));
}

// ../node_modules/parseley/lib/parseley.mjs
var ws = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape3 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape3})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape3})`;
var name = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape3})*'`;
var string22 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape3})*"`;
var lexSelector = o6([
  { name: "ws", regex: new RegExp(ws) },
  { name: "hash", regex: new RegExp(`#${name}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string22, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o6([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape3, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
function sumSpec([a02, a12, a22], [b02, b12, b22]) {
  return [a02 + b02, a12 + b12, a22 + b22];
}
function sumAllSpec(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
}
var unicodeEscapedSequence_ = token((t4) => t4.name === "unicode" ? String.fromCodePoint(parseInt(t4.text.slice(1), 16)) : undefined);
var escapedSequence_ = token((t4) => t4.name === "escape" ? t4.text.slice(1) : undefined);
var anyChar_ = token((t4) => t4.name === "any" ? t4.text : undefined);
var escapedString_ = map6(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(""));
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result.value;
}
function literal5(name2) {
  return token((t4) => t4.name === name2 ? true : undefined);
}
var whitespace_ = token((t4) => t4.name === "ws" ? null : undefined);
var optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
var identifier_ = token((t4) => t4.name === "ident" ? unescape2(t4.text) : undefined);
var hashId_ = token((t4) => t4.name === "hash" ? unescape2(t4.text.slice(1)) : undefined);
var string_ = token((t4) => t4.name.startsWith("str") ? unescape2(t4.text.slice(1, -1)) : undefined);
var namespace_ = left(option(identifier_, ""), literal5("|"));
var qualifiedName_ = otherwise(ab3(namespace_, identifier_, (ns, name2) => ({ name: name2, namespace: ns })), map6(identifier_, (name2) => ({ name: name2, namespace: null })));
var uniSelector_ = otherwise(ab3(namespace_, literal5("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map6(literal5("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map6(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab3(literal5("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
var idSelector_ = map6(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t4) => {
  if (t4.name === "ident") {
    if (t4.text === "i" || t4.text === "I") {
      return "i";
    }
    if (t4.text === "s" || t4.text === "S") {
      return "s";
    }
  }
  return;
});
var attrValue_ = otherwise(ab3(string_, option(right(optionalWhitespace_, attrModifier_), null), (v7, mod) => ({ value: v7, modifier: mod })), ab3(identifier_, option(right(whitespace_, attrModifier_), null), (v7, mod) => ({ value: v7, modifier: mod })));
var attrMatcher_ = choice(map6(literal5("="), () => "="), ab3(literal5("~"), literal5("="), () => "~="), ab3(literal5("|"), literal5("="), () => "|="), ab3(literal5("^"), literal5("="), () => "^="), ab3(literal5("$"), literal5("="), () => "$="), ab3(literal5("*"), literal5("="), () => "*="));
var attrPresenceSelector_ = abc(literal5("["), optionallySpaced(qualifiedName_), literal5("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal5("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value: value3, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value: value3,
  modifier,
  specificity: [0, 1, 0]
})), literal5("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map6(otherwise(flatten2(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
  return {
    type: "compound",
    list: ss,
    specificity: sumAllSpec(ss.map((s5) => s5.specificity))
  };
});
var combinator_ = choice(map6(literal5(">"), () => ">"), map6(literal5("+"), () => "+"), map6(literal5("~"), () => "~"), ab3(literal5("|"), literal5("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map6(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map6(combinatorSeparator_, (c4) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c4, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map6(complexSelector_, (s5) => ({ type: "list", list: [s5] })), map6(optionallySpaced(literal5(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!\n` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m4, t4, r4) => t4 ? "\u2409" : r4 ? "\u240D" : "\u240A")}\n${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node3) => {
        if (node3.type === "combinator") {
          return serialize(node3) + acc;
        } else {
          return acc + serialize(node3);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns) {
  return ns || ns === "" ? _serIdent(ns) + "|" : "";
}
function _codePoint(char2) {
  return `\\${char2.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m4, d12, d22, hy, safe, nl2, ctrl, other) => d12 ? _codePoint(d12) : d22 ? "-" + _codePoint(d22.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
}
function _serStr(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m4, dq, bs, nl2, ctrl) => dq ? '\\"' : bs ? "\\\\" : nl2 ? "\uFFFD" : _codePoint(ctrl));
}
function normalize5(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize5);
      selector.list.sort((a4, b4) => _compareArrays(_getSelectorPriority(a4), _getSelectorPriority(b4)));
      break;
    }
    case "combinator": {
      normalize5(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize5);
      selector.list.sort((a4, b4) => serialize(a4) < serialize(b4) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a4, b4) {
  return _compareArrays(a4, b4);
}
function _compareArrays(a4, b4) {
  if (!Array.isArray(a4) || !Array.isArray(b4)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a4.length < b4.length ? a4.length : b4.length;
  for (let i4 = 0;i4 < shorter; i4++) {
    if (a4[i4] === b4[i4]) {
      continue;
    }
    return a4[i4] < b4[i4] ? -1 : 1;
  }
  return a4.length - b4.length;
}

// ../node_modules/selderee/lib/selderee.mjs
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array5) {
  const len = array5.length;
  const results = new Array(len);
  for (let i4 = 0;i4 < len; i4++) {
    const [selectorString, val2] = array5[i4];
    const ast = preprocess(parse1(selectorString));
    results[i4] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i4, value: val2, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize5(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest: rest5 } = partition3(terminal.cont, (node3) => node3.type === "terminal");
      matches.forEach((node3) => results.push(node3));
      if (rest5.length) {
        terminal.cont = rest5;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node3) => getSelectorKind(node3) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x4) => x4.type === "tag", (x4) => x4.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x4) => x4.type === "attrPresence" && x4.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x4) => x4.type === "attrValue" && x4.name === name2, (x4) => `${x4.matcher} ${x4.modifier || ""} ${x4.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower2 = actual.toLowerCase();
          return expected === lower2 || lower2.startsWith(expected) && lower2[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x4) => x4.type === "combinator" && x4.combinator === combinator, (x4) => serialize(x4.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest: rest5 } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest5;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i4 = simpsels.length;i4-- > 0; ) {
    if (predicate(simpsels[i4])) {
      matches[i4] = true;
      firstIndex = i4;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i4) => !matches[i4]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node3 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node3)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition3(src, predicate) {
  const matches = [];
  const rest5 = [];
  for (const x4 of src) {
    if (predicate(x4)) {
      matches.push(x4);
    } else {
      rest5.push(x4);
    }
  }
  return { matches, rest: rest5 };
}
function partition1(src, predicate) {
  const matches = [];
  const rest5 = [];
  for (const x4 of src) {
    if (predicate(x4)) {
      matches.push(x4);
    } else {
      rest5.push(x4);
    }
  }
  return { matches, rest: rest5 };
}

class Picker {
  constructor(f4) {
    this.f = f4;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i4 = 1;i4 < len; i4++) {
      const next = results[i4];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}

// ../node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m4) => m4(el, ...tail));
}
function handleNode(node3) {
  switch (node3.type) {
    case "terminal": {
      const result = [node3.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node3);
    case "attrValue":
      return handleAttrValueName(node3);
    case "attrPresence":
      return handleAttrPresenceName(node3);
    case "pushElement":
      return handlePushElementNode(node3);
    case "popElement":
      return handlePopElementNode(node3);
  }
}
function handleTagName(node3) {
  const variants = {};
  for (const variant of node3.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node3) {
  const attrName = node3.name;
  const continuation = handleArray(node3.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node3) {
  const callbacks = [];
  for (const matcher of node3.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node3.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb3) => cb3(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node3) {
  const continuation = handleArray(node3.cont);
  const leftElementGetter = node3.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};
function handlePopElementNode(node3) {
  const continuation = handleArray(node3.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}

// ../node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c4) => c4.charCodeAt(0)));

// ../node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c4) => c4.charCodeAt(0)));

// ../node_modules/entities/lib/esm/decode_codepoint.js
var _a3;
var decodeMap = new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a3 = String.fromCodePoint) !== null && _a3 !== undefined ? _a3 : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function replaceCodePoint(codePoint) {
  var _a4;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a4 = decodeMap.get(codePoint)) !== null && _a4 !== undefined ? _a4 : codePoint;
}
// ../node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2) || isHexadecimalCharacter(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a4;
    if (this.consumed <= expectedLength) {
      (_a4 = this.errors) === null || _a4 === undefined || _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char2 = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a4;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a4 = this.errors) === null || _a4 === undefined || _a4.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a4;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a4 = this.errors) === null || _a4 === undefined || _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value3 = char2 - jumpOffset;
    return value3 < 0 || value3 >= branchCount ? -1 : decodeTree[nodeIdx + value3] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo = mid + 1;
    } else if (midVal > char2) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// ../node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c4) {
  return c4 === CharCodes2.Space || c4 === CharCodes2.NewLine || c4 === CharCodes2.Tab || c4 === CharCodes2.FormFeed || c4 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c4) {
  return c4 === CharCodes2.Slash || c4 === CharCodes2.Gt || isWhitespace(c4);
}
function isNumber2(c4) {
  return c4 >= CharCodes2.Zero && c4 <= CharCodes2.Nine;
}
function isASCIIAlpha(c4) {
  return c4 >= CharCodes2.LowerA && c4 <= CharCodes2.LowerZ || c4 >= CharCodes2.UpperA && c4 <= CharCodes2.UpperZ;
}
function isHexDigit(c4) {
  return c4 >= CharCodes2.UpperA && c4 <= CharCodes2.UpperF || c4 >= CharCodes2.LowerA && c4 <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
};

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c4) {
    if (c4 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c4) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c4) : (c4 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c4);
  }
  stateInSpecialTag(c4) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c4 === CharCodes2.Gt || isWhitespace(c4)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c4);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c4 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c4 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c4 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c4) {
    if (c4 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c4);
    }
  }
  fastForwardTo(c4) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c4) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c4) {
    if (c4 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c4 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c4) {
    return this.xmlMode ? !isEndOfTagSection(c4) : isASCIIAlpha(c4);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c4) {
    if (c4 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c4)) {
      const lower2 = c4 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower2 === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower2 === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c4 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c4);
    }
  }
  stateInTagName(c4) {
    if (isEndOfTagSection(c4)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    }
  }
  stateBeforeClosingTagName(c4) {
    if (isWhitespace(c4)) {
    } else if (c4 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c4) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c4) {
    if (c4 === CharCodes2.Gt || isWhitespace(c4)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c4);
    }
  }
  stateAfterClosingTagName(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c4) {
    if (c4 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c4)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c4) {
    if (c4 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c4)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    }
  }
  stateInAttributeName(c4) {
    if (c4 === CharCodes2.Eq || isEndOfTagSection(c4)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c4);
    }
  }
  stateAfterAttributeName(c4) {
    if (c4 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c4 === CharCodes2.Slash || c4 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    } else if (!isWhitespace(c4)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c4) {
    if (c4 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c4)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c4);
    }
  }
  handleInAttributeValue(c4, quote) {
    if (c4 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c4) {
    this.handleInAttributeValue(c4, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c4) {
    this.handleInAttributeValue(c4, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c4) {
    if (isWhitespace(c4) || c4 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c4) {
    if (c4 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c4 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c4) {
    if (c4 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c4) {
    const lower2 = c4 | 32;
    if (lower2 === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower2 === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c4);
    }
  }
  stateBeforeEntity(c4) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c4 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c4 === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c4);
    }
  }
  stateInNamedEntity(c4) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c4);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c4 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c4) {
    if ((c4 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c4);
    }
  }
  emitNumericEntity(strict5) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict5);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c4) {
    if (c4 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c4)) {
      this.entityResult = this.entityResult * 10 + (c4 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c4) {
    if (c4 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c4)) {
      this.entityResult = this.entityResult * 16 + (c4 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c4)) {
      this.entityResult = this.entityResult * 16 + ((c4 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c4 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c4);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c4);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c4);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c4);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c4);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c4);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c4);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c4);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c4);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c4);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c4);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c4);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c4);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c4);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c4);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c4);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c4);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c4);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c4);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c4);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c4);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c4);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c4);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c4);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c4);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c4);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c4);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c4);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c4);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}

// ../node_modules/htmlparser2/lib/esm/Parser.js
var formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;

class Parser {
  constructor(cbs, options = {}) {
    var _a4, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a4 = options.lowerCaseTags) !== null && _a4 !== undefined ? _a4 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a4, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === undefined || _b.call(_a4, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a4, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === undefined || _b.call(_a4, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a4, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a4 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a4, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a4, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a4 = this.cbs).onopentag) === null || _b === undefined || _b.call(_a4, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a4, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a4 = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a4, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a4, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a4 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a4, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a4, _b;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).onattribute) === null || _b === undefined || _b.call(_a4, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value3) {
    const index2 = value3.search(reNameEnd);
    let name2 = index2 < 0 ? value3 : value3.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value3 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value3);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value3}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value3 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value3);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value3}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a4, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).oncomment) === null || _b === undefined || _b.call(_a4, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value3 = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a4 = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a4);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value3);
      (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value3}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a4, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length;index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a4 = this.cbs).onend) === null || _b === undefined || _b.call(_a4);
  }
  reset() {
    var _a4, _b, _c, _d;
    (_b = (_a4 = this.cbs).onreset) === null || _b === undefined || _b.call(_a4);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === undefined || _b.call(_a4, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === undefined || _b.call(_a4, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}
// ../node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (c4, index2) => (c4.charCodeAt(index2) & 64512) === 55296 ? (c4.charCodeAt(index2) - 55296) * 1024 + c4.charCodeAt(index2 + 1) - 56320 + 65536 : c4.charCodeAt(index2);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i4 = match.index;
    const char2 = str.charCodeAt(i4);
    const next = xmlCodeMap.get(char2);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i4) + next;
      lastIdx = i4 + 1;
    } else {
      ret += `${str.substring(lastIdx, i4)}&#x${getCodePoint(str, i4).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char2 & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map7) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map7.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
// ../node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// ../node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));

// ../node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value3) {
  return value3.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a4;
  if (!attributes)
    return;
  const encode3 = ((_a4 = opts.encodeEntities) !== null && _a4 !== undefined ? _a4 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a5, _b;
    const value3 = (_a5 = attributes[key]) !== null && _a5 !== undefined ? _a5 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value3 === "") {
      return key;
    }
    return `${key}="${encode3(value3)}"`;
  }).join(" ");
}
var singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node3, options = {}) {
  const nodes = "length" in node3 ? node3 : [node3];
  let output = "";
  for (let i4 = 0;i4 < nodes.length; i4++) {
    output += renderNode(nodes[i4], options);
  }
  return output;
}
function renderNode(node3, options) {
  switch (node3.type) {
    case Root:
      return render(node3.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node3);
    case Comment:
      return renderComment(node3);
    case CDATA:
      return renderCdata(node3);
    case Script:
    case Style:
    case Tag:
      return renderTag(node3, options);
    case Text:
      return renderText(node3, options);
  }
}
var foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a4;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a4 = elementNames.get(elem.name)) !== null && _a4 !== undefined ? _a4 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a4;
  let data = elem.data || "";
  if (((_a4 = opts.encodeEntities) !== null && _a4 !== undefined ? _a4 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// ../node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser(handler, options).end(data);
  return handler.root;
}

// ../node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs(), 1);
function limitedDepthRecursive(n10, f4, g4 = () => {
  return;
}) {
  if (n10 === undefined) {
    const f12 = function(...args) {
      return f4(f12, ...args);
    };
    return f12;
  }
  if (n10 >= 0) {
    return function(...args) {
      return f4(limitedDepthRecursive(n10 - 1, f4, g4), ...args);
    };
  }
  return g4;
}
function trimCharacter(str, char2) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char2) {
    ++start;
  }
  while (end > start && str[end - 1] === char2) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char2) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char2) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c4) => "\\u" + c4.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map7 = new Map;
  for (let i4 = items.length;i4-- > 0; ) {
    const item = items[i4];
    const key = getKey(item);
    map7.set(key, map7.has(key) ? import_deepmerge.default(item, map7.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map7.values()].reverse();
}
var overwriteMerge$1 = (acc, src, options) => [...src];
function get(obj, path4) {
  for (const key of path4) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n10) => String.fromCharCode(baseCode + n10)).join("");
}
var I9 = ["I", "X", "C", "M"];
var V9 = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n10) => +n10).reverse().map((v7, i4) => v7 % 5 < 4 ? (v7 < 5 ? "" : V9[i4]) + I9[i4].repeat(v7 % 5) : I9[i4] + (v7 < 5 ? V9[i4] : I9[i4 + 1])).reverse().join("");
}

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest5] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest5) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n10 = 1) {
    this.lines.push(this.nextLineWords);
    if (n10 > 1) {
      this.lines.push(...Array.from({ length: n10 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}

class BlockStackItem extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = undefined,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = undefined,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor(options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor(next = null, transform6) {
    super(next);
    this.transform = transform6;
  }
}
function charactersToCodes(str) {
  return [...str].map((c4) => "\\u" + c4.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]\$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*\$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text4, inlineTextBuilder, transform6 = (str) => str, noWrap = false) {
        if (!text4) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m4 = wordOrNewlineRe.exec(text4);
        if (m4) {
          anyMatch = true;
          if (m4[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text4)) {
            inlineTextBuilder.pushWord(transform6(m4[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform6(m4[0]), noWrap);
          }
          while ((m4 = wordOrNewlineRe.exec(text4)) !== null) {
            if (m4[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform6(m4[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text4);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text4, inlineTextBuilder, transform6 = (str) => str, noWrap = false) {
        if (!text4) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m4 = wordRe.exec(text4);
        if (m4) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text4)) {
            inlineTextBuilder.pushWord(transform6(m4[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform6(m4[0]), noWrap);
          }
          while ((m4 = wordRe.exec(text4)) !== null) {
            inlineTextBuilder.pushWord(transform6(m4[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text4);
      };
    }
  }
  addLiteral(text4, inlineTextBuilder, noWrap = true) {
    if (!text4) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m4 = this.newlineOrNonNewlineStringRe.exec(text4);
    if (m4) {
      anyMatch = true;
      if (m4[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m4[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m4[0], noWrap);
      }
      while ((m4 = this.newlineOrNonNewlineStringRe.exec(text4)) !== null) {
        if (m4[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m4[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text4) {
    return this.leadingWhitespaceRe.test(text4);
  }
  testTrailingWhitespace(text4) {
    return this.trailingWhitespaceRe.test(text4);
  }
  testContainsWords(text4) {
    return !this.allWhitespaceOrEmptyRe.test(text4);
  }
  countNewlinesNoWords(text4) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text4)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform6 = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform6;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce = this.options.encodeCharacters;
    return wt ? ce ? (str) => ce(wt(str)) : wt : ce;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can\'t add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text4 = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(list, text4, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text4 = getText(list);
    if (text4) {
      addText(this._stackItem, text4, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can\'t add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can\'t add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text4 = trimCharacter(getText(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text: text4 });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text4, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text4;
  } else {
    stackItem.rawText = text4;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s5) => !s5.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s5) => `\`${s5.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s5) => [s5.selector, s5])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s5, i4) => [s5, i4 + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html, metadata = undefined) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a4, b4) => a4.selectorIndex - b4.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x4) => x4.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format3 = options.formatters[tagDefinition.format];
        format3(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v7]) => v7 !== false);
  const regex = new RegExp(entries.map(([c4]) => `(${unicodeEscape([...c4][0])})`).join("|"), "g");
  const values2 = entries.map(([, v7]) => v7);
  const replacer = (m4, ...cgs) => values2[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k4, v7]) => v7 === "" ? k4 : `${k4}=${v7.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j5) {
  if (!matrix[j5]) {
    matrix[j5] = [];
  }
  return matrix[j5];
}
function findFirstVacantIndex(row, x4 = 0) {
  while (row[x4]) {
    x4++;
  }
  return x4;
}
function transposeInPlace(matrix, maxSize) {
  for (let i4 = 0;i4 < maxSize; i4++) {
    const rowI = getRow(matrix, i4);
    for (let j5 = 0;j5 < i4; j5++) {
      const rowJ = getRow(matrix, j5);
      if (rowI[j5] || rowJ[i4]) {
        const temp = rowI[j5];
        rowI[j5] = rowJ[i4];
        rowJ[i4] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r4 = 0;r4 < cell.rowspan; r4++) {
    const layoutRow = getRow(layout, baseRow + r4);
    for (let c4 = 0;c4 < cell.colspan; c4++) {
      layoutRow[baseCol + c4] = cell;
    }
  }
}
function getOrInitOffset(offsets, index2) {
  if (offsets[index2] === undefined) {
    offsets[index2] = index2 === 0 ? 0 : 1 + getOrInitOffset(offsets, index2 - 1);
  }
  return offsets[index2];
}
function updateOffset(offsets, base, span, value3) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value3);
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j5 = 0;j5 < rowNumber; j5++) {
    const layoutRow = getRow(layout, j5);
    const cells = tableRows[j5];
    let x4 = 0;
    for (let i4 = 0;i4 < cells.length; i4++) {
      const cell = cells[i4];
      x4 = findFirstVacantIndex(layoutRow, x4);
      putCellIntoLayout(cell, layout, j5, x4);
      x4 += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j5, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x4 = 0;x4 < colNumber; x4++) {
    let y4 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x4].length);
    while (y4 < rowsInThisColumn) {
      cell = layout[x4][y4];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j5 = 0;j5 < cell.lines.length; j5++) {
            const line2 = cell.lines[j5];
            const lineOffset = rowOffsets[y4] + j5;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x4]) + line2;
            cellWidth = line2.length > cellWidth ? line2.length : cellWidth;
          }
          updateOffset(colOffsets, x4, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y4 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y4];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y4++;
      }
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line2) => "> " + line2).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path4, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path4, metadata, elem) : path4;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text4 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text4, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text4 = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text4 += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text4;
    if (!hideSameLink) {
      builder.addInline(!text4 ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node: node3, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node3], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i4) => numberToLetterSequence(i4, "a");
    case "A":
      return (i4) => numberToLetterSequence(i4, "A");
    case "i":
      return (i4) => numberToRoman(i4).toLowerCase();
    case "I":
      return (i4) => numberToRoman(i4);
    case "1":
    default:
      return (i4) => i4.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x4) => classes.includes(x4)) || attrIds.some((x4) => ids.includes(x4));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS2 = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: 1 << 24
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  whitespaceCharacters: ` 	\r
\u200B`,
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s5) => typeof s5 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options = {}) {
  options = import_deepmerge.default(DEFAULT_OPTIONS2, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s5) => s5.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert3(html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s5) => s5.selector);
  }
  function set3(obj, path4, value3) {
    const valueKey = path4.pop();
    for (const key of path4) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value3;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set3(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set3(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set3(definition, ["options", "linkBrackets"], false);
    }
  }
}

// ../node_modules/@react-email/render/dist/node/index.mjs
var import_js_beautify = __toESM(require_js(), 1);
import { Writable as Writable2 } from "stream";
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value3) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues = (a4, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp2.call(b4, prop))
      __defNormalProp(a4, prop, b4[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b4)) {
      if (__propIsEnum.call(b4, prop))
        __defNormalProp(a4, prop, b4[prop]);
    }
  return a4;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve3, reject) => {
    var fulfilled = (value3) => {
      try {
        step(generator.next(value3));
      } catch (e6) {
        reject(e6);
      }
    };
    var rejected = (value3) => {
      try {
        step(generator.throw(value3));
      } catch (e6) {
        reject(e6);
      }
    };
    var step = (x4) => x4.done ? resolve3(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var defaults = {
  unformatted: ["code", "pre", "em", "strong", "span"],
  indent_inner_html: true,
  indent_char: " ",
  indent_size: 2,
  sep: "\n"
};
var pretty = (str, options = {}) => {
  return import_js_beautify.default.html(str, __spreadValues(__spreadValues({}, defaults), options));
};
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "#__react-email-preview", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];
var decoder = new TextDecoder("utf-8");
var readStream = (stream2) => __async(undefined, null, function* () {
  let result = "";
  if ("pipeTo" in stream2) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder.decode(chunk);
      }
    });
    yield stream2.pipeTo(writableStream);
  } else {
    const writable = new Writable2({
      write(chunk, _encoding, callback) {
        result += decoder.decode(chunk);
        callback();
      }
    });
    stream2.pipe(writable);
    return new Promise((resolve3, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve3(result);
      });
    });
  }
  return result;
});
var renderAsync = (component, options) => __async(undefined, null, function* () {
  const { default: reactDOMServer } = yield Promise.resolve().then(() => (init_server_node(), exports_server_node));
  let html;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html = yield readStream(yield reactDOMServer.renderToReadableStream(component));
  } else {
    yield new Promise((resolve3, reject) => {
      const stream2 = reactDOMServer.renderToPipeableStream(component, {
        onAllReady() {
          return __async(this, null, function* () {
            html = yield readStream(stream2);
            resolve3();
          });
        },
        onError(error5) {
          reject(error5);
        }
      });
    });
  }
  if (options == null ? undefined : options.plainText) {
    return convert3(html, __spreadValues({
      selectors: plainTextSelectors
    }, options.htmlToTextOptions));
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document2 = `${doctype}${html.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? undefined : options.pretty) {
    return pretty(document2);
  }
  return document2;
});

// ../node_modules/resend/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value3) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues2 = (a4, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp3.call(b4, prop))
      __defNormalProp2(a4, prop, b4[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b4)) {
      if (__propIsEnum2.call(b4, prop))
        __defNormalProp2(a4, prop, b4[prop]);
    }
  return a4;
};
var __spreadProps = (a4, b4) => __defProps(a4, __getOwnPropDescs(b4));
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve3, reject) => {
    var fulfilled = (value3) => {
      try {
        step(generator.next(value3));
      } catch (e6) {
        reject(e6);
      }
    };
    var rejected = (value3) => {
      try {
        step(generator.throw(value3));
      } catch (e6) {
        reject(e6);
      }
    };
    var step = (x4) => x4.done ? resolve3(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var version4 = "4.0.0";
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/api-keys", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/api-keys");
      return data;
    });
  }
  remove(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/api-keys/${id2}`);
      return data;
    });
  }
};
var Audiences = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/audiences", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/audiences");
      return data;
    });
  }
  get(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${id2}`);
      return data;
    });
  }
  remove(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${id2}`);
      return data;
    });
  }
};
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      for (const email of payload) {
        if (email.react) {
          email.html = yield renderAsync(email.react);
          delete email.react;
        }
      }
      const data = yield this.resend.post("/emails/batch", payload, options);
      return data;
    });
  }
};
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName
      }, options);
      return data;
    });
  }
  list(options) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts`);
      return data;
    });
  }
  get(options) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts/${options.id}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/audiences/${payload.audienceId}/contacts/${payload.id}`, {
        unsubscribed: payload.unsubscribed,
        first_name: payload.firstName,
        last_name: payload.lastName
      });
      return data;
    });
  }
  remove(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${payload.audienceId}/contacts/${(payload == null ? undefined : payload.email) ? payload == null ? undefined : payload.email : payload == null ? undefined : payload.id}`);
      return data;
    });
  }
};
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/domains", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/domains");
      return data;
    });
  }
  get(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/domains/${id2}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/domains/${payload.id}`, {
        click_tracking: payload.clickTracking,
        open_tracking: payload.openTracking,
        tls: payload.tls
      });
      return data;
    });
  }
  remove(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/domains/${id2}`);
      return data;
    });
  }
  verify(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/domains/${id2}/verify`);
      return data;
    });
  }
};
var Emails = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_02) {
    return __async2(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        payload.html = yield renderAsync(payload.react);
        delete payload.react;
      }
      const data = yield this.resend.post("/emails", {
        attachments: payload.attachments,
        bcc: payload.bcc,
        cc: payload.cc,
        from: payload.from,
        headers: payload.headers,
        html: payload.html,
        reply_to: payload.replyTo,
        scheduled_at: payload.scheduledAt,
        subject: payload.subject,
        tags: payload.tags,
        text: payload.text,
        to: payload.to
      }, options);
      return data;
    });
  }
  get(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/emails/${id2}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/emails/${payload.id}`, {
        scheduled_at: payload.scheduledAt
      });
      return data;
    });
  }
  cancel(id2) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/emails/${id2}/cancel`);
      return data;
    });
  }
};
var defaultBaseUrl = "https://api.resend.com";
var defaultUserAgent2 = `resend-node:${version4}`;
var baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
var userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent2 : defaultUserAgent2;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.audiences = new Audiences(this);
    this.batch = new Batch(this);
    this.contacts = new Contacts(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env) {
        this.key = "re_7rEGiEVX_FvHDGwUc9BT4pUj1MsW9cTTg";
      }
      if (!this.key) {
        throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
      }
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  fetchRequest(_02) {
    return __async2(this, arguments, function* (path4, options = {}) {
      try {
        const response2 = yield fetch(`${baseUrl}${path4}`, options);
        if (!response2.ok) {
          try {
            const rawError = yield response2.text();
            return { data: null, error: JSON.parse(rawError) };
          } catch (err) {
            if (err instanceof SyntaxError) {
              return {
                data: null,
                error: {
                  name: "application_error",
                  message: "Internal server error. We are unable to process your request right now, please try again later."
                }
              };
            }
            const error5 = {
              message: response2.statusText,
              name: "application_error"
            };
            if (err instanceof Error) {
              return { data: null, error: __spreadProps(__spreadValues2({}, error5), { message: err.message }) };
            }
            return { data: null, error: error5 };
          }
        }
        const data = yield response2.json();
        return { data, error: null };
      } catch (error5) {
        return {
          data: null,
          error: {
            name: "application_error",
            message: "Unable to fetch data. The request could not be resolved."
          }
        };
      }
    });
  }
  post(_02, _12) {
    return __async2(this, arguments, function* (path4, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path4, requestOptions);
    });
  }
  get(_02) {
    return __async2(this, arguments, function* (path4, options = {}) {
      const requestOptions = __spreadValues2({
        method: "GET",
        headers: this.headers
      }, options);
      return this.fetchRequest(path4, requestOptions);
    });
  }
  put(_02, _12) {
    return __async2(this, arguments, function* (path4, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path4, requestOptions);
    });
  }
  patch(_02, _12) {
    return __async2(this, arguments, function* (path4, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "PATCH",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path4, requestOptions);
    });
  }
  delete(path4, query) {
    return __async2(this, null, function* () {
      const requestOptions = {
        method: "DELETE",
        headers: this.headers,
        body: JSON.stringify(query)
      };
      return this.fetchRequest(path4, requestOptions);
    });
  }
};

// src/libs/resend.ts
var resend = new Resend(RESEND_API_KEY);
var sendEmail2 = async (input) => {
  return await resend.emails.send(input);
};

// src/utils/email.ts
var sendEmail3 = async (input) => {
  const template = getTemplate(input.content);
  if (EMAIL_PROVIDER === "SES") {
    await sendEmail({
      to: input.to,
      from: "team@inline.chat",
      content: {
        type: "text",
        subject: template.subject,
        text: template.text
      }
    });
  } else {
    let result = await sendEmail2({
      from: "Inline <team@inline.chat>",
      to: input.to,
      subject: template.subject,
      text: template.text,
      replyTo: "team@inline.chat"
    });
    if (result.error) {
      throw result.error;
    }
  }
};
var getTemplate = (content) => {
  console.log({ content });
  switch (content.template) {
    case "code":
      return CodeTemplate(content.variables);
  }
};
function CodeTemplate({ code, firstName }) {
  console.log({ code, firstName });
  const subject = `Your Inline code: ${code}`;
  const text4 = `
Hey ${firstName ? `${firstName},` : "\u2013"}

Here's your verification code for Inline: ${code}

Inline Team
  `.trim();
  return { subject, text: text4 };
}

// src/methods/sendEmailCode.ts
var Input = Type2.Object({
  email: Type2.String()
});
var Response2 = Type2.Object({
  existingUser: Type2.Boolean()
});
var handler = async (input, _4) => {
  try {
    if (isValidEmail(input.email) === false) {
      throw new InlineError(400 /* INAVLID_ARGS */, "Invalid email");
    }
    let email = normalizeEmail(input.email);
    let { code, existingUser, firstName } = await getLoginCode(email);
    await sendEmailCode(email, code, firstName);
    return { existingUser };
  } catch (error5) {
    Log.shared.error("Failed to send email code", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to send email code");
  }
};
var getLoginCode = async (email) => {
  let existingUsers = await db.select().from(users).where(eq(users.email, email)).limit(1);
  let existingUser = Boolean(existingUsers[0]);
  let firstName = existingUsers[0]?.firstName ?? undefined;
  let existingCode = (await db.select().from(loginCodes).where(and(eq(loginCodes.email, email), gte(loginCodes.expiresAt, new Date), lt(loginCodes.attempts, MAX_LOGIN_ATTEMPTS))).limit(1))?.[0];
  if (existingCode) {
    return { code: existingCode.code, existingUser, firstName };
  }
  let code = secureRandomSixDigitNumber().toString();
  await db.delete(loginCodes).where(eq(loginCodes.email, email));
  await db.insert(loginCodes).values({
    code,
    email,
    expiresAt: new Date(Date.now() + 1000 * 60 * 10),
    attempts: 0
  });
  return { code, existingUser, firstName };
};
var sendEmailCode = async (email, code, firstName) => {
  if (isProd || process.env["SEND_EMAIL"]) {
    await sendEmail3({ to: email, content: { template: "code", variables: { code, firstName } } });
  } else {
    console.info(`Sending email to ${email} with code ${code}. To send emails in dev, set SEND_EMAIL=1.`);
  }
};

// ../node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator8(value3) {
  return IsObject8(value3) && Symbol.asyncIterator in value3;
}
function IsIterator8(value3) {
  return IsObject8(value3) && Symbol.iterator in value3;
}
function IsStandardObject2(value3) {
  return IsObject8(value3) && (Object.getPrototypeOf(value3) === Object.prototype || Object.getPrototypeOf(value3) === null);
}
function IsPromise6(value3) {
  return value3 instanceof Promise;
}
function IsDate8(value3) {
  return value3 instanceof Date && Number.isFinite(value3.getTime());
}
function IsTypedArray2(value3) {
  return ArrayBuffer.isView(value3);
}
function IsUint8Array8(value3) {
  return value3 instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value3, key) {
  return key in value3;
}
function IsObject8(value3) {
  return value3 !== null && typeof value3 === "object";
}
function IsArray8(value3) {
  return Array.isArray(value3) && !ArrayBuffer.isView(value3);
}
function IsUndefined8(value3) {
  return value3 === undefined;
}
function IsNull8(value3) {
  return value3 === null;
}
function IsBoolean8(value3) {
  return typeof value3 === "boolean";
}
function IsNumber8(value3) {
  return typeof value3 === "number";
}
function IsInteger6(value3) {
  return Number.isInteger(value3);
}
function IsBigInt8(value3) {
  return typeof value3 === "bigint";
}
function IsString8(value3) {
  return typeof value3 === "string";
}
function IsFunction8(value3) {
  return typeof value3 === "function";
}
function IsSymbol8(value3) {
  return typeof value3 === "symbol";
}
function IsValueType2(value3) {
  return IsBigInt8(value3) || IsBoolean8(value3) || IsNull8(value3) || IsNumber8(value3) || IsString8(value3) || IsSymbol8(value3) || IsUndefined8(value3);
}
// ../node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy2;
(function(TypeSystemPolicy3) {
  TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy3.AllowArrayObject = false;
  TypeSystemPolicy3.AllowNaN = false;
  TypeSystemPolicy3.AllowNullVoid = false;
  function IsExactOptionalProperty(value3, key) {
    return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key in value3 : value3[key] !== undefined;
  }
  TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value3) {
    const isObject2 = IsObject8(value3);
    return TypeSystemPolicy3.AllowArrayObject ? isObject2 : isObject2 && !IsArray8(value3);
  }
  TypeSystemPolicy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value3) {
    return IsObjectLike(value3) && !(value3 instanceof Date) && !(value3 instanceof Uint8Array);
  }
  TypeSystemPolicy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value3) {
    return TypeSystemPolicy3.AllowNaN ? IsNumber8(value3) : Number.isFinite(value3);
  }
  TypeSystemPolicy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value3) {
    const isUndefined = IsUndefined8(value3);
    return TypeSystemPolicy3.AllowNullVoid ? isUndefined || value3 === null : isUndefined;
  }
  TypeSystemPolicy3.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy2 || (TypeSystemPolicy2 = {}));
// ../node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem2;
(function(TypeSystem3) {
  function Type3(kind, check6) {
    if (exports_type5.Has(kind))
      throw new TypeSystemDuplicateTypeKind2(kind);
    exports_type5.Set(kind, check6);
    return (options = {}) => Unsafe2({ ...options, [Kind3]: kind });
  }
  TypeSystem3.Type = Type3;
  function Format2(format3, check6) {
    if (exports_format2.Has(format3))
      throw new TypeSystemDuplicateFormat2(format3);
    exports_format2.Set(format3, check6);
    return format3;
  }
  TypeSystem3.Format = Format2;
})(TypeSystem2 || (TypeSystem2 = {}));
// ../node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction2(error5) {
  switch (error5.errorType) {
    case ValueErrorType2.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType2.ArrayMaxContains:
      return `Expected array to contain no more than ${error5.schema.maxContains} matching values`;
    case ValueErrorType2.ArrayMinContains:
      return `Expected array to contain at least ${error5.schema.minContains} matching values`;
    case ValueErrorType2.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error5.schema.maxItems}`;
    case ValueErrorType2.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error5.schema.minItems}`;
    case ValueErrorType2.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType2.Array:
      return "Expected array";
    case ValueErrorType2.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType2.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error5.schema.exclusiveMaximum}`;
    case ValueErrorType2.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error5.schema.exclusiveMinimum}`;
    case ValueErrorType2.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error5.schema.maximum}`;
    case ValueErrorType2.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error5.schema.minimum}`;
    case ValueErrorType2.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error5.schema.multipleOf}`;
    case ValueErrorType2.BigInt:
      return "Expected bigint";
    case ValueErrorType2.Boolean:
      return "Expected boolean";
    case ValueErrorType2.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error5.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType2.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error5.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType2.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error5.schema.minimumTimestamp}`;
    case ValueErrorType2.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error5.schema.maximumTimestamp}`;
    case ValueErrorType2.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error5.schema.multipleOfTimestamp}`;
    case ValueErrorType2.Date:
      return "Expected Date";
    case ValueErrorType2.Function:
      return "Expected function";
    case ValueErrorType2.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error5.schema.exclusiveMaximum}`;
    case ValueErrorType2.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error5.schema.exclusiveMinimum}`;
    case ValueErrorType2.IntegerMaximum:
      return `Expected integer to be less or equal to ${error5.schema.maximum}`;
    case ValueErrorType2.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error5.schema.minimum}`;
    case ValueErrorType2.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error5.schema.multipleOf}`;
    case ValueErrorType2.Integer:
      return "Expected integer";
    case ValueErrorType2.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType2.Intersect:
      return "Expected all values to match";
    case ValueErrorType2.Iterator:
      return "Expected Iterator";
    case ValueErrorType2.Literal:
      return `Expected ${typeof error5.schema.const === "string" ? `'${error5.schema.const}'` : error5.schema.const}`;
    case ValueErrorType2.Never:
      return "Never";
    case ValueErrorType2.Not:
      return "Value should not match";
    case ValueErrorType2.Null:
      return "Expected null";
    case ValueErrorType2.NumberExclusiveMaximum:
      return `Expected number to be less than ${error5.schema.exclusiveMaximum}`;
    case ValueErrorType2.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error5.schema.exclusiveMinimum}`;
    case ValueErrorType2.NumberMaximum:
      return `Expected number to be less or equal to ${error5.schema.maximum}`;
    case ValueErrorType2.NumberMinimum:
      return `Expected number to be greater or equal to ${error5.schema.minimum}`;
    case ValueErrorType2.NumberMultipleOf:
      return `Expected number to be a multiple of ${error5.schema.multipleOf}`;
    case ValueErrorType2.Number:
      return "Expected number";
    case ValueErrorType2.Object:
      return "Expected object";
    case ValueErrorType2.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType2.ObjectMaxProperties:
      return `Expected object to have no more than ${error5.schema.maxProperties} properties`;
    case ValueErrorType2.ObjectMinProperties:
      return `Expected object to have at least ${error5.schema.minProperties} properties`;
    case ValueErrorType2.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType2.Promise:
      return "Expected Promise";
    case ValueErrorType2.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType2.StringFormatUnknown:
      return `Unknown format '${error5.schema.format}'`;
    case ValueErrorType2.StringFormat:
      return `Expected string to match '${error5.schema.format}' format`;
    case ValueErrorType2.StringMaxLength:
      return `Expected string length less or equal to ${error5.schema.maxLength}`;
    case ValueErrorType2.StringMinLength:
      return `Expected string length greater or equal to ${error5.schema.minLength}`;
    case ValueErrorType2.StringPattern:
      return `Expected string to match '${error5.schema.pattern}'`;
    case ValueErrorType2.String:
      return "Expected string";
    case ValueErrorType2.Symbol:
      return "Expected symbol";
    case ValueErrorType2.TupleLength:
      return `Expected tuple to have ${error5.schema.maxItems || 0} elements`;
    case ValueErrorType2.Tuple:
      return "Expected tuple";
    case ValueErrorType2.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error5.schema.maxByteLength}`;
    case ValueErrorType2.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error5.schema.minByteLength}`;
    case ValueErrorType2.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType2.Undefined:
      return "Expected undefined";
    case ValueErrorType2.Union:
      return "Expected union value";
    case ValueErrorType2.Void:
      return "Expected void";
    case ValueErrorType2.Kind:
      return `Expected kind '${error5.schema[Kind3]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction2 = DefaultErrorFunction2;
function GetErrorFunction2() {
  return errorFunction2;
}

// ../node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError2 extends TypeBoxError2 {
  constructor(schema5) {
    super(`Unable to dereference schema with \$id '${schema5.$id}'`);
    this.schema = schema5;
  }
}
function Resolve2(schema5, references) {
  const target = references.find((target2) => target2.$id === schema5.$ref);
  if (target === undefined)
    throw new TypeDereferenceError2(schema5);
  return Deref4(target, references);
}
function Deref4(schema5, references) {
  return schema5[Kind3] === "This" || schema5[Kind3] === "Ref" ? Resolve2(schema5, references) : schema5;
}
// ../node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError2 extends TypeBoxError2 {
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker2;
(function(ByteMarker3) {
  ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
  ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
  ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
  ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
  ByteMarker3[ByteMarker3["String"] = 4] = "String";
  ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
  ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
  ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
  ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
  ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
})(ByteMarker2 || (ByteMarker2 = {}));
var Accumulator2 = BigInt("14695981039346656037");
var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes2 = Array.from({ length: 256 }).map((_4, i4) => BigInt(i4));
var F642 = new Float64Array(1);
var F64In2 = new DataView(F642.buffer);
var F64Out2 = new Uint8Array(F642.buffer);
function* NumberToBytes2(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i4 = 0;i4 < byteCount; i4++) {
    yield value3 >> 8 * (byteCount - 1 - i4) & 255;
  }
}
function ArrayType8(value3) {
  FNV1A642(ByteMarker2.Array);
  for (const item of value3) {
    Visit20(item);
  }
}
function BooleanType2(value3) {
  FNV1A642(ByteMarker2.Boolean);
  FNV1A642(value3 ? 1 : 0);
}
function BigIntType2(value3) {
  FNV1A642(ByteMarker2.BigInt);
  F64In2.setBigInt64(0, value3);
  for (const byte of F64Out2) {
    FNV1A642(byte);
  }
}
function DateType6(value3) {
  FNV1A642(ByteMarker2.Date);
  Visit20(value3.getTime());
}
function NullType2(value3) {
  FNV1A642(ByteMarker2.Null);
}
function NumberType2(value3) {
  FNV1A642(ByteMarker2.Number);
  F64In2.setFloat64(0, value3);
  for (const byte of F64Out2) {
    FNV1A642(byte);
  }
}
function ObjectType8(value3) {
  FNV1A642(ByteMarker2.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value3).sort()) {
    Visit20(key);
    Visit20(value3[key]);
  }
}
function StringType2(value3) {
  FNV1A642(ByteMarker2.String);
  for (let i4 = 0;i4 < value3.length; i4++) {
    for (const byte of NumberToBytes2(value3.charCodeAt(i4))) {
      FNV1A642(byte);
    }
  }
}
function SymbolType2(value3) {
  FNV1A642(ByteMarker2.Symbol);
  Visit20(value3.description);
}
function Uint8ArrayType4(value3) {
  FNV1A642(ByteMarker2.Uint8Array);
  for (let i4 = 0;i4 < value3.length; i4++) {
    FNV1A642(value3[i4]);
  }
}
function UndefinedType2(value3) {
  return FNV1A642(ByteMarker2.Undefined);
}
function Visit20(value3) {
  if (IsArray8(value3))
    return ArrayType8(value3);
  if (IsBoolean8(value3))
    return BooleanType2(value3);
  if (IsBigInt8(value3))
    return BigIntType2(value3);
  if (IsDate8(value3))
    return DateType6(value3);
  if (IsNull8(value3))
    return NullType2(value3);
  if (IsNumber8(value3))
    return NumberType2(value3);
  if (IsStandardObject2(value3))
    return ObjectType8(value3);
  if (IsString8(value3))
    return StringType2(value3);
  if (IsSymbol8(value3))
    return SymbolType2(value3);
  if (IsUint8Array8(value3))
    return Uint8ArrayType4(value3);
  if (IsUndefined8(value3))
    return UndefinedType2(value3);
  throw new ValueHashError2(value3);
}
function FNV1A642(byte) {
  Accumulator2 = Accumulator2 ^ Bytes2[byte];
  Accumulator2 = Accumulator2 * Prime2 % Size2;
}
function Hash4(value3) {
  Accumulator2 = BigInt("14695981039346656037");
  Visit20(value3);
  return Accumulator2;
}
// ../node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType2;
(function(ValueErrorType3) {
  ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
  ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
  ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
  ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
  ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
  ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
  ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
  ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
  ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
  ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
  ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
  ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
  ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
  ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
  ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
  ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
  ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
  ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
  ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
  ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
  ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
  ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
  ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
})(ValueErrorType2 || (ValueErrorType2 = {}));

class ValueErrorsUnknownTypeError2 extends TypeBoxError2 {
  constructor(schema5) {
    super("Unknown type");
    this.schema = schema5;
  }
}
function EscapeKey2(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined3(value3) {
  return value3 !== undefined;
}

class ValueErrorIterator2 {
  constructor(iterator5) {
    this.iterator = iterator5;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create4(errorType, schema5, path4, value3) {
  return { type: errorType, schema: schema5, path: path4, value: value3, message: GetErrorFunction2()({ errorType, path: path4, schema: schema5, value: value3 }) };
}
function* FromAny6(schema5, references, path4, value3) {
}
function* FromArray21(schema5, references, path4, value3) {
  if (!IsArray8(value3)) {
    return yield Create4(ValueErrorType2.Array, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minItems) && !(value3.length >= schema5.minItems)) {
    yield Create4(ValueErrorType2.ArrayMinItems, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maxItems) && !(value3.length <= schema5.maxItems)) {
    yield Create4(ValueErrorType2.ArrayMaxItems, schema5, path4, value3);
  }
  for (let i4 = 0;i4 < value3.length; i4++) {
    yield* Visit21(schema5.items, references, `${path4}/${i4}`, value3[i4]);
  }
  if (schema5.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value3) {
      const hashed = Hash4(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create4(ValueErrorType2.ArrayUniqueItems, schema5, path4, value3);
  }
  if (!(IsDefined3(schema5.contains) || IsDefined3(schema5.minContains) || IsDefined3(schema5.maxContains))) {
    return;
  }
  const containsSchema = IsDefined3(schema5.contains) ? schema5.contains : Never2();
  const containsCount = value3.reduce((acc, value4, index2) => Visit21(containsSchema, references, `${path4}${index2}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create4(ValueErrorType2.ArrayContains, schema5, path4, value3);
  }
  if (IsNumber8(schema5.minContains) && containsCount < schema5.minContains) {
    yield Create4(ValueErrorType2.ArrayMinContains, schema5, path4, value3);
  }
  if (IsNumber8(schema5.maxContains) && containsCount > schema5.maxContains) {
    yield Create4(ValueErrorType2.ArrayMaxContains, schema5, path4, value3);
  }
}
function* FromAsyncIterator9(schema5, references, path4, value3) {
  if (!IsAsyncIterator8(value3))
    yield Create4(ValueErrorType2.AsyncIterator, schema5, path4, value3);
}
function* FromBigInt7(schema5, references, path4, value3) {
  if (!IsBigInt8(value3))
    return yield Create4(ValueErrorType2.BigInt, schema5, path4, value3);
  if (IsDefined3(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.BigIntExclusiveMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.BigIntExclusiveMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maximum) && !(value3 <= schema5.maximum)) {
    yield Create4(ValueErrorType2.BigIntMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minimum) && !(value3 >= schema5.minimum)) {
    yield Create4(ValueErrorType2.BigIntMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.multipleOf) && !(value3 % schema5.multipleOf === BigInt(0))) {
    yield Create4(ValueErrorType2.BigIntMultipleOf, schema5, path4, value3);
  }
}
function* FromBoolean7(schema5, references, path4, value3) {
  if (!IsBoolean8(value3))
    yield Create4(ValueErrorType2.Boolean, schema5, path4, value3);
}
function* FromConstructor10(schema5, references, path4, value3) {
  yield* Visit21(schema5.returns, references, path4, value3.prototype);
}
function* FromDate7(schema5, references, path4, value3) {
  if (!IsDate8(value3))
    return yield Create4(ValueErrorType2.Date, schema5, path4, value3);
  if (IsDefined3(schema5.exclusiveMaximumTimestamp) && !(value3.getTime() < schema5.exclusiveMaximumTimestamp)) {
    yield Create4(ValueErrorType2.DateExclusiveMaximumTimestamp, schema5, path4, value3);
  }
  if (IsDefined3(schema5.exclusiveMinimumTimestamp) && !(value3.getTime() > schema5.exclusiveMinimumTimestamp)) {
    yield Create4(ValueErrorType2.DateExclusiveMinimumTimestamp, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maximumTimestamp) && !(value3.getTime() <= schema5.maximumTimestamp)) {
    yield Create4(ValueErrorType2.DateMaximumTimestamp, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minimumTimestamp) && !(value3.getTime() >= schema5.minimumTimestamp)) {
    yield Create4(ValueErrorType2.DateMinimumTimestamp, schema5, path4, value3);
  }
  if (IsDefined3(schema5.multipleOfTimestamp) && !(value3.getTime() % schema5.multipleOfTimestamp === 0)) {
    yield Create4(ValueErrorType2.DateMultipleOfTimestamp, schema5, path4, value3);
  }
}
function* FromFunction9(schema5, references, path4, value3) {
  if (!IsFunction8(value3))
    yield Create4(ValueErrorType2.Function, schema5, path4, value3);
}
function* FromInteger7(schema5, references, path4, value3) {
  if (!IsInteger6(value3))
    return yield Create4(ValueErrorType2.Integer, schema5, path4, value3);
  if (IsDefined3(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.IntegerExclusiveMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.IntegerExclusiveMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maximum) && !(value3 <= schema5.maximum)) {
    yield Create4(ValueErrorType2.IntegerMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minimum) && !(value3 >= schema5.minimum)) {
    yield Create4(ValueErrorType2.IntegerMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.multipleOf) && !(value3 % schema5.multipleOf === 0)) {
    yield Create4(ValueErrorType2.IntegerMultipleOf, schema5, path4, value3);
  }
}
function* FromIntersect25(schema5, references, path4, value3) {
  for (const inner of schema5.allOf) {
    const next = Visit21(inner, references, path4, value3).next();
    if (!next.done) {
      yield Create4(ValueErrorType2.Intersect, schema5, path4, value3);
      yield next.value;
    }
  }
  if (schema5.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern2(schema5));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create4(ValueErrorType2.IntersectUnevaluatedProperties, schema5, `${path4}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema5.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern2(schema5));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit21(schema5.unevaluatedProperties, references, `${path4}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator9(schema5, references, path4, value3) {
  if (!IsIterator8(value3))
    yield Create4(ValueErrorType2.Iterator, schema5, path4, value3);
}
function* FromLiteral9(schema5, references, path4, value3) {
  if (!(value3 === schema5.const))
    yield Create4(ValueErrorType2.Literal, schema5, path4, value3);
}
function* FromNever7(schema5, references, path4, value3) {
  yield Create4(ValueErrorType2.Never, schema5, path4, value3);
}
function* FromNot9(schema5, references, path4, value3) {
  if (Visit21(schema5.not, references, path4, value3).next().done === true)
    yield Create4(ValueErrorType2.Not, schema5, path4, value3);
}
function* FromNull7(schema5, references, path4, value3) {
  if (!IsNull8(value3))
    yield Create4(ValueErrorType2.Null, schema5, path4, value3);
}
function* FromNumber7(schema5, references, path4, value3) {
  if (!TypeSystemPolicy2.IsNumberLike(value3))
    return yield Create4(ValueErrorType2.Number, schema5, path4, value3);
  if (IsDefined3(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.NumberExclusiveMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.NumberExclusiveMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maximum) && !(value3 <= schema5.maximum)) {
    yield Create4(ValueErrorType2.NumberMaximum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minimum) && !(value3 >= schema5.minimum)) {
    yield Create4(ValueErrorType2.NumberMinimum, schema5, path4, value3);
  }
  if (IsDefined3(schema5.multipleOf) && !(value3 % schema5.multipleOf === 0)) {
    yield Create4(ValueErrorType2.NumberMultipleOf, schema5, path4, value3);
  }
}
function* FromObject15(schema5, references, path4, value3) {
  if (!TypeSystemPolicy2.IsObjectLike(value3))
    return yield Create4(ValueErrorType2.Object, schema5, path4, value3);
  if (IsDefined3(schema5.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema5.minProperties)) {
    yield Create4(ValueErrorType2.ObjectMinProperties, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema5.maxProperties)) {
    yield Create4(ValueErrorType2.ObjectMaxProperties, schema5, path4, value3);
  }
  const requiredKeys = Array.isArray(schema5.required) ? schema5.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema5.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create4(ValueErrorType2.ObjectRequiredProperty, schema5.properties[requiredKey], `${path4}/${EscapeKey2(requiredKey)}`, undefined);
  }
  if (schema5.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema5, `${path4}/${EscapeKey2(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema5.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit21(schema5.additionalProperties, references, `${path4}/${EscapeKey2(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema5.properties[knownKey];
    if (schema5.required && schema5.required.includes(knownKey)) {
      yield* Visit21(property, references, `${path4}/${EscapeKey2(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck2(schema5) && !(knownKey in value3)) {
        yield Create4(ValueErrorType2.ObjectRequiredProperty, property, `${path4}/${EscapeKey2(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit21(property, references, `${path4}/${EscapeKey2(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise11(schema5, references, path4, value3) {
  if (!IsPromise6(value3))
    yield Create4(ValueErrorType2.Promise, schema5, path4, value3);
}
function* FromRecord13(schema5, references, path4, value3) {
  if (!TypeSystemPolicy2.IsRecordLike(value3))
    return yield Create4(ValueErrorType2.Object, schema5, path4, value3);
  if (IsDefined3(schema5.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema5.minProperties)) {
    yield Create4(ValueErrorType2.ObjectMinProperties, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema5.maxProperties)) {
    yield Create4(ValueErrorType2.ObjectMaxProperties, schema5, path4, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema5.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit21(patternSchema, references, `${path4}/${EscapeKey2(propertyKey)}`, propertyValue);
  }
  if (typeof schema5.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit21(schema5.additionalProperties, references, `${path4}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
  if (schema5.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema5, `${path4}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef13(schema5, references, path4, value3) {
  yield* Visit21(Deref4(schema5, references), references, path4, value3);
}
function* FromRegExp6(schema5, references, path4, value3) {
  if (!IsString8(value3))
    return yield Create4(ValueErrorType2.String, schema5, path4, value3);
  if (IsDefined3(schema5.minLength) && !(value3.length >= schema5.minLength)) {
    yield Create4(ValueErrorType2.StringMinLength, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maxLength) && !(value3.length <= schema5.maxLength)) {
    yield Create4(ValueErrorType2.StringMaxLength, schema5, path4, value3);
  }
  const regex = new RegExp(schema5.source, schema5.flags);
  if (!regex.test(value3)) {
    return yield Create4(ValueErrorType2.RegExp, schema5, path4, value3);
  }
}
function* FromString7(schema5, references, path4, value3) {
  if (!IsString8(value3))
    return yield Create4(ValueErrorType2.String, schema5, path4, value3);
  if (IsDefined3(schema5.minLength) && !(value3.length >= schema5.minLength)) {
    yield Create4(ValueErrorType2.StringMinLength, schema5, path4, value3);
  }
  if (IsDefined3(schema5.maxLength) && !(value3.length <= schema5.maxLength)) {
    yield Create4(ValueErrorType2.StringMaxLength, schema5, path4, value3);
  }
  if (IsString8(schema5.pattern)) {
    const regex = new RegExp(schema5.pattern);
    if (!regex.test(value3)) {
      yield Create4(ValueErrorType2.StringPattern, schema5, path4, value3);
    }
  }
  if (IsString8(schema5.format)) {
    if (!exports_format2.Has(schema5.format)) {
      yield Create4(ValueErrorType2.StringFormatUnknown, schema5, path4, value3);
    } else {
      const format3 = exports_format2.Get(schema5.format);
      if (!format3(value3)) {
        yield Create4(ValueErrorType2.StringFormat, schema5, path4, value3);
      }
    }
  }
}
function* FromSymbol7(schema5, references, path4, value3) {
  if (!IsSymbol8(value3))
    yield Create4(ValueErrorType2.Symbol, schema5, path4, value3);
}
function* FromTemplateLiteral10(schema5, references, path4, value3) {
  if (!IsString8(value3))
    return yield Create4(ValueErrorType2.String, schema5, path4, value3);
  const regex = new RegExp(schema5.pattern);
  if (!regex.test(value3)) {
    yield Create4(ValueErrorType2.StringPattern, schema5, path4, value3);
  }
}
function* FromThis11(schema5, references, path4, value3) {
  yield* Visit21(Deref4(schema5, references), references, path4, value3);
}
function* FromTuple19(schema5, references, path4, value3) {
  if (!IsArray8(value3))
    return yield Create4(ValueErrorType2.Tuple, schema5, path4, value3);
  if (schema5.items === undefined && !(value3.length === 0)) {
    return yield Create4(ValueErrorType2.TupleLength, schema5, path4, value3);
  }
  if (!(value3.length === schema5.maxItems)) {
    return yield Create4(ValueErrorType2.TupleLength, schema5, path4, value3);
  }
  if (!schema5.items) {
    return;
  }
  for (let i4 = 0;i4 < schema5.items.length; i4++) {
    yield* Visit21(schema5.items[i4], references, `${path4}/${i4}`, value3[i4]);
  }
}
function* FromUndefined7(schema5, references, path4, value3) {
  if (!IsUndefined8(value3))
    yield Create4(ValueErrorType2.Undefined, schema5, path4, value3);
}
function* FromUnion29(schema5, references, path4, value3) {
  let count = 0;
  for (const subschema of schema5.anyOf) {
    const errors2 = [...Visit21(subschema, references, path4, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create4(ValueErrorType2.Union, schema5, path4, value3);
  }
}
function* FromUint8Array6(schema5, references, path4, value3) {
  if (!IsUint8Array8(value3))
    return yield Create4(ValueErrorType2.Uint8Array, schema5, path4, value3);
  if (IsDefined3(schema5.maxByteLength) && !(value3.length <= schema5.maxByteLength)) {
    yield Create4(ValueErrorType2.Uint8ArrayMaxByteLength, schema5, path4, value3);
  }
  if (IsDefined3(schema5.minByteLength) && !(value3.length >= schema5.minByteLength)) {
    yield Create4(ValueErrorType2.Uint8ArrayMinByteLength, schema5, path4, value3);
  }
}
function* FromUnknown6(schema5, references, path4, value3) {
}
function* FromVoid6(schema5, references, path4, value3) {
  if (!TypeSystemPolicy2.IsVoidLike(value3))
    yield Create4(ValueErrorType2.Void, schema5, path4, value3);
}
function* FromKind4(schema5, references, path4, value3) {
  const check6 = exports_type5.Get(schema5[Kind3]);
  if (!check6(schema5, value3))
    yield Create4(ValueErrorType2.Kind, schema5, path4, value3);
}
function* Visit21(schema5, references, path4, value3) {
  const references_ = IsDefined3(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema_[Kind3]) {
    case "Any":
      return yield* FromAny6(schema_, references_, path4, value3);
    case "Array":
      return yield* FromArray21(schema_, references_, path4, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator9(schema_, references_, path4, value3);
    case "BigInt":
      return yield* FromBigInt7(schema_, references_, path4, value3);
    case "Boolean":
      return yield* FromBoolean7(schema_, references_, path4, value3);
    case "Constructor":
      return yield* FromConstructor10(schema_, references_, path4, value3);
    case "Date":
      return yield* FromDate7(schema_, references_, path4, value3);
    case "Function":
      return yield* FromFunction9(schema_, references_, path4, value3);
    case "Integer":
      return yield* FromInteger7(schema_, references_, path4, value3);
    case "Intersect":
      return yield* FromIntersect25(schema_, references_, path4, value3);
    case "Iterator":
      return yield* FromIterator9(schema_, references_, path4, value3);
    case "Literal":
      return yield* FromLiteral9(schema_, references_, path4, value3);
    case "Never":
      return yield* FromNever7(schema_, references_, path4, value3);
    case "Not":
      return yield* FromNot9(schema_, references_, path4, value3);
    case "Null":
      return yield* FromNull7(schema_, references_, path4, value3);
    case "Number":
      return yield* FromNumber7(schema_, references_, path4, value3);
    case "Object":
      return yield* FromObject15(schema_, references_, path4, value3);
    case "Promise":
      return yield* FromPromise11(schema_, references_, path4, value3);
    case "Record":
      return yield* FromRecord13(schema_, references_, path4, value3);
    case "Ref":
      return yield* FromRef13(schema_, references_, path4, value3);
    case "RegExp":
      return yield* FromRegExp6(schema_, references_, path4, value3);
    case "String":
      return yield* FromString7(schema_, references_, path4, value3);
    case "Symbol":
      return yield* FromSymbol7(schema_, references_, path4, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral10(schema_, references_, path4, value3);
    case "This":
      return yield* FromThis11(schema_, references_, path4, value3);
    case "Tuple":
      return yield* FromTuple19(schema_, references_, path4, value3);
    case "Undefined":
      return yield* FromUndefined7(schema_, references_, path4, value3);
    case "Union":
      return yield* FromUnion29(schema_, references_, path4, value3);
    case "Uint8Array":
      return yield* FromUint8Array6(schema_, references_, path4, value3);
    case "Unknown":
      return yield* FromUnknown6(schema_, references_, path4, value3);
    case "Void":
      return yield* FromVoid6(schema_, references_, path4, value3);
    default:
      if (!exports_type5.Has(schema_[Kind3]))
        throw new ValueErrorsUnknownTypeError2(schema5);
      return yield* FromKind4(schema_, references_, path4, value3);
  }
}
function Errors4(...args) {
  const iterator5 = args.length === 3 ? Visit21(args[0], args[1], "", args[2]) : Visit21(args[0], [], "", args[1]);
  return new ValueErrorIterator2(iterator5);
}
// ../node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError2 extends TypeBoxError2 {
  constructor(schema5) {
    super(`Unknown type`);
    this.schema = schema5;
  }
}
function IsAnyOrUnknown2(schema5) {
  return schema5[Kind3] === "Any" || schema5[Kind3] === "Unknown";
}
function IsDefined4(value3) {
  return value3 !== undefined;
}
function FromAny7(schema5, references, value3) {
  return true;
}
function FromArray22(schema5, references, value3) {
  if (!IsArray8(value3))
    return false;
  if (IsDefined4(schema5.minItems) && !(value3.length >= schema5.minItems)) {
    return false;
  }
  if (IsDefined4(schema5.maxItems) && !(value3.length <= schema5.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit22(schema5.items, references, value4))) {
    return false;
  }
  if (schema5.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value3) {
      const hashed = Hash4(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined4(schema5.contains) || IsNumber8(schema5.minContains) || IsNumber8(schema5.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined4(schema5.contains) ? schema5.contains : Never2();
  const containsCount = value3.reduce((acc, value4) => Visit22(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber8(schema5.minContains) && containsCount < schema5.minContains) {
    return false;
  }
  if (IsNumber8(schema5.maxContains) && containsCount > schema5.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator10(schema5, references, value3) {
  return IsAsyncIterator8(value3);
}
function FromBigInt8(schema5, references, value3) {
  if (!IsBigInt8(value3))
    return false;
  if (IsDefined4(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema5.maximum) && !(value3 <= schema5.maximum)) {
    return false;
  }
  if (IsDefined4(schema5.minimum) && !(value3 >= schema5.minimum)) {
    return false;
  }
  if (IsDefined4(schema5.multipleOf) && !(value3 % schema5.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean8(schema5, references, value3) {
  return IsBoolean8(value3);
}
function FromConstructor11(schema5, references, value3) {
  return Visit22(schema5.returns, references, value3.prototype);
}
function FromDate8(schema5, references, value3) {
  if (!IsDate8(value3))
    return false;
  if (IsDefined4(schema5.exclusiveMaximumTimestamp) && !(value3.getTime() < schema5.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema5.exclusiveMinimumTimestamp) && !(value3.getTime() > schema5.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema5.maximumTimestamp) && !(value3.getTime() <= schema5.maximumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema5.minimumTimestamp) && !(value3.getTime() >= schema5.minimumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema5.multipleOfTimestamp) && !(value3.getTime() % schema5.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction10(schema5, references, value3) {
  return IsFunction8(value3);
}
function FromInteger8(schema5, references, value3) {
  if (!IsInteger6(value3)) {
    return false;
  }
  if (IsDefined4(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema5.maximum) && !(value3 <= schema5.maximum)) {
    return false;
  }
  if (IsDefined4(schema5.minimum) && !(value3 >= schema5.minimum)) {
    return false;
  }
  if (IsDefined4(schema5.multipleOf) && !(value3 % schema5.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect26(schema5, references, value3) {
  const check1 = schema5.allOf.every((schema6) => Visit22(schema6, references, value3));
  if (schema5.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern2(schema5));
    const check22 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check22;
  } else if (IsSchema4(schema5.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern2(schema5));
    const check22 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit22(schema5.unevaluatedProperties, references, value3[key]));
    return check1 && check22;
  } else {
    return check1;
  }
}
function FromIterator10(schema5, references, value3) {
  return IsIterator8(value3);
}
function FromLiteral10(schema5, references, value3) {
  return value3 === schema5.const;
}
function FromNever8(schema5, references, value3) {
  return false;
}
function FromNot10(schema5, references, value3) {
  return !Visit22(schema5.not, references, value3);
}
function FromNull8(schema5, references, value3) {
  return IsNull8(value3);
}
function FromNumber8(schema5, references, value3) {
  if (!TypeSystemPolicy2.IsNumberLike(value3))
    return false;
  if (IsDefined4(schema5.exclusiveMaximum) && !(value3 < schema5.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema5.exclusiveMinimum) && !(value3 > schema5.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema5.minimum) && !(value3 >= schema5.minimum)) {
    return false;
  }
  if (IsDefined4(schema5.maximum) && !(value3 <= schema5.maximum)) {
    return false;
  }
  if (IsDefined4(schema5.multipleOf) && !(value3 % schema5.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject16(schema5, references, value3) {
  if (!TypeSystemPolicy2.IsObjectLike(value3))
    return false;
  if (IsDefined4(schema5.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema5.minProperties)) {
    return false;
  }
  if (IsDefined4(schema5.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema5.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema5.properties);
  for (const knownKey of knownKeys) {
    const property = schema5.properties[knownKey];
    if (schema5.required && schema5.required.includes(knownKey)) {
      if (!Visit22(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck2(property) || IsAnyOrUnknown2(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value3, knownKey) && !Visit22(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema5.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema5.required && schema5.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema5.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit22(schema5.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
}
function FromPromise12(schema5, references, value3) {
  return IsPromise6(value3);
}
function FromRecord14(schema5, references, value3) {
  if (!TypeSystemPolicy2.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined4(schema5.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema5.minProperties)) {
    return false;
  }
  if (IsDefined4(schema5.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema5.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema5.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit22(patternSchema, references, value4) : true;
  });
  const check22 = typeof schema5.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit22(schema5.additionalProperties, references, value4) : true;
  }) : true;
  const check32 = schema5.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check22 && check32;
}
function FromRef14(schema5, references, value3) {
  return Visit22(Deref4(schema5, references), references, value3);
}
function FromRegExp7(schema5, references, value3) {
  const regex = new RegExp(schema5.source, schema5.flags);
  if (IsDefined4(schema5.minLength)) {
    if (!(value3.length >= schema5.minLength))
      return false;
  }
  if (IsDefined4(schema5.maxLength)) {
    if (!(value3.length <= schema5.maxLength))
      return false;
  }
  return regex.test(value3);
}
function FromString8(schema5, references, value3) {
  if (!IsString8(value3)) {
    return false;
  }
  if (IsDefined4(schema5.minLength)) {
    if (!(value3.length >= schema5.minLength))
      return false;
  }
  if (IsDefined4(schema5.maxLength)) {
    if (!(value3.length <= schema5.maxLength))
      return false;
  }
  if (IsDefined4(schema5.pattern)) {
    const regex = new RegExp(schema5.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined4(schema5.format)) {
    if (!exports_format2.Has(schema5.format))
      return false;
    const func = exports_format2.Get(schema5.format);
    return func(value3);
  }
  return true;
}
function FromSymbol8(schema5, references, value3) {
  return IsSymbol8(value3);
}
function FromTemplateLiteral11(schema5, references, value3) {
  return IsString8(value3) && new RegExp(schema5.pattern).test(value3);
}
function FromThis12(schema5, references, value3) {
  return Visit22(Deref4(schema5, references), references, value3);
}
function FromTuple20(schema5, references, value3) {
  if (!IsArray8(value3)) {
    return false;
  }
  if (schema5.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema5.maxItems)) {
    return false;
  }
  if (!schema5.items) {
    return true;
  }
  for (let i4 = 0;i4 < schema5.items.length; i4++) {
    if (!Visit22(schema5.items[i4], references, value3[i4]))
      return false;
  }
  return true;
}
function FromUndefined8(schema5, references, value3) {
  return IsUndefined8(value3);
}
function FromUnion30(schema5, references, value3) {
  return schema5.anyOf.some((inner) => Visit22(inner, references, value3));
}
function FromUint8Array7(schema5, references, value3) {
  if (!IsUint8Array8(value3)) {
    return false;
  }
  if (IsDefined4(schema5.maxByteLength) && !(value3.length <= schema5.maxByteLength)) {
    return false;
  }
  if (IsDefined4(schema5.minByteLength) && !(value3.length >= schema5.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown7(schema5, references, value3) {
  return true;
}
function FromVoid7(schema5, references, value3) {
  return TypeSystemPolicy2.IsVoidLike(value3);
}
function FromKind5(schema5, references, value3) {
  if (!exports_type5.Has(schema5[Kind3]))
    return false;
  const func = exports_type5.Get(schema5[Kind3]);
  return func(schema5, value3);
}
function Visit22(schema5, references, value3) {
  const references_ = IsDefined4(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema_[Kind3]) {
    case "Any":
      return FromAny7(schema_, references_, value3);
    case "Array":
      return FromArray22(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator10(schema_, references_, value3);
    case "BigInt":
      return FromBigInt8(schema_, references_, value3);
    case "Boolean":
      return FromBoolean8(schema_, references_, value3);
    case "Constructor":
      return FromConstructor11(schema_, references_, value3);
    case "Date":
      return FromDate8(schema_, references_, value3);
    case "Function":
      return FromFunction10(schema_, references_, value3);
    case "Integer":
      return FromInteger8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect26(schema_, references_, value3);
    case "Iterator":
      return FromIterator10(schema_, references_, value3);
    case "Literal":
      return FromLiteral10(schema_, references_, value3);
    case "Never":
      return FromNever8(schema_, references_, value3);
    case "Not":
      return FromNot10(schema_, references_, value3);
    case "Null":
      return FromNull8(schema_, references_, value3);
    case "Number":
      return FromNumber8(schema_, references_, value3);
    case "Object":
      return FromObject16(schema_, references_, value3);
    case "Promise":
      return FromPromise12(schema_, references_, value3);
    case "Record":
      return FromRecord14(schema_, references_, value3);
    case "Ref":
      return FromRef14(schema_, references_, value3);
    case "RegExp":
      return FromRegExp7(schema_, references_, value3);
    case "String":
      return FromString8(schema_, references_, value3);
    case "Symbol":
      return FromSymbol8(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral11(schema_, references_, value3);
    case "This":
      return FromThis12(schema_, references_, value3);
    case "Tuple":
      return FromTuple20(schema_, references_, value3);
    case "Undefined":
      return FromUndefined8(schema_, references_, value3);
    case "Union":
      return FromUnion30(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array7(schema_, references_, value3);
    case "Unknown":
      return FromUnknown7(schema_, references_, value3);
    case "Void":
      return FromVoid7(schema_, references_, value3);
    default:
      if (!exports_type5.Has(schema_[Kind3]))
        throw new ValueCheckUnknownTypeError2(schema_);
      return FromKind5(schema_, references_, value3);
  }
}
function Check4(...args) {
  return args.length === 3 ? Visit22(args[0], args[1], args[2]) : Visit22(args[0], [], args[1]);
}
// ../node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType9(value3) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value3)) {
    Acc[key] = Clone5(value3[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value3)) {
    Acc[key] = Clone5(value3[key]);
  }
  return Acc;
}
function ArrayType9(value3) {
  return value3.map((element) => Clone5(element));
}
function TypedArrayType5(value3) {
  return value3.slice();
}
function DateType7(value3) {
  return new Date(value3.toISOString());
}
function ValueType5(value3) {
  return value3;
}
function Clone5(value3) {
  if (IsArray8(value3))
    return ArrayType9(value3);
  if (IsDate8(value3))
    return DateType7(value3);
  if (IsStandardObject2(value3))
    return ObjectType9(value3);
  if (IsTypedArray2(value3))
    return TypedArrayType5(value3);
  if (IsValueType2(value3))
    return ValueType5(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// ../node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError2 extends TypeBoxError2 {
  constructor(schema5, message) {
    super(message);
    this.schema = schema5;
  }
}
function FromDefault2(value3) {
  return typeof value3 === "function" ? value3 : Clone5(value3);
}
function FromAny8(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return {};
  }
}
function FromArray23(schema5, references) {
  if (schema5.uniqueItems === true && !HasPropertyKey2(schema5, "default")) {
    throw new ValueCreateError2(schema5, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema5 && !HasPropertyKey2(schema5, "default")) {
    throw new ValueCreateError2(schema5, "Array with the contains constraint requires a default value");
  } else if ("default" in schema5) {
    return FromDefault2(schema5.default);
  } else if (schema5.minItems !== undefined) {
    return Array.from({ length: schema5.minItems }).map((item) => {
      return Visit23(schema5.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator11(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return false;
  }
}
function FromConstructor12(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    const value3 = Visit23(schema5.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val2] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val2;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (schema5.minimumTimestamp !== undefined) {
    return new Date(schema5.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction11(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return () => Visit23(schema5.returns, references);
  }
}
function FromInteger9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (schema5.minimum !== undefined) {
    return schema5.minimum;
  } else {
    return 0;
  }
}
function FromIntersect27(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    const value3 = schema5.allOf.reduce((acc, schema6) => {
      const next = Visit23(schema6, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check4(schema5, references, value3))
      throw new ValueCreateError2(schema5, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
}
function FromIterator11(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral11(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return schema5.const;
  }
}
function FromNever9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    throw new ValueCreateError2(schema5, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot11(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    throw new ValueCreateError2(schema5, "Not types must have a default value");
  }
}
function FromNull9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return null;
  }
}
function FromNumber9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (schema5.minimum !== undefined) {
    return schema5.minimum;
  } else {
    return 0;
  }
}
function FromObject17(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    const required5 = new Set(schema5.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema5.properties)) {
      if (!required5.has(key))
        continue;
      Acc[key] = Visit23(subschema, references);
    }
    return Acc;
  }
}
function FromPromise13(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return Promise.resolve(Visit23(schema5.item, references));
  }
}
function FromRecord15(schema5, references) {
  const [keyPattern, valueSchema] = Object.entries(schema5.patternProperties)[0];
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (!(keyPattern === PatternStringExact3 || keyPattern === PatternNumberExact3)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit23(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef15(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return Visit23(Deref4(schema5, references), references);
  }
}
function FromRegExp8(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    throw new ValueCreateError2(schema5, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString9(schema5, references) {
  if (schema5.pattern !== undefined) {
    if (!HasPropertyKey2(schema5, "default")) {
      throw new ValueCreateError2(schema5, "String types with patterns must specify a default value");
    } else {
      return FromDefault2(schema5.default);
    }
  } else if (schema5.format !== undefined) {
    if (!HasPropertyKey2(schema5, "default")) {
      throw new ValueCreateError2(schema5, "String types with formats must specify a default value");
    } else {
      return FromDefault2(schema5.default);
    }
  } else {
    if (HasPropertyKey2(schema5, "default")) {
      return FromDefault2(schema5.default);
    } else if (schema5.minLength !== undefined) {
      return Array.from({ length: schema5.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if ("value" in schema5) {
    return Symbol.for(schema5.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral12(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  }
  if (!IsTemplateLiteralFinite2(schema5))
    throw new ValueCreateError2(schema5, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate2(schema5);
  return generated[0];
}
function FromThis13(schema5, references) {
  if (recursiveDepth2++ > recursiveMaxDepth2)
    throw new ValueCreateError2(schema5, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return Visit23(Deref4(schema5, references), references);
  }
}
function FromTuple21(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  }
  if (schema5.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema5.minItems }).map((_4, index2) => Visit23(schema5.items[index2], references));
  }
}
function FromUndefined9(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return;
  }
}
function FromUnion31(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (schema5.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit23(schema5.anyOf[0], references);
  }
}
function FromUint8Array8(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else if (schema5.minByteLength !== undefined) {
    return new Uint8Array(schema5.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown8(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return {};
  }
}
function FromVoid8(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    return;
  }
}
function FromKind6(schema5, references) {
  if (HasPropertyKey2(schema5, "default")) {
    return FromDefault2(schema5.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit23(schema5, references) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema_[Kind3]) {
    case "Any":
      return FromAny8(schema_, references_);
    case "Array":
      return FromArray23(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator11(schema_, references_);
    case "BigInt":
      return FromBigInt9(schema_, references_);
    case "Boolean":
      return FromBoolean9(schema_, references_);
    case "Constructor":
      return FromConstructor12(schema_, references_);
    case "Date":
      return FromDate9(schema_, references_);
    case "Function":
      return FromFunction11(schema_, references_);
    case "Integer":
      return FromInteger9(schema_, references_);
    case "Intersect":
      return FromIntersect27(schema_, references_);
    case "Iterator":
      return FromIterator11(schema_, references_);
    case "Literal":
      return FromLiteral11(schema_, references_);
    case "Never":
      return FromNever9(schema_, references_);
    case "Not":
      return FromNot11(schema_, references_);
    case "Null":
      return FromNull9(schema_, references_);
    case "Number":
      return FromNumber9(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise13(schema_, references_);
    case "Record":
      return FromRecord15(schema_, references_);
    case "Ref":
      return FromRef15(schema_, references_);
    case "RegExp":
      return FromRegExp8(schema_, references_);
    case "String":
      return FromString9(schema_, references_);
    case "Symbol":
      return FromSymbol9(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral12(schema_, references_);
    case "This":
      return FromThis13(schema_, references_);
    case "Tuple":
      return FromTuple21(schema_, references_);
    case "Undefined":
      return FromUndefined9(schema_, references_);
    case "Union":
      return FromUnion31(schema_, references_);
    case "Uint8Array":
      return FromUint8Array8(schema_, references_);
    case "Unknown":
      return FromUnknown8(schema_, references_);
    case "Void":
      return FromVoid8(schema_, references_);
    default:
      if (!exports_type5.Has(schema_[Kind3]))
        throw new ValueCreateError2(schema_, "Unknown type");
      return FromKind6(schema_, references_);
  }
}
var recursiveMaxDepth2 = 512;
var recursiveDepth2 = 0;
function Create5(...args) {
  recursiveDepth2 = 0;
  return args.length === 2 ? Visit23(args[0], args[1]) : Visit23(args[0], []);
}
// ../node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError2 extends TypeBoxError2 {
  constructor(schema5, message) {
    super(message);
    this.schema = schema5;
  }
}
function ScoreUnion2(schema5, references, value3) {
  if (schema5[Kind3] === "Object" && typeof value3 === "object" && !IsNull8(value3)) {
    const object5 = schema5;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object5.properties);
    const [point2, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema6]) => {
      const literal6 = schema6[Kind3] === "Literal" && schema6.const === value3[key] ? max : 0;
      const checks = Check4(schema6, references, value3[key]) ? point2 : 0;
      const exists2 = keys.includes(key) ? point2 : 0;
      return acc + (literal6 + checks + exists2);
    }, 0);
  } else {
    return Check4(schema5, references, value3) ? 1 : 0;
  }
}
function SelectUnion2(union8, references, value3) {
  const schemas = union8.anyOf.map((schema5) => Deref4(schema5, references));
  let [select2, best] = [schemas[0], 0];
  for (const schema5 of schemas) {
    const score = ScoreUnion2(schema5, references, value3);
    if (score > best) {
      select2 = schema5;
      best = score;
    }
  }
  return select2;
}
function CastUnion2(union8, references, value3) {
  if ("default" in union8) {
    return typeof value3 === "function" ? union8.default : Clone5(union8.default);
  } else {
    const schema5 = SelectUnion2(union8, references, value3);
    return Cast3(schema5, references, value3);
  }
}
function DefaultClone2(schema5, references, value3) {
  return Check4(schema5, references, value3) ? Clone5(value3) : Create5(schema5, references);
}
function Default7(schema5, references, value3) {
  return Check4(schema5, references, value3) ? value3 : Create5(schema5, references);
}
function FromArray24(schema5, references, value3) {
  if (Check4(schema5, references, value3))
    return Clone5(value3);
  const created = IsArray8(value3) ? Clone5(value3) : Create5(schema5, references);
  const minimum = IsNumber8(schema5.minItems) && created.length < schema5.minItems ? [...created, ...Array.from({ length: schema5.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber8(schema5.maxItems) && minimum.length > schema5.maxItems ? minimum.slice(0, schema5.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit24(schema5.items, references, value4));
  if (schema5.uniqueItems !== true)
    return casted;
  const unique2 = [...new Set(casted)];
  if (!Check4(schema5, references, unique2))
    throw new ValueCastError2(schema5, "Array cast produced invalid data due to uniqueItems constraint");
  return unique2;
}
function FromConstructor13(schema5, references, value3) {
  if (Check4(schema5, references, value3))
    return Create5(schema5, references);
  const required5 = new Set(schema5.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema5.returns.properties)) {
    if (!required5.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit24(property, references, value3.prototype[key]);
  }
  return result;
}
function FromIntersect28(schema5, references, value3) {
  const created = Create5(schema5, references);
  const mapped5 = IsStandardObject2(created) && IsStandardObject2(value3) ? { ...created, ...value3 } : value3;
  return Check4(schema5, references, mapped5) ? mapped5 : Create5(schema5, references);
}
function FromNever10(schema5, references, value3) {
  throw new ValueCastError2(schema5, "Never types cannot be cast");
}
function FromObject18(schema5, references, value3) {
  if (Check4(schema5, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create5(schema5, references);
  const required5 = new Set(schema5.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema5.properties)) {
    if (!required5.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit24(property, references, value3[key]);
  }
  if (typeof schema5.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema5.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit24(schema5.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
}
function FromRecord16(schema5, references, value3) {
  if (Check4(schema5, references, value3))
    return Clone5(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create5(schema5, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema5.patternProperties)[0];
  const subschema = schema5.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit24(subschema, references, propValue);
  }
  return result;
}
function FromRef16(schema5, references, value3) {
  return Visit24(Deref4(schema5, references), references, value3);
}
function FromThis14(schema5, references, value3) {
  return Visit24(Deref4(schema5, references), references, value3);
}
function FromTuple22(schema5, references, value3) {
  if (Check4(schema5, references, value3))
    return Clone5(value3);
  if (!IsArray8(value3))
    return Create5(schema5, references);
  if (schema5.items === undefined)
    return [];
  return schema5.items.map((schema6, index2) => Visit24(schema6, references, value3[index2]));
}
function FromUnion32(schema5, references, value3) {
  return Check4(schema5, references, value3) ? Clone5(value3) : CastUnion2(schema5, references, value3);
}
function Visit24(schema5, references, value3) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema5[Kind3]) {
    case "Array":
      return FromArray24(schema_, references_, value3);
    case "Constructor":
      return FromConstructor13(schema_, references_, value3);
    case "Intersect":
      return FromIntersect28(schema_, references_, value3);
    case "Never":
      return FromNever10(schema_, references_, value3);
    case "Object":
      return FromObject18(schema_, references_, value3);
    case "Record":
      return FromRecord16(schema_, references_, value3);
    case "Ref":
      return FromRef16(schema_, references_, value3);
    case "This":
      return FromThis14(schema_, references_, value3);
    case "Tuple":
      return FromTuple22(schema_, references_, value3);
    case "Union":
      return FromUnion32(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone2(schema5, references, value3);
    default:
      return Default7(schema_, references_, value3);
  }
}
function Cast3(...args) {
  return args.length === 3 ? Visit24(args[0], args[1], args[2]) : Visit24(args[0], [], args[1]);
}
// ../node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable3(schema5) {
  return IsSchema4(schema5) && schema5[Kind3] !== "Unsafe";
}
function FromArray25(schema5, references, value3) {
  if (!IsArray8(value3))
    return value3;
  return value3.map((value4) => Visit25(schema5.items, references, value4));
}
function FromIntersect29(schema5, references, value3) {
  const unevaluatedProperties = schema5.unevaluatedProperties;
  const intersections = schema5.allOf.map((schema6) => Visit25(schema6, references, Clone5(value3)));
  const composite5 = intersections.reduce((acc, value4) => IsObject8(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject8(value3) || !IsObject8(composite5) || !IsSchema4(unevaluatedProperties))
    return composite5;
  const knownkeys = KeyOfPropertyKeys2(schema5);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check4(unevaluatedProperties, references, value3[key])) {
      composite5[key] = Visit25(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite5;
}
function FromObject19(schema5, references, value3) {
  if (!IsObject8(value3) || IsArray8(value3))
    return value3;
  const additionalProperties = schema5.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema5.properties) {
      value3[key] = Visit25(schema5.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema4(additionalProperties) && Check4(additionalProperties, references, value3[key])) {
      value3[key] = Visit25(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
}
function FromRecord17(schema5, references, value3) {
  if (!IsObject8(value3))
    return value3;
  const additionalProperties = schema5.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value3);
  const [propertyKey, propertySchema] = Object.entries(schema5.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit25(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema4(additionalProperties) && Check4(additionalProperties, references, value3[key])) {
      value3[key] = Visit25(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
}
function FromRef17(schema5, references, value3) {
  return Visit25(Deref4(schema5, references), references, value3);
}
function FromThis15(schema5, references, value3) {
  return Visit25(Deref4(schema5, references), references, value3);
}
function FromTuple23(schema5, references, value3) {
  if (!IsArray8(value3))
    return value3;
  if (IsUndefined8(schema5.items))
    return [];
  const length = Math.min(value3.length, schema5.items.length);
  for (let i4 = 0;i4 < length; i4++) {
    value3[i4] = Visit25(schema5.items[i4], references, value3[i4]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
}
function FromUnion33(schema5, references, value3) {
  for (const inner of schema5.anyOf) {
    if (IsCheckable3(inner) && Check4(inner, references, value3)) {
      return Visit25(inner, references, value3);
    }
  }
  return value3;
}
function Visit25(schema5, references, value3) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema_[Kind3]) {
    case "Array":
      return FromArray25(schema_, references_, value3);
    case "Intersect":
      return FromIntersect29(schema_, references_, value3);
    case "Object":
      return FromObject19(schema_, references_, value3);
    case "Record":
      return FromRecord17(schema_, references_, value3);
    case "Ref":
      return FromRef17(schema_, references_, value3);
    case "This":
      return FromThis15(schema_, references_, value3);
    case "Tuple":
      return FromTuple23(schema_, references_, value3);
    case "Union":
      return FromUnion33(schema_, references_, value3);
    default:
      return value3;
  }
}
function Clean3(...args) {
  return args.length === 3 ? Visit25(args[0], args[1], args[2]) : Visit25(args[0], [], args[1]);
}
// ../node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric2(value3) {
  return IsString8(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
}
function IsValueToString2(value3) {
  return IsBigInt8(value3) || IsBoolean8(value3) || IsNumber8(value3);
}
function IsValueTrue2(value3) {
  return value3 === true || IsNumber8(value3) && value3 === 1 || IsBigInt8(value3) && value3 === BigInt("1") || IsString8(value3) && (value3.toLowerCase() === "true" || value3 === "1");
}
function IsValueFalse2(value3) {
  return value3 === false || IsNumber8(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt8(value3) && value3 === BigInt("0") || IsString8(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
}
function IsTimeStringWithTimeZone2(value3) {
  return IsString8(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
}
function IsTimeStringWithoutTimeZone2(value3) {
  return IsString8(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
}
function IsDateTimeStringWithTimeZone2(value3) {
  return IsString8(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
}
function IsDateTimeStringWithoutTimeZone2(value3) {
  return IsString8(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
}
function IsDateString2(value3) {
  return IsString8(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
}
function TryConvertLiteralString2(value3, target) {
  const conversion = TryConvertString2(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteralNumber2(value3, target) {
  const conversion = TryConvertNumber2(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteralBoolean2(value3, target) {
  const conversion = TryConvertBoolean2(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteral2(schema5, value3) {
  return IsString8(schema5.const) ? TryConvertLiteralString2(value3, schema5.const) : IsNumber8(schema5.const) ? TryConvertLiteralNumber2(value3, schema5.const) : IsBoolean8(schema5.const) ? TryConvertLiteralBoolean2(value3, schema5.const) : Clone5(value3);
}
function TryConvertBoolean2(value3) {
  return IsValueTrue2(value3) ? true : IsValueFalse2(value3) ? false : value3;
}
function TryConvertBigInt2(value3) {
  return IsStringNumeric2(value3) ? BigInt(parseInt(value3)) : IsNumber8(value3) ? BigInt(value3 | 0) : IsValueFalse2(value3) ? BigInt(0) : IsValueTrue2(value3) ? BigInt(1) : value3;
}
function TryConvertString2(value3) {
  return IsValueToString2(value3) ? value3.toString() : IsSymbol8(value3) && value3.description !== undefined ? value3.description.toString() : value3;
}
function TryConvertNumber2(value3) {
  return IsStringNumeric2(value3) ? parseFloat(value3) : IsValueTrue2(value3) ? 1 : IsValueFalse2(value3) ? 0 : value3;
}
function TryConvertInteger2(value3) {
  return IsStringNumeric2(value3) ? parseInt(value3) : IsNumber8(value3) ? value3 | 0 : IsValueTrue2(value3) ? 1 : IsValueFalse2(value3) ? 0 : value3;
}
function TryConvertNull2(value3) {
  return IsString8(value3) && value3.toLowerCase() === "null" ? null : value3;
}
function TryConvertUndefined2(value3) {
  return IsString8(value3) && value3 === "undefined" ? undefined : value3;
}
function TryConvertDate2(value3) {
  return IsDate8(value3) ? value3 : IsNumber8(value3) ? new Date(value3) : IsValueTrue2(value3) ? new Date(1) : IsValueFalse2(value3) ? new Date(0) : IsStringNumeric2(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone2(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone2(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone2(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone2(value3) ? new Date(value3) : IsDateString2(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
}
function Default8(value3) {
  return value3;
}
function FromArray26(schema5, references, value3) {
  const elements = IsArray8(value3) ? value3 : [value3];
  return elements.map((element) => Visit26(schema5.items, references, element));
}
function FromBigInt10(schema5, references, value3) {
  return TryConvertBigInt2(value3);
}
function FromBoolean10(schema5, references, value3) {
  return TryConvertBoolean2(value3);
}
function FromDate10(schema5, references, value3) {
  return TryConvertDate2(value3);
}
function FromInteger10(schema5, references, value3) {
  return TryConvertInteger2(value3);
}
function FromIntersect30(schema5, references, value3) {
  return schema5.allOf.reduce((value4, schema6) => Visit26(schema6, references, value4), value3);
}
function FromLiteral12(schema5, references, value3) {
  return TryConvertLiteral2(schema5, value3);
}
function FromNull10(schema5, references, value3) {
  return TryConvertNull2(value3);
}
function FromNumber10(schema5, references, value3) {
  return TryConvertNumber2(value3);
}
function FromObject20(schema5, references, value3) {
  const isConvertable = IsObject8(value3);
  if (!isConvertable)
    return value3;
  const result = {};
  for (const key of Object.keys(value3)) {
    result[key] = HasPropertyKey2(schema5.properties, key) ? Visit26(schema5.properties[key], references, value3[key]) : value3[key];
  }
  return result;
}
function FromRecord18(schema5, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema5.patternProperties)[0];
  const property = schema5.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit26(property, references, propValue);
  }
  return result;
}
function FromRef18(schema5, references, value3) {
  return Visit26(Deref4(schema5, references), references, value3);
}
function FromString10(schema5, references, value3) {
  return TryConvertString2(value3);
}
function FromSymbol10(schema5, references, value3) {
  return IsString8(value3) || IsNumber8(value3) ? Symbol(value3) : value3;
}
function FromThis16(schema5, references, value3) {
  return Visit26(Deref4(schema5, references), references, value3);
}
function FromTuple24(schema5, references, value3) {
  const isConvertable = IsArray8(value3) && !IsUndefined8(schema5.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index2) => {
    return index2 < schema5.items.length ? Visit26(schema5.items[index2], references, value4) : value4;
  });
}
function FromUndefined10(schema5, references, value3) {
  return TryConvertUndefined2(value3);
}
function FromUnion34(schema5, references, value3) {
  for (const subschema of schema5.anyOf) {
    const converted = Visit26(subschema, references, value3);
    if (!Check4(subschema, references, converted))
      continue;
    return converted;
  }
  return value3;
}
function Visit26(schema5, references, value3) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema5[Kind3]) {
    case "Array":
      return FromArray26(schema_, references_, value3);
    case "BigInt":
      return FromBigInt10(schema_, references_, value3);
    case "Boolean":
      return FromBoolean10(schema_, references_, value3);
    case "Date":
      return FromDate10(schema_, references_, value3);
    case "Integer":
      return FromInteger10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect30(schema_, references_, value3);
    case "Literal":
      return FromLiteral12(schema_, references_, value3);
    case "Null":
      return FromNull10(schema_, references_, value3);
    case "Number":
      return FromNumber10(schema_, references_, value3);
    case "Object":
      return FromObject20(schema_, references_, value3);
    case "Record":
      return FromRecord18(schema_, references_, value3);
    case "Ref":
      return FromRef18(schema_, references_, value3);
    case "String":
      return FromString10(schema_, references_, value3);
    case "Symbol":
      return FromSymbol10(schema_, references_, value3);
    case "This":
      return FromThis16(schema_, references_, value3);
    case "Tuple":
      return FromTuple24(schema_, references_, value3);
    case "Undefined":
      return FromUndefined10(schema_, references_, value3);
    case "Union":
      return FromUnion34(schema_, references_, value3);
    default:
      return Default8(value3);
  }
}
function Convert3(...args) {
  return args.length === 3 ? Visit26(args[0], args[1], args[2]) : Visit26(args[0], [], args[1]);
}
// ../node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault2(schema5, value3) {
  return value3 === undefined && "default" in schema5 ? Clone5(schema5.default) : value3;
}
function IsCheckable4(schema5) {
  return IsSchema4(schema5) && schema5[Kind3] !== "Unsafe";
}
function IsDefaultSchema2(value3) {
  return IsSchema4(value3) && "default" in value3;
}
function FromArray27(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  if (!IsArray8(defaulted))
    return defaulted;
  for (let i4 = 0;i4 < defaulted.length; i4++) {
    defaulted[i4] = Visit27(schema5.items, references, defaulted[i4]);
  }
  return defaulted;
}
function FromIntersect31(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  return schema5.allOf.reduce((acc, schema6) => {
    const next = Visit27(schema6, references, defaulted);
    return IsObject8(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject21(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  if (!IsObject8(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema5.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema5.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema2(schema5.properties[key]))
      continue;
    defaulted[key] = Visit27(schema5.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema2(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit27(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord19(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  if (!IsObject8(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema5.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema5.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema2(propertySchema)))
      continue;
    defaulted[key] = Visit27(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema2(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit27(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef19(schema5, references, value3) {
  return Visit27(Deref4(schema5, references), references, ValueOrDefault2(schema5, value3));
}
function FromThis17(schema5, references, value3) {
  return Visit27(Deref4(schema5, references), references, value3);
}
function FromTuple25(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  if (!IsArray8(defaulted) || IsUndefined8(schema5.items))
    return defaulted;
  const [items, max] = [schema5.items, Math.max(schema5.items.length, defaulted.length)];
  for (let i4 = 0;i4 < max; i4++) {
    if (i4 < items.length)
      defaulted[i4] = Visit27(items[i4], references, defaulted[i4]);
  }
  return defaulted;
}
function FromUnion35(schema5, references, value3) {
  const defaulted = ValueOrDefault2(schema5, value3);
  for (const inner of schema5.anyOf) {
    const result = Visit27(inner, references, defaulted);
    if (IsCheckable4(inner) && Check4(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit27(schema5, references, value3) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema_[Kind3]) {
    case "Array":
      return FromArray27(schema_, references_, value3);
    case "Intersect":
      return FromIntersect31(schema_, references_, value3);
    case "Object":
      return FromObject21(schema_, references_, value3);
    case "Record":
      return FromRecord19(schema_, references_, value3);
    case "Ref":
      return FromRef19(schema_, references_, value3);
    case "This":
      return FromThis17(schema_, references_, value3);
    case "Tuple":
      return FromTuple25(schema_, references_, value3);
    case "Union":
      return FromUnion35(schema_, references_, value3);
    default:
      return ValueOrDefault2(schema_, value3);
  }
}
function Default9(...args) {
  return args.length === 3 ? Visit27(args[0], args[1], args[2]) : Visit27(args[0], [], args[1]);
}
// ../node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer2 = {};
__export(exports_pointer2, {
  ValuePointerRootSetError: () => ValuePointerRootSetError2,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError2,
  Set: () => Set7,
  Has: () => Has6,
  Get: () => Get6,
  Format: () => Format2,
  Delete: () => Delete7
});
class ValuePointerRootSetError2 extends TypeBoxError2 {
  constructor(value3, path4, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path4;
    this.update = update;
  }
}

class ValuePointerRootDeleteError2 extends TypeBoxError2 {
  constructor(value3, path4) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path4;
  }
}
function Escape4(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format2(pointer2) {
  if (pointer2 === "")
    return;
  let [start, end] = [0, 0];
  for (let i4 = 0;i4 < pointer2.length; i4++) {
    const char2 = pointer2.charAt(i4);
    if (char2 === "/") {
      if (i4 === 0) {
        start = i4 + 1;
      } else {
        end = i4;
        yield Escape4(pointer2.slice(start, end));
        start = i4 + 1;
      }
    } else {
      end = i4;
    }
  }
  yield Escape4(pointer2.slice(start));
}
function Set7(value3, pointer2, update) {
  if (pointer2 === "")
    throw new ValuePointerRootSetError2(value3, pointer2, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete7(value3, pointer2) {
  if (pointer2 === "")
    throw new ValuePointerRootDeleteError2(value3, pointer2);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index2 = parseInt(key);
    owner.splice(index2, 1);
  } else {
    delete owner[key];
  }
}
function Has6(value3, pointer2) {
  if (pointer2 === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get6(value3, pointer2) {
  if (pointer2 === "")
    return value3;
  let current = value3;
  for (const component of Format2(pointer2)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// ../node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert2 = Object3({
  type: Literal2("insert"),
  path: String3(),
  value: Unknown2()
});
var Update2 = Object3({
  type: Literal2("update"),
  path: String3(),
  value: Unknown2()
});
var Delete8 = Object3({
  type: Literal2("delete"),
  path: String3()
});
var Edit2 = Union3([Insert2, Update2, Delete8]);

class ValueDeltaError2 extends TypeBoxError2 {
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError2 extends ValueDeltaError2 {
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
function CreateUpdate2(path4, value3) {
  return { type: "update", path: path4, value: value3 };
}
function CreateInsert2(path4, value3) {
  return { type: "insert", path: path4, value: value3 };
}
function CreateDelete2(path4) {
  return { type: "delete", path: path4 };
}
function* ObjectType10(path4, current, next) {
  if (!IsStandardObject2(next))
    return yield CreateUpdate2(path4, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol8(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined8(next[key]) && nextKeys.includes(key))
      yield CreateUpdate2(`${path4}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined8(current[key]) || IsUndefined8(next[key]))
      continue;
    if (IsSymbol8(key))
      throw new ValueDeltaSymbolError2(key);
    yield* Visit28(`${path4}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol8(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined8(current[key]))
      yield CreateInsert2(`${path4}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol8(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined8(next[key]) && !nextKeys.includes(key))
      yield CreateDelete2(`${path4}/${globalThis.String(key)}`);
  }
}
function* ArrayType10(path4, current, next) {
  if (!IsArray8(next))
    return yield CreateUpdate2(path4, next);
  for (let i4 = 0;i4 < Math.min(current.length, next.length); i4++) {
    yield* Visit28(`${path4}/${i4}`, current[i4], next[i4]);
  }
  for (let i4 = 0;i4 < next.length; i4++) {
    if (i4 < current.length)
      continue;
    yield CreateInsert2(`${path4}/${i4}`, next[i4]);
  }
  for (let i4 = current.length - 1;i4 >= 0; i4--) {
    if (i4 < next.length)
      continue;
    yield CreateDelete2(`${path4}/${i4}`);
  }
}
function* TypedArrayType6(path4, current, next) {
  if (!IsTypedArray2(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate2(path4, next);
  for (let i4 = 0;i4 < Math.min(current.length, next.length); i4++) {
    yield* Visit28(`${path4}/${i4}`, current[i4], next[i4]);
  }
}
function* ValueType6(path4, current, next) {
  if (current === next)
    return;
  yield CreateUpdate2(path4, next);
}
function* Visit28(path4, current, next) {
  if (IsStandardObject2(current))
    return yield* ObjectType10(path4, current, next);
  if (IsArray8(current))
    return yield* ArrayType10(path4, current, next);
  if (IsTypedArray2(current))
    return yield* TypedArrayType6(path4, current, next);
  if (IsValueType2(current))
    return yield* ValueType6(path4, current, next);
  throw new ValueDeltaError2(current, "Unable to create diff edits for unknown value");
}
function Diff3(current, next) {
  return [...Visit28("", current, next)];
}
function IsRootUpdate2(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity2(edits) {
  return edits.length === 0;
}
function Patch3(current, edits) {
  if (IsRootUpdate2(edits)) {
    return Clone5(edits[0].value);
  }
  if (IsIdentity2(edits)) {
    return Clone5(current);
  }
  const clone6 = Clone5(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer2.Set(clone6, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer2.Set(clone6, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer2.Delete(clone6, edit.path);
        break;
      }
    }
  }
  return clone6;
}
// ../node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType11(left2, right2) {
  if (!IsStandardObject2(right2))
    return false;
  const leftKeys = [...Object.keys(left2), ...Object.getOwnPropertySymbols(left2)];
  const rightKeys = [...Object.keys(right2), ...Object.getOwnPropertySymbols(right2)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal3(left2[key], right2[key]));
}
function DateType8(left2, right2) {
  return IsDate8(right2) && left2.getTime() === right2.getTime();
}
function ArrayType11(left2, right2) {
  if (!IsArray8(right2) || left2.length !== right2.length)
    return false;
  return left2.every((value3, index2) => Equal3(value3, right2[index2]));
}
function TypedArrayType7(left2, right2) {
  if (!IsTypedArray2(right2) || left2.length !== right2.length || Object.getPrototypeOf(left2).constructor.name !== Object.getPrototypeOf(right2).constructor.name)
    return false;
  return left2.every((value3, index2) => Equal3(value3, right2[index2]));
}
function ValueType7(left2, right2) {
  return left2 === right2;
}
function Equal3(left2, right2) {
  if (IsStandardObject2(left2))
    return ObjectType11(left2, right2);
  if (IsDate8(left2))
    return DateType8(left2, right2);
  if (IsTypedArray2(left2))
    return TypedArrayType7(left2, right2);
  if (IsArray8(left2))
    return ArrayType11(left2, right2);
  if (IsValueType2(left2))
    return ValueType7(left2, right2);
  throw new Error("ValueEquals: Unable to compare value");
}
// ../node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError2 extends TypeBoxError2 {
  constructor(message) {
    super(message);
  }
}
function ObjectType12(root2, path4, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer2.Set(root2, path4, Clone5(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit29(root2, `${path4}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType12(root2, path4, current, next) {
  if (!IsArray8(current)) {
    exports_pointer2.Set(root2, path4, Clone5(next));
  } else {
    for (let index2 = 0;index2 < next.length; index2++) {
      Visit29(root2, `${path4}/${index2}`, current[index2], next[index2]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType8(root2, path4, current, next) {
  if (IsTypedArray2(current) && current.length === next.length) {
    for (let i4 = 0;i4 < current.length; i4++) {
      current[i4] = next[i4];
    }
  } else {
    exports_pointer2.Set(root2, path4, Clone5(next));
  }
}
function ValueType8(root2, path4, current, next) {
  if (current === next)
    return;
  exports_pointer2.Set(root2, path4, next);
}
function Visit29(root2, path4, current, next) {
  if (IsArray8(next))
    return ArrayType12(root2, path4, current, next);
  if (IsTypedArray2(next))
    return TypedArrayType8(root2, path4, current, next);
  if (IsStandardObject2(next))
    return ObjectType12(root2, path4, current, next);
  if (IsValueType2(next))
    return ValueType8(root2, path4, current, next);
}
function IsNonMutableValue2(value3) {
  return IsTypedArray2(value3) || IsValueType2(value3);
}
function IsMismatchedValue2(current, next) {
  return IsStandardObject2(current) && IsArray8(next) || IsArray8(current) && IsStandardObject2(next);
}
function Mutate3(current, next) {
  if (IsNonMutableValue2(current) || IsNonMutableValue2(next))
    throw new ValueMutateError2("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue2(current, next))
    throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
  Visit29(current, "", current, next);
}
// ../node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError2 extends TypeBoxError2 {
  constructor(schema5, value3, error5) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema5;
    this.value = value3;
    this.error = error5;
  }
}

class TransformDecodeError2 extends TypeBoxError2 {
  constructor(schema5, path4, value3, error5) {
    super(error5 instanceof Error ? error5.message : "Unknown error");
    this.schema = schema5;
    this.path = path4;
    this.value = value3;
    this.error = error5;
  }
}
function Default10(schema5, path4, value3) {
  try {
    return IsTransform4(schema5) ? schema5[TransformKind3].Decode(value3) : value3;
  } catch (error5) {
    throw new TransformDecodeError2(schema5, path4, value3, error5);
  }
}
function FromArray28(schema5, references, path4, value3) {
  return IsArray8(value3) ? Default10(schema5, path4, value3.map((value4, index2) => Visit30(schema5.items, references, `${path4}/${index2}`, value4))) : Default10(schema5, path4, value3);
}
function FromIntersect32(schema5, references, path4, value3) {
  if (!IsStandardObject2(value3) || IsValueType2(value3))
    return Default10(schema5, path4, value3);
  const knownEntries = KeyOfPropertyEntries2(schema5);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value3 };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit30(knownSchema, references, `${path4}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform4(schema5.unevaluatedProperties)) {
    return Default10(schema5, path4, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema5.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default10(unevaluatedProperties, `${path4}/${key}`, unknownProperties[key]);
    }
  return Default10(schema5, path4, unknownProperties);
}
function FromNot12(schema5, references, path4, value3) {
  return Default10(schema5, path4, Visit30(schema5.not, references, path4, value3));
}
function FromObject22(schema5, references, path4, value3) {
  if (!IsStandardObject2(value3))
    return Default10(schema5, path4, value3);
  const knownKeys = KeyOfPropertyKeys2(schema5);
  const knownProperties = { ...value3 };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit30(schema5.properties[key], references, `${path4}/${key}`, knownProperties[key]);
    }
  if (!IsSchema4(schema5.additionalProperties)) {
    return Default10(schema5, path4, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema5.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default10(additionalProperties, `${path4}/${key}`, unknownProperties[key]);
    }
  return Default10(schema5, path4, unknownProperties);
}
function FromRecord20(schema5, references, path4, value3) {
  if (!IsStandardObject2(value3))
    return Default10(schema5, path4, value3);
  const pattern3 = Object.getOwnPropertyNames(schema5.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = { ...value3 };
  for (const key of Object.getOwnPropertyNames(value3))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit30(schema5.patternProperties[pattern3], references, `${path4}/${key}`, knownProperties[key]);
    }
  if (!IsSchema4(schema5.additionalProperties)) {
    return Default10(schema5, path4, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema5.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default10(additionalProperties, `${path4}/${key}`, unknownProperties[key]);
    }
  return Default10(schema5, path4, unknownProperties);
}
function FromRef20(schema5, references, path4, value3) {
  const target = Deref4(schema5, references);
  return Default10(schema5, path4, Visit30(target, references, path4, value3));
}
function FromThis18(schema5, references, path4, value3) {
  const target = Deref4(schema5, references);
  return Default10(schema5, path4, Visit30(target, references, path4, value3));
}
function FromTuple26(schema5, references, path4, value3) {
  return IsArray8(value3) && IsArray8(schema5.items) ? Default10(schema5, path4, schema5.items.map((schema6, index2) => Visit30(schema6, references, `${path4}/${index2}`, value3[index2]))) : Default10(schema5, path4, value3);
}
function FromUnion36(schema5, references, path4, value3) {
  for (const subschema of schema5.anyOf) {
    if (!Check4(subschema, references, value3))
      continue;
    const decoded = Visit30(subschema, references, path4, value3);
    return Default10(schema5, path4, decoded);
  }
  return Default10(schema5, path4, value3);
}
function Visit30(schema5, references, path4, value3) {
  const references_ = typeof schema5.$id === "string" ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema5[Kind3]) {
    case "Array":
      return FromArray28(schema_, references_, path4, value3);
    case "Intersect":
      return FromIntersect32(schema_, references_, path4, value3);
    case "Not":
      return FromNot12(schema_, references_, path4, value3);
    case "Object":
      return FromObject22(schema_, references_, path4, value3);
    case "Record":
      return FromRecord20(schema_, references_, path4, value3);
    case "Ref":
      return FromRef20(schema_, references_, path4, value3);
    case "Symbol":
      return Default10(schema_, path4, value3);
    case "This":
      return FromThis18(schema_, references_, path4, value3);
    case "Tuple":
      return FromTuple26(schema_, references_, path4, value3);
    case "Union":
      return FromUnion36(schema_, references_, path4, value3);
    default:
      return Default10(schema_, path4, value3);
  }
}
function TransformDecode2(schema5, references, value3) {
  return Visit30(schema5, references, "", value3);
}
// ../node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError2 extends TypeBoxError2 {
  constructor(schema5, value3, error5) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema5;
    this.value = value3;
    this.error = error5;
  }
}

class TransformEncodeError2 extends TypeBoxError2 {
  constructor(schema5, path4, value3, error5) {
    super(`${error5 instanceof Error ? error5.message : "Unknown error"}`);
    this.schema = schema5;
    this.path = path4;
    this.value = value3;
    this.error = error5;
  }
}
function Default11(schema5, path4, value3) {
  try {
    return IsTransform4(schema5) ? schema5[TransformKind3].Encode(value3) : value3;
  } catch (error5) {
    throw new TransformEncodeError2(schema5, path4, value3, error5);
  }
}
function FromArray29(schema5, references, path4, value3) {
  const defaulted = Default11(schema5, path4, value3);
  return IsArray8(defaulted) ? defaulted.map((value4, index2) => Visit31(schema5.items, references, `${path4}/${index2}`, value4)) : defaulted;
}
function FromIntersect33(schema5, references, path4, value3) {
  const defaulted = Default11(schema5, path4, value3);
  if (!IsStandardObject2(value3) || IsValueType2(value3))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries2(schema5);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit31(knownSchema, references, `${path4}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform4(schema5.unevaluatedProperties)) {
    return Default11(schema5, path4, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema5.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default11(unevaluatedProperties, `${path4}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot13(schema5, references, path4, value3) {
  return Default11(schema5.not, path4, Default11(schema5, path4, value3));
}
function FromObject23(schema5, references, path4, value3) {
  const defaulted = Default11(schema5, path4, value3);
  if (!IsStandardObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys2(schema5);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit31(schema5.properties[key], references, `${path4}/${key}`, knownProperties[key]);
    }
  if (!IsSchema4(schema5.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema5.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default11(additionalProperties, `${path4}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord21(schema5, references, path4, value3) {
  const defaulted = Default11(schema5, path4, value3);
  if (!IsStandardObject2(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema5.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value3))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit31(schema5.patternProperties[pattern3], references, `${path4}/${key}`, knownProperties[key]);
    }
  if (!IsSchema4(schema5.additionalProperties)) {
    return Default11(schema5, path4, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema5.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default11(additionalProperties, `${path4}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef21(schema5, references, path4, value3) {
  const target = Deref4(schema5, references);
  const resolved = Visit31(target, references, path4, value3);
  return Default11(schema5, path4, resolved);
}
function FromThis19(schema5, references, path4, value3) {
  const target = Deref4(schema5, references);
  const resolved = Visit31(target, references, path4, value3);
  return Default11(schema5, path4, resolved);
}
function FromTuple27(schema5, references, path4, value3) {
  const value1 = Default11(schema5, path4, value3);
  return IsArray8(schema5.items) ? schema5.items.map((schema6, index2) => Visit31(schema6, references, `${path4}/${index2}`, value1[index2])) : [];
}
function FromUnion37(schema5, references, path4, value3) {
  for (const subschema of schema5.anyOf) {
    if (!Check4(subschema, references, value3))
      continue;
    const value1 = Visit31(subschema, references, path4, value3);
    return Default11(schema5, path4, value1);
  }
  for (const subschema of schema5.anyOf) {
    const value1 = Visit31(subschema, references, path4, value3);
    if (!Check4(schema5, references, value1))
      continue;
    return Default11(schema5, path4, value1);
  }
  return Default11(schema5, path4, value3);
}
function Visit31(schema5, references, path4, value3) {
  const references_ = typeof schema5.$id === "string" ? [...references, schema5] : references;
  const schema_ = schema5;
  switch (schema5[Kind3]) {
    case "Array":
      return FromArray29(schema_, references_, path4, value3);
    case "Intersect":
      return FromIntersect33(schema_, references_, path4, value3);
    case "Not":
      return FromNot13(schema_, references_, path4, value3);
    case "Object":
      return FromObject23(schema_, references_, path4, value3);
    case "Record":
      return FromRecord21(schema_, references_, path4, value3);
    case "Ref":
      return FromRef21(schema_, references_, path4, value3);
    case "This":
      return FromThis19(schema_, references_, path4, value3);
    case "Tuple":
      return FromTuple27(schema_, references_, path4, value3);
    case "Union":
      return FromUnion37(schema_, references_, path4, value3);
    default:
      return Default11(schema_, path4, value3);
  }
}
function TransformEncode2(schema5, references, value3) {
  return Visit31(schema5, references, "", value3);
}
// ../node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray30(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.items, references);
}
function FromAsyncIterator12(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.items, references);
}
function FromConstructor14(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.returns, references) || schema5.parameters.some((schema6) => Visit32(schema6, references));
}
function FromFunction12(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.returns, references) || schema5.parameters.some((schema6) => Visit32(schema6, references));
}
function FromIntersect34(schema5, references) {
  return IsTransform4(schema5) || IsTransform4(schema5.unevaluatedProperties) || schema5.allOf.some((schema6) => Visit32(schema6, references));
}
function FromIterator12(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.items, references);
}
function FromNot14(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.not, references);
}
function FromObject24(schema5, references) {
  return IsTransform4(schema5) || Object.values(schema5.properties).some((schema6) => Visit32(schema6, references)) || IsSchema4(schema5.additionalProperties) && Visit32(schema5.additionalProperties, references);
}
function FromPromise14(schema5, references) {
  return IsTransform4(schema5) || Visit32(schema5.item, references);
}
function FromRecord22(schema5, references) {
  const pattern3 = Object.getOwnPropertyNames(schema5.patternProperties)[0];
  const property = schema5.patternProperties[pattern3];
  return IsTransform4(schema5) || Visit32(property, references) || IsSchema4(schema5.additionalProperties) && IsTransform4(schema5.additionalProperties);
}
function FromRef22(schema5, references) {
  if (IsTransform4(schema5))
    return true;
  return Visit32(Deref4(schema5, references), references);
}
function FromThis20(schema5, references) {
  if (IsTransform4(schema5))
    return true;
  return Visit32(Deref4(schema5, references), references);
}
function FromTuple28(schema5, references) {
  return IsTransform4(schema5) || !IsUndefined8(schema5.items) && schema5.items.some((schema6) => Visit32(schema6, references));
}
function FromUnion38(schema5, references) {
  return IsTransform4(schema5) || schema5.anyOf.some((schema6) => Visit32(schema6, references));
}
function Visit32(schema5, references) {
  const references_ = IsString8(schema5.$id) ? [...references, schema5] : references;
  const schema_ = schema5;
  if (schema5.$id && visited2.has(schema5.$id))
    return false;
  if (schema5.$id)
    visited2.add(schema5.$id);
  switch (schema5[Kind3]) {
    case "Array":
      return FromArray30(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator12(schema_, references_);
    case "Constructor":
      return FromConstructor14(schema_, references_);
    case "Function":
      return FromFunction12(schema_, references_);
    case "Intersect":
      return FromIntersect34(schema_, references_);
    case "Iterator":
      return FromIterator12(schema_, references_);
    case "Not":
      return FromNot14(schema_, references_);
    case "Object":
      return FromObject24(schema_, references_);
    case "Promise":
      return FromPromise14(schema_, references_);
    case "Record":
      return FromRecord22(schema_, references_);
    case "Ref":
      return FromRef22(schema_, references_);
    case "This":
      return FromThis20(schema_, references_);
    case "Tuple":
      return FromTuple28(schema_, references_);
    case "Union":
      return FromUnion38(schema_, references_);
    default:
      return IsTransform4(schema5);
  }
}
var visited2 = new Set;
function HasTransform2(schema5, references) {
  visited2.clear();
  return Visit32(schema5, references);
}
// ../node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value4 = {};
__export(exports_value4, {
  Patch: () => Patch4,
  Mutate: () => Mutate4,
  Hash: () => Hash5,
  Errors: () => Errors5,
  Equal: () => Equal4,
  Encode: () => Encode2,
  Diff: () => Diff4,
  Default: () => Default12,
  Decode: () => Decode2,
  Create: () => Create6,
  Convert: () => Convert4,
  Clone: () => Clone6,
  Clean: () => Clean4,
  Check: () => Check5,
  Cast: () => Cast4
});
function Cast4(...args) {
  return Cast3.apply(Cast3, args);
}
function Create6(...args) {
  return Create5.apply(Create5, args);
}
function Check5(...args) {
  return Check4.apply(Check4, args);
}
function Clean4(...args) {
  return Clean3.apply(Clean3, args);
}
function Convert4(...args) {
  return Convert3.apply(Convert3, args);
}
function Clone6(value3) {
  return Clone5(value3);
}
function Decode2(...args) {
  const [schema5, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check5(schema5, references, value3))
    throw new TransformDecodeCheckError2(schema5, value3, Errors5(schema5, references, value3).First());
  return HasTransform2(schema5, references) ? TransformDecode2(schema5, references, value3) : value3;
}
function Default12(...args) {
  return Default9.apply(Default9, args);
}
function Encode2(...args) {
  const [schema5, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform2(schema5, references) ? TransformEncode2(schema5, references, value3) : value3;
  if (!Check5(schema5, references, encoded))
    throw new TransformEncodeCheckError2(schema5, encoded, Errors5(schema5, references, encoded).First());
  return encoded;
}
function Errors5(...args) {
  return Errors4.apply(Errors4, args);
}
function Equal4(left2, right2) {
  return Equal3(left2, right2);
}
function Diff4(current, next) {
  return Diff3(current, next);
}
function Hash5(value3) {
  return Hash4(value3);
}
function Patch4(current, edits) {
  return Patch3(current, edits);
}
function Mutate4(current, next) {
  Mutate3(current, next);
}
// src/models/index.ts
var Optional3 = (schema5) => Type2.Union([Type2.Null(), Type2.Undefined(), schema5]);
var encodeDate = (date6) => {
  return typeof date6 === "number" ? date6 : date6.getTime();
};
var TSpaceInfo = Type2.Object({
  id: Type2.Integer(),
  name: Type2.String(),
  handle: Optional3(Type2.String()),
  date: Type2.Integer()
});
var encodeSpaceInfo = (space) => {
  return exports_value4.Encode(TSpaceInfo, {
    ...space,
    date: encodeDate(space.date)
  });
};
var TUserInfo = Type2.Object({
  id: Type2.Integer(),
  firstName: Optional3(Type2.String()),
  lastName: Optional3(Type2.String()),
  username: Optional3(Type2.String()),
  email: Optional3(Type2.String()),
  date: Type2.Integer()
});
var encodeUserInfo = (user) => {
  return exports_value4.Encode(TUserInfo, {
    ...user,
    date: user.date ? encodeDate(user.date) : 0
  });
};
var TMemberInfo = Type2.Object({
  id: Type2.Integer(),
  userId: Type2.Integer(),
  spaceId: Type2.Integer(),
  role: Type2.Union([Type2.Literal("owner"), Type2.Literal("admin"), Type2.Literal("member")]),
  date: Type2.Integer()
});
var encodeMemberInfo = (member) => {
  return exports_value4.Encode(TMemberInfo, {
    ...member,
    date: encodeDate(member.date)
  });
};
var TChatInfo = Type2.Object({
  id: Type2.Integer(),
  spaceId: Optional3(Type2.Integer()),
  title: Optional3(Type2.String()),
  date: Type2.Integer(),
  threadNumber: Optional3(Type2.Integer())
});
var encodeChatInfo = (chat) => {
  return exports_value4.Encode(TChatInfo, {
    ...chat,
    date: encodeDate(chat.date),
    threadNumber: chat.threadNumber ? chat.threadNumber : undefined
  });
};
var TMessageInfo = Type2.Object({
  id: Type2.Integer(),
  chatId: Type2.Integer(),
  fromId: Type2.Integer(),
  text: Optional3(Type2.String()),
  date: Type2.Integer(),
  editDate: Optional3(Type2.Integer())
});
var encodeMessageInfo = (message) => {
  return exports_value4.Encode(TMessageInfo, {
    ...message,
    date: encodeDate(message.date)
  });
};

// src/methods/createSpace.ts
var Input2 = Type2.Object({
  name: Type2.String(),
  handle: Type2.Optional(Type2.String())
});
var Response3 = Type2.Object({
  space: TSpaceInfo,
  member: TMemberInfo,
  chats: Type2.Array(TChatInfo)
});
var handler2 = async (input, context8) => {
  try {
    let space = (await db.insert(spaces).values({
      name: input.name,
      handle: input.handle ?? null
    }).returning())[0];
    let member = (await db.insert(members).values({
      spaceId: space.id,
      userId: context8.currentUserId,
      role: "owner"
    }).returning())[0];
    let mainChat = (await db.insert(chats).values({
      spaceId: space.id,
      type: "thread",
      title: "Main",
      spacePublic: true,
      description: "Main chat for everyone in the space",
      threadNumber: 1
    }).returning())[0];
    const output = { space, member, chats: [mainChat] };
    return {
      space: encodeSpaceInfo(output.space),
      member: encodeMemberInfo(output.member),
      chats: output.chats.map(encodeChatInfo)
    };
  } catch (error5) {
    Log.shared.error("Failed to create space", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to create space");
  }
};

// src/methods/getSpaces.ts
var Input3 = Type2.Object({});
var Response4 = Type2.Object({
  spaces: Type2.Array(TSpaceInfo),
  members: Type2.Array(TMemberInfo)
});
var handler3 = async (input, context8) => {
  try {
    const result = await db.select().from(members).where(eq(members.userId, context8.currentUserId)).innerJoin(spaces, eq(members.spaceId, spaces.id));
    const output = {
      spaces: result.map((r4) => r4.spaces),
      members: result.map((r4) => r4.members)
    };
    return {
      spaces: output.spaces.map(encodeSpaceInfo),
      members: output.members.map(encodeMemberInfo)
    };
  } catch (error5) {
    Log.shared.error("Failed to send email code", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to send email code");
  }
};

// src/methods/getSpace.ts
var Input4 = Type2.Object({
  id: Type2.String()
});
var Response5 = Type2.Object({
  space: TSpaceInfo,
  members: Type2.Array(TMemberInfo),
  chats: Type2.Array(TChatInfo)
});
var handler4 = async (input, context8) => {
  try {
    const spaceId = parseInt(input.id, 10);
    if (isNaN(spaceId)) {
      throw new InlineError(400 /* INVALID_INPUT */, "Invalid space ID");
    }
    const result = await db.select().from(spaces).where(eq(spaces.id, spaceId)).innerJoin(members, eq(spaces.id, members.spaceId)).innerJoin(chats, eq(spaces.id, chats.spaceId));
    return {
      space: encodeSpaceInfo(result[0].spaces),
      members: result.map((r4) => encodeMemberInfo(r4.members)),
      chats: result.map((r4) => encodeChatInfo(r4.chats))
    };
  } catch (error5) {
    Log.shared.error("Failed to get space", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to get space");
  }
};

// src/methods/getMe.ts
var Input5 = Type2.Object({});
var Response6 = Type2.Object({
  user: TUserInfo
});
var handler5 = async (_4, { currentUserId }) => {
  try {
    let user = await db.select().from(users).where(eq(users.id, currentUserId));
    return { user: encodeUserInfo(user[0]) };
  } catch (error5) {
    Log.shared.error("Failed to get me", error5);
    throw new InlineError(500 /* SERVER_ERROR */);
  }
};

// src/methods/checkUsername.ts
var Input6 = Type2.Object({
  username: Type2.String()
});
var Response7 = Type2.Object({
  available: Type2.Boolean()
});
var handler6 = async (input, context8) => {
  try {
    const result = await db.select().from(users).where(and(eq(users.username, input.username), not3(eq(users.id, context8.currentUserId))));
    return { available: result.length === 0 };
  } catch (error5) {
    Log.shared.error("Failed to check username", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to check username");
  }
};
var checkUsernameAvailable = async (username) => {
  const normalizedUsername = username.toLowerCase().trim();
  const result = await db.query.users.findFirst({
    where: eq(users.username, normalizedUsername),
    columns: { username: true }
  });
  return result === undefined;
};

// src/methods/updateProfile.ts
var Input7 = Type2.Object({
  firstName: Type2.Optional(Type2.String()),
  lastName: Type2.Optional(Type2.String()),
  username: Type2.Optional(Type2.String())
});
var Response8 = Type2.Object({
  user: TUserInfo
});
var handler7 = async (input, context8) => {
  try {
    if (input.username) {
      let isAvailable = await checkUsernameAvailable(input.username);
      if (!isAvailable) {
        throw new InlineError(400 /* INAVLID_ARGS */, "Username is already taken");
      }
    }
    let props = {};
    if ("firstName" in input)
      props.firstName = input.firstName ?? null;
    if ("lastName" in input)
      props.lastName = input.lastName ?? null;
    if ("username" in input)
      props.username = input.username ?? null;
    let user = await db.update(users).set(props).where(eq(users.id, context8.currentUserId)).returning();
    return { user: encodeUserInfo(user[0]) };
  } catch (error5) {
    Log.shared.error("Failed to set profile", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to set profile");
  }
};

// src/methods/createThread.ts
var Input8 = Type2.Object({
  title: Type2.String(),
  spaceId: Type2.String()
});
var Response9 = Type2.Object({
  chat: TChatInfo
});
var handler8 = async (input, _4) => {
  try {
    const spaceId = parseInt(input.spaceId, 10);
    if (isNaN(spaceId)) {
      throw new InlineError(500 /* SERVER_ERROR */, "Invalid spaceId");
    }
    var maxThreadNumber = await db.select({ maxThreadNumber: sql`MAX(${chats.threadNumber})` }).from(chats).where(eq(chats.spaceId, spaceId)).then((result) => result[0]?.maxThreadNumber ?? 0);
    var threadNumber = maxThreadNumber + 1;
    const chat = await db.insert(chats).values({
      spaceId,
      type: "thread",
      title: input.title,
      spacePublic: true,
      date: new Date,
      threadNumber
    }).returning();
    return { chat: encodeChatInfo(chat[0]) };
  } catch (error5) {
    Log.shared.error("Failed to create thread", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to create thread");
  }
};

// src/libs/ipinfo.ts
var ipinfo = async (ip) => {
  if (!IPINFO_TOKEN) {
    console.warn("Cannot check IP. IPINFO_TOKEN is not defined.");
    return;
  }
  let result = await fetch(`https://ipinfo.io/${ip}?token=${IPINFO_TOKEN}`, {
    headers: {
      Accept: "application/json"
    }
  });
  if (!result.ok) {
    console.warn(`Failed to get IP info for ${ip}.`);
    return;
  }
  return result.json();
};

// src/methods/verifyEmailCode.ts
var Input9 = Type2.Object({
  email: Type2.String(),
  code: Type2.String(),
  clientType: Type2.Optional(Type2.Union([Type2.Literal("ios"), Type2.Literal("macos"), Type2.Literal("web")])),
  clientVersion: Type2.Optional(Type2.String()),
  osVersion: Type2.Optional(Type2.String()),
  deviceName: Type2.Optional(Type2.String()),
  timezone: Type2.Optional(Type2.String())
});
var Response10 = Type2.Object({
  userId: Type2.Number(),
  token: Type2.String(),
  user: TUserInfo
});
var handler9 = async (input, { ip: requestIp }) => {
  try {
    if (isValidEmail(input.email) === false) {
      throw new InlineError(400 /* INAVLID_ARGS */, "Invalid email");
    }
    let email = normalizeEmail(input.email);
    await new Promise((resolve3) => setTimeout(resolve3, Math.random() * 1000));
    await verifyCode(email, input.code);
    let ipInfo = requestIp ? await ipinfo(requestIp) : undefined;
    let ip = requestIp ?? null;
    let country = ipInfo?.country ?? null;
    let region = ipInfo?.region ?? null;
    let city = ipInfo?.city ?? null;
    let timezone = validateIanaTimezone(input.timezone ?? "") ? input.timezone ?? null : ipInfo?.timezone ?? null;
    let clientType = input.clientType ?? null;
    let clientVersion = validateUpToFourSegementSemver(input.clientVersion ?? "") ? input.clientVersion ?? null : null;
    let osVersion = validateUpToFourSegementSemver(input.osVersion ?? "") ? input.osVersion ?? null : null;
    let user = await getUserByEmail(email);
    let userId = user.id;
    let { token: token2 } = await createSession({
      userId,
      ip,
      country,
      region,
      city,
      timezone,
      clientType,
      clientVersion: clientVersion ?? null,
      osVersion: osVersion ?? null,
      deviceName: input.deviceName ?? null
    });
    return { userId, token: token2, user: encodeUserInfo(user) };
  } catch (error5) {
    Log.shared.error("Failed to send email code", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to send email code");
  }
};
var verifyCode = async (email, code) => {
  let existingCode = (await db.select().from(loginCodes).where(and(eq(loginCodes.email, email), gte(loginCodes.expiresAt, new Date), lt(loginCodes.attempts, MAX_LOGIN_ATTEMPTS))).limit(1))[0];
  if (!existingCode) {
    throw new Error("Invalid code. Try again.");
  }
  if (existingCode.code !== code) {
    await db.update(loginCodes).set({
      attempts: (existingCode.attempts ?? 0) + 1
    }).where(eq(loginCodes.id, existingCode.id));
    throw new Error("Invalid code");
  } else {
    await db.delete(loginCodes).where(eq(loginCodes.id, existingCode.id));
    return true;
  }
};
var getUserByEmail = async (email) => {
  let user = (await db.select().from(users).where(eq(users.email, email)).limit(1))[0];
  if (!user) {
    let user2 = (await db.insert(users).values({
      email,
      emailVerified: true
    }).returning())[0];
    return user2;
  }
  return user;
};
var createSession = async ({
  userId,
  ...session
}) => {
  let { token: token2, tokenHash } = await generateToken(userId);
  await db.insert(sessions).values({
    userId,
    ...session,
    tokenHash,
    date: new Date
  });
  return { token: token2 };
};

// src/libs/twilio.ts
class TwilioVerify {
  accountSid;
  authToken;
  serviceSid;
  baseUrl;
  authHeader;
  constructor(accountSid, authToken, serviceSid = null) {
    this.accountSid = accountSid;
    this.authToken = authToken;
    this.serviceSid = serviceSid;
    this.baseUrl = "https://verify.twilio.com/v2";
    this.authHeader = `Basic ${Buffer.from(`${this.accountSid}:${this.authToken}`).toString("base64")}`;
  }
  async sendVerificationToken(to, channel) {
    if (!this.serviceSid) {
      throw new Error("Service SID is not set. Create a verification service first.");
    }
    try {
      const response2 = await fetch(`${this.baseUrl}/Services/${this.serviceSid}/Verifications`, {
        method: "POST",
        headers: {
          Authorization: this.authHeader,
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({ To: to, Channel: channel })
      });
      if (!response2.ok) {
        const errorData = await response2.json();
        throw new Error(`HTTP error! status: ${response2.status}, message: ${errorData.message}`);
      }
      return await response2.json();
    } catch (error5) {
      throw new Error(`Failed to send verification token: ${error5.message}`);
    }
  }
  async checkVerificationToken(to, code) {
    if (!this.serviceSid) {
      throw new Error("Service SID is not set. Create a verification service first.");
    }
    try {
      const response2 = await fetch(`${this.baseUrl}/Services/${this.serviceSid}/VerificationCheck`, {
        method: "POST",
        headers: {
          Authorization: this.authHeader,
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({ To: to, Code: code })
      });
      if (!response2.ok) {
        const errorData = await response2.json();
        throw new Error(`HTTP error! status: ${response2.status}, message: ${errorData.message}`);
      }
      return await response2.json();
    } catch (error5) {
      throw new Error(`Failed to check verification token: ${error5.message}`);
    }
  }
}

class TwilioLookups {
  accountSid;
  authToken;
  baseUrl;
  authHeader;
  constructor(accountSid, authToken) {
    this.accountSid = accountSid;
    this.authToken = authToken;
    this.baseUrl = "https://lookups.twilio.com/v2";
    this.authHeader = `Basic ${Buffer.from(`${this.accountSid}:${this.authToken}`).toString("base64")}`;
  }
  async phoneNumbers(phoneNumber) {
    const response2 = await fetch(`${this.baseUrl}/PhoneNumbers/${phoneNumber}`, {
      headers: { Authorization: this.authHeader }
    });
    return await response2.json();
  }
}
var twilio = {
  verify: new TwilioVerify(TWILIO_SID, TWILIO_AUTH_TOKEN, TWILIO_VERIFY_SERVICE_SID),
  lookups: new TwilioLookups(TWILIO_SID, TWILIO_AUTH_TOKEN)
};

// src/methods/sendSmsCode.ts
var Input10 = Type2.Object({
  phoneNumber: Type2.String()
});
var Response11 = Type2.Object({
  existingUser: Type2.Boolean(),
  phoneNumber: Type2.String()
});
var handler10 = async (input, _4) => {
  try {
    if (isValidPhoneNumber(input.phoneNumber) === false) {
      throw new InlineError(400 /* INAVLID_ARGS */, "Invalid phone number format");
    }
    const lookup = await twilio.lookups.phoneNumbers(input.phoneNumber);
    if (lookup.valid === false) {
      throw new InlineError(400 /* INAVLID_ARGS */, "Invalid phone number");
    }
    let response2 = await twilio.verify.sendVerificationToken(lookup.phone_number, "sms");
    if (response2?.status !== "pending") {
      throw new InlineError(500 /* SERVER_ERROR */, "Failed to send sms code");
    }
    console.log("sending sms code to", lookup.phone_number);
    let existingUser = await db.query.users.findFirst({
      where: eq(users.phoneNumber, lookup.phone_number),
      columns: {
        id: true,
        phoneNumber: true
      }
    });
    return {
      existingUser: !!existingUser,
      phoneNumber: lookup.phone_number
    };
  } catch (error5) {
    Log.shared.error("Failed to send sms code", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to send sms code");
  }
};

// src/methods/verifySmsCode.ts
var Input11 = Type2.Object({
  phoneNumber: Type2.String(),
  code: Type2.String(),
  clientType: Type2.Optional(Type2.Union([Type2.Literal("ios"), Type2.Literal("macos"), Type2.Literal("web")])),
  clientVersion: Type2.Optional(Type2.String()),
  osVersion: Type2.Optional(Type2.String()),
  deviceName: Type2.Optional(Type2.String()),
  timezone: Type2.Optional(Type2.String())
});
var Response12 = Type2.Object({
  userId: Type2.Number(),
  token: Type2.String(),
  user: TUserInfo
});
var handler11 = async (input, { ip: requestIp }) => {
  try {
    if (isValidPhoneNumber(input.phoneNumber) === false) {
      throw new InlineError(400 /* INAVLID_ARGS */, "Invalid phone number format");
    }
    let response2 = await twilio.verify.checkVerificationToken(input.phoneNumber, input.code);
    if (response2?.status !== "approved" || response2?.valid === false || !response2.to) {
      throw new InlineError(500 /* SERVER_ERROR */, "Failed to send sms code");
    }
    const phoneNumber = response2.to;
    let ipInfo = requestIp ? await ipinfo(requestIp) : undefined;
    let ip = requestIp ?? null;
    let country = ipInfo?.country ?? null;
    let region = ipInfo?.region ?? null;
    let city = ipInfo?.city ?? null;
    let timezone = input.timezone ?? ipInfo?.timezone ?? null;
    let clientType = input.clientType ?? null;
    let clientVersion = validateUpToFourSegementSemver(input.clientVersion ?? "") ? input.clientVersion ?? null : null;
    let osVersion = validateUpToFourSegementSemver(input.osVersion ?? "") ? input.osVersion ?? null : null;
    let deviceName = input.deviceName ?? null;
    let user = await getUserByPhoneNumber(phoneNumber);
    let userId = user.id;
    let { token: token2 } = await createSession({
      userId,
      country,
      region,
      city,
      timezone,
      ip,
      clientType,
      clientVersion,
      osVersion,
      deviceName
    });
    return { userId, token: token2, user: encodeUserInfo(user) };
  } catch (error5) {
    Log.shared.error("Failed to verify sms code", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to verify sms code");
  }
};
var getUserByPhoneNumber = async (phoneNumber) => {
  let user = (await db.select().from(users).where(eq(users.phoneNumber, phoneNumber)).limit(1))[0];
  if (!user) {
    let user2 = (await db.insert(users).values({
      phoneNumber,
      phoneVerified: true
    }).returning())[0];
    return user2;
  }
  return user;
};

// src/methods/getUser.ts
var Input12 = Type2.Object({
  id: Type2.String()
});
var Response13 = Type2.Object({
  user: TUserInfo
});
var handler12 = async (input, _4) => {
  try {
    const id2 = parseInt(input.id);
    if (isNaN(id2)) {
      throw new InlineError(400 /* INVALID_INPUT */, "Invalid user ID");
    }
    const result = await db.select().from(users).where(eq(users.id, id2));
    return { user: encodeUserInfo(result[0]) };
  } catch (error5) {
    Log.shared.error("Failed to get user", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to get user");
  }
};

// src/methods/searchContacts.ts
var Input13 = Type2.Object({
  q: Type2.String(),
  limit: Type2.Optional(Type2.Integer({ default: 10 }))
});
var Response14 = Type2.Object({
  users: Type2.Array(TUserInfo)
});
var handler13 = async (input, { currentUserId }) => {
  try {
    let result = await db.select().from(users).where(and(sql`${users.username} ilike ${"%" + input.q + "%"}`, not3(eq(users.id, currentUserId)))).limit(input.limit ?? 10);
    return { users: result.map(encodeUserInfo) };
  } catch (error5) {
    Log.shared.error("Failed to get me", error5);
    throw new InlineError(500 /* SERVER_ERROR */);
  }
};

// src/methods/getChatHistory.ts
var Input14 = Type2.Object({
  id: Type2.String(),
  limit: Type2.Optional(Type2.Integer({ default: 50 }))
});
var Response15 = Type2.Object({
  messages: Type2.Array(TMessageInfo)
});
var handler14 = async (input, context8) => {
  try {
    const chatId = parseInt(input.id, 10);
    if (isNaN(chatId)) {
      throw new InlineError(400 /* INVALID_INPUT */, "Invalid chat ID");
    }
    const result = await db.select().from(messages2).where(eq(messages2.chatId, chatId)).orderBy(desc(messages2.date)).limit(input.limit ?? 50);
    return { messages: result.map(encodeMessageInfo) };
  } catch (error5) {
    Log.shared.error("Failed to get chat history", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to get chat history");
  }
};

// src/methods/sendMessage.ts
var Input15 = Type2.Object({
  chatId: Type2.String(),
  text: Type2.String(),
  peerUserIds: Type2.Array(Type2.String())
});
var Response16 = Type2.Object({
  message: TMessageInfo
});
var handler15 = async (input, context8) => {
  try {
    const chatId = parseInt(input.chatId, 10);
    if (isNaN(chatId)) {
      throw new InlineError(400 /* INVALID_INPUT */, "Invalid chat ID");
    }
    var prevMessageId = await db.select({ messageId: sql`MAX(${messages2.messageId})` }).from(messages2).where(eq(messages2.chatId, chatId)).then(([result]) => result?.messageId ?? 0);
    const [newMessage] = await db.insert(messages2).values({
      chatId,
      text: input.text,
      fromId: context8.currentUserId,
      messageId: prevMessageId + 1
    }).returning();
    await db.update(chats).set({ maxMsgId: prevMessageId + 1 }).where(eq(chats.id, chatId));
    return { message: encodeMessageInfo(newMessage) };
  } catch (error5) {
    Log.shared.error("Failed to get chat history", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to get chat history");
  }
};

// src/methods/createPrivateChat.ts
var Input16 = Type2.Object({
  peerId: Type2.String()
});
var Response17 = Type2.Object({
  chat: TChatInfo
});
var handler16 = async (input, context8) => {
  try {
    const peerId = parseInt(input.peerId, 10);
    if (isNaN(peerId)) {
      throw new InlineError(500 /* SERVER_ERROR */, "Invalid peerId");
    }
    const peerName = await db.select({ name: users.firstName }).from(users).where(eq(users.id, peerId));
    const currentUserName = await db.select({ name: users.firstName }).from(users).where(eq(users.id, context8.currentUserId));
    const minUserId = context8.currentUserId < peerId ? context8.currentUserId : peerId;
    const maxUserId = context8.currentUserId > peerId ? context8.currentUserId : peerId;
    const title = `${currentUserName[0].name}, ${peerName[0].name}`;
    const [chat] = await db.insert(chats).values({
      spaceId: null,
      type: "private",
      title,
      spacePublic: false,
      date: new Date,
      threadNumber: null,
      minUserId,
      maxUserId
    }).onConflictDoUpdate({
      target: [chats.minUserId, chats.maxUserId],
      set: { title }
    }).returning();
    let peerExistingDialog = await db.select().from(dialogs).where(and(eq(dialogs.chatId, chat.id), eq(dialogs.userId, peerId))).then((result) => result[0]);
    let currentUserExistingDialog = await db.select().from(dialogs).where(and(eq(dialogs.chatId, chat.id), eq(dialogs.userId, context8.currentUserId))).then((result) => result[0]);
    if (peerExistingDialog == null) {
      await db.insert(dialogs).values([
        {
          chatId: chat.id,
          userId: peerId,
          date: new Date
        }
      ]);
    }
    if (currentUserExistingDialog == null) {
      await db.insert(dialogs).values([
        {
          chatId: chat.id,
          userId: context8.currentUserId,
          date: new Date
        }
      ]);
    }
    return { chat: encodeChatInfo(chat) };
  } catch (error5) {
    Log.shared.error("Failed to create private chat", error5);
    throw new InlineError(500 /* SERVER_ERROR */, "Failed to create private chat");
  }
};

// src/controllers/v1/index.ts
var apiV1 = new Q0({ name: "v1" }).group("v1", (app) => {
  return app.use(setup).use(makeUnauthApiRoute("/sendSmsCode", Input10, Response11, handler10)).use(makeUnauthApiRoute("/verifySmsCode", Input11, Response12, handler11)).use(makeUnauthApiRoute("/sendEmailCode", Input, Response2, handler)).use(makeUnauthApiRoute("/verifyEmailCode", Input9, Response10, handler9)).use(makeApiRoute("/createSpace", Input2, Response3, handler2)).use(makeApiRoute("/updateProfile", Input7, Response8, handler7)).use(makeApiRoute("/getMe", Input5, Response6, handler5)).use(makeApiRoute("/getSpaces", Input3, Response4, handler3)).use(makeApiRoute("/getSpace", Input4, Response5, handler4)).use(makeApiRoute("/checkUsername", Input6, Response7, handler6)).use(makeApiRoute("/createThread", Input8, Response9, handler8)).use(makeApiRoute("/getUser", Input12, Response13, handler12)).use(makeApiRoute("/searchContacts", Input13, Response14, handler13)).use(makeApiRoute("/getChatHistory", Input14, Response15, handler14)).use(makeApiRoute("/sendMessage", Input15, Response16, handler15)).use(makeApiRoute("/createPrivateChat", Input16, Response17, handler16)).all("/*", () => {
    return { ok: false, errorCode: 404, description: "Method not found" };
  });
}).use(handleError);

// src/ws/protocol.ts
var Methods = V.Union([
  V.Object({
    m: V.Literal("getMe"),
    a: Input5
  })
]);
var ServerMessage = V.Union([
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(1 /* Message */),
    p: V.Any()
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(2 /* Response */),
    p: V.Any()
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(3 /* Error */),
    p: V.Object({
      description: V.String(),
      errorCode: V.Integer()
    })
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(4 /* Ack */)
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(5 /* ConnectionAck */),
    p: V.Any()
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(6 /* Pong */)
  })
]);
var ClientMessage = V.Union([
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(1 /* ConnectionInit */),
    p: V.Object({
      token: V.String(),
      userId: V.Integer()
    })
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(2 /* Message */),
    p: Methods
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(4 /* Ping */)
  }),
  V.Object({
    i: V.String(),
    t: V.Integer(),
    k: V.Literal(3 /* Ack */)
  })
]);
var createMessage = (data) => {
  const t4 = Date.now();
  switch (data.kind) {
    case 4 /* Ack */:
      return {
        i: data.id,
        t: t4,
        k: data.kind
      };
    case 6 /* Pong */:
      return {
        i: data.id,
        t: t4,
        k: data.kind
      };
    case 3 /* Error */:
      return {
        i: data.id,
        t: t4,
        k: data.kind,
        p: {
          description: data.description,
          errorCode: data.errorCode
        }
      };
    case 2 /* Response */:
      return {
        i: data.id,
        t: t4,
        k: data.kind,
        p: data.payload
      };
    case 1 /* Message */:
      return {
        i: data.id,
        t: t4,
        k: data.kind,
        p: data.payload
      };
    case 5 /* ConnectionAck */:
      return {
        i: data.id,
        t: t4,
        k: data.kind,
        p: data.payload
      };
  }
};

// src/ws/connections.ts
var log2 = new Log("ws-connection");

class WsConnection {
  id;
  ws;
  userId;
  constructor(ws2) {
    this.id = nanoid();
    this.ws = ws2;
    setTimeout(() => {
      if (!this.userId) {
        log2.debug(`Connection ${this.id} not authenticated, closing`);
        this.close();
      }
    }, 20000);
  }
  authenticate(userId) {
    this.userId = userId;
    authenticatedConnections.set(this.userId, this);
  }
  close() {
    try {
      this.ws.close();
    } catch (error5) {
      console.error(error5);
    }
    this.remove();
  }
  remove() {
    connections.delete(this.id);
    if (this.userId) {
      authenticatedConnections.delete(this.userId);
    }
  }
  save() {
    connections.set(this.id, this);
  }
}
var connections = new Map;
var authenticatedConnections = new Map;

// src/ws/index.ts
var log3 = new Log("ws");
var webSocket = new Q0().state("userId", undefined).state("connection", undefined).ws("/ws", {
  perMessageDeflate: {
    compress: "32KB",
    decompress: "32KB"
  },
  sendPings: true,
  response: ServerMessage,
  body: ClientMessage,
  open(ws2) {
    const connection3 = new WsConnection(ws2);
    connection3.save();
    ws2.data.store.connection = connection3;
    log3.debug("new ws connection", connection3.id);
  },
  close(ws2) {
    log3.debug("ws connection closed", ws2.data.store.connection?.id);
    ws2.data.store.connection?.remove();
  },
  async message(ws2, message) {
    switch (message.k) {
      case 1 /* ConnectionInit */: {
        log3.debug("ws connection init");
        if (!ws2.data.store.connection) {
          log3.warn("no connection found when authenticating");
          return;
        }
        let { token: token2, userId } = message.p;
        let userIdFromToken = await getUserIdFromToken(token2);
        if (userIdFromToken !== userId) {
          log3.warn(`userId mismatch userIdFromToken: ${userIdFromToken}, userId: ${userId}`);
          throw new InlineError(403 /* UNAUTHORIZED */, "Unauthorized");
        }
        ws2.data.store.connection.authenticate(userIdFromToken);
        log3.debug("authenticated connection", ws2.data.store.connection.id, userIdFromToken);
        ws2.send(createMessage({
          kind: 5 /* ConnectionAck */,
          id: message.i,
          payload: {}
        }));
        break;
      }
      case 2 /* Message */:
        log3.debug("ws message", message.p);
        break;
      case 4 /* Ping */:
        log3.debug("ws ping");
        break;
      default:
        log3.warn("unknown ws message kind", message);
        break;
    }
  }
});

// src/index.ts
init2({
  dsn: SENTRY_DSN,
  tracesSampleRate: 1
});
var port = process.env["PORT"] || 8000;
console.log(`\uD83D\uDEA7 Starting server... (${"production"}, ${"0.0.1"}, ${"42621fd"})`);
var app = new Q0().use(root).use(apiV1).use(webSocket).use(waitlist3).use(there2).use(src_default3({
  path: "/v1/docs",
  exclude: /^(?!\/v1).*$/,
  scalarConfig: {
    servers: [
      {
        url: process.env["NODE_ENV"] === "production" ? "https://api.inline.chat" : "http://localhost:8000",
        description: "Production API server"
      }
    ]
  },
  documentation: {
    info: {
      title: "Inline API Docs",
      version: "0.0.1",
      contact: {
        email: "hi@inline.chat",
        name: "Inline Team",
        url: "https://inline.chat"
      },
      termsOfService: "https://inline.chat/terms"
    }
  }
}));
app.listen(port, (server) => {
  console.info(`\u2705 Server is running on http://${server.hostname}:${server.port}`);
});
