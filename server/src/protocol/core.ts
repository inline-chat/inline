// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "core.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// --- Protocol Messages ---

/**
 * @generated from protobuf message ClientMessage
 */
export interface ClientMessage {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: uint32 seq = 2;
     */
    seq: number;
    /**
     * @generated from protobuf oneof: body
     */
    body: {
        oneofKind: "connectionInit";
        /**
         * @generated from protobuf field: ConnectionInit connection_init = 4;
         */
        connectionInit: ConnectionInit;
    } | {
        oneofKind: "rpcCall";
        /**
         * @generated from protobuf field: RpcCall rpc_call = 5;
         */
        rpcCall: RpcCall;
    } | {
        oneofKind: "ack";
        /**
         * @generated from protobuf field: Ack ack = 6;
         */
        ack: Ack;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: Ping ping = 7;
         */
        ping: Ping;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ConnectionInit
 */
export interface ConnectionInit {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message ServerProtocolMessage
 */
export interface ServerProtocolMessage {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf oneof: body
     */
    body: {
        oneofKind: "connectionOpen";
        /**
         * @generated from protobuf field: ConnectionOpen connection_open = 4;
         */
        connectionOpen: ConnectionOpen;
    } | {
        oneofKind: "rpcResult";
        /**
         * @generated from protobuf field: RpcResult rpc_result = 5;
         */
        rpcResult: RpcResult;
    } | {
        oneofKind: "rpcError";
        /**
         * @generated from protobuf field: RpcError rpc_error = 6;
         */
        rpcError: RpcError;
    } | {
        oneofKind: "message";
        /**
         * @generated from protobuf field: ServerMessage message = 7;
         */
        message: ServerMessage;
    } | {
        oneofKind: "ack";
        /**
         * @generated from protobuf field: Ack ack = 8;
         */
        ack: Ack;
    } | {
        oneofKind: "pong";
        /**
         * @generated from protobuf field: Pong pong = 9;
         */
        pong: Pong;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ServerMessage
 */
export interface ServerMessage {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "update";
        /**
         * @generated from protobuf field: UpdatesPayload update = 4;
         */
        update: UpdatesPayload;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message UpdatesPayload
 */
export interface UpdatesPayload {
    /**
     * @generated from protobuf field: repeated Update updates = 1;
     */
    updates: Update[];
}
/**
 * @generated from protobuf message Ack
 */
export interface Ack {
    /**
     * @generated from protobuf field: uint64 msg_id = 1;
     */
    msgId: bigint;
}
/**
 * @generated from protobuf message ConnectionOpen
 */
export interface ConnectionOpen {
}
/**
 * @generated from protobuf message Ping
 */
export interface Ping {
    /**
     * @generated from protobuf field: uint64 nonce = 1;
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message Pong
 */
export interface Pong {
    /**
     * @generated from protobuf field: uint64 nonce = 1;
     */
    nonce: bigint;
}
// --- Application Types ---

/**
 * @generated from protobuf message InputPeer
 */
export interface InputPeer {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "self";
        /**
         * @generated from protobuf field: InputPeerSelf self = 2;
         */
        self: InputPeerSelf;
    } | {
        oneofKind: "chat";
        /**
         * @generated from protobuf field: InputPeerChat chat = 3;
         */
        chat: InputPeerChat;
    } | {
        oneofKind: "user";
        /**
         * @generated from protobuf field: InputPeerUser user = 4;
         */
        user: InputPeerUser;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message InputPeerSelf
 */
export interface InputPeerSelf {
}
/**
 * @generated from protobuf message InputPeerChat
 */
export interface InputPeerChat {
    /**
     * @generated from protobuf field: int64 chat_id = 1;
     */
    chatId: bigint;
}
/**
 * @generated from protobuf message InputPeerUser
 */
export interface InputPeerUser {
    /**
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
}
/**
 * @generated from protobuf message Peer
 */
export interface Peer {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "chat";
        /**
         * @generated from protobuf field: PeerChat chat = 2;
         */
        chat: PeerChat;
    } | {
        oneofKind: "user";
        /**
         * @generated from protobuf field: PeerUser user = 3;
         */
        user: PeerUser;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message PeerChat
 */
export interface PeerChat {
    /**
     * @generated from protobuf field: int64 chat_id = 1;
     */
    chatId: bigint;
}
/**
 * @generated from protobuf message PeerUser
 */
export interface PeerUser {
    /**
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
}
/**
 * @generated from protobuf message User
 */
export interface User {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: optional string first_name = 2;
     */
    firstName?: string;
    /**
     * @generated from protobuf field: optional string last_name = 3;
     */
    lastName?: string;
    /**
     * @generated from protobuf field: optional string username = 4;
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string phone_number = 5;
     */
    phoneNumber?: string;
    /**
     * @generated from protobuf field: optional string email = 6;
     */
    email?: string;
}
/**
 * @generated from protobuf message Message
 */
export interface Message {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * User ID of the sender
     *
     * @generated from protobuf field: int64 from_id = 2;
     */
    fromId: bigint;
    /**
     * Peer ID of the recipient
     *
     * @generated from protobuf field: Peer peer_id = 3;
     */
    peerId?: Peer;
    /**
     * The "chat ID" of the message, for messages in a chat
     *
     * @generated from protobuf field: int64 chat_id = 4;
     */
    chatId: bigint;
    /**
     * Message text
     *
     * @generated from protobuf field: optional string message = 5;
     */
    message?: string;
    /**
     * Whether the message is outgoing
     *
     * @generated from protobuf field: bool out = 6;
     */
    out: boolean;
    /**
     * Date of the message
     *
     * @generated from protobuf field: int64 date = 7;
     */
    date: bigint;
    /**
     * Whether user is mentioned
     *
     * @generated from protobuf field: optional bool mentioned = 8;
     */
    mentioned?: boolean;
    /**
     * Message ID of the message being replied to
     *
     * @generated from protobuf field: optional int64 reply_to_msg_id = 9;
     */
    replyToMsgId?: bigint;
    /**
     * Media of the message
     *
     * @generated from protobuf field: optional MessageMedia media = 10;
     */
    media?: MessageMedia;
    /**
     * Date of the last edit if edited
     *
     * @generated from protobuf field: optional int64 edit_date = 11;
     */
    editDate?: bigint;
    /**
     * ID of the grouped message if it's part of an album
     *
     * @generated from protobuf field: optional int64 grouped_id = 12;
     */
    groupedId?: bigint;
}
/**
 * WIP: add document, audio, video.
 *
 * @generated from protobuf message MessageMedia
 */
export interface MessageMedia {
    /**
     * @generated from protobuf oneof: media
     */
    media: {
        oneofKind: "photo";
        /**
         * @generated from protobuf field: MessagePhoto photo = 1;
         */
        photo: MessagePhoto;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message MessagePhoto
 */
export interface MessagePhoto {
    /**
     * @generated from protobuf field: Photo photo = 1;
     */
    photo?: Photo;
}
/**
 * Photo for message media, profile photo, space photo, or chat photo
 *
 * @generated from protobuf message Photo
 */
export interface Photo {
    /**
     * ID
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Date of upload
     *
     * @generated from protobuf field: int64 date = 2;
     */
    date: bigint;
    /**
     * @generated from protobuf field: repeated PhotoSize sizes = 3;
     */
    sizes: PhotoSize[];
    /**
     * Format of the photo
     *
     * @generated from protobuf field: Photo.Format format = 4;
     */
    format: Photo_Format;
    /**
     * Unique identifier of the file
     *
     * @generated from protobuf field: string file_unique_id = 100;
     */
    fileUniqueId: string;
}
/**
 * @generated from protobuf enum Photo.Format
 */
export enum Photo_Format {
    /**
     * @generated from protobuf enum value: FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FORMAT_JPEG = 1;
     */
    JPEG = 1,
    /**
     * @generated from protobuf enum value: FORMAT_PNG = 2;
     */
    PNG = 2
}
/**
 * @generated from protobuf message PhotoSize
 */
export interface PhotoSize {
    /**
     * * Thumbnail type.
     * Currently supported:
     * - "b" - small box 140x140
     * - "c" - medium box 320x320
     * - "d" - regular box 800x800
     * - "f" - large box 2560x2560
     * - "s" - stripped (tiny version embedded in bytes)
     * - "y" - ??
     * - "x" - small cropped ??
     * - "w" - medium cropped ??
     * - "v" - ??
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Width in pixels
     *
     * @generated from protobuf field: int32 w = 2;
     */
    w: number;
    /**
     * Height in pixels
     *
     * @generated from protobuf field: int32 h = 3;
     */
    h: number;
    /**
     * File size
     *
     * @generated from protobuf field: int32 size = 4;
     */
    size: number;
    /**
     * Bytes for stripped size used in blur thumbnails
     *
     * @generated from protobuf field: optional bytes bytes = 5;
     */
    bytes?: Uint8Array;
    /**
     * CDN URL
     *
     * @generated from protobuf field: optional string cdn_url = 6;
     */
    cdnUrl?: string;
}
// --- Application RPC Functions ---

/**
 * @generated from protobuf message RpcError
 */
export interface RpcError {
    /**
     * @generated from protobuf field: uint64 req_msg_id = 1;
     */
    reqMsgId: bigint;
    /**
     * @generated from protobuf field: RpcError.Code error_code = 2;
     */
    errorCode: RpcError_Code;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf enum RpcError.Code
 */
export enum RpcError_Code {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: BAD_REQUEST = 1;
     */
    BAD_REQUEST = 1,
    /**
     * @generated from protobuf enum value: UNAUTHENTICATED = 2;
     */
    UNAUTHENTICATED = 2,
    /**
     * @generated from protobuf enum value: RATE_LIMIT = 3;
     */
    RATE_LIMIT = 3,
    /**
     * @generated from protobuf enum value: INTERNAL_ERROR = 4;
     */
    INTERNAL_ERROR = 4
}
/**
 * @generated from protobuf message RpcCall
 */
export interface RpcCall {
    /**
     * @generated from protobuf field: Method method = 1;
     */
    method: Method;
    /**
     * @generated from protobuf oneof: input
     */
    input: {
        oneofKind: "getMe";
        /**
         * @generated from protobuf field: GetMeInput getMe = 2;
         */
        getMe: GetMeInput;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message RpcResult
 */
export interface RpcResult {
    /**
     * @generated from protobuf field: uint64 req_msg_id = 1;
     */
    reqMsgId: bigint;
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "getMe";
        /**
         * @generated from protobuf field: GetMeResult getMe = 2;
         */
        getMe: GetMeResult;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message GetMeInput
 */
export interface GetMeInput {
}
/**
 * @generated from protobuf message GetMeResult
 */
export interface GetMeResult {
    /**
     * @generated from protobuf field: User user = 1;
     */
    user?: User;
}
/**
 *  Updates Subsystem
 *
 * @generated from protobuf message Update
 */
export interface Update {
    /**
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "newMessage";
        /**
         * @generated from protobuf field: UpdateNewMessage new_message = 4;
         */
        newMessage: UpdateNewMessage;
    } | {
        oneofKind: "editMessage";
        /**
         * @generated from protobuf field: UpdateEditMessage edit_message = 5;
         */
        editMessage: UpdateEditMessage;
    } | {
        oneofKind: "updateMessageId";
        /**
         * @generated from protobuf field: UpdateMessageId update_message_id = 6;
         */
        updateMessageId: UpdateMessageId;
    } | {
        oneofKind: "deleteMessages";
        /**
         * @generated from protobuf field: UpdateDeleteMessages delete_messages = 7;
         */
        deleteMessages: UpdateDeleteMessages;
    } | {
        oneofKind: "updateComposeAction";
        /**
         * @generated from protobuf field: UpdateComposeAction update_compose_action = 8;
         */
        updateComposeAction: UpdateComposeAction;
    } | {
        oneofKind: "updateUserStatus";
        /**
         * @generated from protobuf field: UpdateUserStatus update_user_status = 9;
         */
        updateUserStatus: UpdateUserStatus;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message UpdateNewMessage
 */
export interface UpdateNewMessage {
    /**
     * @generated from protobuf field: Message message = 1;
     */
    message?: Message;
}
/**
 * @generated from protobuf message UpdateEditMessage
 */
export interface UpdateEditMessage {
    /**
     * @generated from protobuf field: Message message = 1;
     */
    message?: Message;
}
/**
 * Update when messages are deleted
 *
 * @generated from protobuf message UpdateDeleteMessages
 */
export interface UpdateDeleteMessages {
    /**
     * @generated from protobuf field: repeated int64 message_ids = 1;
     */
    messageIds: bigint[];
    /**
     * @generated from protobuf field: Peer peer_id = 2;
     */
    peerId?: Peer;
}
/**
 * Update when a message ID is updated after sending
 *
 * @generated from protobuf message UpdateMessageId
 */
export interface UpdateMessageId {
    /**
     * @generated from protobuf field: int64 message_id = 1;
     */
    messageId: bigint;
    /**
     * @generated from protobuf field: int64 random_id = 2;
     */
    randomId: bigint;
}
/**
 * Update when a user starts or stops composing a message for typing, uploading a photo, etc
 *
 * @generated from protobuf message UpdateComposeAction
 */
export interface UpdateComposeAction {
    /**
     * User ID of the user who is composing the message
     *
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
    /**
     * Peer ID of the peer user is composing the message to
     *
     * @generated from protobuf field: Peer peer_id = 2;
     */
    peerId?: Peer;
    /**
     * Action of the user (typing, etc)
     *
     * @generated from protobuf field: UpdateComposeAction.ComposeAction action = 3;
     */
    action: UpdateComposeAction_ComposeAction;
}
/**
 * @generated from protobuf enum UpdateComposeAction.ComposeAction
 */
export enum UpdateComposeAction_ComposeAction {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: TYPING = 1;
     */
    TYPING = 1,
    /**
     * @generated from protobuf enum value: UPLOADING_PHOTO = 2;
     */
    UPLOADING_PHOTO = 2,
    /**
     * @generated from protobuf enum value: UPLOADING_DOCUMENT = 3;
     */
    UPLOADING_DOCUMENT = 3,
    /**
     * @generated from protobuf enum value: UPLOADING_VIDEO = 4;
     */
    UPLOADING_VIDEO = 4
}
/**
 * @generated from protobuf message UpdateUserStatus
 */
export interface UpdateUserStatus {
    /**
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
    /**
     * @generated from protobuf field: UserStatus status = 2;
     */
    status?: UserStatus;
}
/**
 * @generated from protobuf message UserStatus
 */
export interface UserStatus {
    /**
     * @generated from protobuf field: UserStatus.Status online = 1;
     */
    online: UserStatus_Status;
    /**
     * @generated from protobuf field: LastOnline last_online = 2;
     */
    lastOnline?: LastOnline;
}
/**
 * @generated from protobuf enum UserStatus.Status
 */
export enum UserStatus_Status {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: ONLINE = 1;
     */
    ONLINE = 1,
    /**
     * @generated from protobuf enum value: OFFLINE = 2;
     */
    OFFLINE = 2
}
/**
 * @generated from protobuf message LastOnline
 */
export interface LastOnline {
    /**
     * Date of the last online if exact last online is permitted by the user
     *
     * @generated from protobuf field: optional int64 date = 1;
     */
    date?: bigint;
}
/**
 * @generated from protobuf enum Method
 */
export enum Method {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: GET_ME = 1;
     */
    GET_ME = 1,
    /**
     * @generated from protobuf enum value: SEND_MESSAGE = 2;
     */
    SEND_MESSAGE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ClientMessage$Type extends MessageType<ClientMessage> {
    constructor() {
        super("ClientMessage", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "connection_init", kind: "message", oneof: "body", T: () => ConnectionInit },
            { no: 5, name: "rpc_call", kind: "message", oneof: "body", T: () => RpcCall },
            { no: 6, name: "ack", kind: "message", oneof: "body", T: () => Ack },
            { no: 7, name: "ping", kind: "message", oneof: "body", T: () => Ping }
        ]);
    }
    create(value?: PartialMessage<ClientMessage>): ClientMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.seq = 0;
        message.body = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ClientMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientMessage): ClientMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint32 seq */ 2:
                    message.seq = reader.uint32();
                    break;
                case /* ConnectionInit connection_init */ 4:
                    message.body = {
                        oneofKind: "connectionInit",
                        connectionInit: ConnectionInit.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).connectionInit)
                    };
                    break;
                case /* RpcCall rpc_call */ 5:
                    message.body = {
                        oneofKind: "rpcCall",
                        rpcCall: RpcCall.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).rpcCall)
                    };
                    break;
                case /* Ack ack */ 6:
                    message.body = {
                        oneofKind: "ack",
                        ack: Ack.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).ack)
                    };
                    break;
                case /* Ping ping */ 7:
                    message.body = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).ping)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint32 seq = 2; */
        if (message.seq !== 0)
            writer.tag(2, WireType.Varint).uint32(message.seq);
        /* ConnectionInit connection_init = 4; */
        if (message.body.oneofKind === "connectionInit")
            ConnectionInit.internalBinaryWrite(message.body.connectionInit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* RpcCall rpc_call = 5; */
        if (message.body.oneofKind === "rpcCall")
            RpcCall.internalBinaryWrite(message.body.rpcCall, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Ack ack = 6; */
        if (message.body.oneofKind === "ack")
            Ack.internalBinaryWrite(message.body.ack, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Ping ping = 7; */
        if (message.body.oneofKind === "ping")
            Ping.internalBinaryWrite(message.body.ping, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientMessage
 */
export const ClientMessage = new ClientMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionInit$Type extends MessageType<ConnectionInit> {
    constructor() {
        super("ConnectionInit", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectionInit>): ConnectionInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectionInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionInit): ConnectionInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectionInit
 */
export const ConnectionInit = new ConnectionInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerProtocolMessage$Type extends MessageType<ServerProtocolMessage> {
    constructor() {
        super("ServerProtocolMessage", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "connection_open", kind: "message", oneof: "body", T: () => ConnectionOpen },
            { no: 5, name: "rpc_result", kind: "message", oneof: "body", T: () => RpcResult },
            { no: 6, name: "rpc_error", kind: "message", oneof: "body", T: () => RpcError },
            { no: 7, name: "message", kind: "message", oneof: "body", T: () => ServerMessage },
            { no: 8, name: "ack", kind: "message", oneof: "body", T: () => Ack },
            { no: 9, name: "pong", kind: "message", oneof: "body", T: () => Pong }
        ]);
    }
    create(value?: PartialMessage<ServerProtocolMessage>): ServerProtocolMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.body = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServerProtocolMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerProtocolMessage): ServerProtocolMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* ConnectionOpen connection_open */ 4:
                    message.body = {
                        oneofKind: "connectionOpen",
                        connectionOpen: ConnectionOpen.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).connectionOpen)
                    };
                    break;
                case /* RpcResult rpc_result */ 5:
                    message.body = {
                        oneofKind: "rpcResult",
                        rpcResult: RpcResult.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).rpcResult)
                    };
                    break;
                case /* RpcError rpc_error */ 6:
                    message.body = {
                        oneofKind: "rpcError",
                        rpcError: RpcError.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).rpcError)
                    };
                    break;
                case /* ServerMessage message */ 7:
                    message.body = {
                        oneofKind: "message",
                        message: ServerMessage.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).message)
                    };
                    break;
                case /* Ack ack */ 8:
                    message.body = {
                        oneofKind: "ack",
                        ack: Ack.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).ack)
                    };
                    break;
                case /* Pong pong */ 9:
                    message.body = {
                        oneofKind: "pong",
                        pong: Pong.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).pong)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerProtocolMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* ConnectionOpen connection_open = 4; */
        if (message.body.oneofKind === "connectionOpen")
            ConnectionOpen.internalBinaryWrite(message.body.connectionOpen, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* RpcResult rpc_result = 5; */
        if (message.body.oneofKind === "rpcResult")
            RpcResult.internalBinaryWrite(message.body.rpcResult, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* RpcError rpc_error = 6; */
        if (message.body.oneofKind === "rpcError")
            RpcError.internalBinaryWrite(message.body.rpcError, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ServerMessage message = 7; */
        if (message.body.oneofKind === "message")
            ServerMessage.internalBinaryWrite(message.body.message, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* Ack ack = 8; */
        if (message.body.oneofKind === "ack")
            Ack.internalBinaryWrite(message.body.ack, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* Pong pong = 9; */
        if (message.body.oneofKind === "pong")
            Pong.internalBinaryWrite(message.body.pong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerProtocolMessage
 */
export const ServerProtocolMessage = new ServerProtocolMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMessage$Type extends MessageType<ServerMessage> {
    constructor() {
        super("ServerMessage", [
            { no: 4, name: "update", kind: "message", oneof: "payload", T: () => UpdatesPayload }
        ]);
    }
    create(value?: PartialMessage<ServerMessage>): ServerMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServerMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerMessage): ServerMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdatesPayload update */ 4:
                    message.payload = {
                        oneofKind: "update",
                        update: UpdatesPayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).update)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdatesPayload update = 4; */
        if (message.payload.oneofKind === "update")
            UpdatesPayload.internalBinaryWrite(message.payload.update, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerMessage
 */
export const ServerMessage = new ServerMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatesPayload$Type extends MessageType<UpdatesPayload> {
    constructor() {
        super("UpdatesPayload", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Update }
        ]);
    }
    create(value?: PartialMessage<UpdatesPayload>): UpdatesPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<UpdatesPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatesPayload): UpdatesPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Update updates */ 1:
                    message.updates.push(Update.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatesPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Update updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            Update.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdatesPayload
 */
export const UpdatesPayload = new UpdatesPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ack$Type extends MessageType<Ack> {
    constructor() {
        super("Ack", [
            { no: 1, name: "msg_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Ack>): Ack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msgId = 0n;
        if (value !== undefined)
            reflectionMergePartial<Ack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ack): Ack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 msg_id */ 1:
                    message.msgId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 msg_id = 1; */
        if (message.msgId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.msgId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ack
 */
export const Ack = new Ack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionOpen$Type extends MessageType<ConnectionOpen> {
    constructor() {
        super("ConnectionOpen", []);
    }
    create(value?: PartialMessage<ConnectionOpen>): ConnectionOpen {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectionOpen>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionOpen): ConnectionOpen {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ConnectionOpen, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectionOpen
 */
export const ConnectionOpen = new ConnectionOpen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ping$Type extends MessageType<Ping> {
    constructor() {
        super("Ping", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Ping>): Ping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<Ping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ping): Ping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ping
 */
export const Ping = new Ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pong$Type extends MessageType<Pong> {
    constructor() {
        super("Pong", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Pong>): Pong {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<Pong>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pong): Pong {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pong, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Pong
 */
export const Pong = new Pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputPeer$Type extends MessageType<InputPeer> {
    constructor() {
        super("InputPeer", [
            { no: 2, name: "self", kind: "message", oneof: "type", T: () => InputPeerSelf },
            { no: 3, name: "chat", kind: "message", oneof: "type", T: () => InputPeerChat },
            { no: 4, name: "user", kind: "message", oneof: "type", T: () => InputPeerUser }
        ]);
    }
    create(value?: PartialMessage<InputPeer>): InputPeer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<InputPeer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputPeer): InputPeer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InputPeerSelf self */ 2:
                    message.type = {
                        oneofKind: "self",
                        self: InputPeerSelf.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).self)
                    };
                    break;
                case /* InputPeerChat chat */ 3:
                    message.type = {
                        oneofKind: "chat",
                        chat: InputPeerChat.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).chat)
                    };
                    break;
                case /* InputPeerUser user */ 4:
                    message.type = {
                        oneofKind: "user",
                        user: InputPeerUser.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).user)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputPeer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InputPeerSelf self = 2; */
        if (message.type.oneofKind === "self")
            InputPeerSelf.internalBinaryWrite(message.type.self, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* InputPeerChat chat = 3; */
        if (message.type.oneofKind === "chat")
            InputPeerChat.internalBinaryWrite(message.type.chat, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* InputPeerUser user = 4; */
        if (message.type.oneofKind === "user")
            InputPeerUser.internalBinaryWrite(message.type.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InputPeer
 */
export const InputPeer = new InputPeer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputPeerSelf$Type extends MessageType<InputPeerSelf> {
    constructor() {
        super("InputPeerSelf", []);
    }
    create(value?: PartialMessage<InputPeerSelf>): InputPeerSelf {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InputPeerSelf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputPeerSelf): InputPeerSelf {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InputPeerSelf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InputPeerSelf
 */
export const InputPeerSelf = new InputPeerSelf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputPeerChat$Type extends MessageType<InputPeerChat> {
    constructor() {
        super("InputPeerChat", [
            { no: 1, name: "chat_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InputPeerChat>): InputPeerChat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatId = 0n;
        if (value !== undefined)
            reflectionMergePartial<InputPeerChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputPeerChat): InputPeerChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 chat_id */ 1:
                    message.chatId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputPeerChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 chat_id = 1; */
        if (message.chatId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.chatId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InputPeerChat
 */
export const InputPeerChat = new InputPeerChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputPeerUser$Type extends MessageType<InputPeerUser> {
    constructor() {
        super("InputPeerUser", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InputPeerUser>): InputPeerUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        if (value !== undefined)
            reflectionMergePartial<InputPeerUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputPeerUser): InputPeerUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputPeerUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InputPeerUser
 */
export const InputPeerUser = new InputPeerUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Peer$Type extends MessageType<Peer> {
    constructor() {
        super("Peer", [
            { no: 2, name: "chat", kind: "message", oneof: "type", T: () => PeerChat },
            { no: 3, name: "user", kind: "message", oneof: "type", T: () => PeerUser }
        ]);
    }
    create(value?: PartialMessage<Peer>): Peer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Peer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Peer): Peer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PeerChat chat */ 2:
                    message.type = {
                        oneofKind: "chat",
                        chat: PeerChat.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).chat)
                    };
                    break;
                case /* PeerUser user */ 3:
                    message.type = {
                        oneofKind: "user",
                        user: PeerUser.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).user)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PeerChat chat = 2; */
        if (message.type.oneofKind === "chat")
            PeerChat.internalBinaryWrite(message.type.chat, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* PeerUser user = 3; */
        if (message.type.oneofKind === "user")
            PeerUser.internalBinaryWrite(message.type.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Peer
 */
export const Peer = new Peer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerChat$Type extends MessageType<PeerChat> {
    constructor() {
        super("PeerChat", [
            { no: 1, name: "chat_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PeerChat>): PeerChat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatId = 0n;
        if (value !== undefined)
            reflectionMergePartial<PeerChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerChat): PeerChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 chat_id */ 1:
                    message.chatId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeerChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 chat_id = 1; */
        if (message.chatId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.chatId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PeerChat
 */
export const PeerChat = new PeerChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerUser$Type extends MessageType<PeerUser> {
    constructor() {
        super("PeerUser", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PeerUser>): PeerUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        if (value !== undefined)
            reflectionMergePartial<PeerUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerUser): PeerUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeerUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PeerUser
 */
export const PeerUser = new PeerUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("User", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "first_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "phone_number", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "email", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* optional string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* optional string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* optional string username */ 4:
                    message.username = reader.string();
                    break;
                case /* optional string phone_number */ 5:
                    message.phoneNumber = reader.string();
                    break;
                case /* optional string email */ 6:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* optional string first_name = 2; */
        if (message.firstName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* optional string last_name = 3; */
        if (message.lastName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* optional string username = 4; */
        if (message.username !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.username);
        /* optional string phone_number = 5; */
        if (message.phoneNumber !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.phoneNumber);
        /* optional string email = 6; */
        if (message.email !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("Message", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "peer_id", kind: "message", T: () => Peer },
            { no: 4, name: "chat_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "out", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "date", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "mentioned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "reply_to_msg_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "media", kind: "message", T: () => MessageMedia },
            { no: 11, name: "edit_date", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "grouped_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.fromId = 0n;
        message.chatId = 0n;
        message.out = false;
        message.date = 0n;
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 from_id */ 2:
                    message.fromId = reader.int64().toBigInt();
                    break;
                case /* Peer peer_id */ 3:
                    message.peerId = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peerId);
                    break;
                case /* int64 chat_id */ 4:
                    message.chatId = reader.int64().toBigInt();
                    break;
                case /* optional string message */ 5:
                    message.message = reader.string();
                    break;
                case /* bool out */ 6:
                    message.out = reader.bool();
                    break;
                case /* int64 date */ 7:
                    message.date = reader.int64().toBigInt();
                    break;
                case /* optional bool mentioned */ 8:
                    message.mentioned = reader.bool();
                    break;
                case /* optional int64 reply_to_msg_id */ 9:
                    message.replyToMsgId = reader.int64().toBigInt();
                    break;
                case /* optional MessageMedia media */ 10:
                    message.media = MessageMedia.internalBinaryRead(reader, reader.uint32(), options, message.media);
                    break;
                case /* optional int64 edit_date */ 11:
                    message.editDate = reader.int64().toBigInt();
                    break;
                case /* optional int64 grouped_id */ 12:
                    message.groupedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 from_id = 2; */
        if (message.fromId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.fromId);
        /* Peer peer_id = 3; */
        if (message.peerId)
            Peer.internalBinaryWrite(message.peerId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 chat_id = 4; */
        if (message.chatId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.chatId);
        /* optional string message = 5; */
        if (message.message !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.message);
        /* bool out = 6; */
        if (message.out !== false)
            writer.tag(6, WireType.Varint).bool(message.out);
        /* int64 date = 7; */
        if (message.date !== 0n)
            writer.tag(7, WireType.Varint).int64(message.date);
        /* optional bool mentioned = 8; */
        if (message.mentioned !== undefined)
            writer.tag(8, WireType.Varint).bool(message.mentioned);
        /* optional int64 reply_to_msg_id = 9; */
        if (message.replyToMsgId !== undefined)
            writer.tag(9, WireType.Varint).int64(message.replyToMsgId);
        /* optional MessageMedia media = 10; */
        if (message.media)
            MessageMedia.internalBinaryWrite(message.media, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 edit_date = 11; */
        if (message.editDate !== undefined)
            writer.tag(11, WireType.Varint).int64(message.editDate);
        /* optional int64 grouped_id = 12; */
        if (message.groupedId !== undefined)
            writer.tag(12, WireType.Varint).int64(message.groupedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageMedia$Type extends MessageType<MessageMedia> {
    constructor() {
        super("MessageMedia", [
            { no: 1, name: "photo", kind: "message", oneof: "media", T: () => MessagePhoto }
        ]);
    }
    create(value?: PartialMessage<MessageMedia>): MessageMedia {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.media = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MessageMedia>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageMedia): MessageMedia {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MessagePhoto photo */ 1:
                    message.media = {
                        oneofKind: "photo",
                        photo: MessagePhoto.internalBinaryRead(reader, reader.uint32(), options, (message.media as any).photo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageMedia, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MessagePhoto photo = 1; */
        if (message.media.oneofKind === "photo")
            MessagePhoto.internalBinaryWrite(message.media.photo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MessageMedia
 */
export const MessageMedia = new MessageMedia$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessagePhoto$Type extends MessageType<MessagePhoto> {
    constructor() {
        super("MessagePhoto", [
            { no: 1, name: "photo", kind: "message", T: () => Photo }
        ]);
    }
    create(value?: PartialMessage<MessagePhoto>): MessagePhoto {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessagePhoto>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessagePhoto): MessagePhoto {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Photo photo */ 1:
                    message.photo = Photo.internalBinaryRead(reader, reader.uint32(), options, message.photo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessagePhoto, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Photo photo = 1; */
        if (message.photo)
            Photo.internalBinaryWrite(message.photo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MessagePhoto
 */
export const MessagePhoto = new MessagePhoto$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Photo$Type extends MessageType<Photo> {
    constructor() {
        super("Photo", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "date", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sizes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PhotoSize },
            { no: 4, name: "format", kind: "enum", T: () => ["Photo.Format", Photo_Format, "FORMAT_"] },
            { no: 100, name: "file_unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Photo>): Photo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.date = 0n;
        message.sizes = [];
        message.format = 0;
        message.fileUniqueId = "";
        if (value !== undefined)
            reflectionMergePartial<Photo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Photo): Photo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 date */ 2:
                    message.date = reader.int64().toBigInt();
                    break;
                case /* repeated PhotoSize sizes */ 3:
                    message.sizes.push(PhotoSize.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* Photo.Format format */ 4:
                    message.format = reader.int32();
                    break;
                case /* string file_unique_id */ 100:
                    message.fileUniqueId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Photo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 date = 2; */
        if (message.date !== 0n)
            writer.tag(2, WireType.Varint).int64(message.date);
        /* repeated PhotoSize sizes = 3; */
        for (let i = 0; i < message.sizes.length; i++)
            PhotoSize.internalBinaryWrite(message.sizes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Photo.Format format = 4; */
        if (message.format !== 0)
            writer.tag(4, WireType.Varint).int32(message.format);
        /* string file_unique_id = 100; */
        if (message.fileUniqueId !== "")
            writer.tag(100, WireType.LengthDelimited).string(message.fileUniqueId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Photo
 */
export const Photo = new Photo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PhotoSize$Type extends MessageType<PhotoSize> {
    constructor() {
        super("PhotoSize", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "w", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "h", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "cdn_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PhotoSize>): PhotoSize {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.w = 0;
        message.h = 0;
        message.size = 0;
        if (value !== undefined)
            reflectionMergePartial<PhotoSize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PhotoSize): PhotoSize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 w */ 2:
                    message.w = reader.int32();
                    break;
                case /* int32 h */ 3:
                    message.h = reader.int32();
                    break;
                case /* int32 size */ 4:
                    message.size = reader.int32();
                    break;
                case /* optional bytes bytes */ 5:
                    message.bytes = reader.bytes();
                    break;
                case /* optional string cdn_url */ 6:
                    message.cdnUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PhotoSize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* int32 w = 2; */
        if (message.w !== 0)
            writer.tag(2, WireType.Varint).int32(message.w);
        /* int32 h = 3; */
        if (message.h !== 0)
            writer.tag(3, WireType.Varint).int32(message.h);
        /* int32 size = 4; */
        if (message.size !== 0)
            writer.tag(4, WireType.Varint).int32(message.size);
        /* optional bytes bytes = 5; */
        if (message.bytes !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.bytes);
        /* optional string cdn_url = 6; */
        if (message.cdnUrl !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.cdnUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PhotoSize
 */
export const PhotoSize = new PhotoSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcError$Type extends MessageType<RpcError> {
    constructor() {
        super("RpcError", [
            { no: 1, name: "req_msg_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "error_code", kind: "enum", T: () => ["RpcError.Code", RpcError_Code] },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcError>): RpcError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reqMsgId = 0n;
        message.errorCode = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RpcError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcError): RpcError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 req_msg_id */ 1:
                    message.reqMsgId = reader.uint64().toBigInt();
                    break;
                case /* RpcError.Code error_code */ 2:
                    message.errorCode = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 req_msg_id = 1; */
        if (message.reqMsgId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.reqMsgId);
        /* RpcError.Code error_code = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.errorCode);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcError
 */
export const RpcError = new RpcError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcCall$Type extends MessageType<RpcCall> {
    constructor() {
        super("RpcCall", [
            { no: 1, name: "method", kind: "enum", T: () => ["Method", Method] },
            { no: 2, name: "getMe", kind: "message", oneof: "input", T: () => GetMeInput }
        ]);
    }
    create(value?: PartialMessage<RpcCall>): RpcCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.method = 0;
        message.input = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RpcCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcCall): RpcCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Method method */ 1:
                    message.method = reader.int32();
                    break;
                case /* GetMeInput getMe */ 2:
                    message.input = {
                        oneofKind: "getMe",
                        getMe: GetMeInput.internalBinaryRead(reader, reader.uint32(), options, (message.input as any).getMe)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Method method = 1; */
        if (message.method !== 0)
            writer.tag(1, WireType.Varint).int32(message.method);
        /* GetMeInput getMe = 2; */
        if (message.input.oneofKind === "getMe")
            GetMeInput.internalBinaryWrite(message.input.getMe, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcCall
 */
export const RpcCall = new RpcCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcResult$Type extends MessageType<RpcResult> {
    constructor() {
        super("RpcResult", [
            { no: 1, name: "req_msg_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "getMe", kind: "message", oneof: "result", T: () => GetMeResult }
        ]);
    }
    create(value?: PartialMessage<RpcResult>): RpcResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reqMsgId = 0n;
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RpcResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcResult): RpcResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 req_msg_id */ 1:
                    message.reqMsgId = reader.uint64().toBigInt();
                    break;
                case /* GetMeResult getMe */ 2:
                    message.result = {
                        oneofKind: "getMe",
                        getMe: GetMeResult.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).getMe)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 req_msg_id = 1; */
        if (message.reqMsgId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.reqMsgId);
        /* GetMeResult getMe = 2; */
        if (message.result.oneofKind === "getMe")
            GetMeResult.internalBinaryWrite(message.result.getMe, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcResult
 */
export const RpcResult = new RpcResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMeInput$Type extends MessageType<GetMeInput> {
    constructor() {
        super("GetMeInput", []);
    }
    create(value?: PartialMessage<GetMeInput>): GetMeInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMeInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMeInput): GetMeInput {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMeInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMeInput
 */
export const GetMeInput = new GetMeInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMeResult$Type extends MessageType<GetMeResult> {
    constructor() {
        super("GetMeResult", [
            { no: 1, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<GetMeResult>): GetMeResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMeResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMeResult): GetMeResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMeResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMeResult
 */
export const GetMeResult = new GetMeResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update$Type extends MessageType<Update> {
    constructor() {
        super("Update", [
            { no: 4, name: "new_message", kind: "message", oneof: "update", T: () => UpdateNewMessage },
            { no: 5, name: "edit_message", kind: "message", oneof: "update", T: () => UpdateEditMessage },
            { no: 6, name: "update_message_id", kind: "message", oneof: "update", T: () => UpdateMessageId },
            { no: 7, name: "delete_messages", kind: "message", oneof: "update", T: () => UpdateDeleteMessages },
            { no: 8, name: "update_compose_action", kind: "message", oneof: "update", T: () => UpdateComposeAction },
            { no: 9, name: "update_user_status", kind: "message", oneof: "update", T: () => UpdateUserStatus }
        ]);
    }
    create(value?: PartialMessage<Update>): Update {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.update = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Update>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update): Update {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateNewMessage new_message */ 4:
                    message.update = {
                        oneofKind: "newMessage",
                        newMessage: UpdateNewMessage.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).newMessage)
                    };
                    break;
                case /* UpdateEditMessage edit_message */ 5:
                    message.update = {
                        oneofKind: "editMessage",
                        editMessage: UpdateEditMessage.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).editMessage)
                    };
                    break;
                case /* UpdateMessageId update_message_id */ 6:
                    message.update = {
                        oneofKind: "updateMessageId",
                        updateMessageId: UpdateMessageId.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).updateMessageId)
                    };
                    break;
                case /* UpdateDeleteMessages delete_messages */ 7:
                    message.update = {
                        oneofKind: "deleteMessages",
                        deleteMessages: UpdateDeleteMessages.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).deleteMessages)
                    };
                    break;
                case /* UpdateComposeAction update_compose_action */ 8:
                    message.update = {
                        oneofKind: "updateComposeAction",
                        updateComposeAction: UpdateComposeAction.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).updateComposeAction)
                    };
                    break;
                case /* UpdateUserStatus update_user_status */ 9:
                    message.update = {
                        oneofKind: "updateUserStatus",
                        updateUserStatus: UpdateUserStatus.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).updateUserStatus)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateNewMessage new_message = 4; */
        if (message.update.oneofKind === "newMessage")
            UpdateNewMessage.internalBinaryWrite(message.update.newMessage, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* UpdateEditMessage edit_message = 5; */
        if (message.update.oneofKind === "editMessage")
            UpdateEditMessage.internalBinaryWrite(message.update.editMessage, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* UpdateMessageId update_message_id = 6; */
        if (message.update.oneofKind === "updateMessageId")
            UpdateMessageId.internalBinaryWrite(message.update.updateMessageId, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* UpdateDeleteMessages delete_messages = 7; */
        if (message.update.oneofKind === "deleteMessages")
            UpdateDeleteMessages.internalBinaryWrite(message.update.deleteMessages, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* UpdateComposeAction update_compose_action = 8; */
        if (message.update.oneofKind === "updateComposeAction")
            UpdateComposeAction.internalBinaryWrite(message.update.updateComposeAction, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* UpdateUserStatus update_user_status = 9; */
        if (message.update.oneofKind === "updateUserStatus")
            UpdateUserStatus.internalBinaryWrite(message.update.updateUserStatus, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Update
 */
export const Update = new Update$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateNewMessage$Type extends MessageType<UpdateNewMessage> {
    constructor() {
        super("UpdateNewMessage", [
            { no: 1, name: "message", kind: "message", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<UpdateNewMessage>): UpdateNewMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateNewMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateNewMessage): UpdateNewMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateNewMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateNewMessage
 */
export const UpdateNewMessage = new UpdateNewMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEditMessage$Type extends MessageType<UpdateEditMessage> {
    constructor() {
        super("UpdateEditMessage", [
            { no: 1, name: "message", kind: "message", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<UpdateEditMessage>): UpdateEditMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateEditMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEditMessage): UpdateEditMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateEditMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateEditMessage
 */
export const UpdateEditMessage = new UpdateEditMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeleteMessages$Type extends MessageType<UpdateDeleteMessages> {
    constructor() {
        super("UpdateDeleteMessages", [
            { no: 1, name: "message_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "peer_id", kind: "message", T: () => Peer }
        ]);
    }
    create(value?: PartialMessage<UpdateDeleteMessages>): UpdateDeleteMessages {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageIds = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateDeleteMessages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeleteMessages): UpdateDeleteMessages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 message_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.messageIds.push(reader.int64().toBigInt());
                    else
                        message.messageIds.push(reader.int64().toBigInt());
                    break;
                case /* Peer peer_id */ 2:
                    message.peerId = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peerId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDeleteMessages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 message_ids = 1; */
        if (message.messageIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.messageIds.length; i++)
                writer.int64(message.messageIds[i]);
            writer.join();
        }
        /* Peer peer_id = 2; */
        if (message.peerId)
            Peer.internalBinaryWrite(message.peerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateDeleteMessages
 */
export const UpdateDeleteMessages = new UpdateDeleteMessages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMessageId$Type extends MessageType<UpdateMessageId> {
    constructor() {
        super("UpdateMessageId", [
            { no: 1, name: "message_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "random_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMessageId>): UpdateMessageId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = 0n;
        message.randomId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateMessageId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMessageId): UpdateMessageId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 message_id */ 1:
                    message.messageId = reader.int64().toBigInt();
                    break;
                case /* int64 random_id */ 2:
                    message.randomId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMessageId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 message_id = 1; */
        if (message.messageId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.messageId);
        /* int64 random_id = 2; */
        if (message.randomId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.randomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateMessageId
 */
export const UpdateMessageId = new UpdateMessageId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateComposeAction$Type extends MessageType<UpdateComposeAction> {
    constructor() {
        super("UpdateComposeAction", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "peer_id", kind: "message", T: () => Peer },
            { no: 3, name: "action", kind: "enum", T: () => ["UpdateComposeAction.ComposeAction", UpdateComposeAction_ComposeAction] }
        ]);
    }
    create(value?: PartialMessage<UpdateComposeAction>): UpdateComposeAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateComposeAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateComposeAction): UpdateComposeAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                case /* Peer peer_id */ 2:
                    message.peerId = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peerId);
                    break;
                case /* UpdateComposeAction.ComposeAction action */ 3:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateComposeAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        /* Peer peer_id = 2; */
        if (message.peerId)
            Peer.internalBinaryWrite(message.peerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* UpdateComposeAction.ComposeAction action = 3; */
        if (message.action !== 0)
            writer.tag(3, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateComposeAction
 */
export const UpdateComposeAction = new UpdateComposeAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserStatus$Type extends MessageType<UpdateUserStatus> {
    constructor() {
        super("UpdateUserStatus", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "status", kind: "message", T: () => UserStatus }
        ]);
    }
    create(value?: PartialMessage<UpdateUserStatus>): UpdateUserStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateUserStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserStatus): UpdateUserStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                case /* UserStatus status */ 2:
                    message.status = UserStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        /* UserStatus status = 2; */
        if (message.status)
            UserStatus.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateUserStatus
 */
export const UpdateUserStatus = new UpdateUserStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserStatus$Type extends MessageType<UserStatus> {
    constructor() {
        super("UserStatus", [
            { no: 1, name: "online", kind: "enum", T: () => ["UserStatus.Status", UserStatus_Status] },
            { no: 2, name: "last_online", kind: "message", T: () => LastOnline }
        ]);
    }
    create(value?: PartialMessage<UserStatus>): UserStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.online = 0;
        if (value !== undefined)
            reflectionMergePartial<UserStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserStatus): UserStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UserStatus.Status online */ 1:
                    message.online = reader.int32();
                    break;
                case /* LastOnline last_online */ 2:
                    message.lastOnline = LastOnline.internalBinaryRead(reader, reader.uint32(), options, message.lastOnline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UserStatus.Status online = 1; */
        if (message.online !== 0)
            writer.tag(1, WireType.Varint).int32(message.online);
        /* LastOnline last_online = 2; */
        if (message.lastOnline)
            LastOnline.internalBinaryWrite(message.lastOnline, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserStatus
 */
export const UserStatus = new UserStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastOnline$Type extends MessageType<LastOnline> {
    constructor() {
        super("LastOnline", [
            { no: 1, name: "date", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LastOnline>): LastOnline {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LastOnline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastOnline): LastOnline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 date */ 1:
                    message.date = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastOnline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 date = 1; */
        if (message.date !== undefined)
            writer.tag(1, WireType.Varint).int64(message.date);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LastOnline
 */
export const LastOnline = new LastOnline$Type();
